Webruntime.define('lwc/itemCreate', ['lwc', 'wire-service', 'instrumentation/service', 'aura-storage', 'aura', 'lightning/configProvider', 'aura-instrumentation'], function (lwc, wireService, service, auraStorage, aura, configProvider, auraInstrumentation) { 'use strict';

    auraStorage = auraStorage && Object.prototype.hasOwnProperty.call(auraStorage, 'default') ? auraStorage['default'] : auraStorage;

    function tmpl($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        s: api_slot,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7
      } = $ctx;
      return [api_element("form", {
        className: $cmp.formClass,
        props: {
          "noValidate": true
        },
        key: 1,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleSubmit)),
          "registeroutputfield": _m2 || ($ctx._m2 = api_bind($cmp.handleRegister)),
          "registerinputfield": _m3 || ($ctx._m3 = api_bind($cmp.handleRegister)),
          "change": _m4 || ($ctx._m4 = api_bind($cmp.handleChange)),
          "registerfielddependency": _m5 || ($ctx._m5 = api_bind($cmp.registerDependentField)),
          "updatedependentfields": _m6 || ($ctx._m6 = api_bind($cmp.updateDependentFields)),
          "error": _m7 || ($ctx._m7 = api_bind($cmp.handleError))
        }
      }, [api_slot("", {
        key: 0,
        on: {
          "slotchange": _m0 || ($ctx._m0 = api_bind($cmp.handleRegister))
        }
      }, [], $slotset)])];
    }

    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.slots = [""];
    tmpl.stylesheets = [];
    tmpl.stylesheetTokens = {
      hostAttribute: "lightning-recordEditForm_recordEditForm-host",
      shadowAttribute: "lightning-recordEditForm_recordEditForm"
    };

    var labelApiNameMismatch = 'API Name {0} is invalid, did you mean "{1}?"';

    var labelInvalidId = 'Error in fetching record: invalid record id.';

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    /*  *******************************************************************************************
     *  ATTENTION!
     *  THIS IS A GENERATED FILE FROM https://github.com/salesforce/lds
     *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
     *  Any changes made to this file in p4 will be automatically overwritten.
     *  *******************************************************************************************
     */
    const {
      assign,
      create,
      freeze,
      keys
    } = Object;
    /**
     * Returns a new object that has a list of fields that has been filtered by
     * edited fields. Only contains fields that have been edited from their original
     * values (excluding Id which is always copied over).
     * @param input The RecordInputRepresentation object to filter.
     * @param original The Record object that contains the original field values.
     * @returns RecordInputRepresentation, see the description
     */


    function createRecordInputFilteredByEditedFields(input, original) {
      const filteredRecordInput = getRecordInput(); // Always copy over any existing id.

      if (original.id) {
        filteredRecordInput.fields.Id = original.id;
      }

      const recordInputFields = input.fields;
      const originalRecordFields = original.fields;
      const recordInputFieldPropertyNames = keys(recordInputFields);

      for (let i = 0, len = recordInputFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordInputFieldPropertyNames[i];
        let originalRecordFieldsEntry;

        if (originalRecordFields) {
          originalRecordFieldsEntry = originalRecordFields[fieldName];
        }

        if (!originalRecordFieldsEntry || originalRecordFields && recordInputFields[fieldName] !== originalRecordFieldsEntry.value) {
          filteredRecordInput.fields[fieldName] = recordInputFields[fieldName];
        }
      }

      return filteredRecordInput;
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned. This object can be
     * used to create a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are createable=true (excluding Id) will
     *        be assigned to the object return value.
     * @returns RecordInputRepresentation See description.
     */


    function generateRecordInputForCreate(record, objectInfo) {
      const recordInput = _generateRecordInput(record, field => field.createable === true, objectInfo);

      recordInput.apiName = record.apiName; // fields.Id is not required for CREATE which might have been copied over,
      // so delete fields.Id

      delete recordInput.fields.Id;
      return recordInput;
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned. This object can be
     * used to update a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are updateable=true (excluding Id) will
     *        be assigned to the object return value.
     * @returns RecordInputRepresentation See description.
     */


    function generateRecordInputForUpdate(record, objectInfo) {
      const recordInput = _generateRecordInput(record, field => field.updateable === true, objectInfo);

      if (!record.id) {
        throw new Error('record must have id for update');
      } // Always copy over any existing id.


      recordInput.fields.Id = record.id;
      return recordInput;
    }

    function isRecordInputFieldValue(unknown) {
      const type = typeof unknown;
      return unknown === null || type === 'string' || type === 'number' || type === 'boolean';
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned.
     * @param record The record that contains the source data.
     * @param copyFieldPredicate predicate to determine if a field should be copied.
     *        Required if "objectInfo" parameter is passed.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that match the copyFieldPredicate (excluding
     *        Id) will be assigned to the object return value.
     * @returns RecordInputRepresentation
     */


    function _generateRecordInput(record, copyFieldPredicate, objectInfo) {
      const recordInput = getRecordInput();
      const recordFields = record.fields;
      let objectInfoFields;

      if (objectInfo) {
        objectInfoFields = objectInfo.fields;
      }

      const recordFieldPropertyNames = keys(recordFields);

      for (let i = 0, len = recordFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordFieldPropertyNames[i];
        const recordFieldsFieldNameEntry = recordFields[fieldName].value;

        if (isRecordInputFieldValue(recordFieldsFieldNameEntry)) {
          if (objectInfoFields && copyFieldPredicate) {
            const objectInfoFieldsFieldNameValue = objectInfoFields[fieldName];

            if (objectInfoFieldsFieldNameValue && copyFieldPredicate(objectInfoFieldsFieldNameValue)) {
              recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
            }
          } else {
            recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
          }
        }
      }

      return recordInput;
    }
    /**
     * Gets a new Record Input.
     */


    function getRecordInput() {
      return {
        apiName: undefined,
        fields: {}
      };
    }

    var LayoutType;

    (function (LayoutType) {
      LayoutType["Full"] = "Full";
      LayoutType["Compact"] = "Compact";
    })(LayoutType || (LayoutType = {}));

    var LayoutMode;

    (function (LayoutMode) {
      LayoutMode["View"] = "View";
      LayoutMode["Edit"] = "Edit";
      LayoutMode["Create"] = "Create";
    })(LayoutMode || (LayoutMode = {}));

    const getListUiByApiName_ConfigPropertyNames = {
      displayName: 'getListUiByApiName',
      parameters: {
        required: ['objectApiName', 'listViewApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
      }
    };
    const getListUiByListViewId_ConfigPropertyNames = {
      displayName: 'getListUiByListViewId',
      parameters: {
        required: ['listViewId'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
      }
    };
    const getMruListUi_ConfigPropertyNames = {
      displayName: 'getMruListUi',
      parameters: {
        required: ['objectApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
      }
    }; // make local copies of the adapter configs so we can ignore other getListUi config parameters to match
    // lds222 behavior

    const getMruListUi_ConfigPropertyNames_augmented = _objectSpread({}, getMruListUi_ConfigPropertyNames, {
      parameters: _objectSpread({}, getMruListUi_ConfigPropertyNames.parameters, {
        optional: [...getMruListUi_ConfigPropertyNames.parameters.optional, 'listViewApiName', 'listViewId']
      })
    }); // make local copies of the adapter configs so we can have them ignore each other's config parameters
    // to match lds222 behavior


    const getListUiByApiName_ConfigPropertyNames_augmented = _objectSpread({}, getListUiByApiName_ConfigPropertyNames, {
      parameters: _objectSpread({}, getListUiByApiName_ConfigPropertyNames.parameters, {
        optional: [...getListUiByApiName_ConfigPropertyNames.parameters.optional, 'listViewId']
      })
    });

    const getListUiByListViewId_ConfigPropertyNames_augmented = _objectSpread({}, getListUiByListViewId_ConfigPropertyNames, {
      parameters: _objectSpread({}, getListUiByListViewId_ConfigPropertyNames.parameters, {
        optional: [...getListUiByListViewId_ConfigPropertyNames.parameters.optional, 'listViewApiName', 'objectApiName']
      })
    });

    const DEFAULT_MODE = LayoutMode.View;
    var DiscriminatorValues;

    (function (DiscriminatorValues) {
      DiscriminatorValues["Photo"] = "Photo";
      DiscriminatorValues["Theme"] = "Theme";
    })(DiscriminatorValues || (DiscriminatorValues = {}));

    var FormFactor;

    (function (FormFactor) {
      FormFactor["Large"] = "Large";
      FormFactor["Medium"] = "Medium";
      FormFactor["Small"] = "Small";
    })(FormFactor || (FormFactor = {}));

    const select$j = function LeadStatusPicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$m();
      return {
        kind: 'Fragment',
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'converted',
          kind: 'Scalar'
        }]
      };
    };

    const select$k = function CaseStatusPicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$m();
      return {
        kind: 'Fragment',
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'closed',
          kind: 'Scalar'
        }]
      };
    };

    const select$l = function OpportunityStagePicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$m();
      return {
        kind: 'Fragment',
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'closed',
          kind: 'Scalar'
        }, {
          name: 'defaultProbability',
          kind: 'Scalar'
        }, {
          name: 'forecastCategoryName',
          kind: 'Scalar'
        }, {
          name: 'won',
          kind: 'Scalar'
        }]
      };
    };

    var DiscriminatorValues$2;

    (function (DiscriminatorValues) {
      DiscriminatorValues["LeadStatus"] = "LeadStatus";
      DiscriminatorValues["CaseStatus"] = "CaseStatus";
      DiscriminatorValues["OpportunityStage"] = "OpportunityStage";
    })(DiscriminatorValues$2 || (DiscriminatorValues$2 = {}));

    const selectChildren$2 = function AbstractPicklistValueAttributesRepresentationSelectChildren(params) {
      const {
        selections: LeadStatusPicklistValueAttributesRepresentationSelections
      } = select$j();
      const {
        selections: CaseStatusPicklistValueAttributesRepresentationSelections
      } = select$k();
      const {
        selections: OpportunityStagePicklistValueAttributesRepresentationSelections
      } = select$l();
      return {
        kind: 'Object',
        name: params.propertyName,
        nullable: params.nullable,
        union: true,
        discriminator: 'picklistAtrributesValueType',
        unionSelections: {
          [DiscriminatorValues$2.LeadStatus]: LeadStatusPicklistValueAttributesRepresentationSelections,
          [DiscriminatorValues$2.CaseStatus]: CaseStatusPicklistValueAttributesRepresentationSelections,
          [DiscriminatorValues$2.OpportunityStage]: OpportunityStagePicklistValueAttributesRepresentationSelections
        }
      };
    };

    const select$m = function AbstractPicklistValueAttributesRepresentationSelect() {
      return {
        kind: 'Fragment',
        selections: [{
          name: 'picklistAtrributesValueType',
          kind: 'Scalar'
        }]
      };
    };

    const select$n = function PicklistValueRepresentationSelect() {
      const AbstractPicklistValueAttributesRepresentation__unionSelections = selectChildren$2({
        propertyName: 'attributes',
        nullable: true
      });
      return {
        kind: 'Fragment',
        selections: [AbstractPicklistValueAttributesRepresentation__unionSelections, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'validFor',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'value',
          kind: 'Scalar'
        }]
      };
    };

    const select$o = function PicklistValuesRepresentationSelect() {
      const {
        selections: PicklistValueRepresentation__selections,
        opaque: PicklistValueRepresentation__opaque
      } = select$n();
      return {
        kind: 'Fragment',
        selections: [{
          name: 'controllerValues',
          kind: 'Scalar',
          map: true
        }, {
          name: 'defaultValue',
          kind: 'Object',
          nullable: true,
          selections: PicklistValueRepresentation__selections
        }, {
          name: 'url',
          kind: 'Scalar'
        }, {
          name: 'values',
          kind: 'Object',
          plural: true,
          selections: PicklistValueRepresentation__selections
        }]
      };
    };

    const path = select$o().selections;

    function _objectSpread$1(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?Object(arguments[i]):{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==='function'){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable;}));}ownKeys.forEach(function(key){_defineProperty$1(target,key,source[key]);});}return target;}function _defineProperty$1(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}// really should just be whatever the server sends back for currentPageToken
    // when the request did not specify a pageToken parameter.
    const DEFAULT_TOKEN='0';const END_TOKEN='__END__';// TODO: re-evaluate passing save function vs something like getPaginationData
    function pagination(pd,save){const pd_=pd||{[DEFAULT_TOKEN]:0};return {defaultToken:()=>DEFAULT_TOKEN,endOffset:()=>pd_[END_TOKEN],isPastEnd:offset=>{return END_TOKEN in pd_&&offset>=pd_[END_TOKEN];},limitToEnd:offset=>{return END_TOKEN in pd_&&offset>=pd_[END_TOKEN]?pd_[END_TOKEN]:offset;},offsetFor:token=>{return pd_[token||DEFAULT_TOKEN];},save:()=>{if(!save){{throw new Error('pagination.save() invoked but no save function supplied');}}else {save(pd_);}},setEnd:offset=>{if(offset===undefined){delete pd_[END_TOKEN];}else {pd_[END_TOKEN]=offset;}},setToken:(token,offset)=>{if(offset===undefined){delete pd_[token];}else {pd_[token]=offset;}},tokenFor:offset=>{const tokens=Object.keys(pd_);for(let i=0;i<tokens.length;++i){if(pd_[tokens[i]]===offset){return tokens[i];}}},tokenForAtMost:offset=>{let result=[DEFAULT_TOKEN,0];const tokens=Object.keys(pd_);for(let i=0;i<tokens.length;++i){let offsetI=pd_[tokens[i]];if(offsetI<=offset&&offsetI>result[1]){result=[tokens[i],offsetI];}}return result;}};}function isUnionLinkSelection(sel){return sel.union===true&&sel.kind==='Link';}function isUnionObjectSelection(sel){return sel.union===true&&sel.kind==='Object';}function isFragmentUnionSelection(sel){return sel.union===true;}const{keys: keys$1,create: create$1,freeze: freeze$1}=Object;const{hasOwnProperty}=Object.prototype;const{isArray}=Array;const{push,indexOf,slice}=Array.prototype;const{stringify}=JSON;function formatStorageKey(name,argValues){if(!argValues){return name;}var values=[];for(var _argName in argValues){if(hasOwnProperty.call(argValues,_argName)){var value=argValues[_argName];if(value!==null||value!==undefined){values.push(_argName+':'+stringify(value));}}}return values.length===0?name:name+'('.concat(values.join(','),')');}function getArgumentValues(args,variables){const values={};args.forEach(arg=>{if(arg.kind==='Variable'){// Variables are provided at runtime and are not guaranteed to be stable.
    values[arg.name]=variables[arg.variableName];}else {values[arg.name]=arg.value;}});return values;}function getStorageKey(field,variables){const{args,name}=field;if(args&&args.length!==0){return formatStorageKey(name,getArgumentValues(args,variables));}return name;}const READER_PATH_ROOT='ROOT';const EMPTY_STRING='';function validateUnionSelection(record,selection,path){const{discriminator}=selection;const discriminatorValue=record[discriminator];if(discriminatorValue===undefined){throw new Error(`Invalid discriminator. Expected discriminator at path "${path.fullPath}.${discriminator}" but received "${stringify(record)}"`);}const unionSelection=selection.unionSelections[discriminatorValue];if(unionSelection===undefined){const keys=Object.keys(selection.unionSelections).map(key=>`"${key}"`).join(', ');throw new Error(`Invalid union selection. Expected to be one of ${keys} but received "${discriminatorValue}"`);}}class Reader{constructor(records,expirationMap,variables,refresh,baseSnapshot){this.missingPaths={};this.hasPendingData=false;this.variables=variables;this.records=records;this.seenIds={};this.isMissingData=false;this.refresh=refresh;// When we aren't passed a base snapshot, we don't have to worry about
    // marking the snapshot as changed because there is nothing to compare against.
    // Therefore, our initial state is that the snapshot has changed.
    let snapshotChanged=true;// When we aren't passed a base snapshot, we do not have any previous data
    // So we can just assign this to undefined
    let baseSnapshotValue=undefined;// When we are passed a base snapshot, we want to keep track of the previous data
    // We also will need to compare all of our data against the snapshot's previous data
    // Our initial state is that the snapshot has not changed. The reason for this is because
    // Once we detect a change, we can just flip this boolean on the first change and then
    // not have to worry about it for additional changes.
    if(baseSnapshot!==undefined&&baseSnapshot.state===SnapshotState.Fulfilled){baseSnapshotValue=baseSnapshot.data;snapshotChanged=false;}this.snapshotChanged=snapshotChanged;this.currentPath={fullPath:EMPTY_STRING,key:READER_PATH_ROOT,parent:null,baseSnapshotValue};this.baseSnapshot=baseSnapshot;this.expirationMap=expirationMap;this.timestamp=Date.now();}pagination(key){return pagination(this.records[key]);}readFragmentUnion(recordId,record,selection){{validateUnionSelection(record,selection,this.currentPath);}const{discriminator}=selection;const discriminatorValue=record[discriminator];return this.read({recordId,node:{kind:'Fragment',selections:selection.unionSelections[discriminatorValue]},variables:this.variables});}read(selector){const{recordId}=selector;const record=this.storeLookup(recordId);const{node:selectorNode}=selector;// Record does not exist or is expired
    if(record===undefined){if(this.isMissingData===false){this.isMissingData=true;this.snapshotChanged=true;}return this.createSnapshot(undefined,selector);}if(isFragmentUnionSelection(selectorNode)){return this.readFragmentUnion(recordId,record,selectorNode);}// top level record could be null when opaque
    if(record===null&&selectorNode.opaque===true){return this.createSnapshot(null,selector);}if(isStoreRecordError(record)){return this.createErrorSnapshot(record.error);}if(selectorNode.opaque===true){this.checkIfChanged(record);return this.createSnapshot(record,selector);}let data=isArray(record)?[]:{};this.traverseSelections(selectorNode,record,data);freeze$1(data);return this.createSnapshot(data,selector);}getSnapshotState(){if(this.isMissingData===true){return SnapshotState.Unfulfilled;}if(this.hasPendingData===true){return SnapshotState.Pending;}return SnapshotState.Fulfilled;}createErrorSnapshot(data){return {data:undefined,error:data,state:SnapshotState.Error,refresh:this.refresh};}createSnapshot(data,selector){if(this.snapshotChanged===false){return this.baseSnapshot;}return {recordId:selector.recordId,select:selector,variables:this.variables,seenRecords:this.seenIds,data,state:this.getSnapshotState(),missingPaths:this.missingPaths,refresh:this.refresh};// Typescript complains about unfulfilled vs fulfilled snapshot if we don't cast
    }deepCopy(record,data,key,visitedKeys){const value=record[key];this.enterPath(key);if(isArray(value)){// Array
    const items=[];this.selectAll(value,items,visitedKeys);data[key]=items;}else if(typeof value==='object'&&value!==null){// Object
    if(value.__ref!==undefined){// Link
    const nextRecordId=value.__ref;if(isArray(nextRecordId)){const items=[];this.selectAll(nextRecordId,items,visitedKeys);data[key]=items;}else {if(hasOwnProperty.call(visitedKeys,nextRecordId)===true){throw new Error(`Invalid eager selection on records with circular references.`);}this.seenIds[nextRecordId]=true;const nextRecord=this.storeLookup(nextRecordId);if(nextRecord===undefined){this.markMissing();data[key]=undefined;}else {const nested={};this.selectAll(nextRecord,nested,_objectSpread$1({},visitedKeys,{[nextRecordId]:true}));data[key]=nested;}}}else {// Inlined object
    const items={};this.selectAll(value,items,visitedKeys);data[key]=items;}}else {// Scalar
    this.checkIfChanged(value);data[key]=value;}this.exitPath();}selectAllArray(record,data,visitedKeys){const{length}=record;for(let key=0;key<length;key+=1){this.deepCopy(record,data,key,visitedKeys);}}selectAllObject(record,data,visitedKeys){const recordKeys=keys$1(record);const{length}=recordKeys;for(let i=0;i<length;i+=1){const key=recordKeys[i];this.deepCopy(record,data,key,visitedKeys);}}selectAll(record,data,visitedKeys={}){const recordIsArray=isArray(record);if(recordIsArray===true){this.selectAllArray(record,data,visitedKeys);}else {this.selectAllObject(record,data,visitedKeys);}freeze$1(data);}markPending(){this.hasPendingData=true;}markMissing(){this.isMissingData=true;this.missingPaths[this.currentPath.fullPath]=true;this.checkIfChanged(undefined);}assignNonScalar(sink,key,value){sink[key]=value;freeze$1(value);}enterPath(key){const parent=this.currentPath;const{key:parentKey,fullPath:parentFullPath,baseSnapshotValue:parentBaseSnapshotValue}=parent;let baseSnapshotValue=undefined;if(parentBaseSnapshotValue!==undefined&&parentBaseSnapshotValue!==null){baseSnapshotValue=parentBaseSnapshotValue[key];}this.currentPath={parent,key,fullPath:parentKey===READER_PATH_ROOT?key:parentFullPath+'.'+key,baseSnapshotValue};}exitPath(){this.currentPath=this.currentPath.parent;}readSingleLink(propertyName,selection,record,data){const{seenIds:ids}=this;const link=record[propertyName];// This condition is hit when the link it self isn't present
    if(link===undefined){return this.markMissing();}if(selection.nullable===true&&link===null){this.readScalar(propertyName,record,data);return;}const{__ref:refId,pending,isMissing}=link;if(pending===true){this.markPending();return;}if(isMissing===true&&selection.required===false){return;}if(refId===undefined){return this.markMissing();}const linkedRecord=this.storeLookup(refId);// This condition is hit when the link is present
    // but the node it is pointing to is not present
    if(linkedRecord===undefined){if(selection.required===false){return;}return this.markMissing();}ids[refId]=true;const obj=isArray(linkedRecord)?[]:{};if(selection.selections===undefined){this.selectAll(linkedRecord,obj);}else {this.traverseSelections(selection,linkedRecord,obj);}this.assignNonScalar(data,propertyName,obj);}readObject(key,selection,source,sink){const sourceValue=source[key];if(selection.nullable===true&&sourceValue===null){this.readScalar(key,source,sink);return;}if(selection.opaque===true){this.readOpaque(sink,key,sourceValue);return;}if(sourceValue===undefined){if(selection.required===false){return;}return this.markMissing();}const sinkValue=isArray(sourceValue)?[]:{};if(selection.selections===undefined){this.selectAll(sourceValue,sinkValue);}else {this.traverseSelections(selection,sourceValue,sinkValue);}this.assignNonScalar(sink,key,sinkValue);}checkIfChanged(value){// If we've already detected a change, just return
    if(this.snapshotChanged===true){return;}this.snapshotChanged=this.currentPath.baseSnapshotValue!==value;}computeCopyBounds(array,selection){// pageToken *can* be undefined
    if(selection.tokenDataKey!==undefined&&selection.pageSize!==undefined){const pagination=this.pagination(selection.tokenDataKey);const startingOffset=pagination.offsetFor(selection.pageToken);if(startingOffset===undefined){return;}const endingOffset=pagination.limitToEnd(startingOffset+selection.pageSize);this.seenIds[selection.tokenDataKey]=true;return [startingOffset,endingOffset];}else {return [0,array.length];}}/**
         * This method is public *only* so CustomReaders can call it.
         */readPluralLink(propertyName,selection,record,data){if(selection.selections===undefined){return;}const{storeLookup,seenIds:ids}=this;const array=record[propertyName];const[start,end]=this.computeCopyBounds(array,selection)||[-1,-1];if(start<0){return this.markMissing();}const sink=data[propertyName]=[];for(let i=start;i<end;i+=1){this.enterPath(i);const next=array[i];const nextId=next&&next.__ref;const nextRecord=nextId&&storeLookup.call(this,nextId);if(nextRecord===undefined){this.markMissing();this.exitPath();return;}ids[nextId]=true;const obj={};this.traverseSelections(selection,nextRecord,obj);this.assignNonScalar(sink,i-start,obj);freeze$1(obj);this.exitPath();}freeze$1(sink);}readObjectMap(propertyName,selection,record,data){const obj=record[propertyName];if(obj===undefined){if(selection.required===false){return;}return this.markMissing();}const sink=data[propertyName]={};const keys$1$1=keys$1(obj);for(let i=0,len=keys$1$1.length;i<len;i+=1){const key=keys$1$1[i];this.enterPath(key);this.readObject(key,selection,obj,sink);this.exitPath();}freeze$1(sink);}readLinkMap(propertyName,selection,record,data){const{seenIds:ids}=this;const map=record[propertyName];const keys$1$1=keys$1(map);const sink=data[propertyName]={};for(let i=0,len=keys$1$1.length;i<len;i+=1){const key=keys$1$1[i];this.enterPath(key);const next=map[key];const nextId=next.__ref;const nextRecord=this.storeLookup(nextId);if(nextRecord===undefined){this.markMissing();this.exitPath();return;}ids[nextId]=true;const obj={};this.traverseSelections(selection,nextRecord,obj);this.assignNonScalar(sink,key,obj);freeze$1(obj);this.exitPath();}freeze$1(sink);}/**
         * This method is public *only* so CustomReaders can call it.
         */readPluralObject(propertyName,selection,record,data){if(selection.selections===undefined){return;}const array=record[propertyName];const[start,end]=this.computeCopyBounds(array,selection)||[-1,-1];if(start<0){return this.markMissing();}const sink=data[propertyName]=[];for(let i=start;i<end;i+=1){this.enterPath(i);const nextRecord=array[i];if(nextRecord===undefined){this.markMissing();this.exitPath();return;}const obj={};this.traverseSelections(selection,nextRecord,obj);push.call(sink,obj);freeze$1(obj);this.exitPath();}freeze$1(sink);}readOpaque(sink,propertyName,value){sink[propertyName]=value;this.checkIfChanged(value);}readScalarMap(propertyName,record,data){const obj=record[propertyName];const sink=data[propertyName]={};const keys$1$1=keys$1(obj);for(let i=0,len=keys$1$1.length;i<len;i+=1){const key=keys$1$1[i];this.enterPath(key);this.readScalar(key,obj,sink);this.exitPath();}freeze$1(sink);}readScalarPlural(propertyName,record,data){const array=record[propertyName];const sink=data[propertyName]=[];for(let i=0,len=array.length;i<len;i+=1){this.enterPath(i);const value=array[i];push.call(sink,value);this.checkIfChanged(value);this.exitPath();}freeze$1(sink);}/**
         * This method is public *only* so CustomReaders can call it.
         */readScalar(propertyName,record,data){if(!hasOwnProperty.call(record,propertyName)){return this.markMissing();}data[propertyName]=record[propertyName];this.checkIfChanged(record[propertyName]);}/**
         * This method is public *only* so CustomReaders can call it.
         */storeLookup(recordId){const value=this.records[recordId];if(value===undefined){return undefined;}const expiration=this.expirationMap[recordId];if(expiration!==undefined&&this.timestamp>expiration){return undefined;}return value;}selectUnion(selection,storeEntry,discriminatedObject,sink){const{discriminator}=selection;const discriminatorValue=discriminatedObject[discriminator];{validateUnionSelection(discriminatedObject,selection,this.currentPath);}const unionSelection=selection.unionSelections[discriminatorValue];const childSelection={selections:unionSelection,name:selection.name,kind:selection.kind};this.traverseSelection(childSelection,storeEntry,sink);}selectObjectUnion(selection,source,sink){const{name:propertyName}=selection;const object=source[propertyName];if(object===undefined){this.markMissing();return;}if(selection.nullable===true&&object===null){this.readScalar(propertyName,source,sink);return;}this.selectUnion(selection,source,object,sink);}selectLinkUnion(selection,source,sink){const{name:propertyName}=selection;const sourceValue=source[propertyName];const link=source[propertyName];// This condition is hit when the link it self isn't present
    if(link===undefined){return this.markMissing();}if(selection.nullable===true&&sourceValue===null){this.readScalar(propertyName,sourceValue,sink);return;}const{__ref:refId}=link;if(refId===undefined){return this.markMissing();}const linkedRecord=this.records[refId];// If we can't find the link, mark it as missing
    if(linkedRecord===undefined){return this.markMissing();}this.selectUnion(selection,source,linkedRecord,sink);}traverseSelection(selection,record,data){const{variables}=this;const key=getStorageKey(selection,variables);if(isUnionLinkSelection(selection)){this.selectLinkUnion(selection,record,data);return;}else if(isUnionObjectSelection(selection)){this.selectObjectUnion(selection,record,data);return;}if(selection.kind==='Link'){if(selection.plural===true){this.readPluralLink(key,selection,record,data);}else if(selection.map===true){this.readLinkMap(key,selection,record,data);}else {this.readSingleLink(key,selection,record,data);}}else if(selection.kind==='Scalar'){if(selection.map===true){this.readScalarMap(key,record,data);}else if(selection.plural===true){this.readScalarPlural(key,record,data);}else {this.readScalar(key,record,data);}}else if(selection.kind==='Object'){if(selection.map===true){this.readObjectMap(key,selection,record,data);}else if(selection.plural===true){this.readPluralObject(key,selection,record,data);}else {this.readObject(key,selection,record,data);}}else if(selection.kind==='Custom'){selection.reader(key,selection,record,data,variables,this);}}traverseSelections(node,record,data){const{selections}=node;if(selections===undefined){this.selectAll(record,data);return;}const{length:len}=selections;for(let i=0;i<len;i+=1){const selection=selections[i];this.enterPath(selection.name);this.traverseSelection(selection,record,data);this.exitPath();}}}function deepFreeze(value){// No need to freeze primitives
    if(typeof value!=='object'||value===null){return;}if(isArray(value)){for(let i=0,len=value.length;i<len;i+=1){deepFreeze(value[i]);}}else {const keys$1$1=keys$1(value);for(let i=0,len=keys$1$1.length;i<len;i+=1){deepFreeze(value[keys$1$1[i]]);}}freeze$1(value);}var SnapshotState;(function(SnapshotState){SnapshotState["Fulfilled"]="Fulfilled";SnapshotState["Unfulfilled"]="Unfulfilled";SnapshotState["Error"]="Error";SnapshotState["Pending"]="Pending";})(SnapshotState||(SnapshotState={}));function isErrorSnapshot(snapshot){return snapshot.state===SnapshotState.Error;}function isFulfilledSnapshot(snapshot){return snapshot.state===SnapshotState.Fulfilled;}function isUnfulfilledSnapshot(snapshot){return snapshot.state===SnapshotState.Unfulfilled;}function createErrorSnapshot(error){deepFreeze(error);const snap={error,state:SnapshotState.Error,data:undefined};return snap;}function createSnapshot(records,recordExpirations,selector,refresh){return new Reader(records,recordExpirations,selector.variables,refresh).read(selector);}function rebuildSnapshot(snapshot,records,recordExpirations){return new Reader(records,recordExpirations,snapshot.variables,snapshot.refresh,snapshot).read(snapshot.select);}// Cannot use a symbol because we cannot serialize a symbol
    // Also, IE11 polyfill have problems when a lot of symbols
    // are created
    var StoreErrorStatus;(function(StoreErrorStatus){StoreErrorStatus[StoreErrorStatus["RESOURCE_NOT_FOUND"]=404]="RESOURCE_NOT_FOUND";})(StoreErrorStatus||(StoreErrorStatus={}));var StoreRecordType;(function(StoreRecordType){StoreRecordType["Error"]="error";})(StoreRecordType||(StoreRecordType={}));function isStoreRecordError(storeRecord){return storeRecord.__type===StoreRecordType.Error;}function hasOverlappingIds(snapshot,visitedIds){const{length:len}=visitedIds;const{seenRecords}=snapshot;for(let i=0;i<len;i+=1){const id=visitedIds[i];if(seenRecords[id]||id===snapshot.recordId){return true;}}return false;}function getMatchingIds(prefix,visitedIds){const matchingIds=[];for(let i=0,len=visitedIds.length;i<len;i++){const visitedId=visitedIds[i];if(visitedId.indexOf(prefix)===0){push.call(matchingIds,visitedId);}}return matchingIds;}class Store{constructor(){this.recordExpirations=create$1(null);this.records=create$1(null);this.snapshotSubscriptions=[];this.watchSubscriptions=[];this.visitedIds=create$1(null);this.insertedIds=create$1(null);this.selectorToDataSnapshotMap=new WeakMap();}reset(){this.recordExpirations=create$1(null);this.records=create$1(null);this.snapshotSubscriptions=[];this.watchSubscriptions=[];this.visitedIds=create$1(null);this.insertedIds=create$1(null);}publish(recordId,record){const{records,visitedIds,insertedIds}=this;if(hasOwnProperty.call(records,recordId)===false){insertedIds[recordId]=true;}records[recordId]=record;{freeze$1(record);}visitedIds[recordId]=true;}setExpiration(recordId,time){this.recordExpirations[recordId]=time;}broadcast(){// Note: we should always get the subscription references from this at the beginning
    // of the function, in case the reference changes (because of an unsubscribe)
    const{snapshotSubscriptions,watchSubscriptions,visitedIds,insertedIds,records}=this;const allVisitedIds=keys$1(visitedIds);// Early exit if nothing has changed
    if(allVisitedIds.length===0){return;}// Process snapshot subscriptions
    for(let i=0,len=snapshotSubscriptions.length;i<len;i++){const subscription=snapshotSubscriptions[i];const{snapshot,callback}=subscription;// Don't re-emit the snapshot if there is no overlap between the visited keys and the
    // snapshot seen keys.
    if(isErrorSnapshot(snapshot)||hasOverlappingIds(snapshot,allVisitedIds)===false){continue;}const updatedSnapshot=subscription.snapshot=rebuildSnapshot(snapshot,records,{});if((isFulfilledSnapshot(updatedSnapshot)||isErrorSnapshot(updatedSnapshot))&&updatedSnapshot!==snapshot){callback(updatedSnapshot);}else if(isUnfulfilledSnapshot(updatedSnapshot)){const{refresh}=updatedSnapshot;if(refresh!==undefined){refresh.resolve(refresh.config);}}}// Process watch subscriptions
    for(let i=0,len=watchSubscriptions.length;i<len;i++){const{prefix,callback}=watchSubscriptions[i];const matchingIds=getMatchingIds(prefix,allVisitedIds);if(matchingIds.length>0){const watchCallbackEntries=[];for(let i=0,len=matchingIds.length;i<len;i++){const id=matchingIds[i];const inserted=insertedIds[id]||false;push.call(watchCallbackEntries,{id,inserted});}callback(watchCallbackEntries);}}this.visitedIds=create$1(null);this.insertedIds=create$1(null);}lookup(selector,refresh){const{records,recordExpirations}=this;return createSnapshot(records,recordExpirations,selector,refresh);}lookupMemoize(selector,refresh){const{records,recordExpirations}=this;const snapshot=this.selectorToDataSnapshotMap.get(selector);let returnSnapshot;if(snapshot===undefined||isErrorSnapshot(snapshot)){returnSnapshot=createSnapshot(records,recordExpirations,selector,refresh);}else {returnSnapshot=rebuildSnapshot(snapshot,records,recordExpirations);}this.selectorToDataSnapshotMap.set(selector,returnSnapshot);return returnSnapshot;}subscribe(snapshot,callback){const subscription={snapshot,callback};this.snapshotSubscriptions=[...this.snapshotSubscriptions,subscription];return ()=>{const{snapshotSubscriptions}=this;const index=indexOf.call(snapshotSubscriptions,subscription);this.snapshotSubscriptions=[...slice.call(snapshotSubscriptions,0,index),...slice.call(snapshotSubscriptions,index+1)];{this.snapshotSubscriptions=freeze$1(this.snapshotSubscriptions);}};}watch(prefix,callback){const subscription={prefix,callback};this.watchSubscriptions=[...this.watchSubscriptions,subscription];return ()=>{const{watchSubscriptions}=this;const index=indexOf.call(watchSubscriptions,subscription);this.watchSubscriptions=[...slice.call(watchSubscriptions,0,index),...slice.call(watchSubscriptions,index+1)];{this.watchSubscriptions=freeze$1(this.watchSubscriptions);}};}evict(key){delete this.records[key];this.visitedIds[key]=true;}}function isNodeLink(node){return typeof node==='object'&&node!==null&&hasOwnProperty.call(node,'__ref');}var GraphNodeType;(function(GraphNodeType){GraphNodeType["Link"]="Link";GraphNodeType["Node"]="Node";GraphNodeType["Error"]="Error";})(GraphNodeType||(GraphNodeType={}));class GraphNodeError{constructor(store,data){this.type=GraphNodeType.Error;this.store=store;this.data=data;}retrieve(){return this.data;}}function followLink(store,key){return store.records[key];}class GraphLink{constructor(store,data){this.type=GraphNodeType.Link;this.store=store;this.data=data;}isPending(){return this.data.pending===true;}isMissing(){return this.data.isMissing===true;}follow(){const{__ref}=this.data;if(__ref===undefined){return null;}const linked=followLink(this.store,__ref);if(linked===null||linked===undefined){return null;}if(isStoreRecordError(linked)){return new GraphNodeError(this.store,linked);}return new GraphNode(this.store,linked);}linkData(){return this.data.data;}writeLinkData(data){this.data.data=data;}}class GraphNode{constructor(store,data){this.type=GraphNodeType.Node;this.store=store;this.data=data;}object(propertyName){const value=this.data[propertyName];if(isNodeLink(value)){throw new Error(`Cannot walk to path ${propertyName}. "${propertyName}" is a link: "${value}"`);}if(typeof value!=='object'||value===null){throw new Error(`Cannot walk to path ${propertyName}. "${propertyName}" is a scalar: "${value}"`);}return new GraphNode(this.store,value);}link(propertyName){const value=this.data[propertyName];if(!isNodeLink(value)){throw new Error(`Cannot walk to link ${propertyName}. "${propertyName}" is not a link: "${value}"`);}return new GraphLink(this.store,value);}scalar(propertyName){const value=this.data[propertyName];if(typeof value==='object'&&value!==null){throw new Error(`Cannot return value at path ${propertyName}. ${propertyName} is not a scalar.`);}return value;}keys(){return keys$1(this.data);}isScalar(propertyName){// TODO W-6900046 - merge.ts casts these to any and manually sets `data`
    // so this guard is required
    if(this.data===undefined){return true;}const value=this.data[propertyName];return typeof value!=='object'||value===null;}write(propertyName,value){this.data[propertyName]=value;}isUndefined(propertyName){return this.data[propertyName]===undefined;}retrieve(){return this.data;}}class LDS{constructor(store,networkAdapter,options={}){this.store=store;this.networkAdapter=networkAdapter;this.options=options;}pagination(key){let data=this.store.records[key];data=data&&_objectSpread$1({},data);return pagination(data,pd=>{this.storePublish(key,pd);});}storePublish(key,data){this.store.publish(key,data);}storeBroadcast(){this.store.broadcast();}storeIngest(key,request,response){if(request.ingest!==null){request.ingest(response,{fullPath:key,parent:null},this,this.store,Date.now());}}storeIngestFetchResponse(key,response,ttl){const{status}=response;deepFreeze(response);if(status===404){const{store}=this;const entry={__type:StoreRecordType.Error,status:StoreErrorStatus.RESOURCE_NOT_FOUND,error:response};freeze$1(entry);store.publish(key,entry);if(ttl!==undefined){store.setExpiration(key,Date.now()+ttl);}}}storeSubscribe(snapshot,callback){return this.store.subscribe(snapshot,callback);}storeWatch(prefix,callback){return this.store.watch(prefix,callback);}storeLookup(sel){return this.store.lookup(sel);}storeLookupMemoize(sel){return this.store.lookupMemoize(sel);}storeEvict(key){this.store.evict(key);}errorSnapshot(error){return createErrorSnapshot(error);}dispatchResourceRequest(resourceRequest,overrides){let mergedResourceRequest=resourceRequest;// Apply resource request override if passed as argument.
    if(overrides!==undefined){mergedResourceRequest=_objectSpread$1({},resourceRequest,{headers:_objectSpread$1({},resourceRequest.headers,overrides.headers)});}return this.networkAdapter(mergedResourceRequest);}refreshSnapshot(snapshot){const{refresh}=snapshot;if(refresh!==undefined){return refresh.resolve(refresh.config);}throw new Error('Snapshot is not refreshable');}getNode(key){const{store}=this;const value=store.records[key];// doesn't exist
    if(value===undefined){return null;}return this.wrapNormalizedGraphNode(value);}wrapNormalizedGraphNode(normalized){if(normalized===null){return null;}if(isStoreRecordError(normalized)){return new GraphNodeError(this.store,normalized);}return new GraphNode(this.store,normalized);}instrument(paramsBuilder){const{instrument}=this.options;if(instrument){instrument(paramsBuilder());}}}var HttpStatusCode;(function(HttpStatusCode){HttpStatusCode[HttpStatusCode["Ok"]=200]="Ok";HttpStatusCode[HttpStatusCode["NotModified"]=304]="NotModified";HttpStatusCode[HttpStatusCode["NotFound"]=404]="NotFound";HttpStatusCode[HttpStatusCode["BadRequest"]=400]="BadRequest";HttpStatusCode[HttpStatusCode["ServerError"]=500]="ServerError";})(HttpStatusCode||(HttpStatusCode={}));const{freeze:freeze$1$1,keys:keys$1$1}=Object;const{isArray:isArray$1}=Array;const{stringify:stringify$1}=JSON;class Sanitizer{constructor(obj){this.obj=obj;this.copy={};this.currentPath={key:'',value:obj,parent:null,data:this.copy};}sanitize(){const sanitizer=this;stringify$1(this.obj,function(key,value){if(key===''){return value;}const parent=this;if(parent!==sanitizer.currentPath.value){sanitizer.exit(parent);}if(typeof value==='object'&&value!==null){sanitizer.enter(key,value);return value;}sanitizer.currentPath.data[key]=value;return value;});return this.copy;}enter(key,value){const{currentPath:parentPath}=this;const data=parentPath.data[key]=isArray$1(value)?[]:{};this.currentPath={key,value,parent:parentPath,data};}exit(parent){while(this.currentPath.value!==parent){this.currentPath=this.currentPath.parent||this.currentPath;}}}/**
     * Returns a sanitized version of an object by recursively unwrapping the Proxies.
     *
     * In order to keep the LDS performance optimal on IE11, we need to make sure that LDS code get
     * transform by the es5-proxy-compat. At the same, time we need to ensure that no ProxyCompat leaks
     * into the LDS engine code nor into the adapters. All the data coming from LWC-land need to be
     * sanitized first.
     */function sanitize(obj){return new Sanitizer(obj).sanitize();}const USERLAND_PROVISION_ERROR_MESSAGE="LWC component's @wire target property or method threw an error during value provisioning. Original error:";const ADAPTER_SNAPSHOT_REJECTED_MESSAGE='Lightning Data Service wire adapter Promise<Snapshot> rejected. Original error:';const dataToSnapshotWeakMap=new WeakMap();function buildAdapterEventPayload(snapshot){// We should never broadcast an unfulfilled snapshot to a component
    {if(isUnfulfilledSnapshot(snapshot)){throw new Error(`Unfulfilled snapshot emitted to component from subscription, missingPaths: ${keys$1$1(snapshot.missingPaths)}`);}}if(isErrorSnapshot(snapshot)){return {data:undefined,error:snapshot.error};}else {// fulfilled
    return {data:snapshot.data,error:undefined};}}function dispatchValue(eventTarget,ValueChangedEvent,snapshot,_lds){const payload=buildAdapterEventPayload(snapshot);dataToSnapshotWeakMap.set(payload,snapshot);// ideally this should be handled by LWC event handler error handling
    try{eventTarget.dispatchEvent(new ValueChangedEvent(payload));}catch(error){if(error instanceof Error){error.message=`${USERLAND_PROVISION_ERROR_MESSAGE}\n[${error.message}]`;throw error;}}}function isPromise(value){// check for Thenable due to test frameworks using custom Promise impls
    return value.then!==undefined;}function dispatchAndSubscribe(wireService,eventTarget,lds){const{ValueChangedEvent}=wireService;return snapshot=>{if(isFulfilledSnapshot(snapshot)||isErrorSnapshot(snapshot)){dispatchValue(eventTarget,ValueChangedEvent,snapshot);}if(isErrorSnapshot(snapshot)){return;}if(isUnfulfilledSnapshot(snapshot)){{throw new Error(`Unfulfilled snapshot from adapterDispatchAndSubscribe, missingPaths: ${keys$1$1(snapshot.missingPaths)}`);}}return lds.storeSubscribe(snapshot,updated=>{dispatchValue(eventTarget,ValueChangedEvent,updated);});};}function register(lds,wireService,adapter,identifier){const wireIdentifier=typeof identifier==='function'?identifier:()=>{if(identifier!==undefined){throw new Error(`Wire identifier ${stringify$1(identifier)} is not directly invocable.`);}throw new Error(`Wire identifier ${adapter.name!==undefined?adapter.name:''} is not directly invocable.`);};const{register:wireServiceRegister,ValueChangedEvent}=wireService;wireServiceRegister(wireIdentifier,eventTarget=>{const adapterDispatchAndSubscribe=dispatchAndSubscribe(wireService,eventTarget,lds);let unsubscribe;let isConnected=false;let config;// initialize the wired property with a properly shaped object so cmps can use <template if:true={wiredProperty.data}>
    try{eventTarget.dispatchEvent(new ValueChangedEvent({data:undefined,error:undefined}));}catch(error){if(error instanceof Error){error.message=`${USERLAND_PROVISION_ERROR_MESSAGE}\n[${error.message}]`;throw error;}}function unsub(){if(unsubscribe){unsubscribe();unsubscribe=undefined;}}eventTarget.addEventListener('config',newConfig=>{unsub();config=newConfig;const snapshotOrPromise=adapter(sanitize(config));// insufficient config
    if(snapshotOrPromise===null){return;}// Data resolved sync
    if(!isPromise(snapshotOrPromise)){unsubscribe=adapterDispatchAndSubscribe(snapshotOrPromise);return;}// We want to let errors from this promise propagate to the app container,
    // which is why we do not have a reject handler here.
    // If an error is thrown here, it means that there was an error somewhere
    // inside an adapter which means that there was a mistake by the implementor.
    // Errors that come from the network should never hit this block because
    // they are treated like regular snapshots, not true error paths.
    function asyncHandler(oldConfig,snapshot){// if config has changed before promise resolves then ignore resolved value
    if(oldConfig!==config){return;}unsub();if(isConnected){unsubscribe=adapterDispatchAndSubscribe(snapshot);}}snapshotOrPromise.then(asyncHandler.bind(undefined,config),reason=>{if(reason instanceof Error){reason.message=`${ADAPTER_SNAPSHOT_REJECTED_MESSAGE}\n[${reason.message}]`;throw reason;}else {throw new Error(`${ADAPTER_SNAPSHOT_REJECTED_MESSAGE}\n[${stringify$1(reason)}]`);}});});eventTarget.addEventListener('connect',()=>{// TODO W-6568533 - wire reform changes this behavior
    isConnected=true;});eventTarget.addEventListener('disconnect',()=>{isConnected=false;unsub();});});return wireIdentifier;}const{hasOwnProperty:ObjectPrototypeHasOwnProperty}=Object.prototype;const{keys:ObjectKeys$1}=Object;const{isArray:ArrayIsArray$2}=Array;function isPromise$2(value){return value.then!==undefined;}/**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */function validateConfig(config,adapter,oneOf){const{displayName}=adapter;const{required,optional,unsupported}=adapter.parameters;if(config===undefined||required.every(req=>ObjectPrototypeHasOwnProperty.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);}if(oneOf&&oneOf.some(req=>ObjectPrototypeHasOwnProperty.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);}if(unsupported!==undefined&&unsupported.some(req=>ObjectPrototypeHasOwnProperty.call(config,req))){throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);}const supported=required.concat(optional);if(ObjectKeys$1(config).some(key=>!supported.includes(key))){throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);}}function untrustedIsObject$1(untrusted){return typeof untrusted==='object'&&untrusted!==null&&ArrayIsArray$2(untrusted)===false;}function areRequiredParametersPresent(config,configPropertyNames){return configPropertyNames.parameters.required.every(req=>req in config);}function refreshable$1(adapter,resolve){return config=>{const result=adapter(config);if(result===null){return result;}if(isPromise$2(result)){return result.then(snapshot=>{snapshot.refresh={config,resolve};return snapshot;});}result.refresh={config,resolve};return result;};}const SNAPSHOT_STATE_FULFILLED='Fulfilled';const keyPrefix='Commerce::';const{freeze:ObjectFreeze$1,keys:ObjectKeys$1$1}=Object;const{isArray:ArrayIsArray$1$1}=Array;const{stringify:JSONStrinify}=JSON;function createLink$1(ref){return {__ref:ref};}function validate(obj,path='ProductMediaRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$1(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_alternateText=obj.alternateText;const path_alternateText=path+'.alternateText';let obj_alternateText_union0=null;const obj_alternateText_union0_error=(()=>{if(typeof obj_alternateText!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_alternateText+'" (at "'+path_alternateText+'")');}})();if(obj_alternateText_union0_error!=null){obj_alternateText_union0=obj_alternateText_union0_error.message;}let obj_alternateText_union1=null;const obj_alternateText_union1_error=(()=>{if(obj_alternateText!==null){return new TypeError('Expected "null" but received "'+typeof obj_alternateText+'" (at "'+path_alternateText+'")');}})();if(obj_alternateText_union1_error!=null){obj_alternateText_union1=obj_alternateText_union1_error.message;}if(obj_alternateText_union0&&obj_alternateText_union1){let message='Object doesn\'t match union (at "'+path_alternateText+'")';message+='\n'+obj_alternateText_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_alternateText_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_contentVersionId=obj.contentVersionId;const path_contentVersionId=path+'.contentVersionId';let obj_contentVersionId_union0=null;const obj_contentVersionId_union0_error=(()=>{if(typeof obj_contentVersionId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_contentVersionId+'" (at "'+path_contentVersionId+'")');}})();if(obj_contentVersionId_union0_error!=null){obj_contentVersionId_union0=obj_contentVersionId_union0_error.message;}let obj_contentVersionId_union1=null;const obj_contentVersionId_union1_error=(()=>{if(obj_contentVersionId!==null){return new TypeError('Expected "null" but received "'+typeof obj_contentVersionId+'" (at "'+path_contentVersionId+'")');}})();if(obj_contentVersionId_union1_error!=null){obj_contentVersionId_union1=obj_contentVersionId_union1_error.message;}if(obj_contentVersionId_union0&&obj_contentVersionId_union1){let message='Object doesn\'t match union (at "'+path_contentVersionId+'")';message+='\n'+obj_contentVersionId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_contentVersionId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_mediaType=obj.mediaType;const path_mediaType=path+'.mediaType';if(typeof obj_mediaType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_mediaType+'" (at "'+path_mediaType+'")');}const obj_sortOrder=obj.sortOrder;const path_sortOrder=path+'.sortOrder';if(typeof obj_sortOrder!=='number'||typeof obj_sortOrder==='number'&&Math.floor(obj_sortOrder)!==obj_sortOrder){return new TypeError('Expected "integer" but received "'+typeof obj_sortOrder+'" (at "'+path_sortOrder+'")');}const obj_title=obj.title;const path_title=path+'.title';if(typeof obj_title!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_title+'" (at "'+path_title+'")');}const obj_url=obj.url;const path_url=path+'.url';if(typeof obj_url!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_url+'" (at "'+path_url+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$2(input){ObjectFreeze$1(input);}function validate$1(obj,path='ProductEntitlementRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$1(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_canViewPrice=obj.canViewPrice;const path_canViewPrice=path+'.canViewPrice';let obj_canViewPrice_union0=null;const obj_canViewPrice_union0_error=(()=>{if(typeof obj_canViewPrice!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_canViewPrice+'" (at "'+path_canViewPrice+'")');}})();if(obj_canViewPrice_union0_error!=null){obj_canViewPrice_union0=obj_canViewPrice_union0_error.message;}let obj_canViewPrice_union1=null;const obj_canViewPrice_union1_error=(()=>{if(obj_canViewPrice!==null){return new TypeError('Expected "null" but received "'+typeof obj_canViewPrice+'" (at "'+path_canViewPrice+'")');}})();if(obj_canViewPrice_union1_error!=null){obj_canViewPrice_union1=obj_canViewPrice_union1_error.message;}if(obj_canViewPrice_union0&&obj_canViewPrice_union1){let message='Object doesn\'t match union (at "'+path_canViewPrice+'")';message+='\n'+obj_canViewPrice_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_canViewPrice_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function deepFreeze$1$1(input){ObjectFreeze$1(input);}function validate$2(obj,path='ProductMediaGroupRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$1(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_developerName=obj.developerName;const path_developerName=path+'.developerName';if(typeof obj_developerName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_developerName+'" (at "'+path_developerName+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_mediaItems=obj.mediaItems;const path_mediaItems=path+'.mediaItems';if(!ArrayIsArray$1$1(obj_mediaItems)){return new TypeError('Expected "array" but received "'+typeof obj_mediaItems+'" (at "'+path_mediaItems+'")');}for(let i=0;i<obj_mediaItems.length;i++){const obj_mediaItems_item=obj_mediaItems[i];const path_mediaItems_item=path_mediaItems+'['+i+']';const referenceProductMediaRepresentationValidationError=validate(obj_mediaItems_item,path_mediaItems_item);if(referenceProductMediaRepresentationValidationError!==null){let message='Object doesn\'t match ProductMediaRepresentation (at "'+path_mediaItems_item+'")\n';message+=referenceProductMediaRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_name=obj.name;const path_name=path+'.name';if(typeof obj_name!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_name+'" (at "'+path_name+'")');}const obj_usageType=obj.usageType;const path_usageType=path+'.usageType';if(typeof obj_usageType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_usageType+'" (at "'+path_usageType+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$2$1(input){const input_mediaItems=input.mediaItems;for(let i=0;i<input_mediaItems.length;i++){const input_mediaItems_item=input_mediaItems[i];deepFreeze$2(input_mediaItems_item);}ObjectFreeze$1(input_mediaItems);ObjectFreeze$1(input);}function validate$3(obj,path='ProductCategoryRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$1(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_description=obj.description;const path_description=path+'.description';let obj_description_union0=null;const obj_description_union0_error=(()=>{if(typeof obj_description!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_description+'" (at "'+path_description+'")');}})();if(obj_description_union0_error!=null){obj_description_union0=obj_description_union0_error.message;}let obj_description_union1=null;const obj_description_union1_error=(()=>{if(obj_description!==null){return new TypeError('Expected "null" but received "'+typeof obj_description+'" (at "'+path_description+'")');}})();if(obj_description_union1_error!=null){obj_description_union1=obj_description_union1_error.message;}if(obj_description_union0&&obj_description_union1){let message='Object doesn\'t match union (at "'+path_description+'")';message+='\n'+obj_description_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_description_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_name=obj.name;const path_name=path+'.name';if(typeof obj_name!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_name+'" (at "'+path_name+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$3(input){ObjectFreeze$1(input);}function validate$4(obj,path='ProductCategoryPathRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$1(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_path=obj.path;const path_path=path+'.path';if(!ArrayIsArray$1$1(obj_path)){return new TypeError('Expected "array" but received "'+typeof obj_path+'" (at "'+path_path+'")');}for(let i=0;i<obj_path.length;i++){const obj_path_item=obj_path[i];const path_path_item=path_path+'['+i+']';const referenceProductCategoryRepresentationValidationError=validate$3(obj_path_item,path_path_item);if(referenceProductCategoryRepresentationValidationError!==null){let message='Object doesn\'t match ProductCategoryRepresentation (at "'+path_path_item+'")\n';message+=referenceProductCategoryRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function normalize(input,existing,path,lds,store,timestamp){return input;}const select=function ProductCategoryPathRepresentationSelect(){return {kind:'Fragment',opaque:true};};function equals(existing,incoming){if(JSONStrinify(incoming)!==JSONStrinify(existing)){return false;}return true;}function deepFreeze$4(input){const input_path=input.path;for(let i=0;i<input_path.length;i++){const input_path_item=input_path[i];deepFreeze$3(input_path_item);}ObjectFreeze$1(input_path);ObjectFreeze$1(input);}const ingest=function ProductCategoryPathRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$4(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$4(input);if(existingRecord===undefined||equals(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$1(key);};function validate$5(obj,path='ProductDetailRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$1(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_defaultImage=obj.defaultImage;const path_defaultImage=path+'.defaultImage';const referenceProductMediaRepresentationValidationError=validate(obj_defaultImage,path_defaultImage);if(referenceProductMediaRepresentationValidationError!==null){let message='Object doesn\'t match ProductMediaRepresentation (at "'+path_defaultImage+'")\n';message+=referenceProductMediaRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_entitlement=obj.entitlement;const path_entitlement=path+'.entitlement';const referenceProductEntitlementRepresentationValidationError=validate$1(obj_entitlement,path_entitlement);if(referenceProductEntitlementRepresentationValidationError!==null){let message='Object doesn\'t match ProductEntitlementRepresentation (at "'+path_entitlement+'")\n';message+=referenceProductEntitlementRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$1$1(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$1$1(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];const path_fields_prop=path_fields+'["'+key+'"]';let obj_fields_prop_union0=null;const obj_fields_prop_union0_error=(()=>{if(typeof obj_fields_prop!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fields_prop+'" (at "'+path_fields_prop+'")');}})();if(obj_fields_prop_union0_error!=null){obj_fields_prop_union0=obj_fields_prop_union0_error.message;}let obj_fields_prop_union1=null;const obj_fields_prop_union1_error=(()=>{if(obj_fields_prop!==null){return new TypeError('Expected "null" but received "'+typeof obj_fields_prop+'" (at "'+path_fields_prop+'")');}})();if(obj_fields_prop_union1_error!=null){obj_fields_prop_union1=obj_fields_prop_union1_error.message;}if(obj_fields_prop_union0&&obj_fields_prop_union1){let message='Object doesn\'t match union (at "'+path_fields_prop+'")';message+='\n'+obj_fields_prop_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_fields_prop_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_mediaGroups=obj.mediaGroups;const path_mediaGroups=path+'.mediaGroups';if(!ArrayIsArray$1$1(obj_mediaGroups)){return new TypeError('Expected "array" but received "'+typeof obj_mediaGroups+'" (at "'+path_mediaGroups+'")');}for(let i=0;i<obj_mediaGroups.length;i++){const obj_mediaGroups_item=obj_mediaGroups[i];const path_mediaGroups_item=path_mediaGroups+'['+i+']';const referenceProductMediaGroupRepresentationValidationError=validate$2(obj_mediaGroups_item,path_mediaGroups_item);if(referenceProductMediaGroupRepresentationValidationError!==null){let message='Object doesn\'t match ProductMediaGroupRepresentation (at "'+path_mediaGroups_item+'")\n';message+=referenceProductMediaGroupRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_primaryProductCategoryPath=obj.primaryProductCategoryPath;const path_primaryProductCategoryPath=path+'.primaryProductCategoryPath';const referenceProductCategoryPathRepresentationValidationError=validate$4(obj_primaryProductCategoryPath,path_primaryProductCategoryPath);if(referenceProductCategoryPathRepresentationValidationError!==null){let message='Object doesn\'t match ProductCategoryPathRepresentation (at "'+path_primaryProductCategoryPath+'")\n';message+=referenceProductCategoryPathRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function normalize$1(input,existing,path,lds,store,timestamp){return input;}const select$1=function ProductDetailRepresentationSelect(){return {kind:'Fragment',opaque:true};};function equals$1(existing,incoming){if(JSONStrinify(incoming)!==JSONStrinify(existing)){return false;}return true;}function deepFreeze$5(input){const input_defaultImage=input.defaultImage;deepFreeze$2(input_defaultImage);const input_entitlement=input.entitlement;deepFreeze$1$1(input_entitlement);const input_fields=input.fields;const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];}ObjectFreeze$1(input_fields);const input_mediaGroups=input.mediaGroups;for(let i=0;i<input_mediaGroups.length;i++){const input_mediaGroups_item=input_mediaGroups[i];deepFreeze$2$1(input_mediaGroups_item);}ObjectFreeze$1(input_mediaGroups);const input_primaryProductCategoryPath=input.primaryProductCategoryPath;deepFreeze$4(input_primaryProductCategoryPath);ObjectFreeze$1(input);}const ingest$1=function ProductDetailRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$5(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$1(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$5(input);if(existingRecord===undefined||equals$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$1(key);};function getCommerceWebstoresProductsByProductIdAndWebstoreId(config){const key=keyPrefix+'ProductDetailRepresentation('+'effectiveAccountId:'+config.queryParams.effectiveAccountId+','+'excludeEntitlement:'+config.queryParams.excludeEntitlement+','+'excludeFields:'+config.queryParams.excludeFields+','+'excludeMedia:'+config.queryParams.excludeMedia+','+'excludePrimaryProductCategory:'+config.queryParams.excludePrimaryProductCategory+','+'fields:'+config.queryParams.fields+','+'mediaGroups:'+config.queryParams.mediaGroups+','+'productId:'+config.urlParams.productId+','+'webstoreId:'+config.urlParams.webstoreId+')';const headers={};return {path:'/services/data/v49.0/commerce/webstores/'+config.urlParams.webstoreId+'/products/'+config.urlParams.productId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$1,headers};}const getProduct_ConfigPropertyNames={displayName:'getProduct',parameters:{required:['productId','webstoreId'],optional:['effectiveAccountId','excludeEntitlement','excludeFields','excludeMedia','excludePrimaryProductCategory','fields','mediaGroups']}};function typeCheckConfig(untrustedConfig){const config={};const untrustedConfig_productId=untrustedConfig.productId;if(typeof untrustedConfig_productId==='string'){config.productId=untrustedConfig_productId;}const untrustedConfig_webstoreId=untrustedConfig.webstoreId;if(typeof untrustedConfig_webstoreId==='string'){config.webstoreId=untrustedConfig_webstoreId;}const untrustedConfig_effectiveAccountId=untrustedConfig.effectiveAccountId;if(typeof untrustedConfig_effectiveAccountId==='string'){config.effectiveAccountId=untrustedConfig_effectiveAccountId;}const untrustedConfig_excludeEntitlement=untrustedConfig.excludeEntitlement;if(typeof untrustedConfig_excludeEntitlement==='boolean'){config.excludeEntitlement=untrustedConfig_excludeEntitlement;}const untrustedConfig_excludeFields=untrustedConfig.excludeFields;if(typeof untrustedConfig_excludeFields==='boolean'){config.excludeFields=untrustedConfig_excludeFields;}const untrustedConfig_excludeMedia=untrustedConfig.excludeMedia;if(typeof untrustedConfig_excludeMedia==='boolean'){config.excludeMedia=untrustedConfig_excludeMedia;}const untrustedConfig_excludePrimaryProductCategory=untrustedConfig.excludePrimaryProductCategory;if(typeof untrustedConfig_excludePrimaryProductCategory==='boolean'){config.excludePrimaryProductCategory=untrustedConfig_excludePrimaryProductCategory;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$2(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_mediaGroups=untrustedConfig.mediaGroups;if(ArrayIsArray$2(untrustedConfig_mediaGroups)){const untrustedConfig_mediaGroups_array=[];for(let i=0,arrayLength=untrustedConfig_mediaGroups.length;i<arrayLength;i++){const untrustedConfig_mediaGroups_item=untrustedConfig_mediaGroups[i];if(typeof untrustedConfig_mediaGroups_item==='string'){untrustedConfig_mediaGroups_array.push(untrustedConfig_mediaGroups_item);}}config.mediaGroups=untrustedConfig_mediaGroups_array;}return config;}function validateAdapterConfig$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1(untrustedConfig)){return null;}{validateConfig(untrustedConfig,configPropertyNames);}const config=typeCheckConfig(untrustedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot(lds,config){const request=getCommerceWebstoresProductsByProductIdAndWebstoreId({urlParams:{productId:config.productId,webstoreId:config.webstoreId},queryParams:{effectiveAccountId:config.effectiveAccountId,excludeEntitlement:config.excludeEntitlement,excludeFields:config.excludeFields,excludeMedia:config.excludeMedia,excludePrimaryProductCategory:config.excludePrimaryProductCategory,fields:config.fields,mediaGroups:config.mediaGroups}});const selector={recordId:request.key,node:select$1(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot(lds,config,override){const request=getCommerceWebstoresProductsByProductIdAndWebstoreId({urlParams:{productId:config.productId,webstoreId:config.webstoreId},queryParams:{effectiveAccountId:config.effectiveAccountId,excludeEntitlement:config.excludeEntitlement,excludeFields:config.excludeFields,excludeMedia:config.excludeMedia,excludePrimaryProductCategory:config.excludePrimaryProductCategory,fields:config.fields,mediaGroups:config.mediaGroups}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getProductAdapterFactory=lds=>{return refreshable$1(// Create snapshot either via a cache hit or via the network
    function getProduct(untrustedConfig){const config=validateAdapterConfig$1(untrustedConfig,getProduct_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED){return cacheSnapshot;}return buildNetworkSnapshot(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$1(untrustedConfig,getProduct_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getProduct" refresh function');}return buildNetworkSnapshot(lds,config,{headers:{'Cache-Control':'no-cache'}});});};function getCommerceWebstoresProductCategoryPathProductCategoriesByProductCategoryIdAndWebstoreId(config){const key=keyPrefix+'ProductCategoryPathRepresentation('+'productCategoryId:'+config.urlParams.productCategoryId+','+'webstoreId:'+config.urlParams.webstoreId+')';const headers={};return {path:'/services/data/v49.0/commerce/webstores/'+config.urlParams.webstoreId+'/product-category-path/product-categories/'+config.urlParams.productCategoryId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest,headers};}const getProductCategoryPath_ConfigPropertyNames={displayName:'getProductCategoryPath',parameters:{required:['productCategoryId','webstoreId'],optional:[]}};function typeCheckConfig$1(untrustedConfig){const config={};const untrustedConfig_productCategoryId=untrustedConfig.productCategoryId;if(typeof untrustedConfig_productCategoryId==='string'){config.productCategoryId=untrustedConfig_productCategoryId;}const untrustedConfig_webstoreId=untrustedConfig.webstoreId;if(typeof untrustedConfig_webstoreId==='string'){config.webstoreId=untrustedConfig_webstoreId;}return config;}function validateAdapterConfig$1$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1(untrustedConfig)){return null;}{validateConfig(untrustedConfig,configPropertyNames);}const config=typeCheckConfig$1(untrustedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$1(lds,config){const request=getCommerceWebstoresProductCategoryPathProductCategoriesByProductCategoryIdAndWebstoreId({urlParams:{productCategoryId:config.productCategoryId,webstoreId:config.webstoreId}});const selector={recordId:request.key,node:select(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$1(lds,config,override){const request=getCommerceWebstoresProductCategoryPathProductCategoriesByProductCategoryIdAndWebstoreId({urlParams:{productCategoryId:config.productCategoryId,webstoreId:config.webstoreId}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$1(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getProductCategoryPathAdapterFactory=lds=>{return refreshable$1(// Create snapshot either via a cache hit or via the network
    function getProductCategoryPath(untrustedConfig){const config=validateAdapterConfig$1$1(untrustedConfig,getProductCategoryPath_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$1(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED){return cacheSnapshot;}return buildNetworkSnapshot$1(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$1$1(untrustedConfig,getProductCategoryPath_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getProductCategoryPath" refresh function');}return buildNetworkSnapshot$1(lds,config,{headers:{'Cache-Control':'no-cache'}});});};const{hasOwnProperty:ObjectPrototypeHasOwnProperty$1}=Object.prototype;const{keys:ObjectKeys$2}=Object;const{isArray:ArrayIsArray$3}=Array;function isPromise$3(value){return value.then!==undefined;}/**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */function validateConfig$1(config,adapter,oneOf){const{displayName}=adapter;const{required,optional,unsupported}=adapter.parameters;if(config===undefined||required.every(req=>ObjectPrototypeHasOwnProperty$1.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);}if(oneOf&&oneOf.some(req=>ObjectPrototypeHasOwnProperty$1.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);}if(unsupported!==undefined&&unsupported.some(req=>ObjectPrototypeHasOwnProperty$1.call(config,req))){throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);}const supported=required.concat(optional);if(ObjectKeys$2(config).some(key=>!supported.includes(key))){throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);}}function untrustedIsObject$2(untrusted){return typeof untrusted==='object'&&untrusted!==null&&ArrayIsArray$3(untrusted)===false;}function areRequiredParametersPresent$1(config,configPropertyNames){return configPropertyNames.parameters.required.every(req=>req in config);}function refreshable$2(adapter,resolve){return config=>{const result=adapter(config);if(result===null){return result;}if(isPromise$3(result)){return result.then(snapshot=>{snapshot.refresh={config,resolve};return snapshot;});}result.refresh={config,resolve};return result;};}const SNAPSHOT_STATE_FULFILLED$1='Fulfilled';const keyPrefix$1='Commerce::';const{freeze:ObjectFreeze$2,keys:ObjectKeys$1$2}=Object;const{isArray:ArrayIsArray$1$2}=Array;const{stringify:JSONStrinify$1}=JSON;function createLink$2(ref){return {__ref:ref};}function validate$6(obj,path='SearchCategoryRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_children=obj.children;const path_children=path+'.children';if(!ArrayIsArray$1$2(obj_children)){return new TypeError('Expected "array" but received "'+typeof obj_children+'" (at "'+path_children+'")');}for(let i=0;i<obj_children.length;i++){const obj_children_item=obj_children[i];const path_children_item=path_children+'['+i+']';const referenceSearchCategoryRepresentationValidationError=validate$6(obj_children_item,path_children_item);if(referenceSearchCategoryRepresentationValidationError!==null){let message='Object doesn\'t match SearchCategoryRepresentation (at "'+path_children_item+'")\n';message+=referenceSearchCategoryRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_productCount=obj.productCount;const path_productCount=path+'.productCount';if(typeof obj_productCount!=='number'||typeof obj_productCount==='number'&&Math.floor(obj_productCount)!==obj_productCount){return new TypeError('Expected "integer" but received "'+typeof obj_productCount+'" (at "'+path_productCount+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$6(input){const input_children=input.children;for(let i=0;i<input_children.length;i++){const input_children_item=input_children[i];deepFreeze$6(input_children_item);}ObjectFreeze$2(input_children);ObjectFreeze$2(input);}function validate$1$1(obj,path='SearchFacetRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}if(obj.attributeType!==undefined){const obj_attributeType=obj.attributeType;const path_attributeType=path+'.attributeType';if(typeof obj_attributeType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_attributeType+'" (at "'+path_attributeType+'")');}}const obj_displayName=obj.displayName;const path_displayName=path+'.displayName';if(typeof obj_displayName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_displayName+'" (at "'+path_displayName+'")');}const obj_displayRank=obj.displayRank;const path_displayRank=path+'.displayRank';if(typeof obj_displayRank!=='number'||typeof obj_displayRank==='number'&&Math.floor(obj_displayRank)!==obj_displayRank){return new TypeError('Expected "integer" but received "'+typeof obj_displayRank+'" (at "'+path_displayRank+'")');}const obj_displayType=obj.displayType;const path_displayType=path+'.displayType';if(typeof obj_displayType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_displayType+'" (at "'+path_displayType+'")');}if(obj.facetType!==undefined){const obj_facetType=obj.facetType;const path_facetType=path+'.facetType';if(typeof obj_facetType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_facetType+'" (at "'+path_facetType+'")');}}const obj_nameOrId=obj.nameOrId;const path_nameOrId=path+'.nameOrId';if(typeof obj_nameOrId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nameOrId+'" (at "'+path_nameOrId+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$1$2(input){ObjectFreeze$2(input);}function validate$2$1(obj,path='ProductSummaryRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$1$2(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$1$2(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];const path_fields_prop=path_fields+'["'+key+'"]';let obj_fields_prop_union0=null;const obj_fields_prop_union0_error=(()=>{if(typeof obj_fields_prop!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fields_prop+'" (at "'+path_fields_prop+'")');}})();if(obj_fields_prop_union0_error!=null){obj_fields_prop_union0=obj_fields_prop_union0_error.message;}let obj_fields_prop_union1=null;const obj_fields_prop_union1_error=(()=>{if(obj_fields_prop!==null){return new TypeError('Expected "null" but received "'+typeof obj_fields_prop+'" (at "'+path_fields_prop+'")');}})();if(obj_fields_prop_union1_error!=null){obj_fields_prop_union1=obj_fields_prop_union1_error.message;}if(obj_fields_prop_union0&&obj_fields_prop_union1){let message='Object doesn\'t match union (at "'+path_fields_prop+'")';message+='\n'+obj_fields_prop_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_fields_prop_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_name=obj.name;const path_name=path+'.name';if(typeof obj_name!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_name+'" (at "'+path_name+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$2$2(input){const input_fields=input.fields;const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];}ObjectFreeze$2(input_fields);ObjectFreeze$2(input);}function validate$3$1(obj,path='ProductSummaryCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_currencyIsoCode=obj.currencyIsoCode;const path_currencyIsoCode=path+'.currencyIsoCode';if(typeof obj_currencyIsoCode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currencyIsoCode+'" (at "'+path_currencyIsoCode+'")');}if(obj.pageSize!==undefined){const obj_pageSize=obj.pageSize;const path_pageSize=path+'.pageSize';if(typeof obj_pageSize!=='number'||typeof obj_pageSize==='number'&&Math.floor(obj_pageSize)!==obj_pageSize){return new TypeError('Expected "integer" but received "'+typeof obj_pageSize+'" (at "'+path_pageSize+'")');}}const obj_products=obj.products;const path_products=path+'.products';if(!ArrayIsArray$1$2(obj_products)){return new TypeError('Expected "array" but received "'+typeof obj_products+'" (at "'+path_products+'")');}for(let i=0;i<obj_products.length;i++){const obj_products_item=obj_products[i];const path_products_item=path_products+'['+i+']';const referenceProductSummaryRepresentationValidationError=validate$2$1(obj_products_item,path_products_item);if(referenceProductSummaryRepresentationValidationError!==null){let message='Object doesn\'t match ProductSummaryRepresentation (at "'+path_products_item+'")\n';message+=referenceProductSummaryRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_total=obj.total;const path_total=path+'.total';if(typeof obj_total!=='number'||typeof obj_total==='number'&&Math.floor(obj_total)!==obj_total){return new TypeError('Expected "integer" but received "'+typeof obj_total+'" (at "'+path_total+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$3$1(input){const input_products=input.products;for(let i=0;i<input_products.length;i++){const input_products_item=input_products[i];deepFreeze$2$2(input_products_item);}ObjectFreeze$2(input_products);ObjectFreeze$2(input);}function validate$4$1(obj,path='ProductSearchResultsRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_categories=obj.categories;const path_categories=path+'.categories';const referenceSearchCategoryRepresentationValidationError=validate$6(obj_categories,path_categories);if(referenceSearchCategoryRepresentationValidationError!==null){let message='Object doesn\'t match SearchCategoryRepresentation (at "'+path_categories+'")\n';message+=referenceSearchCategoryRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_facets=obj.facets;const path_facets=path+'.facets';if(!ArrayIsArray$1$2(obj_facets)){return new TypeError('Expected "array" but received "'+typeof obj_facets+'" (at "'+path_facets+'")');}for(let i=0;i<obj_facets.length;i++){const obj_facets_item=obj_facets[i];const path_facets_item=path_facets+'['+i+']';const referenceSearchFacetRepresentationValidationError=validate$1$1(obj_facets_item,path_facets_item);if(referenceSearchFacetRepresentationValidationError!==null){let message='Object doesn\'t match SearchFacetRepresentation (at "'+path_facets_item+'")\n';message+=referenceSearchFacetRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_locale=obj.locale;const path_locale=path+'.locale';if(typeof obj_locale!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_locale+'" (at "'+path_locale+'")');}const obj_productsPage=obj.productsPage;const path_productsPage=path+'.productsPage';const referenceProductSummaryCollectionRepresentationValidationError=validate$3$1(obj_productsPage,path_productsPage);if(referenceProductSummaryCollectionRepresentationValidationError!==null){let message='Object doesn\'t match ProductSummaryCollectionRepresentation (at "'+path_productsPage+'")\n';message+=referenceProductSummaryCollectionRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function normalize$2(input,existing,path,lds,store,timestamp){return input;}const select$2=function ProductSearchResultsRepresentationSelect(){return {kind:'Fragment',opaque:true};};function equals$2(existing,incoming){if(JSONStrinify$1(incoming)!==JSONStrinify$1(existing)){return false;}return true;}function deepFreeze$4$1(input){const input_categories=input.categories;deepFreeze$6(input_categories);const input_facets=input.facets;for(let i=0;i<input_facets.length;i++){const input_facets_item=input_facets[i];deepFreeze$1$2(input_facets_item);}ObjectFreeze$2(input_facets);const input_productsPage=input.productsPage;deepFreeze$3$1(input_productsPage);ObjectFreeze$2(input);}const ingest$2=function ProductSearchResultsRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$4$1(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$2(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$4$1(input);if(existingRecord===undefined||equals$2(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$2(key);};function postCommerceWebstoresSearchProductSearchByWebstoreId(config){const key=keyPrefix$1+'ProductSearchResultsRepresentation('+'effectiveAccountId:'+config.queryParams.effectiveAccountId+','+'webstoreId:'+config.urlParams.webstoreId+')';const headers={};return {path:'/services/data/v49.0/commerce/webstores/'+config.urlParams.webstoreId+'/search/product-search',method:'post',body:config.body,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$2,headers};}const productSearch_ConfigPropertyNames={displayName:'productSearch',parameters:{required:['webstoreId','categoryId','fields','page','pageSize','refinements','searchTerm','sortOrderId'],optional:['effectiveAccountId']}};function typeCheckConfig$2(untrustedConfig){const config={};const untrustedConfig_webstoreId=untrustedConfig.webstoreId;if(typeof untrustedConfig_webstoreId==='string'){config.webstoreId=untrustedConfig_webstoreId;}const untrustedConfig_effectiveAccountId=untrustedConfig.effectiveAccountId;if(typeof untrustedConfig_effectiveAccountId==='string'){config.effectiveAccountId=untrustedConfig_effectiveAccountId;}const untrustedConfig_categoryId=untrustedConfig.categoryId;if(typeof untrustedConfig_categoryId==='string'){config.categoryId=untrustedConfig_categoryId;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$3(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_page=untrustedConfig.page;if(typeof untrustedConfig_page==='number'&&Math.floor(untrustedConfig_page)===untrustedConfig_page){config.page=untrustedConfig_page;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_refinements=untrustedConfig.refinements;if(ArrayIsArray$3(untrustedConfig_refinements)){const untrustedConfig_refinements_array=[];for(let i=0,arrayLength=untrustedConfig_refinements.length;i<arrayLength;i++){const untrustedConfig_refinements_item=untrustedConfig_refinements[i];if(untrustedIsObject$2(untrustedConfig_refinements_item)){const untrustedConfig_refinements_item_object={};if(Object.keys(untrustedConfig_refinements_item_object).length>0){untrustedConfig_refinements_array.push(untrustedConfig_refinements_item_object);}}}config.refinements=untrustedConfig_refinements_array;}const untrustedConfig_searchTerm=untrustedConfig.searchTerm;if(typeof untrustedConfig_searchTerm==='string'){config.searchTerm=untrustedConfig_searchTerm;}const untrustedConfig_sortOrderId=untrustedConfig.sortOrderId;if(typeof untrustedConfig_sortOrderId==='string'){config.sortOrderId=untrustedConfig_sortOrderId;}return config;}function validateAdapterConfig$2(untrustedConfig,configPropertyNames){if(!untrustedIsObject$2(untrustedConfig)){return null;}{validateConfig$1(untrustedConfig,configPropertyNames);}const config=typeCheckConfig$2(untrustedConfig);if(!areRequiredParametersPresent$1(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$2(lds,config){const request=postCommerceWebstoresSearchProductSearchByWebstoreId({urlParams:{webstoreId:config.webstoreId},queryParams:{effectiveAccountId:config.effectiveAccountId},body:{categoryId:config.categoryId,fields:config.fields,page:config.page,pageSize:config.pageSize,refinements:config.refinements,searchTerm:config.searchTerm,sortOrderId:config.sortOrderId}});const selector={recordId:request.key,node:select$2(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$2(lds,config,override){const request=postCommerceWebstoresSearchProductSearchByWebstoreId({urlParams:{webstoreId:config.webstoreId},queryParams:{effectiveAccountId:config.effectiveAccountId},body:{categoryId:config.categoryId,fields:config.fields,page:config.page,pageSize:config.pageSize,refinements:config.refinements,searchTerm:config.searchTerm,sortOrderId:config.sortOrderId}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$2(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const productSearchAdapterFactory=lds=>{return refreshable$2(// Create snapshot either via a cache hit or via the network
    function productSearch(untrustedConfig){const config=validateAdapterConfig$2(untrustedConfig,productSearch_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$2(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$1){return cacheSnapshot;}return buildNetworkSnapshot$2(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$2(untrustedConfig,productSearch_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "productSearch" refresh function');}return buildNetworkSnapshot$2(lds,config,{headers:{'Cache-Control':'no-cache'}});});};const{hasOwnProperty:ObjectPrototypeHasOwnProperty$2}=Object.prototype;const{keys:ObjectKeys$3}=Object;const{isArray:ArrayIsArray$4}=Array;function isPromise$4(value){return value.then!==undefined;}/**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */function validateConfig$2(config,adapter,oneOf){const{displayName}=adapter;const{required,optional,unsupported}=adapter.parameters;if(config===undefined||required.every(req=>ObjectPrototypeHasOwnProperty$2.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);}if(oneOf&&oneOf.some(req=>ObjectPrototypeHasOwnProperty$2.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);}if(unsupported!==undefined&&unsupported.some(req=>ObjectPrototypeHasOwnProperty$2.call(config,req))){throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);}const supported=required.concat(optional);if(ObjectKeys$3(config).some(key=>!supported.includes(key))){throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);}}function untrustedIsObject$3(untrusted){return typeof untrusted==='object'&&untrusted!==null&&ArrayIsArray$4(untrusted)===false;}function areRequiredParametersPresent$2(config,configPropertyNames){return configPropertyNames.parameters.required.every(req=>req in config);}function refreshable$3(adapter,resolve){return config=>{const result=adapter(config);if(result===null){return result;}if(isPromise$4(result)){return result.then(snapshot=>{snapshot.refresh={config,resolve};return snapshot;});}result.refresh={config,resolve};return result;};}const SNAPSHOT_STATE_FULFILLED$2='Fulfilled';const keyPrefix$2='Commerce::';const{freeze:ObjectFreeze$3,keys:ObjectKeys$1$3}=Object;const{isArray:ArrayIsArray$1$3}=Array;const{stringify:JSONStrinify$2}=JSON;function createLink$3(ref){return {__ref:ref};}function validate$7(obj,path='PriceAdjustmentTierRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$3(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_adjustmentType=obj.adjustmentType;const path_adjustmentType=path+'.adjustmentType';if(typeof obj_adjustmentType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_adjustmentType+'" (at "'+path_adjustmentType+'")');}const obj_adjustmentValue=obj.adjustmentValue;const path_adjustmentValue=path+'.adjustmentValue';if(typeof obj_adjustmentValue!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_adjustmentValue+'" (at "'+path_adjustmentValue+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_lowerBound=obj.lowerBound;const path_lowerBound=path+'.lowerBound';if(typeof obj_lowerBound!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lowerBound+'" (at "'+path_lowerBound+'")');}const obj_tierUnitPrice=obj.tierUnitPrice;const path_tierUnitPrice=path+'.tierUnitPrice';if(typeof obj_tierUnitPrice!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_tierUnitPrice+'" (at "'+path_tierUnitPrice+'")');}const obj_upperBound=obj.upperBound;const path_upperBound=path+'.upperBound';if(typeof obj_upperBound!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_upperBound+'" (at "'+path_upperBound+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$7(input){ObjectFreeze$3(input);}function validate$1$2(obj,path='PriceAdjustmentScheduleRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$3(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_priceAdjustmentTiers=obj.priceAdjustmentTiers;const path_priceAdjustmentTiers=path+'.priceAdjustmentTiers';if(!ArrayIsArray$1$3(obj_priceAdjustmentTiers)){return new TypeError('Expected "array" but received "'+typeof obj_priceAdjustmentTiers+'" (at "'+path_priceAdjustmentTiers+'")');}for(let i=0;i<obj_priceAdjustmentTiers.length;i++){const obj_priceAdjustmentTiers_item=obj_priceAdjustmentTiers[i];const path_priceAdjustmentTiers_item=path_priceAdjustmentTiers+'['+i+']';const referencePriceAdjustmentTierRepresentationValidationError=validate$7(obj_priceAdjustmentTiers_item,path_priceAdjustmentTiers_item);if(referencePriceAdjustmentTierRepresentationValidationError!==null){let message='Object doesn\'t match PriceAdjustmentTierRepresentation (at "'+path_priceAdjustmentTiers_item+'")\n';message+=referencePriceAdjustmentTierRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function deepFreeze$1$3(input){const input_priceAdjustmentTiers=input.priceAdjustmentTiers;for(let i=0;i<input_priceAdjustmentTiers.length;i++){const input_priceAdjustmentTiers_item=input_priceAdjustmentTiers[i];deepFreeze$7(input_priceAdjustmentTiers_item);}ObjectFreeze$3(input_priceAdjustmentTiers);ObjectFreeze$3(input);}function validate$2$2(obj,path='ProductPriceRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$3(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_currencyIsoCode=obj.currencyIsoCode;const path_currencyIsoCode=path+'.currencyIsoCode';if(typeof obj_currencyIsoCode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currencyIsoCode+'" (at "'+path_currencyIsoCode+'")');}const obj_listPrice=obj.listPrice;const path_listPrice=path+'.listPrice';if(typeof obj_listPrice!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_listPrice+'" (at "'+path_listPrice+'")');}const obj_priceAdjustment=obj.priceAdjustment;const path_priceAdjustment=path+'.priceAdjustment';let obj_priceAdjustment_union0=null;const obj_priceAdjustment_union0_error=(()=>{const referencePriceAdjustmentScheduleRepresentationValidationError=validate$1$2(obj_priceAdjustment,path_priceAdjustment);if(referencePriceAdjustmentScheduleRepresentationValidationError!==null){let message='Object doesn\'t match PriceAdjustmentScheduleRepresentation (at "'+path_priceAdjustment+'")\n';message+=referencePriceAdjustmentScheduleRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_priceAdjustment_union0_error!=null){obj_priceAdjustment_union0=obj_priceAdjustment_union0_error.message;}let obj_priceAdjustment_union1=null;const obj_priceAdjustment_union1_error=(()=>{if(obj_priceAdjustment!==null){return new TypeError('Expected "null" but received "'+typeof obj_priceAdjustment+'" (at "'+path_priceAdjustment+'")');}})();if(obj_priceAdjustment_union1_error!=null){obj_priceAdjustment_union1=obj_priceAdjustment_union1_error.message;}if(obj_priceAdjustment_union0&&obj_priceAdjustment_union1){let message='Object doesn\'t match union (at "'+path_priceAdjustment+'")';message+='\n'+obj_priceAdjustment_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_priceAdjustment_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_pricebookEntryId=obj.pricebookEntryId;const path_pricebookEntryId=path+'.pricebookEntryId';if(typeof obj_pricebookEntryId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_pricebookEntryId+'" (at "'+path_pricebookEntryId+'")');}const obj_unitPrice=obj.unitPrice;const path_unitPrice=path+'.unitPrice';if(typeof obj_unitPrice!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_unitPrice+'" (at "'+path_unitPrice+'")');}})();return v_error===undefined?null:v_error;}function normalize$3(input,existing,path,lds,store,timestamp){return input;}const select$3=function ProductPriceRepresentationSelect(){return {kind:'Fragment',opaque:true};};function equals$3(existing,incoming){if(JSONStrinify$2(incoming)!==JSONStrinify$2(existing)){return false;}return true;}function deepFreeze$2$3(input){const input_priceAdjustment=input.priceAdjustment;if(input_priceAdjustment!==null&&typeof input_priceAdjustment==='object'){deepFreeze$1$3(input_priceAdjustment);}ObjectFreeze$3(input);}const ingest$3=function ProductPriceRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$2$2(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$3(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$2$3(input);if(existingRecord===undefined||equals$3(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$3(key);};function getCommerceWebstoresPricingProductsByProductIdAndWebstoreId(config){const key=keyPrefix$2+'ProductPriceRepresentation('+'effectiveAccountId:'+config.queryParams.effectiveAccountId+','+'productId:'+config.urlParams.productId+','+'webstoreId:'+config.urlParams.webstoreId+')';const headers={};return {path:'/services/data/v49.0/commerce/webstores/'+config.urlParams.webstoreId+'/pricing/products/'+config.urlParams.productId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$3,headers};}const getProductPrice_ConfigPropertyNames={displayName:'getProductPrice',parameters:{required:['productId','webstoreId','effectiveAccountId'],optional:[]}};function typeCheckConfig$3(untrustedConfig){const config={};const untrustedConfig_productId=untrustedConfig.productId;if(typeof untrustedConfig_productId==='string'){config.productId=untrustedConfig_productId;}const untrustedConfig_webstoreId=untrustedConfig.webstoreId;if(typeof untrustedConfig_webstoreId==='string'){config.webstoreId=untrustedConfig_webstoreId;}const untrustedConfig_effectiveAccountId=untrustedConfig.effectiveAccountId;if(typeof untrustedConfig_effectiveAccountId==='string'){config.effectiveAccountId=untrustedConfig_effectiveAccountId;}return config;}function validateAdapterConfig$3(untrustedConfig,configPropertyNames){if(!untrustedIsObject$3(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const config=typeCheckConfig$3(untrustedConfig);if(!areRequiredParametersPresent$2(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$3(lds,config){const request=getCommerceWebstoresPricingProductsByProductIdAndWebstoreId({urlParams:{productId:config.productId,webstoreId:config.webstoreId},queryParams:{effectiveAccountId:config.effectiveAccountId}});const selector={recordId:request.key,node:select$3(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$3(lds,config,override){const request=getCommerceWebstoresPricingProductsByProductIdAndWebstoreId({urlParams:{productId:config.productId,webstoreId:config.webstoreId},queryParams:{effectiveAccountId:config.effectiveAccountId}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$3(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getProductPriceAdapterFactory=lds=>{return refreshable$3(// Create snapshot either via a cache hit or via the network
    function getProductPrice(untrustedConfig){const config=validateAdapterConfig$3(untrustedConfig,getProductPrice_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$3(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$2){return cacheSnapshot;}return buildNetworkSnapshot$3(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$3(untrustedConfig,getProductPrice_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getProductPrice" refresh function');}return buildNetworkSnapshot$3(lds,config,{headers:{'Cache-Control':'no-cache'}});});};const{hasOwnProperty:ObjectPrototypeHasOwnProperty$3}=Object.prototype;const{keys:ObjectKeys$4}=Object;const{isArray:ArrayIsArray$5}=Array;function isPromise$5(value){return value.then!==undefined;}/**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */function validateConfig$3(config,adapter,oneOf){const{displayName}=adapter;const{required,optional,unsupported}=adapter.parameters;if(config===undefined||required.every(req=>ObjectPrototypeHasOwnProperty$3.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);}if(oneOf&&oneOf.some(req=>ObjectPrototypeHasOwnProperty$3.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);}if(unsupported!==undefined&&unsupported.some(req=>ObjectPrototypeHasOwnProperty$3.call(config,req))){throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);}const supported=required.concat(optional);if(ObjectKeys$4(config).some(key=>!supported.includes(key))){throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);}}function untrustedIsObject$4(untrusted){return typeof untrusted==='object'&&untrusted!==null&&ArrayIsArray$5(untrusted)===false;}function areRequiredParametersPresent$3(config,configPropertyNames){return configPropertyNames.parameters.required.every(req=>req in config);}function refreshable$4(adapter,resolve){return config=>{const result=adapter(config);if(result===null){return result;}if(isPromise$5(result)){return result.then(snapshot=>{snapshot.refresh={config,resolve};return snapshot;});}result.refresh={config,resolve};return result;};}const SNAPSHOT_STATE_FULFILLED$3='Fulfilled';const keyPrefix$3='CommunityNavigation::';const{freeze:ObjectFreeze$4,keys:ObjectKeys$1$4}=Object;const{isArray:ArrayIsArray$1$4}=Array;const{stringify:JSONStrinify$3}=JSON;function createLink$4(ref){return {__ref:ref};}function validate$8(obj,path='NavigationMenuItemRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$4(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_actionType=obj.actionType;const path_actionType=path+'.actionType';if(typeof obj_actionType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionType+'" (at "'+path_actionType+'")');}const obj_actionValue=obj.actionValue;const path_actionValue=path+'.actionValue';let obj_actionValue_union0=null;const obj_actionValue_union0_error=(()=>{if(typeof obj_actionValue!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionValue+'" (at "'+path_actionValue+'")');}})();if(obj_actionValue_union0_error!=null){obj_actionValue_union0=obj_actionValue_union0_error.message;}let obj_actionValue_union1=null;const obj_actionValue_union1_error=(()=>{if(obj_actionValue!==null){return new TypeError('Expected "null" but received "'+typeof obj_actionValue+'" (at "'+path_actionValue+'")');}})();if(obj_actionValue_union1_error!=null){obj_actionValue_union1=obj_actionValue_union1_error.message;}if(obj_actionValue_union0&&obj_actionValue_union1){let message='Object doesn\'t match union (at "'+path_actionValue+'")';message+='\n'+obj_actionValue_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_actionValue_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_imageUrl=obj.imageUrl;const path_imageUrl=path+'.imageUrl';let obj_imageUrl_union0=null;const obj_imageUrl_union0_error=(()=>{if(typeof obj_imageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_imageUrl+'" (at "'+path_imageUrl+'")');}})();if(obj_imageUrl_union0_error!=null){obj_imageUrl_union0=obj_imageUrl_union0_error.message;}let obj_imageUrl_union1=null;const obj_imageUrl_union1_error=(()=>{if(obj_imageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_imageUrl+'" (at "'+path_imageUrl+'")');}})();if(obj_imageUrl_union1_error!=null){obj_imageUrl_union1=obj_imageUrl_union1_error.message;}if(obj_imageUrl_union0&&obj_imageUrl_union1){let message='Object doesn\'t match union (at "'+path_imageUrl+'")';message+='\n'+obj_imageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_imageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_subMenu=obj.subMenu;const path_subMenu=path+'.subMenu';if(!ArrayIsArray$1$4(obj_subMenu)){return new TypeError('Expected "array" but received "'+typeof obj_subMenu+'" (at "'+path_subMenu+'")');}for(let i=0;i<obj_subMenu.length;i++){const obj_subMenu_item=obj_subMenu[i];const path_subMenu_item=path_subMenu+'['+i+']';const referenceNavigationMenuItemRepresentationValidationError=validate$8(obj_subMenu_item,path_subMenu_item);if(referenceNavigationMenuItemRepresentationValidationError!==null){let message='Object doesn\'t match NavigationMenuItemRepresentation (at "'+path_subMenu_item+'")\n';message+=referenceNavigationMenuItemRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_target=obj.target;const path_target=path+'.target';if(typeof obj_target!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_target+'" (at "'+path_target+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$8(input){const input_subMenu=input.subMenu;for(let i=0;i<input_subMenu.length;i++){const input_subMenu_item=input_subMenu[i];deepFreeze$8(input_subMenu_item);}ObjectFreeze$4(input_subMenu);ObjectFreeze$4(input);}function validate$1$3(obj,path='NavigationMenuItemCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$1$4(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_menuItems=obj.menuItems;const path_menuItems=path+'.menuItems';if(!ArrayIsArray$1$4(obj_menuItems)){return new TypeError('Expected "array" but received "'+typeof obj_menuItems+'" (at "'+path_menuItems+'")');}for(let i=0;i<obj_menuItems.length;i++){const obj_menuItems_item=obj_menuItems[i];const path_menuItems_item=path_menuItems+'['+i+']';const referenceNavigationMenuItemRepresentationValidationError=validate$8(obj_menuItems_item,path_menuItems_item);if(referenceNavigationMenuItemRepresentationValidationError!==null){let message='Object doesn\'t match NavigationMenuItemRepresentation (at "'+path_menuItems_item+'")\n';message+=referenceNavigationMenuItemRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function normalize$4(input,existing,path,lds,store,timestamp){return input;}const select$4=function NavigationMenuItemCollectionRepresentationSelect(){return {kind:'Fragment',opaque:true};};function equals$4(existing,incoming){if(JSONStrinify$3(incoming)!==JSONStrinify$3(existing)){return false;}return true;}function deepFreeze$1$4(input){const input_menuItems=input.menuItems;for(let i=0;i<input_menuItems.length;i++){const input_menuItems_item=input_menuItems[i];deepFreeze$8(input_menuItems_item);}ObjectFreeze$4(input_menuItems);ObjectFreeze$4(input);}const ingest$4=function NavigationMenuItemCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$1$3(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$4(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$1$4(input);if(existingRecord===undefined||equals$4(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$4(key);};function getConnectCommunitiesNavigationMenuNavigationMenuItemsByCommunityId(config){const key=keyPrefix$3+'NavigationMenuItemCollectionRepresentation('+'addHomeMenuItem:'+config.queryParams.addHomeMenuItem+','+'includeImageUrl:'+config.queryParams.includeImageUrl+','+'menuItemTypesToSkip:'+config.queryParams.menuItemTypesToSkip+','+'navigationLinkSetDeveloperName:'+config.queryParams.navigationLinkSetDeveloperName+','+'navigationLinkSetId:'+config.queryParams.navigationLinkSetId+','+'publishStatus:'+config.queryParams.publishStatus+','+'communityId:'+config.urlParams.communityId+')';const headers={};return {path:'/services/data/v49.0/connect/communities/'+config.urlParams.communityId+'/navigation-menu/navigation-menu-items',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$4,headers};}const getCommunityNavigationMenu_ConfigPropertyNames={displayName:'getCommunityNavigationMenu',parameters:{required:['communityId'],optional:['addHomeMenuItem','includeImageUrl','menuItemTypesToSkip','navigationLinkSetDeveloperName','navigationLinkSetId','publishStatus']}};function typeCheckConfig$4(untrustedConfig){const config={};const untrustedConfig_communityId=untrustedConfig.communityId;if(typeof untrustedConfig_communityId==='string'){config.communityId=untrustedConfig_communityId;}const untrustedConfig_addHomeMenuItem=untrustedConfig.addHomeMenuItem;if(typeof untrustedConfig_addHomeMenuItem==='boolean'){config.addHomeMenuItem=untrustedConfig_addHomeMenuItem;}const untrustedConfig_includeImageUrl=untrustedConfig.includeImageUrl;if(typeof untrustedConfig_includeImageUrl==='boolean'){config.includeImageUrl=untrustedConfig_includeImageUrl;}const untrustedConfig_menuItemTypesToSkip=untrustedConfig.menuItemTypesToSkip;if(ArrayIsArray$5(untrustedConfig_menuItemTypesToSkip)){const untrustedConfig_menuItemTypesToSkip_array=[];for(let i=0,arrayLength=untrustedConfig_menuItemTypesToSkip.length;i<arrayLength;i++){const untrustedConfig_menuItemTypesToSkip_item=untrustedConfig_menuItemTypesToSkip[i];if(typeof untrustedConfig_menuItemTypesToSkip_item==='string'){untrustedConfig_menuItemTypesToSkip_array.push(untrustedConfig_menuItemTypesToSkip_item);}}config.menuItemTypesToSkip=untrustedConfig_menuItemTypesToSkip_array;}const untrustedConfig_navigationLinkSetDeveloperName=untrustedConfig.navigationLinkSetDeveloperName;if(typeof untrustedConfig_navigationLinkSetDeveloperName==='string'){config.navigationLinkSetDeveloperName=untrustedConfig_navigationLinkSetDeveloperName;}const untrustedConfig_navigationLinkSetId=untrustedConfig.navigationLinkSetId;if(typeof untrustedConfig_navigationLinkSetId==='string'){config.navigationLinkSetId=untrustedConfig_navigationLinkSetId;}const untrustedConfig_publishStatus=untrustedConfig.publishStatus;if(typeof untrustedConfig_publishStatus==='string'){config.publishStatus=untrustedConfig_publishStatus;}return config;}function validateAdapterConfig$4(untrustedConfig,configPropertyNames){if(!untrustedIsObject$4(untrustedConfig)){return null;}{validateConfig$3(untrustedConfig,configPropertyNames);}const config=typeCheckConfig$4(untrustedConfig);if(!areRequiredParametersPresent$3(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$4(lds,config){const request=getConnectCommunitiesNavigationMenuNavigationMenuItemsByCommunityId({urlParams:{communityId:config.communityId},queryParams:{addHomeMenuItem:config.addHomeMenuItem,includeImageUrl:config.includeImageUrl,menuItemTypesToSkip:config.menuItemTypesToSkip,navigationLinkSetDeveloperName:config.navigationLinkSetDeveloperName,navigationLinkSetId:config.navigationLinkSetId,publishStatus:config.publishStatus}});const selector={recordId:request.key,node:select$4(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$4(lds,config,override){const request=getConnectCommunitiesNavigationMenuNavigationMenuItemsByCommunityId({urlParams:{communityId:config.communityId},queryParams:{addHomeMenuItem:config.addHomeMenuItem,includeImageUrl:config.includeImageUrl,menuItemTypesToSkip:config.menuItemTypesToSkip,navigationLinkSetDeveloperName:config.navigationLinkSetDeveloperName,navigationLinkSetId:config.navigationLinkSetId,publishStatus:config.publishStatus}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$4(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getCommunityNavigationMenuAdapterFactory=lds=>{return refreshable$4(// Create snapshot either via a cache hit or via the network
    function getCommunityNavigationMenu(untrustedConfig){const config=validateAdapterConfig$4(untrustedConfig,getCommunityNavigationMenu_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$4(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$3){return cacheSnapshot;}return buildNetworkSnapshot$4(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$4(untrustedConfig,getCommunityNavigationMenu_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getCommunityNavigationMenu" refresh function');}return buildNetworkSnapshot$4(lds,config,{headers:{'Cache-Control':'no-cache'}});});};const{assign: assign$1,create:create$1$1,freeze:freeze$2,keys:keys$3}=Object;const{hasOwnProperty:hasOwnProperty$1}=Object.prototype;const{split,endsWith}=String.prototype;const{isArray:isArray$3}=Array;const{push:push$1}=Array.prototype;const{parse,stringify:stringify$3}=JSON;function deepFreeze$9(value){// No need to freeze primitives
    if(typeof value!=='object'||value===null){return;}if(isArray$3(value)){for(let i=0,len=value.length;i<len;i+=1){deepFreeze$9(value[i]);}}else {const keys$1=keys$3(value);for(let i=0,len=keys$1.length;i<len;i+=1){deepFreeze$9(value[keys$1[i]]);}}freeze$2(value);}const MAX_RECORD_DEPTH=5;const FIELD_SEPARATOR='.';const API_NAME_SELECTION={kind:'Scalar',name:'apiName'};const CHILD_RELATIONSHIP_SELECTION={// We don't support RecordRep.childRelationships because it has a nasty
    // degenerate case of multiple pages of child records
    kind:'Object',name:'childRelationships'};const ID_SELECTION={kind:'Scalar',name:'id'};const LAST_MODIFIED_BY_ID_SELECTION={kind:'Scalar',name:'lastModifiedById'};const LAST_MODIFIED_BY_DATE_SELECTION={kind:'Scalar',name:'lastModifiedDate'};const RECORD_TYPE_ID_SELECTION={kind:'Scalar',name:'recordTypeId'};const RECORD_TYPE_INFO_SELECTION={kind:'Object',name:'recordTypeInfo',nullable:true,selections:[{kind:'Scalar',name:'available'},{kind:'Scalar',name:'defaultRecordTypeMapping'},{kind:'Scalar',name:'master'},{kind:'Scalar',name:'name'},{kind:'Scalar',name:'recordTypeId'}]};const SYSTEM_MODSTAMP_SELECTION={kind:'Scalar',name:'systemModstamp'};const DISPLAY_VALUE_SELECTION={kind:'Scalar',name:'displayValue'};const SCALAR_VALUE_SELECTION={kind:'Scalar',name:'value'};function isSpanningRecord(fieldValue){return fieldValue!==null&&typeof fieldValue==='object';}function insertFieldsIntoTrie(root,fields,optional){for(let i=0,len=fields.length;i<len;i++){const field=fields[i].split(FIELD_SEPARATOR);let current=root;for(let j=1,len=field.length;j<len&&j<=MAX_RECORD_DEPTH+1;j++){const fieldName=field[j];let next=current.children[fieldName];if(next===undefined){// A field is scalar only if it is the last field name in the field.
    const scalar=j===len-1;// LDS restricts the numbers of fields that can be traversed to MAX_RECORD_DEPTH,
    // however we still denormalize fields at MAX_RECORD_DEPTH + 1, only if they are
    // scalar fields.
    if(j<=MAX_RECORD_DEPTH||scalar===true){// We now know that there are children fields, so we can mark the parent
    // as not a scalar
    current.scalar=false;next={name:fieldName,scalar,optional,children:{}};current.children[fieldName]=next;}}current=next;}}}function convertTrieToSelection(fieldDefinition){const fieldsSelection=[];const{children}=fieldDefinition;const childrenKeys=keys$3(children);for(let i=0,len=childrenKeys.length;i<len;i+=1){const childKey=childrenKeys[i];const childFieldDefinition=children[childKey];let fieldValueSelection;if(childFieldDefinition.scalar===true){fieldValueSelection=SCALAR_VALUE_SELECTION;}else {fieldValueSelection={kind:'Link',name:'value',nullable:true,selections:convertTrieToSelection(childFieldDefinition)};}push$1.call(fieldsSelection,{kind:'Link',name:childFieldDefinition.name,required:childFieldDefinition.optional===true?false:undefined,selections:[DISPLAY_VALUE_SELECTION,fieldValueSelection]});}return [API_NAME_SELECTION,CHILD_RELATIONSHIP_SELECTION,ID_SELECTION,LAST_MODIFIED_BY_ID_SELECTION,LAST_MODIFIED_BY_DATE_SELECTION,RECORD_TYPE_ID_SELECTION,RECORD_TYPE_INFO_SELECTION,SYSTEM_MODSTAMP_SELECTION,{kind:'Object',name:'fields',selections:fieldsSelection}];}/**
     * Convert a list of fields and optional fields into RecordRepresentation its equivalent
     * selection.
     */function buildSelectionFromFields(fields,optionalFields=[]){const root={name:'<root>',optional:false,scalar:false,children:{}};insertFieldsIntoTrie(root,fields,false);insertFieldsIntoTrie(root,optionalFields,true);return convertTrieToSelection(root);}/**
     * Convert a RecordRepresentationLike into its equivalent selection.
     */function buildSelectionFromRecord(record){const fieldsSelection=[];const{fields}=record;const fieldNames=keys$3(fields);for(let i=0,len=fieldNames.length;i<len;i++){const fieldName=fieldNames[i];const{value:fieldValue}=fields[fieldName];let fieldValueSelection=SCALAR_VALUE_SELECTION;if(isSpanningRecord(fieldValue)){fieldValueSelection={kind:'Link',name:'value',nullable:true,selections:buildSelectionFromRecord(fieldValue)};}push$1.call(fieldsSelection,{kind:'Link',name:fieldName,required:undefined,selections:[DISPLAY_VALUE_SELECTION,fieldValueSelection]});}return [API_NAME_SELECTION,CHILD_RELATIONSHIP_SELECTION,ID_SELECTION,LAST_MODIFIED_BY_ID_SELECTION,LAST_MODIFIED_BY_DATE_SELECTION,RECORD_TYPE_ID_SELECTION,RECORD_TYPE_INFO_SELECTION,SYSTEM_MODSTAMP_SELECTION,{kind:'Object',name:'fields',selections:fieldsSelection}];}function extractRecordFieldsRecursively(record){const fields=[];const fieldNames=keys$3(record.fields);for(let i=0,len=fieldNames.length;i<len;i++){const fieldName=fieldNames[i];const{value:fieldValue}=record.fields[fieldName];if(isSpanningRecord(fieldValue)){const spanningRecordFields=extractRecordFieldsRecursively(fieldValue);for(let j=0,len=spanningRecordFields.length;j<len;j++){spanningRecordFields[j]=`${fieldName}.${spanningRecordFields[j]}`;}push$1.apply(fields,spanningRecordFields);}else {push$1.call(fields,fieldName);}}return fields;}/**
     * Returns a list of fields for a RecordRepresentationLike.
     *
     * TODO W-6900271 - Remove this function once getRelatedList don't depend on it anymore. Always prefer
     * generating a selection out of a record, than convert a record to a field list and back to a
     * selection.
     */function extractRecordFields(record){const{apiName}=record;const fields=extractRecordFieldsRecursively(record);for(let i=0,len=fields.length;i<len;i++){fields[i]=`${apiName}.${fields[i]}`;}return fields;}const{freeze:ObjectFreeze$5,keys:ObjectKeys$5}=Object;const{isArray:ArrayIsArray$6}=Array;const{stringify:JSONStrinify$4}=JSON;function equalsArray(a,b,equalsItem){const aLength=a.length;const bLength=b.length;if(aLength!==bLength){return false;}for(let i=0;i<aLength;i++){if(equalsItem(a[i],b[i])===false){return false;}}return true;}function equalsObject(a,b,equalsProp){const aKeys=ObjectKeys$5(a).sort();const bKeys=ObjectKeys$5(b).sort();const aKeysLength=aKeys.length;const bKeysLength=bKeys.length;if(aKeysLength!==bKeysLength){return false;}for(let i=0;i<aKeys.length;i++){const key=aKeys[i];if(key!==bKeys[i]){return false;}if(equalsProp(a[key],b[key])===false){return false;}}return true;}function createLink$5(ref){return {__ref:ref};}function validate$9(obj,path='RecordTypeInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_available=obj.available;const path_available=path+'.available';if(typeof obj_available!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_available+'" (at "'+path_available+'")');}const obj_defaultRecordTypeMapping=obj.defaultRecordTypeMapping;const path_defaultRecordTypeMapping=path+'.defaultRecordTypeMapping';if(typeof obj_defaultRecordTypeMapping!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_defaultRecordTypeMapping+'" (at "'+path_defaultRecordTypeMapping+'")');}const obj_master=obj.master;const path_master=path+'.master';if(typeof obj_master!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_master+'" (at "'+path_master+'")');}const obj_name=obj.name;const path_name=path+'.name';if(typeof obj_name!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_name+'" (at "'+path_name+'")');}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();return v_error===undefined?null:v_error;}function equals$5(existing,incoming){const existing_available=existing.available;const incoming_available=incoming.available;if(!(existing_available===incoming_available)){return false;}const existing_defaultRecordTypeMapping=existing.defaultRecordTypeMapping;const incoming_defaultRecordTypeMapping=incoming.defaultRecordTypeMapping;if(!(existing_defaultRecordTypeMapping===incoming_defaultRecordTypeMapping)){return false;}const existing_master=existing.master;const incoming_master=incoming.master;if(!(existing_master===incoming_master)){return false;}const existing_name=existing.name;const incoming_name=incoming.name;if(!(existing_name===incoming_name)){return false;}const existing_recordTypeId=existing.recordTypeId;const incoming_recordTypeId=incoming.recordTypeId;if(!(existing_recordTypeId===incoming_recordTypeId)){return false;}return true;}function deepFreeze$1$5(input){ObjectFreeze$5(input);}function validate$1$4(obj,path='RecordCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_count=obj.count;const path_count=path+'.count';if(typeof obj_count!=='number'||typeof obj_count==='number'&&Math.floor(obj_count)!==obj_count){return new TypeError('Expected "integer" but received "'+typeof obj_count+'" (at "'+path_count+'")');}const obj_currentPageToken=obj.currentPageToken;const path_currentPageToken=path+'.currentPageToken';let obj_currentPageToken_union0=null;const obj_currentPageToken_union0_error=(()=>{if(typeof obj_currentPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}})();if(obj_currentPageToken_union0_error!=null){obj_currentPageToken_union0=obj_currentPageToken_union0_error.message;}let obj_currentPageToken_union1=null;const obj_currentPageToken_union1_error=(()=>{if(obj_currentPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}})();if(obj_currentPageToken_union1_error!=null){obj_currentPageToken_union1=obj_currentPageToken_union1_error.message;}if(obj_currentPageToken_union0&&obj_currentPageToken_union1){let message='Object doesn\'t match union (at "'+path_currentPageToken+'")';message+='\n'+obj_currentPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_currentPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_currentPageUrl=obj.currentPageUrl;const path_currentPageUrl=path+'.currentPageUrl';if(typeof obj_currentPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageUrl+'" (at "'+path_currentPageUrl+'")');}const obj_nextPageToken=obj.nextPageToken;const path_nextPageToken=path+'.nextPageToken';let obj_nextPageToken_union0=null;const obj_nextPageToken_union0_error=(()=>{if(typeof obj_nextPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union0_error!=null){obj_nextPageToken_union0=obj_nextPageToken_union0_error.message;}let obj_nextPageToken_union1=null;const obj_nextPageToken_union1_error=(()=>{if(obj_nextPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union1_error!=null){obj_nextPageToken_union1=obj_nextPageToken_union1_error.message;}if(obj_nextPageToken_union0&&obj_nextPageToken_union1){let message='Object doesn\'t match union (at "'+path_nextPageToken+'")';message+='\n'+obj_nextPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_nextPageUrl=obj.nextPageUrl;const path_nextPageUrl=path+'.nextPageUrl';let obj_nextPageUrl_union0=null;const obj_nextPageUrl_union0_error=(()=>{if(typeof obj_nextPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union0_error!=null){obj_nextPageUrl_union0=obj_nextPageUrl_union0_error.message;}let obj_nextPageUrl_union1=null;const obj_nextPageUrl_union1_error=(()=>{if(obj_nextPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union1_error!=null){obj_nextPageUrl_union1=obj_nextPageUrl_union1_error.message;}if(obj_nextPageUrl_union0&&obj_nextPageUrl_union1){let message='Object doesn\'t match union (at "'+path_nextPageUrl+'")';message+='\n'+obj_nextPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageToken=obj.previousPageToken;const path_previousPageToken=path+'.previousPageToken';let obj_previousPageToken_union0=null;const obj_previousPageToken_union0_error=(()=>{if(typeof obj_previousPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union0_error!=null){obj_previousPageToken_union0=obj_previousPageToken_union0_error.message;}let obj_previousPageToken_union1=null;const obj_previousPageToken_union1_error=(()=>{if(obj_previousPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union1_error!=null){obj_previousPageToken_union1=obj_previousPageToken_union1_error.message;}if(obj_previousPageToken_union0&&obj_previousPageToken_union1){let message='Object doesn\'t match union (at "'+path_previousPageToken+'")';message+='\n'+obj_previousPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageUrl=obj.previousPageUrl;const path_previousPageUrl=path+'.previousPageUrl';let obj_previousPageUrl_union0=null;const obj_previousPageUrl_union0_error=(()=>{if(typeof obj_previousPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union0_error!=null){obj_previousPageUrl_union0=obj_previousPageUrl_union0_error.message;}let obj_previousPageUrl_union1=null;const obj_previousPageUrl_union1_error=(()=>{if(obj_previousPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union1_error!=null){obj_previousPageUrl_union1=obj_previousPageUrl_union1_error.message;}if(obj_previousPageUrl_union0&&obj_previousPageUrl_union1){let message='Object doesn\'t match union (at "'+path_previousPageUrl+'")';message+='\n'+obj_previousPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_records=obj.records;const path_records=path+'.records';if(!ArrayIsArray$6(obj_records)){return new TypeError('Expected "array" but received "'+typeof obj_records+'" (at "'+path_records+'")');}for(let i=0;i<obj_records.length;i++){const obj_records_item=obj_records[i];const path_records_item=path_records+'['+i+']';if(typeof obj_records_item!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_records_item+'" (at "'+path_records_item+'")');}}})();return v_error===undefined?null:v_error;}function normalize$5(input,existing,path,lds,store,timestamp){const input_records=input.records;const input_records_id=path.fullPath+'__records';for(let i=0;i<input_records.length;i++){const input_records_item=input_records[i];let input_records_item_id=input_records_id+'__'+i;input_records[i]=ingest$2$1(input_records_item,{fullPath:input_records_item_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}function equals$1$1(existing,incoming){const existing_count=existing.count;const incoming_count=incoming.count;if(!(existing_count===incoming_count)){return false;}const existing_currentPageUrl=existing.currentPageUrl;const incoming_currentPageUrl=incoming.currentPageUrl;if(!(existing_currentPageUrl===incoming_currentPageUrl)){return false;}const existing_currentPageToken=existing.currentPageToken;const incoming_currentPageToken=incoming.currentPageToken;if(!(existing_currentPageToken===incoming_currentPageToken)){return false;}const existing_nextPageToken=existing.nextPageToken;const incoming_nextPageToken=incoming.nextPageToken;if(!(existing_nextPageToken===incoming_nextPageToken)){return false;}const existing_nextPageUrl=existing.nextPageUrl;const incoming_nextPageUrl=incoming.nextPageUrl;if(!(existing_nextPageUrl===incoming_nextPageUrl)){return false;}const existing_previousPageToken=existing.previousPageToken;const incoming_previousPageToken=incoming.previousPageToken;if(!(existing_previousPageToken===incoming_previousPageToken)){return false;}const existing_previousPageUrl=existing.previousPageUrl;const incoming_previousPageUrl=incoming.previousPageUrl;if(!(existing_previousPageUrl===incoming_previousPageUrl)){return false;}const existing_records=existing.records;const incoming_records=incoming.records;const equals_records_items=equalsArray(existing_records,incoming_records,(existing_records_item,incoming_records_item)=>{if(!(existing_records_item.__ref===incoming_records_item.__ref)){return false;}});if(equals_records_items===false){return false;}return true;}const ingest$5=function RecordCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$1$4(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$5(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$1$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+120000);return createLink$5(key);};function merge(existing,incoming,_lds,path){if(existing===undefined){return incoming;}// TODO: (W-7164913) remove once UISDK is done with a long term fix.
    // Temporary fix for the issue that non-null displayValue gets replaced by null.
    // If displayValue and value are both null, it means the field is empty.
    if(incoming.displayValue===null&&incoming.value!==null&&existing.displayValue!==null){incoming.displayValue=existing.displayValue;}const{value}=incoming;if(value===null||value.__ref===undefined){// Parent will never be null this field only exists in the context of a RecordRep.
    const parent=path.parent;// It may happen that a parent.exists is null, this is the case when the same field is
    // ingested multiple times in the same ingestion cycle. For example: when the same record
    // is present multiple time in the ingested payload.
    if(parent.existing===undefined){return incoming;}const existingVersion=parent.existing.weakEtag;const incomingVersion=parent.data.weakEtag;if(existingVersion>incomingVersion){return existing;}}return incoming;}function validate$2$3(obj,path='FieldValueRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_displayValue=obj.displayValue;const path_displayValue=path+'.displayValue';let obj_displayValue_union0=null;const obj_displayValue_union0_error=(()=>{if(typeof obj_displayValue!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_displayValue+'" (at "'+path_displayValue+'")');}})();if(obj_displayValue_union0_error!=null){obj_displayValue_union0=obj_displayValue_union0_error.message;}let obj_displayValue_union1=null;const obj_displayValue_union1_error=(()=>{if(obj_displayValue!==null){return new TypeError('Expected "null" but received "'+typeof obj_displayValue+'" (at "'+path_displayValue+'")');}})();if(obj_displayValue_union1_error!=null){obj_displayValue_union1=obj_displayValue_union1_error.message;}if(obj_displayValue_union0&&obj_displayValue_union1){let message='Object doesn\'t match union (at "'+path_displayValue+'")';message+='\n'+obj_displayValue_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_displayValue_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_value=obj.value;const path_value=path+'.value';let obj_value_union0=null;const obj_value_union0_error=(()=>{if(obj_value!==null){return new TypeError('Expected "null" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union0_error!=null){obj_value_union0=obj_value_union0_error.message;}let obj_value_union1=null;const obj_value_union1_error=(()=>{if(typeof obj_value!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union1_error!=null){obj_value_union1=obj_value_union1_error.message;}let obj_value_union2=null;const obj_value_union2_error=(()=>{if(typeof obj_value!=='number'){return new TypeError('Expected "number" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union2_error!=null){obj_value_union2=obj_value_union2_error.message;}let obj_value_union3=null;const obj_value_union3_error=(()=>{if(typeof obj_value!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union3_error!=null){obj_value_union3=obj_value_union3_error.message;}let obj_value_union4=null;const obj_value_union4_error=(()=>{if(typeof obj_value!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union4_error!=null){obj_value_union4=obj_value_union4_error.message;}if(obj_value_union0&&obj_value_union1&&obj_value_union2&&obj_value_union3&&obj_value_union4){let message='Object doesn\'t match union (at "'+path_value+'")';message+='\n'+obj_value_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union1.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union2.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union3.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union4.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function normalize$1$1(input,existing,path,lds,store,timestamp){const input_value=input.value;const input_value_id=path.fullPath+'__value';if(input_value!==null&&typeof input_value==='object'){input.value=ingest$2$1(input_value,{fullPath:input_value_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}function equals$2$1(existing,incoming){const existing_displayValue=existing.displayValue;const incoming_displayValue=incoming.displayValue;if(!(existing_displayValue===incoming_displayValue)){return false;}const existing_value=existing.value;const incoming_value=incoming.value;if(!(existing_value===incoming_value||existing_value!=null&&incoming_value!=null&&existing_value.__ref!=null&&incoming_value.__ref!=null&&existing_value.__ref===incoming_value.__ref)){return false;}return true;}const ingest$1$1=function FieldValueRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$2$3(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$1$1(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];incomingRecord=merge(existingRecord,incomingRecord,lds,path);if(existingRecord===undefined||equals$2$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};const{hasOwnProperty:ObjectPrototypeHasOwnProperty$4}=Object.prototype;const{keys:ObjectKeys$1$5}=Object;const{isArray:ArrayIsArray$1$5}=Array;function isPromise$6(value){return value.then!==undefined;}/**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */function validateConfig$4(config,adapter,oneOf){const{displayName}=adapter;const{required,optional,unsupported}=adapter.parameters;if(config===undefined||required.every(req=>ObjectPrototypeHasOwnProperty$4.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);}if(oneOf&&oneOf.some(req=>ObjectPrototypeHasOwnProperty$4.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);}if(unsupported!==undefined&&unsupported.some(req=>ObjectPrototypeHasOwnProperty$4.call(config,req))){throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);}const supported=required.concat(optional);if(ObjectKeys$1$5(config).some(key=>!supported.includes(key))){throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);}}function untrustedIsObject$5(untrusted){return typeof untrusted==='object'&&untrusted!==null&&ArrayIsArray$1$5(untrusted)===false;}function areRequiredParametersPresent$4(config,configPropertyNames){return configPropertyNames.parameters.required.every(req=>req in config);}function refreshable$5(adapter,resolve){return config=>{const result=adapter(config);if(result===null){return result;}if(isPromise$6(result)){return result.then(snapshot=>{snapshot.refresh={config,resolve};return snapshot;});}result.refresh={config,resolve};return result;};}const SNAPSHOT_STATE_FULFILLED$4='Fulfilled';const keyPrefix$4='UiApi::';const VIEW_ENTITY_API_NAME='Name';const VIEW_ENTITY_KEY_PREFIX=`${keyPrefix$4}RecordViewEntityRepresentation:${VIEW_ENTITY_API_NAME}:`;function polymorph(input){const{apiName,id}=input;if(apiName===VIEW_ENTITY_API_NAME){return VIEW_ENTITY_KEY_PREFIX+id;}return keyBuilder({recordId:id});}function isString(value){return typeof value==='string';}/**
     * @param value The array to inspect.
     * @returns True if the array is non-empty and contains only non-empty strings.
     */function isArrayOfNonEmptyStrings(value){if(value.length===0){return false;}return value.every(v=>isString(v)&&v.trim().length>0);}/**
     * @param value The array to dedupe
     * @returns An array without duplicates.
     */function dedupe(value){const result={};for(let i=0,len=value.length;i<len;i+=1){result[value[i]]=true;}return keys$3(result);}/**
     * @param source The array of string to filter
     * @param compare The array to filter against
     * @returns An array with values from source that do not exist in compare
     * If the "compare" array is empty, "source" array itself is returned, not a shallow copy
     */function difference(source,compare){const{length:sourceLength}=source;const{length:compareLength}=compare;if(sourceLength===0||source===compare){return [];}if(compareLength===0){return source;}// Put all the values from "compare" into a map
    // This should be faster than doing an indexOf for every string in source
    const map={};for(let i=0;i<compareLength;i+=1){map[compare[i]]=true;}const strings=[];for(let i=0;i<sourceLength;i+=1){const string=source[i];if(map[string]===undefined){strings.push(string);}}return strings;}function isFieldId(unknown){if(typeof unknown!=='object'||unknown===null){return false;}const value=unknown;return isString(value.objectApiName)&&isString(value.fieldApiName);}function stringToFieldId(fieldApiName){const split=fieldApiName.split('.');{if(split.length===1){// object api name must non-empty
    throw new TypeError('Value does not include an object API name.');}}return {objectApiName:split[0],fieldApiName:split[1]};}function getFieldId(value){if(isFieldId(value)){return value;}return stringToFieldId(value);}/**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @return The qualified field API name.
     */function getFieldApiName(value){// Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if(isString(value)){const trimmed=value.trim();if(trimmed.length>0){return trimmed;}}else if(isFieldId(value)){return value.objectApiName+'.'+value.fieldApiName;}return undefined;}/**
     * The master record type id.
     */const MASTER_RECORD_TYPE_ID='012000000000000AAA';const CUSTOM_API_NAME_SUFFIX='__c';const CUSTOM_RELATIONSHIP_FIELD_SUFFIX='__r';function isGraphNode(node){return node!==null&&node.type==='Node';}function extractTrackedFields(node,parentFieldName,fieldsList=[],visitedRecordIds={},depth=0){// Filter Error and null nodes
    if(!isGraphNode(node)||depth>MAX_RECORD_DEPTH){return [];}const recordId=node.data.id;// Stop the traversal if the key has already been visited, since the fields for this record
    // have already been gathered at this point.
    if(hasOwnProperty$1.call(visitedRecordIds,recordId)){return fieldsList;}// The visitedRecordIds object passed to the spanning record is a copy of the original
    // visitedRecordIds + the current record id, since we want to detect circular references within
    // a given path.
    let spanningVisitedRecordIds=_objectSpread$1({},visitedRecordIds,{[recordId]:true});const fields=node.object('fields');const keys=fields.keys();for(let i=0,len=keys.length;i<len;i+=1){const key=keys[i];const fieldValueRep=fields.link(key);const fieldName=`${parentFieldName}.${key}`;if(fieldValueRep.isMissing()){push$1.call(fieldsList,fieldName);continue;}const field=fieldValueRep.follow();// Filter Error and null nodes
    if(!isGraphNode(field)){continue;}if(field.isScalar('value')===false){const spanning=field.link('value').follow();extractTrackedFields(spanning,fieldName,fieldsList,spanningVisitedRecordIds,depth+1);}else {const state=fieldValueRep.linkData();if(state!==undefined){const{fields}=state;for(let s=0,len=fields.length;s<len;s+=1){const childFieldName=fields[s];push$1.call(fieldsList,`${fieldName}.${childFieldName}`);}}else if(depth===MAX_RECORD_DEPTH&&field.scalar('value')===null&&isLookupFieldKey(key,fields)===true){// When this is max depth and the field's value is null,
    // it needs to check the key to see if this is a lookup field.
    continue;}else {push$1.call(fieldsList,fieldName);}}}return fieldsList;}function isLookupFieldKey(key,fields){return endsWith.call(key,CUSTOM_RELATIONSHIP_FIELD_SUFFIX)||endsWith.call(key,CUSTOM_API_NAME_SUFFIX)===false&&fields.data[`${key}Id`]!==undefined;}function getTrackedFields(lds,recordId,fieldsFromConfig){const key=keyBuilder({recordId});const fieldsList=fieldsFromConfig===undefined?[]:[...fieldsFromConfig];const graphNode=lds.getNode(key);if(!isGraphNode(graphNode)){return fieldsList;}const fileName=graphNode.scalar('apiName');const fields=extractTrackedFields(graphNode,fileName,fieldsList);return dedupe(fields).sort();}function getRecordTypeId(record){return record.recordTypeId===null?MASTER_RECORD_TYPE_ID:record.recordTypeId;}// This function traverses through a record and marks missing
    // optional fields as "missing"
    function markMissingOptionalFields(record,optionalFields){if(!isGraphNode(record)){return;}const apiName=record.scalar('apiName');for(let a=0,aLen=optionalFields.length;a<aLen;a++){const parts=optionalFields[a].split('.');if(parts[0]===apiName){_markMissingPath(record,parts.slice(1));}}}function markNulledOutPath(record,path){if(!isGraphNode(record)){return;}const fieldValueRepresentation=record.object('fields');const fieldName=path.shift();if(fieldValueRepresentation.isUndefined(fieldName)){return;}const link=fieldValueRepresentation.link(fieldName);const resolved=link.follow();if(isGraphNode(resolved)&&resolved.isScalar('value')&&path.length>0){const linkState=link.linkData();const fields=linkState===undefined?[]:linkState.fields;link.writeLinkData({fields:dedupe([...fields,path.join('.')])});}}function markNulledOutRequiredFields(record,fields){if(!isGraphNode(record)){return;}const apiName=record.scalar('apiName');for(let a=0,aLen=fields.length;a<aLen;a++){const parts=fields[a].split('.');if(parts[0]===apiName){markNulledOutPath(record,parts.slice(1));}}}function _markMissingPath(record,path){// Filter out Error and null nodes
    if(!isGraphNode(record)){return;}const fieldValueRepresentation=record.object('fields');const fieldName=path.shift();if(fieldValueRepresentation.isUndefined(fieldName)===true){// TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
    // an undefined/non-present __ref if isMissing is present
    fieldValueRepresentation.write(fieldName,{__ref:undefined,isMissing:true});return;}const link=fieldValueRepresentation.link(fieldName);if(link.isPending()){// TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
    // an undefined/non-present __ref if isMissing is present
    fieldValueRepresentation.write(fieldName,{__ref:undefined,isMissing:true});}else if(path.length>0&&link.isMissing()===false){const fieldValue=link.follow();// Filter out Error and null nodes
    if(!isGraphNode(fieldValue)){return;}// if value is not a scalar, follow the link and mark it as missing
    if(fieldValue.isScalar('value')===false){_markMissingPath(fieldValue.link('value').follow(),path);}}}/**
     * A set of the string names of known ui-api supported entities.
     * Source: ui-uisdk-connect-impl-object-whitelist.yaml
     */const UIAPI_SUPPORTED_ENTITY_API_NAMES={Account:true,AccountBrand:true,AccountContactRelation:true,AccountForecast:true,AccountForecastPeriodMetric:true,AccountParticipant:true,AccountPartner:true,AccountProductForecast:true,AccountProductPeriodForecast:true,AccountTeamMember:true,AcctMgrPeriodicTargetDstr:true,AcctMgrTarget:true,AcctMgrTargetDstr:true,ActionCadence:true,ActionPlanItem:true,ActionPlanTemplate:true,ActionPlanTemplateItem:true,ActionPlanTemplateItemValue:true,ActionPlanTemplateVersion:true,ActivationTarget:true,Address:true,AssessmentIndDefinedValue:true,AssessmentIndicatorDefinition:true,AssessmentTask:true,AssessmentTaskContentDocument:true,AssessmentTaskOrder:true,Asset:true,AssetRelationship:true,AssetStatePeriod:true,AssignedResource:true,AttachedContentNote:true,AuthorizedInsuranceLine:true,Award:true,BCEntityPermission:true,BCEntityPermissionSet:true,BCFieldPermission:true,BCParticipant:true,BCParticipantAccess:true,BCPermissionSet:true,BCRecordAccess:true,BCRecordAccessApproval:true,BCRelatedParticipant:true,BasicDataRecord:true,BlockchainAppMember:true,BlockchainApplication:true,BlockchainEntity:true,BlockchainField:true,BlockchainMember:true,BusinessLicense:true,BusinessMilestone:true,BusinessProfile:true,Campaign:true,CampaignMember:true,CareBarrier:true,CareBarrierType:true,CarePgmProvHealthcareProvider:true,CareProgram:true,CareProgramEnrollee:true,CareRegisteredDevice:true,Case:true,Claim:true,ClaimCase:true,ClaimItem:true,ClaimParticipant:true,Contact:true,ContactRequest:true,ContentDocument:true,ContentNote:true,ContentVersion:true,ContentWorkspace:true,Contract:true,ContractContactRole:true,ContractLineItem:true,CoverageType:true,CustomerProperty:true,DeleteEvent:true,DigitalSignature:true,DistributorAuthorization:true,ElectronicMediaGroup:true,Employee:true,EmployeeJob:true,EmployeeJobPosition:true,EmployeeOrganization:true,Entitlement:true,EntityArchivingSetup:true,EntityMilestone:true,EnvironmentHubMember:true,Expense:true,FtestZosUiPrototypeChild1:true,FtestZosUiPrototypeChild2:true,FtestZosUiPrototypeParent:true,HealthCareDiagnosis:true,HealthCareProcedure:true,HealthcareProvider:true,IdentityDocument:true,Image:true,Individual:true,InspectionAssessmentInd:true,InsuranceClaimAsset:true,InsurancePolicy:true,InsurancePolicyAsset:true,InsurancePolicyCoverage:true,InsurancePolicyMemberAsset:true,InsurancePolicyParticipant:true,InsuranceProfile:true,JobFamily:true,JobPosition:true,JobProfile:true,KnowledgeArticleVersion:true,Lead:true,LegalEntity:true,LicensingRequest:true,ListEmail:true,Location:true,LoyaltyProgram:true,LoyaltyProgramCurrency:true,LoyaltyProgramMember:true,LoyaltyProgramPartner:true,LoyaltyTier:true,LoyaltyTierGroup:true,MaintenanceAsset:true,MaintenancePlan:true,MaintenanceWorkRule:true,MarketSegment:true,MarketSegmentActivation:true,MarketingAction:true,MarketingResource:true,Note:true,OperatingHours:true,Opportunity:true,OpportunityLineItem:true,OpportunityLineItemSchedule:true,OpportunityPartner:true,OpportunityTeamMember:true,Order:true,OrderItem:true,OrderItemSummaryChange:true,OrderSummary:true,OrgMetric:true,OrgMetricScanResult:true,OrgMetricScanSummary:true,Partner:true,PersonAccount:true,PersonEducation:true,PersonEmployment:true,PersonLifeEvent:true,PriceAdjustmentSchedule:true,Pricebook2:true,PricebookEntry:true,Producer:true,ProducerPolicyAssignment:true,Product2:true,Product2DataTranslation:true,ProductCategoryDataTranslation:true,ProductCategoryMedia:true,ProductCoverage:true,ProductMedia:true,Promotion:true,Quote:true,QuoteDocument:true,QuoteLineItem:true,RecordAction:true,RecordType:true,RecordsetFilterCriteria:true,RecordsetFilterCriteriaRule:true,RegulatoryCode:true,ResourceAbsence:true,ResourcePreference:true,RetailStore:true,RetailVisitKpi:true,ReturnOrder:true,ReturnOrderLineItem:true,SalesAgreement:true,SalesAgreementProduct:true,SalesAgreementProductSchedule:true,SecuritiesHolding:true,ServiceAppointment:true,ServiceContract:true,ServiceCrew:true,ServiceCrewMember:true,ServiceResource:true,ServiceResourceCapacity:true,ServiceResourceSkill:true,ServiceTerritory:true,ServiceTerritoryLocation:true,ServiceTerritoryMember:true,Shift:true,Shipment:true,SkillRequirement:true,SocialPost:true,SurveyInvitation:true,SurveyResponse:true,SurveySubject:true,Tenant:true,TimeSheet:true,TimeSheetEntry:true,TimeSlot:true,UsageEntitlement:true,UsageEntitlementPeriod:true,User:true,Visit:true,VisitedParty:true,Visitor:true,VoiceCall:true,WebStoreSearchProdSettings:true,WorkOrder:true,WorkOrderLineItem:true,WorkType:true,WorkerCompCoverageClass:true};/**
     * Tells you if an objectApiName is supported by UI API or not.
     * Note: LDS does not currently support all the entities, the list is limited to UI API supported entities
     * @param objectApiName the object API name from a record.
     * @return True if the provided objectApiName is supported in UI API.
     */function isSupportedEntity(objectApiName){return UIAPI_SUPPORTED_ENTITY_API_NAMES[objectApiName]===true||endsWith.call(objectApiName,CUSTOM_API_NAME_SUFFIX);}/** Return true if a >= b */function isSuperset(a,b){if(b.length>a.length){return false;}const aMap={};// Put all keys from subset into a map
    // so we don't have to use subset.includes which will be slow
    for(let i=0,len=a.length;i<len;i+=1){aMap[a[i]]=true;}for(let i=0,len=b.length;i<len;i+=1){if(aMap[b[i]]===undefined){return false;}}return true;}function fulfill(existing,incoming){// early out if incoming isn't a request only for fields and optionalFields
    const{queryParams,headers,path}=incoming;const{path:existingPath,headers:existingHeaders}=existing;if(queryParams.layoutTypes!==undefined){return false;}if(existingPath!==path){return false;}const headersKeys=keys$3(headers);const headersKeyLength=headersKeys.length;if(headersKeyLength!==keys$3(existingHeaders).length){return false;}for(let i=0,len=headersKeyLength;i<len;i++){let key=headersKeys[i];if(headers[key]!==existingHeaders[key]){return false;}}// TODO W-6900100 - handle when incoming.fields are only in existing.optionalFields, and
    // existing's response doesn't include those fields. We need to detect this then
    // re-issue the request to get the relevant error response.
    const existingFieldsUnion=unionFields(existing.queryParams.fields,existing.queryParams.optionalFields);const incomingFieldsUnion=unionFields(queryParams.fields,queryParams.optionalFields);return isSuperset(existingFieldsUnion,incomingFieldsUnion);}function unionFields(fields,optionalFields){const fieldsArray=isArray$3(fields)?fields:[];const optionalFieldsArray=isArray$3(optionalFields)?optionalFields:[];return [...fieldsArray,...optionalFieldsArray];}function getUiApiRecordsByRecordId(config){const key=keyBuilder({recordId:config.urlParams.recordId});const headers={};return {path:'/services/data/v49.0/ui-api/records/'+config.urlParams.recordId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$2$1,headers,fulfill:fulfill};}function isFulfilledSnapshot$1(snapshot){return snapshot.state==='Fulfilled';}function isUnfulfilledSnapshot$1(snapshot){return snapshot.state==='Unfulfilled';}function isErrorSnapshot$1(snapshot){return snapshot.state==='Error';}function buildRecordSelector(recordId,fields,optionalFields){return {recordId:keyBuilder({recordId}),node:{kind:'Fragment',selections:buildSelectionFromFields(fields,optionalFields)},variables:{}};}function buildNetworkSnapshot$5(lds,config){const{recordId,fields}=config;// Should this go into the coersion logic?
    const allTrackedFields=getTrackedFields(lds,recordId,config.optionalFields);const request=getUiApiRecordsByRecordId({urlParams:{recordId},queryParams:{fields,optionalFields:fields===undefined?allTrackedFields:difference(allTrackedFields,fields)}});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const fields=config.fields===undefined?[]:config.fields;const optionalFields=config.optionalFields===undefined?[]:config.optionalFields;lds.storeIngest(request.key,request,body);const recordNode=lds.getNode(request.key);markNulledOutRequiredFields(recordNode,[...fields,...optionalFields]);markMissingOptionalFields(recordNode,allTrackedFields);lds.storeBroadcast();return lds.storeLookup(buildRecordSelector(config.recordId,fields,optionalFields));},err=>{lds.storeIngestFetchResponse(request.key,err,TTL);lds.storeBroadcast();return lds.errorSnapshot(err);});}// used by getRecordLayoutType#refresh
    function buildInMemorySnapshot$5(lds,config){const fields=config.fields===undefined?[]:config.fields;const optionalFields=config.optionalFields===undefined?[]:config.optionalFields;const sel=buildRecordSelector(config.recordId,fields,optionalFields);return lds.storeLookup(sel);}function getRecordByFields(lds,config){const snapshot=buildInMemorySnapshot$5(lds,config);if(isFulfilledSnapshot$1(snapshot)||isErrorSnapshot$1(snapshot)){return snapshot;}return buildNetworkSnapshot$5(lds,config);}const INCOMING_WEAKETAG_0_KEY='incoming-weaketag-0';const EXISTING_WEAKETAG_0_KEY='existing-weaketag-0';// This function sets fields that we are refreshing to pending
    // These values will go into the store
    function mergePendingFields(newRecord,oldRecord){// TODO W-6900046 - avoid casting to any by updating
    // RecordRepresentationNormalized['fields'] to include `pending:true` property
    const mergedFields=_objectSpread$1({},newRecord.fields);const merged=_objectSpread$1({},newRecord,{fields:mergedFields});const existingFields=keys$3(oldRecord.fields);for(let i=0,len=existingFields.length;i<len;i+=1){const spanningFieldName=existingFields[i];if(newRecord.fields[spanningFieldName]===undefined){// TODO W-6900046 - fix above casting issue so we're not stuffing arbitrary things
    // into RecordRepresentationNormalized['fields']
    mergedFields[spanningFieldName]={__ref:undefined,pending:true};}}return merged;}// This method gets called
    // when incoming record has a higher version
    // than the record that is currently in the store
    function mergeAndRefreshHigherVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames){// If the higher version (incoming) does not contain a superset of fields as existing
    // then we need to refresh to get updated versions of fields in existing
    if(isSuperset(incomingQualifiedApiNames,existingQualifiedApiNames)===false){// If this is an unsupported entity, do NOT attempt to go to the network
    // Simply merge what we have and move on
    if(isSupportedEntity(incoming.apiName)===false){return mergeRecordFields(incoming,existing);}buildNetworkSnapshot$5(lds,{recordId:incoming.id,optionalFields:incomingQualifiedApiNames});// We want to mark fields in the store as pending
    // Because we don't want to emit any data to components
    return mergePendingFields(incoming,existing);}return incoming;}// This method gets called
    // when incoming record has a lower version
    // than the record that is currently in the store
    function mergeAndRefreshLowerVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames){// If the higher version (existing) does not have a superset of fields as incoming
    // then we need to refresh to get updated versions of fields on incoming
    if(isSuperset(existingQualifiedApiNames,incomingQualifiedApiNames)===false){// If this is an unsupported entity, do NOT attempt to go to the network
    // Simply merge what we have and move on
    if(isSupportedEntity(incoming.apiName)===false){return mergeRecordFields(existing,incoming);}const merged=mergePendingFields(existing,incoming);buildNetworkSnapshot$5(lds,{recordId:incoming.id,optionalFields:incomingQualifiedApiNames});return merged;}return existing;}function mergeRecordConflict(lds,incoming,existing){const{apiName}=incoming;const incomingNode=lds.wrapNormalizedGraphNode(incoming);const existingNode=lds.wrapNormalizedGraphNode(existing);const incomingQualifiedApiNames=extractTrackedFields(incomingNode,apiName);const existingQualifiedApiNames=extractTrackedFields(existingNode,apiName);if(incoming.weakEtag>existing.weakEtag){return mergeAndRefreshHigherVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames);}return mergeAndRefreshLowerVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames);}function getNotNull(recordAValue,recordBValue){return recordAValue===null?recordBValue:recordAValue;}function mergeRecordFields(recordA,recordB){const lastModifiedDate=getNotNull(recordA.lastModifiedDate,recordB.lastModifiedDate);const lastModifiedById=getNotNull(recordA.lastModifiedById,recordB.lastModifiedById);const systemModstamp=getNotNull(recordA.systemModstamp,recordB.systemModstamp);return _objectSpread$1({},recordA,{fields:_objectSpread$1({},recordB.fields,recordA.fields),lastModifiedDate,lastModifiedById,systemModstamp});}function isErrorEntry(entry){return entry.__type==='error';}function merge$1(existing,incoming,lds,_path){if(existing===undefined||isErrorEntry(existing)){return incoming;}// recordTypeId may get changed based on record state.
    // Evicts all dependencies from store.
    if(incoming.recordTypeId!==existing.recordTypeId){const recordDepKey=depenpendencyKeyBuilder({recordId:existing.id});const node=lds.getNode(recordDepKey);if(isGraphNode(node)){const dependencies=node.retrieve();if(dependencies!==null){const depKeys=keys$3(dependencies);for(let i=0,len=depKeys.length;i<len;i++){lds.storeEvict(depKeys[i]);}}}}// TODO - handle merging of records that change apiName
    // if (existing.apiName !== incoming.apiName) {
    //     if ("development" === 'production') {
    //         lds.log(`API Name changed from ${existing.apiName} to ${incoming.apiName}`);
    //     } else {
    //         throw new Error('API Name cannot be different for merging records.');
    //     }
    // }
    const incomingWeakEtag=incoming.weakEtag;const existingWeakEtag=existing.weakEtag;if(incomingWeakEtag===0||existingWeakEtag===0){const paramsBuilder=()=>{return {[INCOMING_WEAKETAG_0_KEY]:incomingWeakEtag===0,[EXISTING_WEAKETAG_0_KEY]:existingWeakEtag===0,apiName:incoming.apiName};};lds.instrument(paramsBuilder);}// TODO W-6900085 - UIAPI returns weakEtag=0 when the record is >2 levels nested. For now
    // we treat the record as mergeable.
    if(incomingWeakEtag!==0&&existingWeakEtag!==0&&incomingWeakEtag!==existingWeakEtag){return mergeRecordConflict(lds,incoming,existing);}return mergeRecordFields(incoming,existing);}function depenpendencyKeyBuilder(config){return `UiApi::RecordRepresentationDependency:${config.recordId}`;}const TTL=30000;function validate$3$2(obj,path='RecordRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_childRelationships=obj.childRelationships;const path_childRelationships=path+'.childRelationships';if(typeof obj_childRelationships!=='object'||ArrayIsArray$6(obj_childRelationships)||obj_childRelationships===null){return new TypeError('Expected "object" but received "'+typeof obj_childRelationships+'" (at "'+path_childRelationships+'")');}const obj_childRelationships_keys=ObjectKeys$5(obj_childRelationships);for(let i=0;i<obj_childRelationships_keys.length;i++){const key=obj_childRelationships_keys[i];const obj_childRelationships_prop=obj_childRelationships[key];const path_childRelationships_prop=path_childRelationships+'["'+key+'"]';if(typeof obj_childRelationships_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_childRelationships_prop+'" (at "'+path_childRelationships_prop+'")');}}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$6(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$5(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];const path_fields_prop=path_fields+'["'+key+'"]';if(typeof obj_fields_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_fields_prop+'" (at "'+path_fields_prop+'")');}}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_lastModifiedById=obj.lastModifiedById;const path_lastModifiedById=path+'.lastModifiedById';let obj_lastModifiedById_union0=null;const obj_lastModifiedById_union0_error=(()=>{if(typeof obj_lastModifiedById!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union0_error!=null){obj_lastModifiedById_union0=obj_lastModifiedById_union0_error.message;}let obj_lastModifiedById_union1=null;const obj_lastModifiedById_union1_error=(()=>{if(obj_lastModifiedById!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union1_error!=null){obj_lastModifiedById_union1=obj_lastModifiedById_union1_error.message;}if(obj_lastModifiedById_union0&&obj_lastModifiedById_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedById+'")';message+='\n'+obj_lastModifiedById_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedById_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_lastModifiedDate=obj.lastModifiedDate;const path_lastModifiedDate=path+'.lastModifiedDate';let obj_lastModifiedDate_union0=null;const obj_lastModifiedDate_union0_error=(()=>{if(typeof obj_lastModifiedDate!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union0_error!=null){obj_lastModifiedDate_union0=obj_lastModifiedDate_union0_error.message;}let obj_lastModifiedDate_union1=null;const obj_lastModifiedDate_union1_error=(()=>{if(obj_lastModifiedDate!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union1_error!=null){obj_lastModifiedDate_union1=obj_lastModifiedDate_union1_error.message;}if(obj_lastModifiedDate_union0&&obj_lastModifiedDate_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedDate+'")';message+='\n'+obj_lastModifiedDate_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedDate_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';let obj_recordTypeId_union0=null;const obj_recordTypeId_union0_error=(()=>{if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();if(obj_recordTypeId_union0_error!=null){obj_recordTypeId_union0=obj_recordTypeId_union0_error.message;}let obj_recordTypeId_union1=null;const obj_recordTypeId_union1_error=(()=>{if(obj_recordTypeId!==null){return new TypeError('Expected "null" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();if(obj_recordTypeId_union1_error!=null){obj_recordTypeId_union1=obj_recordTypeId_union1_error.message;}if(obj_recordTypeId_union0&&obj_recordTypeId_union1){let message='Object doesn\'t match union (at "'+path_recordTypeId+'")';message+='\n'+obj_recordTypeId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_recordTypeId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recordTypeInfo=obj.recordTypeInfo;const path_recordTypeInfo=path+'.recordTypeInfo';let obj_recordTypeInfo_union0=null;const obj_recordTypeInfo_union0_error=(()=>{const referenceRecordTypeInfoRepresentationValidationError=validate$9(obj_recordTypeInfo,path_recordTypeInfo);if(referenceRecordTypeInfoRepresentationValidationError!==null){let message='Object doesn\'t match RecordTypeInfoRepresentation (at "'+path_recordTypeInfo+'")\n';message+=referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_recordTypeInfo_union0_error!=null){obj_recordTypeInfo_union0=obj_recordTypeInfo_union0_error.message;}let obj_recordTypeInfo_union1=null;const obj_recordTypeInfo_union1_error=(()=>{if(obj_recordTypeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_recordTypeInfo+'" (at "'+path_recordTypeInfo+'")');}})();if(obj_recordTypeInfo_union1_error!=null){obj_recordTypeInfo_union1=obj_recordTypeInfo_union1_error.message;}if(obj_recordTypeInfo_union0&&obj_recordTypeInfo_union1){let message='Object doesn\'t match union (at "'+path_recordTypeInfo+'")';message+='\n'+obj_recordTypeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_recordTypeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_systemModstamp=obj.systemModstamp;const path_systemModstamp=path+'.systemModstamp';let obj_systemModstamp_union0=null;const obj_systemModstamp_union0_error=(()=>{if(typeof obj_systemModstamp!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union0_error!=null){obj_systemModstamp_union0=obj_systemModstamp_union0_error.message;}let obj_systemModstamp_union1=null;const obj_systemModstamp_union1_error=(()=>{if(obj_systemModstamp!==null){return new TypeError('Expected "null" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union1_error!=null){obj_systemModstamp_union1=obj_systemModstamp_union1_error.message;}if(obj_systemModstamp_union0&&obj_systemModstamp_union1){let message='Object doesn\'t match union (at "'+path_systemModstamp+'")';message+='\n'+obj_systemModstamp_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_systemModstamp_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_weakEtag=obj.weakEtag;const path_weakEtag=path+'.weakEtag';if(typeof obj_weakEtag!=='number'||typeof obj_weakEtag==='number'&&Math.floor(obj_weakEtag)!==obj_weakEtag){return new TypeError('Expected "integer" but received "'+typeof obj_weakEtag+'" (at "'+path_weakEtag+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder(config){return keyPrefix$4+'RecordRepresentation:'+config.recordId;}function normalize$2$1(input,existing,path,lds,store,timestamp){const input_childRelationships=input.childRelationships;const input_childRelationships_id=path.fullPath+'__childRelationships';const input_childRelationships_keys=Object.keys(input_childRelationships);const input_childRelationships_length=input_childRelationships_keys.length;for(let i=0;i<input_childRelationships_length;i++){const key=input_childRelationships_keys[i];const input_childRelationships_prop=input_childRelationships[key];const input_childRelationships_prop_id=input_childRelationships_id+'__'+key;input_childRelationships[key]=ingest$5(input_childRelationships_prop,{fullPath:input_childRelationships_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}const input_fields=input.fields;const input_fields_id=path.fullPath+'__fields';const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];const input_fields_prop=input_fields[key];const input_fields_prop_id=input_fields_id+'__'+key;input_fields[key]=ingest$1$1(input_fields_prop,{fullPath:input_fields_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}function equals$3$1(existing,incoming){const existing_weakEtag=existing.weakEtag;const incoming_weakEtag=incoming.weakEtag;if(!(existing_weakEtag===incoming_weakEtag)){return false;}const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_childRelationships=existing.childRelationships;const incoming_childRelationships=incoming.childRelationships;const equals_childRelationships_props=equalsObject(existing_childRelationships,incoming_childRelationships,(existing_childRelationships_prop,incoming_childRelationships_prop)=>{if(!(existing_childRelationships_prop.__ref===incoming_childRelationships_prop.__ref)){return false;}});if(equals_childRelationships_props===false){return false;}const existing_fields=existing.fields;const incoming_fields=incoming.fields;const equals_fields_props=equalsObject(existing_fields,incoming_fields,(existing_fields_prop,incoming_fields_prop)=>{if(!(existing_fields_prop.__ref===incoming_fields_prop.__ref)){return false;}});if(equals_fields_props===false){return false;}const existing_lastModifiedById=existing.lastModifiedById;const incoming_lastModifiedById=incoming.lastModifiedById;if(!(existing_lastModifiedById===incoming_lastModifiedById)){return false;}const existing_lastModifiedDate=existing.lastModifiedDate;const incoming_lastModifiedDate=incoming.lastModifiedDate;if(!(existing_lastModifiedDate===incoming_lastModifiedDate)){return false;}const existing_recordTypeId=existing.recordTypeId;const incoming_recordTypeId=incoming.recordTypeId;if(!(existing_recordTypeId===incoming_recordTypeId)){return false;}const existing_recordTypeInfo=existing.recordTypeInfo;const incoming_recordTypeInfo=incoming.recordTypeInfo;if(!(existing_recordTypeInfo===incoming_recordTypeInfo||existing_recordTypeInfo!=null&&incoming_recordTypeInfo!=null&&equals$5(existing_recordTypeInfo,incoming_recordTypeInfo))){return false;}const existing_systemModstamp=existing.systemModstamp;const incoming_systemModstamp=incoming.systemModstamp;if(!(existing_systemModstamp===incoming_systemModstamp)){return false;}return true;}const ingest$2$1=function RecordRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$3$2(input);if(validateError!==null){throw validateError;}}const key=polymorph(input);let incomingRecord=normalize$2$1(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];incomingRecord=merge$1(existingRecord,incomingRecord,lds);if(existingRecord===undefined||equals$3$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+30000);return createLink$5(key);};function postUiApiRecords(config){const key=keyPrefix$4+'RecordRepresentation('+ +')';const headers={};return {path:'/services/data/v49.0/ui-api/records',method:'post',body:config.body,urlParams:{},queryParams:{},key:key,ingest:ingest$2$1,headers};}const factory$1=lds=>{return function(config){const request=postUiApiRecords({body:config});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const selections=buildSelectionFromRecord(body);const key=keyBuilder({recordId:body.id});lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:key,node:{kind:'Fragment',selections},variables:{}});},err=>{deepFreeze$9(err);throw err;});};};const RECORD_ID_DECODER='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456';/**
     * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
     * @param value A 15- or 18-char record id.
     * @returns An 18-char record id, and throws error if an invalid record id was provided.
     */function getRecordId18(value){if(!isString(value)){return undefined;}else if(value.length===18){return value;}else if(value.length===15){// Add the 3 character suffix
    let recordId=value;for(let offset=0;offset<15;offset+=5){let decodeValue=0;for(let bit=0;bit<5;bit++){const c=value[offset+bit];if(c>='A'&&c<='Z'){decodeValue+=1<<bit;}}recordId+=RECORD_ID_DECODER[decodeValue];}return recordId;}return undefined;}function isObjectId(unknown){if(typeof unknown!=='object'||unknown===null){return false;}return isString(unknown.objectApiName);}/**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */function getObjectApiName(value){// Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if(typeof value==='string'){const trimmed=value.trim();if(trimmed.length>0){return trimmed;}}else if(isObjectId(value)){return value.objectApiName.trim();}return undefined;}var LayoutType$1;(function(LayoutType){LayoutType["Full"]="Full";LayoutType["Compact"]="Compact";})(LayoutType$1||(LayoutType$1={}));function coerceLayoutType(value){if(value===LayoutType$1.Full||value===LayoutType$1.Compact){return value;}return undefined;}var LayoutMode$1;(function(LayoutMode){LayoutMode["View"]="View";LayoutMode["Edit"]="Edit";LayoutMode["Create"]="Create";})(LayoutMode$1||(LayoutMode$1={}));function coerceLayoutMode(value){if(value===LayoutMode$1.Create||value===LayoutMode$1.Edit||value===LayoutMode$1.View){return value;}return undefined;}function validate$4$2(obj,path='AbstractRecordLayoutComponentRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';let obj_apiName_union0=null;const obj_apiName_union0_error=(()=>{if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}})();if(obj_apiName_union0_error!=null){obj_apiName_union0=obj_apiName_union0_error.message;}let obj_apiName_union1=null;const obj_apiName_union1_error=(()=>{if(obj_apiName!==null){return new TypeError('Expected "null" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}})();if(obj_apiName_union1_error!=null){obj_apiName_union1=obj_apiName_union1_error.message;}if(obj_apiName_union0&&obj_apiName_union1){let message='Object doesn\'t match union (at "'+path_apiName+'")';message+='\n'+obj_apiName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_apiName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_componentType=obj.componentType;const path_componentType=path+'.componentType';if(typeof obj_componentType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_componentType+'" (at "'+path_componentType+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$2$4(input){ObjectFreeze$5(input);}function validate$5$1(obj,path='RecordLayoutItemRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_editableForNew=obj.editableForNew;const path_editableForNew=path+'.editableForNew';if(typeof obj_editableForNew!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_editableForNew+'" (at "'+path_editableForNew+'")');}const obj_editableForUpdate=obj.editableForUpdate;const path_editableForUpdate=path+'.editableForUpdate';if(typeof obj_editableForUpdate!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_editableForUpdate+'" (at "'+path_editableForUpdate+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_layoutComponents=obj.layoutComponents;const path_layoutComponents=path+'.layoutComponents';if(!ArrayIsArray$6(obj_layoutComponents)){return new TypeError('Expected "array" but received "'+typeof obj_layoutComponents+'" (at "'+path_layoutComponents+'")');}for(let i=0;i<obj_layoutComponents.length;i++){const obj_layoutComponents_item=obj_layoutComponents[i];const path_layoutComponents_item=path_layoutComponents+'['+i+']';const referenceAbstractRecordLayoutComponentRepresentationValidationError=validate$4$2(obj_layoutComponents_item,path_layoutComponents_item);if(referenceAbstractRecordLayoutComponentRepresentationValidationError!==null){let message='Object doesn\'t match AbstractRecordLayoutComponentRepresentation (at "'+path_layoutComponents_item+'")\n';message+=referenceAbstractRecordLayoutComponentRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_lookupIdApiName=obj.lookupIdApiName;const path_lookupIdApiName=path+'.lookupIdApiName';let obj_lookupIdApiName_union0=null;const obj_lookupIdApiName_union0_error=(()=>{if(typeof obj_lookupIdApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lookupIdApiName+'" (at "'+path_lookupIdApiName+'")');}})();if(obj_lookupIdApiName_union0_error!=null){obj_lookupIdApiName_union0=obj_lookupIdApiName_union0_error.message;}let obj_lookupIdApiName_union1=null;const obj_lookupIdApiName_union1_error=(()=>{if(obj_lookupIdApiName!==null){return new TypeError('Expected "null" but received "'+typeof obj_lookupIdApiName+'" (at "'+path_lookupIdApiName+'")');}})();if(obj_lookupIdApiName_union1_error!=null){obj_lookupIdApiName_union1=obj_lookupIdApiName_union1_error.message;}if(obj_lookupIdApiName_union0&&obj_lookupIdApiName_union1){let message='Object doesn\'t match union (at "'+path_lookupIdApiName+'")';message+='\n'+obj_lookupIdApiName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lookupIdApiName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_required=obj.required;const path_required=path+'.required';if(typeof obj_required!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_required+'" (at "'+path_required+'")');}const obj_sortable=obj.sortable;const path_sortable=path+'.sortable';if(typeof obj_sortable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_sortable+'" (at "'+path_sortable+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$3$2(input){const input_layoutComponents=input.layoutComponents;for(let i=0;i<input_layoutComponents.length;i++){const input_layoutComponents_item=input_layoutComponents[i];deepFreeze$2$4(input_layoutComponents_item);}ObjectFreeze$5(input_layoutComponents);ObjectFreeze$5(input);}function validate$6$1(obj,path='RecordLayoutRowRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_layoutItems=obj.layoutItems;const path_layoutItems=path+'.layoutItems';if(!ArrayIsArray$6(obj_layoutItems)){return new TypeError('Expected "array" but received "'+typeof obj_layoutItems+'" (at "'+path_layoutItems+'")');}for(let i=0;i<obj_layoutItems.length;i++){const obj_layoutItems_item=obj_layoutItems[i];const path_layoutItems_item=path_layoutItems+'['+i+']';const referenceRecordLayoutItemRepresentationValidationError=validate$5$1(obj_layoutItems_item,path_layoutItems_item);if(referenceRecordLayoutItemRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutItemRepresentation (at "'+path_layoutItems_item+'")\n';message+=referenceRecordLayoutItemRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function deepFreeze$4$2(input){const input_layoutItems=input.layoutItems;for(let i=0;i<input_layoutItems.length;i++){const input_layoutItems_item=input_layoutItems[i];deepFreeze$3$2(input_layoutItems_item);}ObjectFreeze$5(input_layoutItems);ObjectFreeze$5(input);}function validate$7$1(obj,path='RecordLayoutSectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_collapsible=obj.collapsible;const path_collapsible=path+'.collapsible';if(typeof obj_collapsible!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_collapsible+'" (at "'+path_collapsible+'")');}const obj_columns=obj.columns;const path_columns=path+'.columns';if(typeof obj_columns!=='number'||typeof obj_columns==='number'&&Math.floor(obj_columns)!==obj_columns){return new TypeError('Expected "integer" but received "'+typeof obj_columns+'" (at "'+path_columns+'")');}const obj_heading=obj.heading;const path_heading=path+'.heading';let obj_heading_union0=null;const obj_heading_union0_error=(()=>{if(typeof obj_heading!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_heading+'" (at "'+path_heading+'")');}})();if(obj_heading_union0_error!=null){obj_heading_union0=obj_heading_union0_error.message;}let obj_heading_union1=null;const obj_heading_union1_error=(()=>{if(obj_heading!==null){return new TypeError('Expected "null" but received "'+typeof obj_heading+'" (at "'+path_heading+'")');}})();if(obj_heading_union1_error!=null){obj_heading_union1=obj_heading_union1_error.message;}if(obj_heading_union0&&obj_heading_union1){let message='Object doesn\'t match union (at "'+path_heading+'")';message+='\n'+obj_heading_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_heading_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_layoutRows=obj.layoutRows;const path_layoutRows=path+'.layoutRows';if(!ArrayIsArray$6(obj_layoutRows)){return new TypeError('Expected "array" but received "'+typeof obj_layoutRows+'" (at "'+path_layoutRows+'")');}for(let i=0;i<obj_layoutRows.length;i++){const obj_layoutRows_item=obj_layoutRows[i];const path_layoutRows_item=path_layoutRows+'['+i+']';const referenceRecordLayoutRowRepresentationValidationError=validate$6$1(obj_layoutRows_item,path_layoutRows_item);if(referenceRecordLayoutRowRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutRowRepresentation (at "'+path_layoutRows_item+'")\n';message+=referenceRecordLayoutRowRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_rows=obj.rows;const path_rows=path+'.rows';if(typeof obj_rows!=='number'||typeof obj_rows==='number'&&Math.floor(obj_rows)!==obj_rows){return new TypeError('Expected "integer" but received "'+typeof obj_rows+'" (at "'+path_rows+'")');}const obj_useHeading=obj.useHeading;const path_useHeading=path+'.useHeading';if(typeof obj_useHeading!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_useHeading+'" (at "'+path_useHeading+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$5$1(input){const input_layoutRows=input.layoutRows;for(let i=0;i<input_layoutRows.length;i++){const input_layoutRows_item=input_layoutRows[i];deepFreeze$4$2(input_layoutRows_item);}ObjectFreeze$5(input_layoutRows);ObjectFreeze$5(input);}function validate$8$1(obj,path='RecordLayoutRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}const obj_layoutType=obj.layoutType;const path_layoutType=path+'.layoutType';if(typeof obj_layoutType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_layoutType+'" (at "'+path_layoutType+'")');}const obj_mode=obj.mode;const path_mode=path+'.mode';if(typeof obj_mode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_mode+'" (at "'+path_mode+'")');}const obj_sections=obj.sections;const path_sections=path+'.sections';if(!ArrayIsArray$6(obj_sections)){return new TypeError('Expected "array" but received "'+typeof obj_sections+'" (at "'+path_sections+'")');}for(let i=0;i<obj_sections.length;i++){const obj_sections_item=obj_sections[i];const path_sections_item=path_sections+'['+i+']';const referenceRecordLayoutSectionRepresentationValidationError=validate$7$1(obj_sections_item,path_sections_item);if(referenceRecordLayoutSectionRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutSectionRepresentation (at "'+path_sections_item+'")\n';message+=referenceRecordLayoutSectionRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function keyBuilder$1(config){return keyPrefix$4+'RecordLayoutRepresentation:'+config.recordTypeId+':'+config.apiName+':'+config.layoutType+':'+config.mode;}function normalize$3$1(input,existing,path,lds,store,timestamp){return input;}const select$5=function RecordLayoutRepresentationSelect(){return {kind:'Fragment',selections:[{name:'id',kind:'Scalar'},{name:'layoutType',kind:'Scalar'},{name:'mode',kind:'Scalar'},{name:'sections',kind:'Object',opaque:true}]};};function equals$4$1(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}function deepFreeze$6$1(input){const input_sections=input.sections;for(let i=0;i<input_sections.length;i++){const input_sections_item=input_sections[i];deepFreeze$5$1(input_sections_item);}ObjectFreeze$5(input_sections);ObjectFreeze$5(input);}const ingest$3$1=function RecordLayoutRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$8$1(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$1({recordTypeId:input.recordTypeId,apiName:input.apiName,layoutType:input.layoutType,mode:input.mode});let incomingRecord=normalize$3$1(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$6$1(input);if(existingRecord===undefined||equals$4$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return createLink$5(key);};function getUiApiLayoutByObjectApiName(config){const key=keyPrefix$4+'RecordLayoutRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'layoutType:'+config.queryParams.layoutType+','+'mode:'+config.queryParams.mode+','+'recordTypeId:'+config.queryParams.recordTypeId+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v49.0/ui-api/layout/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$3$1,headers};}function coerceConfig(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const formFactor=config.formFactor;if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const layoutType=coerceLayoutType(config.layoutType);if(layoutType!==undefined){coercedConfig.layoutType=layoutType;}const mode=coerceLayoutMode(config.mode);if(mode!==undefined){coercedConfig.mode=mode;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig$5(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_layoutType=untrustedConfig.layoutType;if(typeof untrustedConfig_layoutType==='string'){config.layoutType=untrustedConfig_layoutType;}const untrustedConfig_mode=untrustedConfig.mode;if(typeof untrustedConfig_mode==='string'){config.mode=untrustedConfig_mode;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$5(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig(untrustedConfig);const config=typeCheckConfig$5(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}const layoutSelections=select$5();// FYI stricter required set than RAML, matches lds222 behavior
    const getLayout_ConfigPropertyNames$1={displayName:'getLayout',parameters:{required:['objectApiName','layoutType','mode'],optional:['recordTypeId']}};function buildNetworkSnapshot$1$1(lds,config,requestOverride){const recordTypeId=config.recordTypeId;const request=getUiApiLayoutByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{layoutType:config.layoutType,mode:config.mode,recordTypeId}});const key=keyBuilder$1({apiName:config.objectApiName,recordTypeId,layoutType:config.layoutType,mode:config.mode});return lds.dispatchResourceRequest(request,requestOverride).then(response=>{const{body}=response;// TODO W-6399239 - fix API so we don't have to augment the response with request details in order
    // to support refresh. these are never emitted out per (private).
    body.apiName=config.objectApiName;body.recordTypeId=recordTypeId;lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:key,node:layoutSelections,variables:{}});},error=>{lds.storeIngestFetchResponse(key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}function buildInMemorySnapshot$1$1(lds,config){const{recordTypeId,layoutType,mode}=config;const key=keyBuilder$1({apiName:config.objectApiName,recordTypeId,layoutType,mode});return lds.storeLookup({recordId:key,node:layoutSelections,variables:{}});}function coerceConfigWithDefaults(untrusted){const config=validateAdapterConfig$5(untrusted,getLayout_ConfigPropertyNames$1);if(config===null){return null;}// recordTypeId coercion is nuts: if `null` (but not undefined) then use MASTER record type id
    let recordTypeId=config.recordTypeId;if(recordTypeId===undefined){// must check untrusted bc config has been coerced
    if(untrusted.recordTypeId!==null){return null;}recordTypeId=MASTER_RECORD_TYPE_ID;}// layoutType and mode are required during validation.
    // They will always be valid at this point.
    return _objectSpread$1({},config,{recordTypeId,layoutType:config.layoutType,mode:config.mode});}const factory$2=lds=>{return refreshable$5(untrusted=>{const config=coerceConfigWithDefaults(untrusted);if(config===null){return null;}const snapshot=buildInMemorySnapshot$1$1(lds,config);// Cache hit
    if(isFulfilledSnapshot$1(snapshot)){return snapshot;}return buildNetworkSnapshot$1$1(lds,config);},untrusted=>{const config=coerceConfigWithDefaults(untrusted);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$1$1(lds,config,{headers:{'Cache-Control':'no-cache'}});});};function validate$9$1(obj,path='RecordLayoutSectionUserStateRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_collapsed=obj.collapsed;const path_collapsed=path+'.collapsed';if(typeof obj_collapsed!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_collapsed+'" (at "'+path_collapsed+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$7$1(input){ObjectFreeze$5(input);}function validate$a(obj,path='RecordLayoutUserStateRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_sectionUserStates=obj.sectionUserStates;const path_sectionUserStates=path+'.sectionUserStates';if(typeof obj_sectionUserStates!=='object'||ArrayIsArray$6(obj_sectionUserStates)||obj_sectionUserStates===null){return new TypeError('Expected "object" but received "'+typeof obj_sectionUserStates+'" (at "'+path_sectionUserStates+'")');}const obj_sectionUserStates_keys=ObjectKeys$5(obj_sectionUserStates);for(let i=0;i<obj_sectionUserStates_keys.length;i++){const key=obj_sectionUserStates_keys[i];const obj_sectionUserStates_prop=obj_sectionUserStates[key];const path_sectionUserStates_prop=path_sectionUserStates+'["'+key+'"]';const referenceRecordLayoutSectionUserStateRepresentationValidationError=validate$9$1(obj_sectionUserStates_prop,path_sectionUserStates_prop);if(referenceRecordLayoutSectionUserStateRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutSectionUserStateRepresentation (at "'+path_sectionUserStates_prop+'")\n';message+=referenceRecordLayoutSectionUserStateRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}const obj_layoutType=obj.layoutType;const path_layoutType=path+'.layoutType';if(typeof obj_layoutType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_layoutType+'" (at "'+path_layoutType+'")');}const obj_mode=obj.mode;const path_mode=path+'.mode';if(typeof obj_mode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_mode+'" (at "'+path_mode+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$2(config){return keyPrefix$4+'RecordLayoutUserStateRepresentation:'+config.recordTypeId+':'+config.apiName+':'+config.layoutType+':'+config.mode;}function normalize$4$1(input,existing,path,lds,store,timestamp){return input;}const select$1$1=function RecordLayoutUserStateRepresentationSelect(){return {kind:'Fragment',selections:[{name:'id',kind:'Scalar'},{name:'sectionUserStates',kind:'Object',opaque:true}]};};function equals$5$1(existing,incoming){if(JSONStrinify$4(incoming)!==JSONStrinify$4(existing)){return false;}return true;}function deepFreeze$8$1(input){const input_sectionUserStates=input.sectionUserStates;const input_sectionUserStates_keys=Object.keys(input_sectionUserStates);const input_sectionUserStates_length=input_sectionUserStates_keys.length;for(let i=0;i<input_sectionUserStates_length;i++){const key=input_sectionUserStates_keys[i];const input_sectionUserStates_prop=input_sectionUserStates[key];deepFreeze$7$1(input_sectionUserStates_prop);}ObjectFreeze$5(input_sectionUserStates);ObjectFreeze$5(input);}const ingest$4$1=function RecordLayoutUserStateRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$a(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$2({recordTypeId:input.recordTypeId,apiName:input.apiName,layoutType:input.layoutType,mode:input.mode});let incomingRecord=normalize$4$1(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$8$1(input);if(existingRecord===undefined||equals$5$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return createLink$5(key);};function getUiApiLayoutUserStateByObjectApiName(config){const key=keyPrefix$4+'RecordLayoutUserStateRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'layoutType:'+config.queryParams.layoutType+','+'mode:'+config.queryParams.mode+','+'recordTypeId:'+config.queryParams.recordTypeId+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v49.0/ui-api/layout/'+config.urlParams.objectApiName+'/user-state',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$4$1,headers};}function coerceConfig$1(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const formFactor=config.formFactor;if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const layoutType=coerceLayoutType(config.layoutType);if(layoutType!==undefined){coercedConfig.layoutType=layoutType;}const mode=coerceLayoutMode(config.mode);if(mode!==undefined){coercedConfig.mode=mode;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig$1$1(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_layoutType=untrustedConfig.layoutType;if(typeof untrustedConfig_layoutType==='string'){config.layoutType=untrustedConfig_layoutType;}const untrustedConfig_mode=untrustedConfig.mode;if(typeof untrustedConfig_mode==='string'){config.mode=untrustedConfig_mode;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$1$2(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$1(untrustedConfig);const config=typeCheckConfig$1$1(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}const recordLayoutSelect=select$1$1();// FYI stricter required set than RAML defines, matches lds222 behavior
    const getLayoutUserState_ConfigPropertyNames$1={displayName:'getLayoutUserState',parameters:{required:['objectApiName','recordTypeId'],optional:['formFactor','layoutType','mode']}};function coerceConfigWithDefaults$1(untrustedConfig){const config=validateAdapterConfig$1$2(untrustedConfig,getLayoutUserState_ConfigPropertyNames$1);if(config===null){return null;}// recordTypeId is overridden to be required
    const recordTypeId=config.recordTypeId;const untrusted=untrustedConfig;let layoutType=config.layoutType;if(layoutType===undefined){if(untrusted.layoutType===undefined){layoutType=LayoutType$1.Full;}else {return null;}}let mode=config.mode;if(mode===undefined){if(untrusted.mode===undefined){mode=LayoutMode$1.View;}else {return null;}}return _objectSpread$1({},config,{recordTypeId,layoutType,mode});}function buildInMemorySnapshot$2$1(lds,config){const{objectApiName,recordTypeId,layoutType,mode}=config;const key=keyBuilder$2({apiName:objectApiName,recordTypeId,layoutType,mode});return lds.storeLookup({recordId:key,node:recordLayoutSelect,variables:{}});}function buildNetworkSnapshot$2$1(lds,config){const{recordTypeId,layoutType,mode,objectApiName}=config;const key=keyBuilder$2({apiName:objectApiName,recordTypeId,layoutType,mode});const request=getUiApiLayoutUserStateByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{layoutType:config.layoutType,mode:config.mode,recordTypeId:config.recordTypeId}});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;// Hack- adding in this params so record-ui will be able to use normed values.
    body.apiName=config.objectApiName;body.recordTypeId=recordTypeId;body.layoutType=layoutType;body.mode=mode;lds.storeIngest(key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$2$1(lds,config);},error=>{lds.storeIngestFetchResponse(key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const factory$3=lds=>{return refreshable$5(function getLayoutUserState(untrustedConfig){const config=coerceConfigWithDefaults$1(untrustedConfig);if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$2$1(lds,config);// Cache Hit
    if(isFulfilledSnapshot$1(cacheSnapshot)){return cacheSnapshot;}return buildNetworkSnapshot$2$1(lds,config);},untrustedConfig=>{const config=coerceConfigWithDefaults$1(untrustedConfig);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$2$1(lds,config);});};/**
     * Returns the field API name.
     * @param value The value from which to get the field API name.
     * @returns The field API name.
     */function getFieldApiNamesArray(value){const valueArray=isArray$3(value)?value:[value];const array=[];for(let i=0,len=valueArray.length;i<len;i+=1){const item=valueArray[i];const apiName=getFieldApiName(item);if(apiName===undefined){return undefined;}push$1.call(array,apiName);}if(array.length===0){return undefined;}return dedupe(array).sort();}function validate$b(obj,path='ListColumnRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_fieldApiName=obj.fieldApiName;const path_fieldApiName=path+'.fieldApiName';if(typeof obj_fieldApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldApiName+'" (at "'+path_fieldApiName+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_sortable=obj.sortable;const path_sortable=path+'.sortable';if(typeof obj_sortable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_sortable+'" (at "'+path_sortable+'")');}})();return v_error===undefined?null:v_error;}const select$2$1=function ListColumnRepresentationSelect(){return {kind:'Fragment',selections:[{name:'fieldApiName',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'sortable',kind:'Scalar'}]};};function validate$c(obj,path='ListFilterByInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_fieldApiName=obj.fieldApiName;const path_fieldApiName=path+'.fieldApiName';if(typeof obj_fieldApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldApiName+'" (at "'+path_fieldApiName+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_operandLabels=obj.operandLabels;const path_operandLabels=path+'.operandLabels';if(!ArrayIsArray$6(obj_operandLabels)){return new TypeError('Expected "array" but received "'+typeof obj_operandLabels+'" (at "'+path_operandLabels+'")');}for(let i=0;i<obj_operandLabels.length;i++){const obj_operandLabels_item=obj_operandLabels[i];const path_operandLabels_item=path_operandLabels+'['+i+']';if(typeof obj_operandLabels_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_operandLabels_item+'" (at "'+path_operandLabels_item+'")');}}const obj_operator=obj.operator;const path_operator=path+'.operator';if(typeof obj_operator!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_operator+'" (at "'+path_operator+'")');}})();return v_error===undefined?null:v_error;}const select$3$1=function ListFilterByInfoRepresentationSelect(){return {kind:'Fragment',selections:[{name:'fieldApiName',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'operandLabels',kind:'Scalar',plural:true},{name:'operator',kind:'Scalar'}]};};function validate$d(obj,path='ListOrderByInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_fieldApiName=obj.fieldApiName;const path_fieldApiName=path+'.fieldApiName';if(typeof obj_fieldApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldApiName+'" (at "'+path_fieldApiName+'")');}const obj_isAscending=obj.isAscending;const path_isAscending=path+'.isAscending';if(typeof obj_isAscending!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_isAscending+'" (at "'+path_isAscending+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}})();return v_error===undefined?null:v_error;}const select$4$1=function ListOrderByInfoRepresentationSelect(){return {kind:'Fragment',selections:[{name:'fieldApiName',kind:'Scalar'},{name:'isAscending',kind:'Scalar'},{name:'label',kind:'Scalar'}]};};function validate$e(obj,path='ListUserPreferenceRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_columnWidths=obj.columnWidths;const path_columnWidths=path+'.columnWidths';if(typeof obj_columnWidths!=='object'||ArrayIsArray$6(obj_columnWidths)||obj_columnWidths===null){return new TypeError('Expected "object" but received "'+typeof obj_columnWidths+'" (at "'+path_columnWidths+'")');}const obj_columnWidths_keys=ObjectKeys$5(obj_columnWidths);for(let i=0;i<obj_columnWidths_keys.length;i++){const key=obj_columnWidths_keys[i];const obj_columnWidths_prop=obj_columnWidths[key];const path_columnWidths_prop=path_columnWidths+'["'+key+'"]';if(typeof obj_columnWidths_prop!=='number'||typeof obj_columnWidths_prop==='number'&&Math.floor(obj_columnWidths_prop)!==obj_columnWidths_prop){return new TypeError('Expected "integer" but received "'+typeof obj_columnWidths_prop+'" (at "'+path_columnWidths_prop+'")');}}const obj_columnWrap=obj.columnWrap;const path_columnWrap=path+'.columnWrap';if(typeof obj_columnWrap!=='object'||ArrayIsArray$6(obj_columnWrap)||obj_columnWrap===null){return new TypeError('Expected "object" but received "'+typeof obj_columnWrap+'" (at "'+path_columnWrap+'")');}const obj_columnWrap_keys=ObjectKeys$5(obj_columnWrap);for(let i=0;i<obj_columnWrap_keys.length;i++){const key=obj_columnWrap_keys[i];const obj_columnWrap_prop=obj_columnWrap[key];const path_columnWrap_prop=path_columnWrap+'["'+key+'"]';if(typeof obj_columnWrap_prop!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_columnWrap_prop+'" (at "'+path_columnWrap_prop+'")');}}})();return v_error===undefined?null:v_error;}const select$5$1=function ListUserPreferenceRepresentationSelect(){return {kind:'Fragment',selections:[{name:'columnWidths',kind:'Scalar',map:true},{name:'columnWrap',kind:'Scalar',map:true}]};};function validate$f(obj,path='ListReferenceRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_listViewApiName=obj.listViewApiName;const path_listViewApiName=path+'.listViewApiName';let obj_listViewApiName_union0=null;const obj_listViewApiName_union0_error=(()=>{if(typeof obj_listViewApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_listViewApiName+'" (at "'+path_listViewApiName+'")');}})();if(obj_listViewApiName_union0_error!=null){obj_listViewApiName_union0=obj_listViewApiName_union0_error.message;}let obj_listViewApiName_union1=null;const obj_listViewApiName_union1_error=(()=>{if(obj_listViewApiName!==null){return new TypeError('Expected "null" but received "'+typeof obj_listViewApiName+'" (at "'+path_listViewApiName+'")');}})();if(obj_listViewApiName_union1_error!=null){obj_listViewApiName_union1=obj_listViewApiName_union1_error.message;}if(obj_listViewApiName_union0&&obj_listViewApiName_union1){let message='Object doesn\'t match union (at "'+path_listViewApiName+'")';message+='\n'+obj_listViewApiName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_listViewApiName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_objectApiName=obj.objectApiName;const path_objectApiName=path+'.objectApiName';if(typeof obj_objectApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_objectApiName+'" (at "'+path_objectApiName+'")');}const obj_type=obj.type;const path_type=path+'.type';if(typeof obj_type!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_type+'" (at "'+path_type+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$3(config){return keyPrefix$4+'ListReferenceRepresentation:'+(config.id===null?'':config.id);}function normalize$5$1(input,existing,path,lds,store,timestamp){return input;}const select$6=function ListReferenceRepresentationSelect(){return {kind:'Fragment',selections:[{name:'id',kind:'Scalar'},{name:'listViewApiName',kind:'Scalar'},{name:'objectApiName',kind:'Scalar'},{name:'type',kind:'Scalar'}]};};function equals$6(existing,incoming){const existing_objectApiName=existing.objectApiName;const incoming_objectApiName=incoming.objectApiName;if(!(existing_objectApiName===incoming_objectApiName)){return false;}const existing_type=existing.type;const incoming_type=incoming.type;if(!(existing_type===incoming_type)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_listViewApiName=existing.listViewApiName;const incoming_listViewApiName=incoming.listViewApiName;if(!(existing_listViewApiName===incoming_listViewApiName)){return false;}return true;}const ingest$5$1=function ListReferenceRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$f(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$3({id:input.id});let incomingRecord=normalize$5$1(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$6(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$g(obj,path='ListInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_cloneable=obj.cloneable;const path_cloneable=path+'.cloneable';if(typeof obj_cloneable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_cloneable+'" (at "'+path_cloneable+'")');}const obj_createable=obj.createable;const path_createable=path+'.createable';if(typeof obj_createable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_createable+'" (at "'+path_createable+'")');}const obj_deletable=obj.deletable;const path_deletable=path+'.deletable';if(typeof obj_deletable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_deletable+'" (at "'+path_deletable+'")');}const obj_displayColumns=obj.displayColumns;const path_displayColumns=path+'.displayColumns';if(!ArrayIsArray$6(obj_displayColumns)){return new TypeError('Expected "array" but received "'+typeof obj_displayColumns+'" (at "'+path_displayColumns+'")');}for(let i=0;i<obj_displayColumns.length;i++){const obj_displayColumns_item=obj_displayColumns[i];const path_displayColumns_item=path_displayColumns+'['+i+']';const referenceListColumnRepresentationValidationError=validate$b(obj_displayColumns_item,path_displayColumns_item);if(referenceListColumnRepresentationValidationError!==null){let message='Object doesn\'t match ListColumnRepresentation (at "'+path_displayColumns_item+'")\n';message+=referenceListColumnRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_filterLogicString=obj.filterLogicString;const path_filterLogicString=path+'.filterLogicString';let obj_filterLogicString_union0=null;const obj_filterLogicString_union0_error=(()=>{if(typeof obj_filterLogicString!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_filterLogicString+'" (at "'+path_filterLogicString+'")');}})();if(obj_filterLogicString_union0_error!=null){obj_filterLogicString_union0=obj_filterLogicString_union0_error.message;}let obj_filterLogicString_union1=null;const obj_filterLogicString_union1_error=(()=>{if(obj_filterLogicString!==null){return new TypeError('Expected "null" but received "'+typeof obj_filterLogicString+'" (at "'+path_filterLogicString+'")');}})();if(obj_filterLogicString_union1_error!=null){obj_filterLogicString_union1=obj_filterLogicString_union1_error.message;}if(obj_filterLogicString_union0&&obj_filterLogicString_union1){let message='Object doesn\'t match union (at "'+path_filterLogicString+'")';message+='\n'+obj_filterLogicString_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_filterLogicString_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_filteredByInfo=obj.filteredByInfo;const path_filteredByInfo=path+'.filteredByInfo';if(!ArrayIsArray$6(obj_filteredByInfo)){return new TypeError('Expected "array" but received "'+typeof obj_filteredByInfo+'" (at "'+path_filteredByInfo+'")');}for(let i=0;i<obj_filteredByInfo.length;i++){const obj_filteredByInfo_item=obj_filteredByInfo[i];const path_filteredByInfo_item=path_filteredByInfo+'['+i+']';const referenceListFilterByInfoRepresentationValidationError=validate$c(obj_filteredByInfo_item,path_filteredByInfo_item);if(referenceListFilterByInfoRepresentationValidationError!==null){let message='Object doesn\'t match ListFilterByInfoRepresentation (at "'+path_filteredByInfo_item+'")\n';message+=referenceListFilterByInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_listReference=obj.listReference;const path_listReference=path+'.listReference';if(typeof obj_listReference!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_listReference+'" (at "'+path_listReference+'")');}const obj_orderedByInfo=obj.orderedByInfo;const path_orderedByInfo=path+'.orderedByInfo';if(!ArrayIsArray$6(obj_orderedByInfo)){return new TypeError('Expected "array" but received "'+typeof obj_orderedByInfo+'" (at "'+path_orderedByInfo+'")');}for(let i=0;i<obj_orderedByInfo.length;i++){const obj_orderedByInfo_item=obj_orderedByInfo[i];const path_orderedByInfo_item=path_orderedByInfo+'['+i+']';const referenceListOrderByInfoRepresentationValidationError=validate$d(obj_orderedByInfo_item,path_orderedByInfo_item);if(referenceListOrderByInfoRepresentationValidationError!==null){let message='Object doesn\'t match ListOrderByInfoRepresentation (at "'+path_orderedByInfo_item+'")\n';message+=referenceListOrderByInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_updateable=obj.updateable;const path_updateable=path+'.updateable';if(typeof obj_updateable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_updateable+'" (at "'+path_updateable+'")');}const obj_userPreferences=obj.userPreferences;const path_userPreferences=path+'.userPreferences';const referenceListUserPreferenceRepresentationValidationError=validate$e(obj_userPreferences,path_userPreferences);if(referenceListUserPreferenceRepresentationValidationError!==null){let message='Object doesn\'t match ListUserPreferenceRepresentation (at "'+path_userPreferences+'")\n';message+=referenceListUserPreferenceRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_visibility=obj.visibility;const path_visibility=path+'.visibility';if(typeof obj_visibility!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_visibility+'" (at "'+path_visibility+'")');}const obj_visibilityEditable=obj.visibilityEditable;const path_visibilityEditable=path+'.visibilityEditable';if(typeof obj_visibilityEditable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_visibilityEditable+'" (at "'+path_visibilityEditable+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$4(config){return keyPrefix$4+'ListInfoRepresentation:'+(config.listViewApiName===null?'':config.listViewApiName)+':'+config.objectApiName+':'+config.type;}function normalize$6(input,existing,path,lds,store,timestamp){const input_listReference=input.listReference;const input_listReference_id=path.fullPath+'__listReference';input.listReference=ingest$5$1(input_listReference,{fullPath:input_listReference_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store);return input;}const select$7=function ListInfoRepresentationSelect(){const{selections:ListColumnRepresentation__selections,opaque:ListColumnRepresentation__opaque}=select$2$1();const{selections:ListFilterByInfoRepresentation__selections,opaque:ListFilterByInfoRepresentation__opaque}=select$3$1();const{selections:ListReferenceRepresentation__selections,opaque:ListReferenceRepresentation__opaque}=select$6();const{selections:ListOrderByInfoRepresentation__selections,opaque:ListOrderByInfoRepresentation__opaque}=select$4$1();const{selections:ListUserPreferenceRepresentation__selections,opaque:ListUserPreferenceRepresentation__opaque}=select$5$1();return {kind:'Fragment',selections:[{name:'cloneable',kind:'Scalar'},{name:'createable',kind:'Scalar'},{name:'deletable',kind:'Scalar'},{name:'displayColumns',kind:'Object',plural:true,selections:ListColumnRepresentation__selections},{name:'filterLogicString',kind:'Scalar'},{name:'filteredByInfo',kind:'Object',plural:true,selections:ListFilterByInfoRepresentation__selections},{name:'label',kind:'Scalar'},{name:'listReference',kind:'Link',selections:ListReferenceRepresentation__selections},{name:'orderedByInfo',kind:'Object',plural:true,selections:ListOrderByInfoRepresentation__selections},{name:'updateable',kind:'Scalar'},{name:'userPreferences',kind:'Object',selections:ListUserPreferenceRepresentation__selections},{name:'visibility',kind:'Scalar'},{name:'visibilityEditable',kind:'Scalar'}]};};function equals$7(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}const ingest$6=function ListInfoRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$g(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$4({listViewApiName:input.listReference.listViewApiName,objectApiName:input.listReference.objectApiName,type:input.listReference.type});let incomingRecord=normalize$6(input,store.records[key],{fullPath:key,parent:path.parent},lds,store);const existingRecord=store.records[key];if(existingRecord===undefined||equals$7(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$h(obj,path='ListRecordCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_count=obj.count;const path_count=path+'.count';if(typeof obj_count!=='number'||typeof obj_count==='number'&&Math.floor(obj_count)!==obj_count){return new TypeError('Expected "integer" but received "'+typeof obj_count+'" (at "'+path_count+'")');}const obj_currentPageToken=obj.currentPageToken;const path_currentPageToken=path+'.currentPageToken';if(typeof obj_currentPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}const obj_currentPageUrl=obj.currentPageUrl;const path_currentPageUrl=path+'.currentPageUrl';if(typeof obj_currentPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageUrl+'" (at "'+path_currentPageUrl+'")');}const obj_fields=obj.fields;const path_fields=path+'.fields';if(!ArrayIsArray$6(obj_fields)){return new TypeError('Expected "array" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}for(let i=0;i<obj_fields.length;i++){const obj_fields_item=obj_fields[i];const path_fields_item=path_fields+'['+i+']';if(typeof obj_fields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fields_item+'" (at "'+path_fields_item+'")');}}const obj_listInfoETag=obj.listInfoETag;const path_listInfoETag=path+'.listInfoETag';if(typeof obj_listInfoETag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_listInfoETag+'" (at "'+path_listInfoETag+'")');}const obj_listReference=obj.listReference;const path_listReference=path+'.listReference';if(typeof obj_listReference!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_listReference+'" (at "'+path_listReference+'")');}const obj_nextPageToken=obj.nextPageToken;const path_nextPageToken=path+'.nextPageToken';let obj_nextPageToken_union0=null;const obj_nextPageToken_union0_error=(()=>{if(typeof obj_nextPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union0_error!=null){obj_nextPageToken_union0=obj_nextPageToken_union0_error.message;}let obj_nextPageToken_union1=null;const obj_nextPageToken_union1_error=(()=>{if(obj_nextPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union1_error!=null){obj_nextPageToken_union1=obj_nextPageToken_union1_error.message;}if(obj_nextPageToken_union0&&obj_nextPageToken_union1){let message='Object doesn\'t match union (at "'+path_nextPageToken+'")';message+='\n'+obj_nextPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_nextPageUrl=obj.nextPageUrl;const path_nextPageUrl=path+'.nextPageUrl';let obj_nextPageUrl_union0=null;const obj_nextPageUrl_union0_error=(()=>{if(typeof obj_nextPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union0_error!=null){obj_nextPageUrl_union0=obj_nextPageUrl_union0_error.message;}let obj_nextPageUrl_union1=null;const obj_nextPageUrl_union1_error=(()=>{if(obj_nextPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union1_error!=null){obj_nextPageUrl_union1=obj_nextPageUrl_union1_error.message;}if(obj_nextPageUrl_union0&&obj_nextPageUrl_union1){let message='Object doesn\'t match union (at "'+path_nextPageUrl+'")';message+='\n'+obj_nextPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_optionalFields=obj.optionalFields;const path_optionalFields=path+'.optionalFields';if(!ArrayIsArray$6(obj_optionalFields)){return new TypeError('Expected "array" but received "'+typeof obj_optionalFields+'" (at "'+path_optionalFields+'")');}for(let i=0;i<obj_optionalFields.length;i++){const obj_optionalFields_item=obj_optionalFields[i];const path_optionalFields_item=path_optionalFields+'['+i+']';if(typeof obj_optionalFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_optionalFields_item+'" (at "'+path_optionalFields_item+'")');}}const obj_pageSize=obj.pageSize;const path_pageSize=path+'.pageSize';if(typeof obj_pageSize!=='number'||typeof obj_pageSize==='number'&&Math.floor(obj_pageSize)!==obj_pageSize){return new TypeError('Expected "integer" but received "'+typeof obj_pageSize+'" (at "'+path_pageSize+'")');}const obj_previousPageToken=obj.previousPageToken;const path_previousPageToken=path+'.previousPageToken';let obj_previousPageToken_union0=null;const obj_previousPageToken_union0_error=(()=>{if(typeof obj_previousPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union0_error!=null){obj_previousPageToken_union0=obj_previousPageToken_union0_error.message;}let obj_previousPageToken_union1=null;const obj_previousPageToken_union1_error=(()=>{if(obj_previousPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union1_error!=null){obj_previousPageToken_union1=obj_previousPageToken_union1_error.message;}if(obj_previousPageToken_union0&&obj_previousPageToken_union1){let message='Object doesn\'t match union (at "'+path_previousPageToken+'")';message+='\n'+obj_previousPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageUrl=obj.previousPageUrl;const path_previousPageUrl=path+'.previousPageUrl';let obj_previousPageUrl_union0=null;const obj_previousPageUrl_union0_error=(()=>{if(typeof obj_previousPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union0_error!=null){obj_previousPageUrl_union0=obj_previousPageUrl_union0_error.message;}let obj_previousPageUrl_union1=null;const obj_previousPageUrl_union1_error=(()=>{if(obj_previousPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union1_error!=null){obj_previousPageUrl_union1=obj_previousPageUrl_union1_error.message;}if(obj_previousPageUrl_union0&&obj_previousPageUrl_union1){let message='Object doesn\'t match union (at "'+path_previousPageUrl+'")';message+='\n'+obj_previousPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_records=obj.records;const path_records=path+'.records';if(!ArrayIsArray$6(obj_records)){return new TypeError('Expected "array" but received "'+typeof obj_records+'" (at "'+path_records+'")');}for(let i=0;i<obj_records.length;i++){const obj_records_item=obj_records[i];const path_records_item=path_records+'['+i+']';if(typeof obj_records_item!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_records_item+'" (at "'+path_records_item+'")');}}const obj_sortBy=obj.sortBy;const path_sortBy=path+'.sortBy';let obj_sortBy_union0=null;const obj_sortBy_union0_error=(()=>{if(!ArrayIsArray$6(obj_sortBy)){return new TypeError('Expected "array" but received "'+typeof obj_sortBy+'" (at "'+path_sortBy+'")');}for(let i=0;i<obj_sortBy.length;i++){const obj_sortBy_item=obj_sortBy[i];const path_sortBy_item=path_sortBy+'['+i+']';if(typeof obj_sortBy_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_sortBy_item+'" (at "'+path_sortBy_item+'")');}}})();if(obj_sortBy_union0_error!=null){obj_sortBy_union0=obj_sortBy_union0_error.message;}let obj_sortBy_union1=null;const obj_sortBy_union1_error=(()=>{if(obj_sortBy!==null){return new TypeError('Expected "null" but received "'+typeof obj_sortBy+'" (at "'+path_sortBy+'")');}})();if(obj_sortBy_union1_error!=null){obj_sortBy_union1=obj_sortBy_union1_error.message;}if(obj_sortBy_union0&&obj_sortBy_union1){let message='Object doesn\'t match union (at "'+path_sortBy+'")';message+='\n'+obj_sortBy_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_sortBy_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function keyBuilder$5(config){return keyPrefix$4+'ListRecordCollectionRepresentation:'+config.listViewId+':'+(config.sortBy===null?'':'['+config.sortBy.join(',')+']');}function paginationKeyBuilder(config){return keyBuilder$5(config)+'__pagination';}function normalize$7(input,existing,path,lds,store,timestamp){const input_listReference=input.listReference;const input_listReference_id=path.fullPath+'__listReference';input.listReference=ingest$5$1(input_listReference,{fullPath:input_listReference_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store);const input_records=input.records;const input_records_id=path.fullPath+'__records';for(let i=0;i<input_records.length;i++){const input_records_item=input_records[i];let input_records_item_id=input_records_id+'__'+i;input_records[i]=ingest$2$1(input_records_item,{fullPath:input_records_item_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}function equals$8(existing,incoming){const existing_count=existing.count;const incoming_count=incoming.count;if(!(existing_count===incoming_count)){return false;}const existing_pageSize=existing.pageSize;const incoming_pageSize=incoming.pageSize;if(!(existing_pageSize===incoming_pageSize)){return false;}const existing_currentPageToken=existing.currentPageToken;const incoming_currentPageToken=incoming.currentPageToken;if(!(existing_currentPageToken===incoming_currentPageToken)){return false;}const existing_currentPageUrl=existing.currentPageUrl;const incoming_currentPageUrl=incoming.currentPageUrl;if(!(existing_currentPageUrl===incoming_currentPageUrl)){return false;}const existing_listInfoETag=existing.listInfoETag;const incoming_listInfoETag=incoming.listInfoETag;if(!(existing_listInfoETag===incoming_listInfoETag)){return false;}const existing_fields=existing.fields;const incoming_fields=incoming.fields;const equals_fields_items=equalsArray(existing_fields,incoming_fields,(existing_fields_item,incoming_fields_item)=>{if(!(existing_fields_item===incoming_fields_item)){return false;}});if(equals_fields_items===false){return false;}const existing_listReference=existing.listReference;const incoming_listReference=incoming.listReference;if(!(existing_listReference.__ref===incoming_listReference.__ref)){return false;}const existing_nextPageToken=existing.nextPageToken;const incoming_nextPageToken=incoming.nextPageToken;if(!(existing_nextPageToken===incoming_nextPageToken)){return false;}const existing_nextPageUrl=existing.nextPageUrl;const incoming_nextPageUrl=incoming.nextPageUrl;if(!(existing_nextPageUrl===incoming_nextPageUrl)){return false;}const existing_optionalFields=existing.optionalFields;const incoming_optionalFields=incoming.optionalFields;const equals_optionalFields_items=equalsArray(existing_optionalFields,incoming_optionalFields,(existing_optionalFields_item,incoming_optionalFields_item)=>{if(!(existing_optionalFields_item===incoming_optionalFields_item)){return false;}});if(equals_optionalFields_items===false){return false;}const existing_previousPageToken=existing.previousPageToken;const incoming_previousPageToken=incoming.previousPageToken;if(!(existing_previousPageToken===incoming_previousPageToken)){return false;}const existing_previousPageUrl=existing.previousPageUrl;const incoming_previousPageUrl=incoming.previousPageUrl;if(!(existing_previousPageUrl===incoming_previousPageUrl)){return false;}const existing_records=existing.records;const incoming_records=incoming.records;const equals_records_items=equalsArray(existing_records,incoming_records,(existing_records_item,incoming_records_item)=>{if(!(existing_records_item.__ref===incoming_records_item.__ref)){return false;}});if(equals_records_items===false){return false;}const existing_sortBy=existing.sortBy;const incoming_sortBy=incoming.sortBy;if(!(()=>{if(existing_sortBy===null||incoming_sortBy===null){return existing_sortBy===incoming_sortBy;}const equals_sortBy_items=equalsArray(existing_sortBy,incoming_sortBy,(existing_sortBy_item,incoming_sortBy_item)=>{if(!(existing_sortBy_item===incoming_sortBy_item)){return false;}});if(equals_sortBy_items===false){return false;}})()){return false;}return true;}const ingest$7=function ListRecordCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$h(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$5({listViewId:input.listInfoETag,sortBy:input.sortBy});let incomingRecord=normalize$7(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];const paginationKey=paginationKeyBuilder({listViewId:input.listInfoETag,sortBy:input.sortBy});const{isPastEnd,offsetFor,save,setEnd,setToken}=lds.pagination(paginationKey);const currentOffset=offsetFor(input.currentPageToken);{if(currentOffset===undefined||existingRecord&&existingRecord.records.length<currentOffset){throw new RangeError("currentPageToken value "+input.currentPageToken+" not recognized");}}const nextOffset=currentOffset+input.count;if(input.nextPageToken){setToken(input.nextPageToken,nextOffset);if(isPastEnd(nextOffset)){setEnd(undefined);}}else {setEnd(nextOffset);}if(input.previousPageToken){// TODO - need request's pageSize to ingest previousPageToken at end of list
    if(input.nextPageToken){setToken(input.previousPageToken,currentOffset-input.count);}}save();if(existingRecord){incomingRecord.currentPageUrl=existingRecord.currentPageUrl;// TODO: needs optimization
    incomingRecord.records=[...existingRecord.records.slice(0,currentOffset),...incomingRecord.records,...(input.nextPageToken?existingRecord.records.slice(nextOffset):[])];}if(existingRecord===undefined||equals$8(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$i(obj,path='ListUiRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_info=obj.info;const path_info=path+'.info';if(typeof obj_info!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_info+'" (at "'+path_info+'")');}const obj_records=obj.records;const path_records=path+'.records';if(typeof obj_records!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_records+'" (at "'+path_records+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$6(config){return keyPrefix$4+'ListUiRepresentation:'+(config.listViewApiName===null?'':config.listViewApiName)+':'+config.objectApiName+':'+config.type+':'+(config.sortBy===null?'':'['+config.sortBy.join(',')+']');}function normalize$8(input,existing,path,lds,store,timestamp){const input_info=input.info;const input_info_id=path.fullPath+'__info';input.info=ingest$6(input_info,{fullPath:input_info_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store);const input_records=input.records;const input_records_id=path.fullPath+'__records';input.records=ingest$7(input_records,{fullPath:input_records_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);return input;}function equals$9(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_info=existing.info;const incoming_info=incoming.info;if(!(existing_info.__ref===incoming_info.__ref)){return false;}const existing_records=existing.records;const incoming_records=incoming.records;if(!(existing_records.__ref===incoming_records.__ref)){return false;}return true;}const ingest$8=function ListUiRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$i(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$6({listViewApiName:input.info.listReference.listViewApiName,objectApiName:input.info.listReference.objectApiName,type:input.info.listReference.type,sortBy:input.records.sortBy});let incomingRecord=normalize$8(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$9(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function getUiApiListUiByObjectApiNameAndListViewApiName(config){const key=keyBuilder$6({listViewApiName:config.urlParams.listViewApiName,objectApiName:config.urlParams.objectApiName,type:"listView",sortBy:config.queryParams.sortBy||null});const headers={};return {path:'/services/data/v49.0/ui-api/list-ui/'+config.urlParams.objectApiName+'/'+config.urlParams.listViewApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$8,headers};}const getListUiByApiName_ConfigPropertyNames$1={displayName:'getListUiByApiName',parameters:{required:['objectApiName','listViewApiName'],optional:['fields','optionalFields','pageSize','pageToken','sortBy']}};function coerceConfig$2(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const listViewApiName=config.listViewApiName;if(listViewApiName!==undefined){coercedConfig.listViewApiName=listViewApiName;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const sortBy=config.sortBy;if(sortBy!==undefined){coercedConfig.sortBy=sortBy;}return coercedConfig;}function typeCheckConfig$2$1(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_listViewApiName=untrustedConfig.listViewApiName;if(typeof untrustedConfig_listViewApiName==='string'){config.listViewApiName=untrustedConfig_listViewApiName;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$5(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$5(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_sortBy=untrustedConfig.sortBy;if(ArrayIsArray$1$5(untrustedConfig_sortBy)){const untrustedConfig_sortBy_array=[];for(let i=0,arrayLength=untrustedConfig_sortBy.length;i<arrayLength;i++){const untrustedConfig_sortBy_item=untrustedConfig_sortBy[i];if(typeof untrustedConfig_sortBy_item==='string'){untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);}}config.sortBy=untrustedConfig_sortBy_array;}return config;}function validateAdapterConfig$2$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$2(untrustedConfig);const config=typeCheckConfig$2$1(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function getUiApiListUiByListViewId(config){const key=keyPrefix$4+'ListUiRepresentation('+'fields:'+config.queryParams.fields+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'pageToken:'+config.queryParams.pageToken+','+'sortBy:'+config.queryParams.sortBy+','+'listViewId:'+config.urlParams.listViewId+')';const headers={};return {path:'/services/data/v49.0/ui-api/list-ui/'+config.urlParams.listViewId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$8,headers};}const getListUiByListViewId_ConfigPropertyNames$1={displayName:'getListUiByListViewId',parameters:{required:['listViewId'],optional:['fields','optionalFields','pageSize','pageToken','sortBy']}};function coerceConfig$3(config){const coercedConfig={};const listViewId=config.listViewId;if(listViewId!==undefined){coercedConfig.listViewId=listViewId;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const sortBy=config.sortBy;if(sortBy!==undefined){coercedConfig.sortBy=sortBy;}return coercedConfig;}function typeCheckConfig$3$1(untrustedConfig){const config={};const untrustedConfig_listViewId=untrustedConfig.listViewId;if(typeof untrustedConfig_listViewId==='string'){config.listViewId=untrustedConfig_listViewId;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$5(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$5(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_sortBy=untrustedConfig.sortBy;if(ArrayIsArray$1$5(untrustedConfig_sortBy)){const untrustedConfig_sortBy_array=[];for(let i=0,arrayLength=untrustedConfig_sortBy.length;i<arrayLength;i++){const untrustedConfig_sortBy_item=untrustedConfig_sortBy[i];if(typeof untrustedConfig_sortBy_item==='string'){untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);}}config.sortBy=untrustedConfig_sortBy_array;}return config;}function validateAdapterConfig$3$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$3(untrustedConfig);const config=typeCheckConfig$3$1(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function validate$j(obj,path='ListViewSummaryRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_listUiUrl=obj.listUiUrl;const path_listUiUrl=path+'.listUiUrl';if(typeof obj_listUiUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_listUiUrl+'" (at "'+path_listUiUrl+'")');}})();return v_error===undefined?null:v_error;}const select$8=function ListViewSummaryRepresentationSelect(){return {kind:'Fragment',selections:[{name:'apiName',kind:'Scalar'},{name:'id',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'listUiUrl',kind:'Scalar'}]};};function equals$a(existing,incoming){const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_label=existing.label;const incoming_label=incoming.label;if(!(existing_label===incoming_label)){return false;}const existing_listUiUrl=existing.listUiUrl;const incoming_listUiUrl=incoming.listUiUrl;if(!(existing_listUiUrl===incoming_listUiUrl)){return false;}return true;}function validate$k(obj,path='ListViewSummaryCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_count=obj.count;const path_count=path+'.count';if(typeof obj_count!=='number'||typeof obj_count==='number'&&Math.floor(obj_count)!==obj_count){return new TypeError('Expected "integer" but received "'+typeof obj_count+'" (at "'+path_count+'")');}const obj_currentPageToken=obj.currentPageToken;const path_currentPageToken=path+'.currentPageToken';if(typeof obj_currentPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}const obj_currentPageUrl=obj.currentPageUrl;const path_currentPageUrl=path+'.currentPageUrl';if(typeof obj_currentPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageUrl+'" (at "'+path_currentPageUrl+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_lists=obj.lists;const path_lists=path+'.lists';if(!ArrayIsArray$6(obj_lists)){return new TypeError('Expected "array" but received "'+typeof obj_lists+'" (at "'+path_lists+'")');}for(let i=0;i<obj_lists.length;i++){const obj_lists_item=obj_lists[i];const path_lists_item=path_lists+'['+i+']';const referenceListViewSummaryRepresentationValidationError=validate$j(obj_lists_item,path_lists_item);if(referenceListViewSummaryRepresentationValidationError!==null){let message='Object doesn\'t match ListViewSummaryRepresentation (at "'+path_lists_item+'")\n';message+=referenceListViewSummaryRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_nextPageToken=obj.nextPageToken;const path_nextPageToken=path+'.nextPageToken';let obj_nextPageToken_union0=null;const obj_nextPageToken_union0_error=(()=>{if(typeof obj_nextPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union0_error!=null){obj_nextPageToken_union0=obj_nextPageToken_union0_error.message;}let obj_nextPageToken_union1=null;const obj_nextPageToken_union1_error=(()=>{if(obj_nextPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union1_error!=null){obj_nextPageToken_union1=obj_nextPageToken_union1_error.message;}if(obj_nextPageToken_union0&&obj_nextPageToken_union1){let message='Object doesn\'t match union (at "'+path_nextPageToken+'")';message+='\n'+obj_nextPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_nextPageUrl=obj.nextPageUrl;const path_nextPageUrl=path+'.nextPageUrl';let obj_nextPageUrl_union0=null;const obj_nextPageUrl_union0_error=(()=>{if(typeof obj_nextPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union0_error!=null){obj_nextPageUrl_union0=obj_nextPageUrl_union0_error.message;}let obj_nextPageUrl_union1=null;const obj_nextPageUrl_union1_error=(()=>{if(obj_nextPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union1_error!=null){obj_nextPageUrl_union1=obj_nextPageUrl_union1_error.message;}if(obj_nextPageUrl_union0&&obj_nextPageUrl_union1){let message='Object doesn\'t match union (at "'+path_nextPageUrl+'")';message+='\n'+obj_nextPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_objectApiName=obj.objectApiName;const path_objectApiName=path+'.objectApiName';if(typeof obj_objectApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_objectApiName+'" (at "'+path_objectApiName+'")');}const obj_pageSize=obj.pageSize;const path_pageSize=path+'.pageSize';if(typeof obj_pageSize!=='number'||typeof obj_pageSize==='number'&&Math.floor(obj_pageSize)!==obj_pageSize){return new TypeError('Expected "integer" but received "'+typeof obj_pageSize+'" (at "'+path_pageSize+'")');}const obj_previousPageToken=obj.previousPageToken;const path_previousPageToken=path+'.previousPageToken';let obj_previousPageToken_union0=null;const obj_previousPageToken_union0_error=(()=>{if(typeof obj_previousPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union0_error!=null){obj_previousPageToken_union0=obj_previousPageToken_union0_error.message;}let obj_previousPageToken_union1=null;const obj_previousPageToken_union1_error=(()=>{if(obj_previousPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union1_error!=null){obj_previousPageToken_union1=obj_previousPageToken_union1_error.message;}if(obj_previousPageToken_union0&&obj_previousPageToken_union1){let message='Object doesn\'t match union (at "'+path_previousPageToken+'")';message+='\n'+obj_previousPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageUrl=obj.previousPageUrl;const path_previousPageUrl=path+'.previousPageUrl';let obj_previousPageUrl_union0=null;const obj_previousPageUrl_union0_error=(()=>{if(typeof obj_previousPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union0_error!=null){obj_previousPageUrl_union0=obj_previousPageUrl_union0_error.message;}let obj_previousPageUrl_union1=null;const obj_previousPageUrl_union1_error=(()=>{if(obj_previousPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union1_error!=null){obj_previousPageUrl_union1=obj_previousPageUrl_union1_error.message;}if(obj_previousPageUrl_union0&&obj_previousPageUrl_union1){let message='Object doesn\'t match union (at "'+path_previousPageUrl+'")';message+='\n'+obj_previousPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_queryString=obj.queryString;const path_queryString=path+'.queryString';let obj_queryString_union0=null;const obj_queryString_union0_error=(()=>{if(typeof obj_queryString!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_queryString+'" (at "'+path_queryString+'")');}})();if(obj_queryString_union0_error!=null){obj_queryString_union0=obj_queryString_union0_error.message;}let obj_queryString_union1=null;const obj_queryString_union1_error=(()=>{if(obj_queryString!==null){return new TypeError('Expected "null" but received "'+typeof obj_queryString+'" (at "'+path_queryString+'")');}})();if(obj_queryString_union1_error!=null){obj_queryString_union1=obj_queryString_union1_error.message;}if(obj_queryString_union0&&obj_queryString_union1){let message='Object doesn\'t match union (at "'+path_queryString+'")';message+='\n'+obj_queryString_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_queryString_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recentListsOnly=obj.recentListsOnly;const path_recentListsOnly=path+'.recentListsOnly';if(typeof obj_recentListsOnly!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_recentListsOnly+'" (at "'+path_recentListsOnly+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$7(config){return keyPrefix$4+'ListViewSummaryCollectionRepresentation:'+config.objectApiName+':'+(config.queryString===null?'':config.queryString)+':'+config.recentListsOnly;}function paginationKeyBuilder$1(config){return keyBuilder$7(config)+'__pagination';}function normalize$9(input,existing,path,lds,store,timestamp){return input;}function equals$b(existing,incoming){const existing_recentListsOnly=existing.recentListsOnly;const incoming_recentListsOnly=incoming.recentListsOnly;if(!(existing_recentListsOnly===incoming_recentListsOnly)){return false;}const existing_count=existing.count;const incoming_count=incoming.count;if(!(existing_count===incoming_count)){return false;}const existing_pageSize=existing.pageSize;const incoming_pageSize=incoming.pageSize;if(!(existing_pageSize===incoming_pageSize)){return false;}const existing_currentPageToken=existing.currentPageToken;const incoming_currentPageToken=incoming.currentPageToken;if(!(existing_currentPageToken===incoming_currentPageToken)){return false;}const existing_currentPageUrl=existing.currentPageUrl;const incoming_currentPageUrl=incoming.currentPageUrl;if(!(existing_currentPageUrl===incoming_currentPageUrl)){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_objectApiName=existing.objectApiName;const incoming_objectApiName=incoming.objectApiName;if(!(existing_objectApiName===incoming_objectApiName)){return false;}const existing_lists=existing.lists;const incoming_lists=incoming.lists;const equals_lists_items=equalsArray(existing_lists,incoming_lists,(existing_lists_item,incoming_lists_item)=>{if(!equals$a(existing_lists_item,incoming_lists_item)){return false;}});if(equals_lists_items===false){return false;}const existing_nextPageToken=existing.nextPageToken;const incoming_nextPageToken=incoming.nextPageToken;if(!(existing_nextPageToken===incoming_nextPageToken)){return false;}const existing_nextPageUrl=existing.nextPageUrl;const incoming_nextPageUrl=incoming.nextPageUrl;if(!(existing_nextPageUrl===incoming_nextPageUrl)){return false;}const existing_previousPageToken=existing.previousPageToken;const incoming_previousPageToken=incoming.previousPageToken;if(!(existing_previousPageToken===incoming_previousPageToken)){return false;}const existing_previousPageUrl=existing.previousPageUrl;const incoming_previousPageUrl=incoming.previousPageUrl;if(!(existing_previousPageUrl===incoming_previousPageUrl)){return false;}const existing_queryString=existing.queryString;const incoming_queryString=incoming.queryString;if(!(existing_queryString===incoming_queryString)){return false;}return true;}const ingest$9=function ListViewSummaryCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$k(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$7({objectApiName:input.objectApiName,queryString:input.queryString,recentListsOnly:input.recentListsOnly});let incomingRecord=normalize$9(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];const paginationKey=paginationKeyBuilder$1({objectApiName:input.objectApiName,queryString:input.queryString,recentListsOnly:input.recentListsOnly});const{isPastEnd,offsetFor,save,setEnd,setToken}=lds.pagination(paginationKey);const currentOffset=offsetFor(input.currentPageToken);{if(currentOffset===undefined||existingRecord&&existingRecord.lists.length<currentOffset){throw new RangeError("currentPageToken value "+input.currentPageToken+" not recognized");}}const nextOffset=currentOffset+input.count;if(input.nextPageToken){setToken(input.nextPageToken,nextOffset);if(isPastEnd(nextOffset)){setEnd(undefined);}}else {setEnd(nextOffset);}if(input.previousPageToken){// TODO - need request's pageSize to ingest previousPageToken at end of list
    if(input.nextPageToken){setToken(input.previousPageToken,currentOffset-input.count);}}save();if(existingRecord){incomingRecord.currentPageUrl=existingRecord.currentPageUrl;// TODO: needs optimization
    incomingRecord.lists=[...existingRecord.lists.slice(0,currentOffset),...incomingRecord.lists,...(input.nextPageToken?existingRecord.lists.slice(nextOffset):[])];}if(existingRecord===undefined||equals$b(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function getUiApiListUiByObjectApiName(config){const key=keyBuilder$7({objectApiName:config.urlParams.objectApiName,queryString:config.queryParams.q||null,recentListsOnly:config.queryParams.recentListsOnly||false});const headers={};return {path:'/services/data/v49.0/ui-api/list-ui/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$9,headers};}const getListViewSummaryCollection_ConfigPropertyNames={displayName:'getListViewSummaryCollection',parameters:{required:['objectApiName'],optional:['pageSize','pageToken','q','recentListsOnly']}};function coerceConfig$4(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const q=config.q;if(q!==undefined){coercedConfig.q=q;}const recentListsOnly=config.recentListsOnly;if(recentListsOnly!==undefined){coercedConfig.recentListsOnly=recentListsOnly;}return coercedConfig;}function typeCheckConfig$4$1(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_q=untrustedConfig.q;if(typeof untrustedConfig_q==='string'){config.q=untrustedConfig_q;}const untrustedConfig_recentListsOnly=untrustedConfig.recentListsOnly;if(typeof untrustedConfig_recentListsOnly==='boolean'){config.recentListsOnly=untrustedConfig_recentListsOnly;}return config;}function validateAdapterConfig$4$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$4(untrustedConfig);const config=typeCheckConfig$4$1(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function getUiApiMruListUiByObjectApiName(config){const key=keyBuilder$6({listViewApiName:null,objectApiName:config.urlParams.objectApiName,type:"mru",sortBy:config.queryParams.sortBy||null});const headers={};return {path:'/services/data/v49.0/ui-api/mru-list-ui/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$8,headers};}const getMruListUi_ConfigPropertyNames$1={displayName:'getMruListUi',parameters:{required:['objectApiName'],optional:['fields','optionalFields','pageSize','pageToken','sortBy']}};function coerceConfig$5(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const sortBy=config.sortBy;if(sortBy!==undefined){coercedConfig.sortBy=sortBy;}return coercedConfig;}function typeCheckConfig$5$1(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$5(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$5(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_sortBy=untrustedConfig.sortBy;if(ArrayIsArray$1$5(untrustedConfig_sortBy)){const untrustedConfig_sortBy_array=[];for(let i=0,arrayLength=untrustedConfig_sortBy.length;i<arrayLength;i++){const untrustedConfig_sortBy_item=untrustedConfig_sortBy[i];if(typeof untrustedConfig_sortBy_item==='string'){untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);}}config.sortBy=untrustedConfig_sortBy_array;}return config;}function validateAdapterConfig$5$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$5(untrustedConfig);const config=typeCheckConfig$5$1(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function getUiApiListRecordsByListViewId(config){const key=keyBuilder$5({listViewId:config.urlParams.listViewId,sortBy:config.queryParams.sortBy||null});const headers={};return {path:'/services/data/v49.0/ui-api/list-records/'+config.urlParams.listViewId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$7,headers};}function getUiApiListRecordsByObjectApiNameAndListViewApiName(config){const key=keyPrefix$4+'ListRecordCollectionRepresentation('+'fields:'+config.queryParams.fields+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'pageToken:'+config.queryParams.pageToken+','+'sortBy:'+config.queryParams.sortBy+','+'objectApiName:'+config.urlParams.objectApiName+','+'listViewApiName:'+config.urlParams.listViewApiName+')';const headers={};return {path:'/services/data/v49.0/ui-api/list-records/'+config.urlParams.objectApiName+'/'+config.urlParams.listViewApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$7,headers};}const listReferences={byId:{},byApiNames:{}};/**
     * Adds a list reference so it can be retrieved with #getListReference later.
     *
     * @param listRef list refenence
     */function addListReference(listRef){if(listRef.id){listReferences.byId[listRef.id]=listRef;}listReferences.byApiNames[`${listRef.objectApiName}:${listRef.listViewApiName}`]=listRef;}/**
     * Returns a list reference from the store if it's present.
     *
     * @param query list view to look for
     * @param lds LDS
     */function getListReference(query){return query.listViewId?listReferences.byId[query.listViewId]:listReferences.byApiNames[`${query.objectApiName}:${query.listViewApiName}`];}/**
     * Reader selections to copy a list info
     */const LIST_INFO_SELECTIONS=select$7().selections;const LIST_INFO_SELECTIONS_ETAG=[...LIST_INFO_SELECTIONS,{kind:'Scalar',name:'eTag'}];/**
     * Retrieves the list info corresponding to the specified list reference from the store.
     *
     * @param listRef list reference
     * @param lds LDS
     */function getListInfo(listRef,lds){const key=keyBuilder$4(listRef);const lookupResult=lds.storeLookup({recordId:key,node:{kind:'Fragment',selections:LIST_INFO_SELECTIONS_ETAG},variables:{}});if(isFulfilledSnapshot$1(lookupResult)){return lookupResult.data;}}const serverDefaults={};/**
     * Update the default values based on a server response.
     *
     * @param config getListUi config
     * @param serverResponse ListUiRepresentation from the server
     */function addServerDefaults(config,serverResponse){const key=`${serverResponse.info.listReference.objectApiName}:${serverResponse.info.listReference.listViewApiName}`;let defaults=serverDefaults[key]||(serverDefaults[key]={});if(config.sortBy===undefined&&serverResponse.records.sortBy!==null){defaults.sortBy=serverResponse.records.sortBy;}}/**
     * Returns default values observed on previous requests for a list.
     *
     * @param config getListUi config
     * @returns defaults from previous requests for this list, or {} if no defaults are known
     */function getServerDefaults(config){const listRef=getListReference(config);if(listRef===undefined){return {};}const key=`${listRef.objectApiName}:${listRef.listViewApiName}`;return serverDefaults[key]||{};}// Logic to deal with fields on the list view. This would be reasonably straightforward
    // except that the server sometimes adds 5 well-known fields to every record & nested
    // record in its responses.
    // hardcoded fields that the server adds
    const DEFAULT_SERVER_FIELDS=['CreatedDate','Id','LastModifiedById','LastModifiedDate','SystemModstamp'];/**
     * Adds default fields for every record referenced in a given field name. E.g. if field
     * is "Opportunity.Account.Name" then add default fields "Opportunity.CreatedDate",
     * "Opportunity.Id", ..., "Opportunity.Account.CreatedDate", "Opportunity.Account.Id", ... .
     *
     * @param field explicitly included field
     * @param defaultFields fields object to be updated with the fields that the server will
     *    implicitly add
     */function addDefaultFields(field,defaultFields){const fieldParts=field.split('.');for(let i=1;i<fieldParts.length;++i){const fieldPrefix=fieldParts.slice(0,i).join('.');for(let j=0;j<DEFAULT_SERVER_FIELDS.length;++j){defaultFields[`${fieldPrefix}.${DEFAULT_SERVER_FIELDS[j]}`]=true;}}}/**
     * Indicates if a RecordRepresntation contains a specified field.
     *
     * @param record record
     * @param field field to check for, split on '.'s, with the leading object api name omitted.
     *    E.g. if searching an Opportunity for "Opportunity.Account.Name" this parameter should
     *    be ['Account','Name'].
     */function recordContainsField(record,field){// make sure it looks like a record and the first piece of the field path has a value
    if(!record||!record.fields||!record.fields[field[0]]||record.fields[field[0]].value===undefined){return false;}// recurse if nested record
    else if(field.length>1){return recordContainsField(record.fields[field[0]].value,field.slice(1));}// found it
    return true;}function listFields(lds,{fields=[],optionalFields=[],sortBy},listInfo){const{displayColumns,listReference:{objectApiName}}=listInfo;let fields_={},optionalFields_={},defaultFields_={};// all the fields in the list info are required
    for(let i=0,len=displayColumns.length;i<len;++i){const qualifiedField=`${objectApiName}.${displayColumns[i].fieldApiName}`;fields_[qualifiedField]=true;addDefaultFields(qualifiedField,defaultFields_);}// required fields from the component
    for(let i=0,len=fields.length;i<len;++i){const qualifiedField=fields[i].startsWith(`${objectApiName}.`)?fields[i]:`${objectApiName}.${fields[i]}`;if(!fields_[qualifiedField]){fields_[qualifiedField]=true;addDefaultFields(qualifiedField,defaultFields_);}}// optional fields from the component
    for(let i=0,len=optionalFields.length;i<len;++i){const qualifiedField=optionalFields[i].startsWith(`${objectApiName}.`)?optionalFields[i]:`${objectApiName}.${optionalFields[i]}`;if(!fields_[qualifiedField]){optionalFields_[qualifiedField]=true;addDefaultFields(qualifiedField,defaultFields_);}}const key=keyBuilder$5({listViewId:listInfo.eTag,sortBy:sortBy||null})+'__fieldstatus';const node=lds.getNode(key);const defaultServerFieldStatus=isGraphNode(node)?node.retrieve():{missingFields:_objectSpread$1({},defaultFields_)};return {getRecordSelectionFieldSets(){const optionalPlusDefaultFields=_objectSpread$1({},optionalFields_);const fields=keys$3(defaultFields_);for(let i=0;i<fields.length;++i){const field=fields[i];if(!fields_[field]&&!defaultServerFieldStatus.missingFields[field]){optionalPlusDefaultFields[field]=true;}}return [keys$3(fields_).sort(),keys$3(optionalPlusDefaultFields).sort()];},processRecords(records){const{missingFields}=defaultServerFieldStatus;const fields=keys$3(missingFields);for(let i=0;i<fields.length;++i){const field=fields[i],splitField=field.split('.').slice(1);for(let i=0;i<records.length;++i){if(recordContainsField(records[i],splitField)){delete missingFields[field];break;}}}lds.storePublish(key,defaultServerFieldStatus);// snapshots do not subscribe to this key, so no need to broadcast
    return this;}};}function paginatedDataCustomReader(key,selection,record,data,variables,reader){const nonCustomSelection={name:selection.name,plural:true,selections:selection.selections,pageToken:selection.pageToken,pageSize:selection.pageSize,tokenDataKey:selection.tokenDataKey};if(record[selection.name]&&record[selection.name][0]&&record[selection.name][0].__ref){nonCustomSelection.kind='Link';reader.readPluralLink(key,nonCustomSelection,record,data);}else {nonCustomSelection.kind='Object';reader.readPluralObject(key,nonCustomSelection,record,data);}const pagination=reader.pagination(selection.tokenDataKey);variables.__pageSize=selection.pageSize;const currentOffset=pagination.offsetFor(selection.pageToken);const nextOffset=currentOffset+selection.pageSize;const previousOffset=currentOffset-selection.pageSize;// count
    variables.count=data[selection.name].length;// current/next/previousPageToken
    variables.currentPageToken=selection.pageToken||pagination.defaultToken();const nextPageToken=pagination.isPastEnd(nextOffset)?null:pagination.tokenFor(nextOffset);if(nextPageToken!==undefined){variables.nextPageToken=nextPageToken;}const previousPageToken=previousOffset<0?null:pagination.tokenFor(previousOffset);if(previousPageToken!==undefined){variables.previousPageToken=previousPageToken;}// current/next/previousPageUrls cannot be generated until we have a template url
    }function variablesCustomReader(key,selection,record,data,variables,reader){reader.readScalar(selection.name,variables,data);}function urlCustomReader(key,selection,record,data,variables,reader){let urlProp=selection.name;let tokenProp=`${urlProp.substring(0,urlProp.indexOf('Url'))}Token`;if(variables[tokenProp]){// currentPageUrl should never be empty so use that as the template
    variables[urlProp]=record.currentPageUrl.replace(/pageToken=[^&]+/,`pageToken=${variables[tokenProp]}`).replace(/pageSize=\d+/,`pageSize=${variables.__pageSize}`);}else if(variables[tokenProp]===null){variables[urlProp]=null;}reader.readScalar(selection.name,variables,data);}/**
     * Constructs a PathSelection[] to have Reader correctly populate paginated data
     * and metadata in a Snapshot. The metadata is assumed to follow the standard
     * UI API naming conventions: count, currentPageToken, currentPageUrl,
     * nextPageToken, nextPageUrl, previousPageToken, and previousPageUrl.
     *
     * @param config.name name of the field containing the paginated data
     * @param config.pageSize number of items to be included
     * @param config.pageToken token corresponding to starting offset
     * @param config.selections PathSelection[] to apply to each item
     * @param config.tokenDataKey store key of the pagination data
     * @returns PathSelection[] to populate the paginated data and associated metadata
     */function pathSelectionsFor(config){return [{kind:'Custom',name:config.name,pageToken:config.pageToken,pageSize:config.pageSize,plural:true,reader:paginatedDataCustomReader,selections:config.selections,tokenDataKey:config.tokenDataKey},{kind:'Custom',name:'count',reader:variablesCustomReader},{kind:'Custom',name:'currentPageToken',reader:variablesCustomReader},{kind:'Custom',name:'currentPageUrl',reader:urlCustomReader},{kind:'Custom',name:'nextPageToken',reader:variablesCustomReader},{kind:'Custom',name:'nextPageUrl',reader:urlCustomReader},{kind:'Custom',name:'previousPageToken',reader:variablesCustomReader},{kind:'Custom',name:'previousPageUrl',reader:urlCustomReader}];}/**
     * Returns a PathSelection that injects a predetermined value at the specified name.
     *
     * @param config.name key associated with the value
     * @param config.value value to be injected
     */function staticValuePathSelection(config){return {kind:'Custom',name:config.name,reader:(key,_selection,_record,data,_variables,_reader)=>{data[key]=config.value;}};}/**
     * Examines a set of paginated data & metadata from an UnfulfilledSnapshot and computes a
     * pageToken and pageSize that will minimize the amount of data requested while still
     * satisfying the original request.
     *
     * @param config.name name of the field within data that contains the items
     * @param conifg.data paginated data/metadata from an UnfulfilledSnapshot
     * @param config.pageSize requested pageSize
     * @param config.pagination pagination data/functions from engine
     * @returns pageToken & pageSize to fill in the missing data
     */function minimizeRequest(config){// the only way to handle missing current or previous token is to ask for the full set of requested records
    if(!config.data||!config.data[config.name]||config.data.previousPageToken===undefined){return {pageSize:config.pageSize,pageToken:config.pageToken};}else {// compute the offset of the last record that was found
    const pageTokenOffset=config.pagination.offsetFor(config.data.currentPageToken);const lastFoundOffset=pageTokenOffset+config.data[config.name].length;// backup to the nearest offset for which we have a token
    const[newToken,newOffset]=config.pagination.tokenForAtMost(lastFoundOffset);// recompute pageToken and pageSize for query based on new starting token
    return {pageSize:pageTokenOffset-newOffset+config.pageSize,pageToken:newToken};}}// TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE=20;const LISTVIEWSUMMARY_PATH_SELECTIONS=select$8().selections;function buildListViewSummaryCollectionFragment(config){return {kind:'Fragment',selections:[...pathSelectionsFor({name:'lists',selections:LISTVIEWSUMMARY_PATH_SELECTIONS,pageSize:config.pageSize||DEFAULT_PAGE_SIZE,pageToken:config.pageToken,tokenDataKey:paginationKeyBuilder$1({objectApiName:config.objectApiName,queryString:config.q===undefined?null:config.q,recentListsOnly:config.recentListsOnly===undefined?false:config.recentListsOnly})}),{kind:'Scalar',name:'objectApiName'},staticValuePathSelection({name:'pageSize',value:config.pageSize===undefined?DEFAULT_PAGE_SIZE:config.pageSize}),{kind:'Scalar',name:'queryString'},{kind:'Scalar',name:'recentListsOnly'}]};}function buildInMemorySnapshot$3$1(lds,config){const request=getUiApiListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{pageSize:config.pageSize,pageToken:config.pageToken,q:config.q,recentListsOnly:config.recentListsOnly}});const selector={recordId:request.key,node:buildListViewSummaryCollectionFragment(config),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$3$1(lds,config,snapshot){const request=getUiApiListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{pageSize:config.pageSize,pageToken:config.pageToken,q:config.q,recentListsOnly:config.recentListsOnly}});if(snapshot){// compute the minimum number of records we need to request
    const{pageSize,pageToken}=minimizeRequest({data:snapshot.data,name:'lists',pageSize:config.pageSize||DEFAULT_PAGE_SIZE,pageToken:config.pageToken,pagination:lds.pagination(paginationKeyBuilder$1({objectApiName:config.objectApiName,queryString:config.q===undefined?null:config.q,recentListsOnly:config.recentListsOnly===undefined?false:config.recentListsOnly}))});// update request, but don't harden default values unless they were already present
    if(pageSize!==DEFAULT_PAGE_SIZE||request.queryParams.pageSize!==undefined){request.queryParams.pageSize=pageSize;}if(pageToken||request.queryParams.pageToken!==undefined){request.queryParams.pageToken=pageToken;}}return lds.dispatchResourceRequest(request).then(resp=>{const{body}=resp;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$3$1(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getListViewSummaryCollectionAdapterFactory=lds=>{return refreshable$5(function getListViewSummaryCollection(untrustedConfig){const config=validateAdapterConfig$4$1(untrustedConfig,getListViewSummaryCollection_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$3$1(lds,config);// Cache Hit
    if(isFulfilledSnapshot$1(cacheSnapshot)){return cacheSnapshot;}return buildNetworkSnapshot$3$1(lds,config,cacheSnapshot);},// Refresh snapshot
    untrustedConfig=>{const config=validateAdapterConfig$4$1(untrustedConfig,getListViewSummaryCollection_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getListViewSummaryCollection" refresh function');}return buildNetworkSnapshot$3$1(lds,config);});};function getUiApiMruListRecordsByObjectApiName(config){const key=keyPrefix$4+'ListRecordCollectionRepresentation('+'fields:'+config.queryParams.fields+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'pageToken:'+config.queryParams.pageToken+','+'sortBy:'+config.queryParams.sortBy+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v49.0/ui-api/mru-list-records/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$7,headers};}const LIST_REFERENCE_SELECTIONS=select$6().selections;// TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE$1=50;// make local copies of the adapter configs so we can ignore other getListUi config parameters to match
    // lds222 behavior
    const getMruListUi_ConfigPropertyNames_augmented$1=_objectSpread$1({},getMruListUi_ConfigPropertyNames$1,{parameters:_objectSpread$1({},getMruListUi_ConfigPropertyNames$1.parameters,{optional:[...getMruListUi_ConfigPropertyNames$1.parameters.optional,'listViewApiName','listViewId']})});function buildListUiFragment(config,listInfo,fields){return {kind:'Fragment',selections:[{kind:'Link',name:'info',selections:LIST_INFO_SELECTIONS},{kind:'Link',name:'records',selections:[...pathSelectionsFor({name:'records',pageSize:config.pageSize||DEFAULT_PAGE_SIZE$1,pageToken:config.pageToken,selections:buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),tokenDataKey:paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:config.sortBy===undefined?null:config.sortBy})}),{kind:'Scalar',name:'fields',plural:true},{kind:'Scalar',name:'listInfoETag'},{kind:'Link',name:'listReference',selections:LIST_REFERENCE_SELECTIONS},{kind:'Scalar',name:'optionalFields',plural:true},staticValuePathSelection({name:'pageSize',value:config.pageSize===undefined?DEFAULT_PAGE_SIZE$1:config.pageSize}),{// TODO - check type; re-verify after sortBy added to key
    kind:'Scalar',name:'sortBy'}]}]};}function buildInMemorySnapshot$4$1(lds,config,listInfo,fields){const listFields_=fields||listFields(lds,config,listInfo);const request=getUiApiMruListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{fields:config.fields,optionalFields:config.optionalFields,pageSize:config.pageSize,pageToken:config.pageToken,sortBy:config.sortBy}});const selector={recordId:request.key,node:buildListUiFragment(config,listInfo,listFields_),variables:{}};return lds.storeLookup(selector);}/**
     * Builds, sends, and processes the result of a mru-list-ui request, ignoring any cached
     * data for the list.
     *
     * @param lds LDS engine
     * @param config wire config
     */function buildNetworkSnapshot_getMruListUi(lds,config){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};let request=getUiApiMruListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const listInfo=body.info;// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.records.listReference=body.info.listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.records.pageSize===null){body.records.pageSize=DEFAULT_PAGE_SIZE$1;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.records.sortBy===null);// server returns sortBy in csv format
    if(body.records.sortBy){body.records.sortBy=body.records.sortBy.split(',');}const listUiKey=keyBuilder$6(_objectSpread$1({},listInfo.listReference,{sortBy:body.records.sortBy}));// grab relevant bits before ingest destroys the structure
    const fields=listFields(lds,config,listInfo);fields.processRecords(body.records.records);// build the selector while the list info is still easily accessible
    const fragment=buildListUiFragment(config,listInfo,fields);lds.storeIngest(listUiKey,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:listUiKey,node:fragment,variables:{}});},err=>{return lds.errorSnapshot(err);});}function buildNetworkSnapshot_getMruListRecords(lds,config,listInfo,snapshot){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};const request=getUiApiMruListRecordsByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams});if(snapshot){// compute the minimum number of records we need to request
    const{pageSize,pageToken}=minimizeRequest({data:snapshot.data?snapshot.data.records:null,name:'records',pageSize:config.pageSize||DEFAULT_PAGE_SIZE$1,pageToken:config.pageToken,pagination:lds.pagination(paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:config.sortBy===undefined?null:config.sortBy}))});// update request, but don't harden default values unless they were already present
    if(pageSize!==DEFAULT_PAGE_SIZE$1||request.queryParams.pageSize!==undefined){request.queryParams.pageSize=pageSize;}if(pageToken!==undefined||request.queryParams.pageToken!==undefined){request.queryParams.pageToken=pageToken;}}return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const{listInfoETag}=body;// fall back to mru-list-ui if list view has changed
    if(listInfoETag!==listInfo.eTag){return buildNetworkSnapshot_getMruListUi(lds,config);}// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.listReference=listInfo.listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.pageSize===null){body.pageSize=DEFAULT_PAGE_SIZE$1;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.sortBy===null);// server returns sortBy in csv format
    if(body.sortBy){body.sortBy=body.sortBy.split(',');}const fields=listFields(lds,config,listInfo).processRecords(body.records);lds.storeIngest(keyBuilder$5({listViewId:listInfoETag,sortBy:body.sortBy}),request,body);lds.storeBroadcast();return buildInMemorySnapshot$4$1(lds,config,listInfo,fields);},err=>{lds.storeIngestFetchResponse(keyBuilder$6(_objectSpread$1({},listInfo.listReference,{sortBy:config.sortBy===undefined?null:config.sortBy})),err);lds.storeBroadcast();return lds.errorSnapshot(err);});}const getMruListUiAdapterFactory=lds=>{return refreshable$5(untrustedConfig=>{const config=validateAdapterConfig$5$1(untrustedConfig,getMruListUi_ConfigPropertyNames_augmented$1);if(config===null){return null;}// try to get a list reference and a list info for the list; this should come back
    // non-null if we have the list info cached
    const listInfo=getListInfo({id:null,listViewApiName:null,objectApiName:config.objectApiName,type:'mru'},lds);// no list info means it's not in the cache - make a full list-ui request
    if(!listInfo){return buildNetworkSnapshot_getMruListUi(lds,config);}// with the list info we can construct the full selector and try to get the
    // list ui from the store
    const snapshot=buildInMemorySnapshot$4$1(lds,config,listInfo);if(isFulfilledSnapshot$1(snapshot)){// cache hit :partyparrot:
    return snapshot;}// if there was an error or if the list ui was not found in the store then
    // make a full list-ui request
    else if(isErrorSnapshot$1(snapshot)||!snapshot.data){return buildNetworkSnapshot_getMruListUi(lds,config);}// we *should* only be missing records and/or tokens at this point; send a list-records
    // request to fill them in
    return buildNetworkSnapshot_getMruListRecords(lds,config,listInfo,snapshot);},untrustedConfig=>{const config=validateAdapterConfig$5$1(untrustedConfig,getMruListUi_ConfigPropertyNames$1);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getMruListUi" refresh function');}return buildNetworkSnapshot_getMruListUi(lds,config);});};const LIST_REFERENCE_SELECTIONS$1=select$6().selections;// TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE$2=50;// make local copies of the adapter configs so we can have them ignore each other's config parameters
    // to match lds222 behavior
    const getListUiByApiName_ConfigPropertyNames_augmented$1=_objectSpread$1({},getListUiByApiName_ConfigPropertyNames$1,{parameters:_objectSpread$1({},getListUiByApiName_ConfigPropertyNames$1.parameters,{optional:[...getListUiByApiName_ConfigPropertyNames$1.parameters.optional,'listViewId']})});const getListUiByListViewId_ConfigPropertyNames_augmented$1=_objectSpread$1({},getListUiByListViewId_ConfigPropertyNames$1,{parameters:_objectSpread$1({},getListUiByListViewId_ConfigPropertyNames$1.parameters,{optional:[...getListUiByListViewId_ConfigPropertyNames$1.parameters.optional,'listViewApiName','objectApiName']})});function getSortBy(config){if(config.sortBy!==undefined){return config.sortBy;}const defaults=getServerDefaults(config);if(defaults.sortBy!==undefined){return defaults.sortBy;}return null;}function buildListUiFragment$1(config,listInfo,fields){const defaultedConfig=_objectSpread$1({},getServerDefaults(config),config);return {kind:'Fragment',selections:[{kind:'Link',name:'info',selections:LIST_INFO_SELECTIONS},{kind:'Link',name:'records',selections:[...pathSelectionsFor({name:'records',pageSize:defaultedConfig.pageSize||DEFAULT_PAGE_SIZE$2,pageToken:defaultedConfig.pageToken,selections:buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),tokenDataKey:paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:defaultedConfig.sortBy===undefined?null:defaultedConfig.sortBy})}),{kind:'Scalar',name:'fields',plural:true},{kind:'Scalar',name:'listInfoETag'},{kind:'Link',name:'listReference',selections:LIST_REFERENCE_SELECTIONS$1},{kind:'Scalar',name:'optionalFields',plural:true},staticValuePathSelection({name:'pageSize',value:defaultedConfig.pageSize===undefined?DEFAULT_PAGE_SIZE$2:defaultedConfig.pageSize}),{kind:'Scalar',name:'sortBy',plural:true}]}]};}function buildInMemorySnapshot$5$1(lds,config,listInfo,fields){const listUiKey=keyBuilder$6(_objectSpread$1({},listInfo.listReference,{sortBy:getSortBy(config)}));const listFields_=fields||listFields(lds,config,listInfo);const selector={recordId:listUiKey,node:buildListUiFragment$1(config,listInfo,listFields_),variables:{}};return lds.storeLookup(selector);}/**
     * Builds, sends, and processes the result of a list-ui request, ignoring any cached
     * data for the list view.
     *
     * @param lds LDS engine
     * @param config wire config
     */function buildNetworkSnapshot_getListUi(lds,config){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};let request;if(isGetListUiByApiNameConfig(config)){request=getUiApiListUiByObjectApiNameAndListViewApiName({urlParams:{listViewApiName:config.listViewApiName,objectApiName:config.objectApiName},queryParams});}else if(isGetListUiByListViewIdConfig(config)){request=getUiApiListUiByListViewId({urlParams:{listViewId:config.listViewId},queryParams});}else {throw new Error('unrecognized config');}return lds.dispatchResourceRequest(request).then(response=>{const{body}=response,listInfo=body.info,{listReference}=listInfo;// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.records.listReference=listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.records.pageSize===null){body.records.pageSize=DEFAULT_PAGE_SIZE$2;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.records.sortBy===null);// server returns sortBy in csv format
    if(body.records.sortBy){body.records.sortBy=body.records.sortBy.split(',');}const listUiKey=keyBuilder$6(_objectSpread$1({},listReference,{sortBy:body.records.sortBy}));// grab relevant bits before ingest destroys the structure
    const fields=listFields(lds,config,listInfo);fields.processRecords(body.records.records);// remember the id/name of this list
    addListReference(listReference);// remember any default values that the server filled in
    addServerDefaults(config,body);// build the selector while the list info is still easily accessible
    const fragment=buildListUiFragment$1(config,listInfo,fields);lds.storeIngest(listUiKey,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:listUiKey,node:fragment,variables:{}});},err=>{return lds.errorSnapshot(err);});}function buildNetworkSnapshot_getListRecords(lds,config,listInfo,snapshot){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};let request;if(isGetListUiByApiNameConfig(config)){request=getUiApiListRecordsByObjectApiNameAndListViewApiName({urlParams:{listViewApiName:config.listViewApiName,objectApiName:config.objectApiName},queryParams});}else if(isGetListUiByListViewIdConfig(config)){request=getUiApiListRecordsByListViewId({urlParams:{listViewId:config.listViewId},queryParams});}else {throw new Error('how did MRU config get here?');}if(snapshot){// compute the minimum number of records we need to request
    const{pageSize,pageToken}=minimizeRequest({data:snapshot.data?snapshot.data.records:null,name:'records',pageSize:config.pageSize||DEFAULT_PAGE_SIZE$2,pageToken:config.pageToken,pagination:lds.pagination(paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:getSortBy(config)}))});// update request, but don't harden default values unless they were already present
    if(pageSize!==DEFAULT_PAGE_SIZE$2||request.queryParams.pageSize!==undefined){request.queryParams.pageSize=pageSize;}if(pageToken||request.queryParams.pageToken!==undefined){request.queryParams.pageToken=pageToken;}}return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const{listInfoETag}=body;// fall back to list-ui if list view has changed
    if(listInfoETag!==listInfo.eTag){return buildNetworkSnapshot_getListUi(lds,config);}// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.listReference=listInfo.listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.pageSize===null){body.pageSize=DEFAULT_PAGE_SIZE$2;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.sortBy===null);// server returns sortBy in csv format
    if(body.sortBy){body.sortBy=body.sortBy.split(',');}const fields=listFields(lds,config,listInfo).processRecords(body.records);lds.storeIngest(keyBuilder$5({listViewId:listInfoETag,sortBy:body.sortBy}),request,body);lds.storeBroadcast();return buildInMemorySnapshot$5$1(lds,config,listInfo,fields);},err=>{lds.storeIngestFetchResponse(keyBuilder$6(_objectSpread$1({},listInfo.listReference,{sortBy:getSortBy(config)})),err);lds.storeBroadcast();return lds.errorSnapshot(err);});}// functions to discern config variations
    function isGetListUiByApiNameConfig(config){return config.listViewApiName!==undefined;}function looksLikeGetListUiByApiNameConfig(untrustedConfig){return untrustedIsObject$5(untrustedConfig)&&untrustedConfig.objectApiName&&untrustedConfig.listViewApiName;}function isGetListUiByListViewIdConfig(config){return !!config.listViewId;}function looksLikeGetListUiByListViewIdConfig(untrustedConfig){return untrustedIsObject$5(untrustedConfig)&&untrustedConfig.listViewId;}function looksLikeGetListViewSummaryCollectionConfig(untrustedConfig){return untrustedIsObject$5(untrustedConfig)&&untrustedConfig.objectApiName&&!untrustedConfig.listViewId&&!untrustedConfig.listViewApiName;}function looksLikeGetMruListUiConfig(untrustedConfig){// the MRU symbol is a carryover hack from 222 and doesn't show up in any
    // of the generated config types, so we cast to any in order to check for it
    return untrustedIsObject$5(untrustedConfig)&&untrustedConfig.listViewApiName===MRU;}function validateGetListUiConfig(untrustedConfig){return looksLikeGetListUiByApiNameConfig(untrustedConfig)?validateAdapterConfig$2$1(untrustedConfig,getListUiByApiName_ConfigPropertyNames_augmented$1):looksLikeGetListUiByListViewIdConfig(untrustedConfig)?validateAdapterConfig$3$1(untrustedConfig,getListUiByListViewId_ConfigPropertyNames_augmented$1):null;}// the listViewApiName value to pass to getListUi() to request the MRU list
    const MRU=Symbol.for('MRU');const factory$4=lds=>{// adapter implementation for getListUiBy*
    const listUiAdapter=refreshable$5(untrustedConfig=>{const config=validateGetListUiConfig(untrustedConfig);if(config===null){return null;}// try to get a list reference and a list info for the list; this should come back
    // non-null if we have the list info cached
    const listRef=getListReference(config);const listInfo=listRef&&getListInfo(listRef,lds);// no list info means it's not in the cache - make a full list-ui request
    if(!listInfo){return buildNetworkSnapshot_getListUi(lds,config);}// with the list info we can construct the full selector and try to get the
    // list ui from the store
    const snapshot=buildInMemorySnapshot$5$1(lds,config,listInfo);if(isFulfilledSnapshot$1(snapshot)){// cache hit :partyparrot:
    return snapshot;}// if there was an error or if the list ui was not found in the store then
    // make a full list-ui request
    else if(isErrorSnapshot$1(snapshot)||!snapshot.data){return buildNetworkSnapshot_getListUi(lds,config);}// we *should* only be missing records and/or tokens at this point; send a list-records
    // request to fill them in
    return buildNetworkSnapshot_getListRecords(lds,config,listInfo,snapshot);},untrustedConfig=>{const config=validateGetListUiConfig(untrustedConfig);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getListUi" refresh function');}return buildNetworkSnapshot_getListUi(lds,config);});let listViewSummaryCollectionAdapter=null;let mruAdapter=null;// delegate to various other adapter based on what config looks like; note that the adapters
    // we delegate to are responsible for returning refreshable results
    return function(untrustedConfig){// if the MRU symbol is there then just return the getMruListUi adapter
    if(looksLikeGetMruListUiConfig(untrustedConfig)){if(mruAdapter===null){mruAdapter=getMruListUiAdapterFactory(lds);}// the symbol in the listViewApiName is just a hack so we can recognize the request as MRU
    const mruConfig=_objectSpread$1({},untrustedConfig);delete mruConfig.listViewApiName;return mruAdapter(mruConfig);}// if config has objectApiName but no listViewId or listViewApiName then hand off
    // to listViewSummaryCollectionAdapter
    if(looksLikeGetListViewSummaryCollectionConfig(untrustedConfig)){if(listViewSummaryCollectionAdapter===null){listViewSummaryCollectionAdapter=getListViewSummaryCollectionAdapterFactory(lds);}return listViewSummaryCollectionAdapter(untrustedConfig);}// see if config looks like a listViewId or listViewApiName request
    if(looksLikeGetListUiByApiNameConfig(untrustedConfig)||looksLikeGetListUiByListViewIdConfig(untrustedConfig)){return listUiAdapter(untrustedConfig);}return null;};};function getUiApiLookupsByObjectApiNameAndFieldApiNameAndTargetApiName(config){const key=keyPrefix$4+'RecordCollectionRepresentation('+'dependentFieldBindings:'+config.queryParams.dependentFieldBindings+','+'page:'+config.queryParams.page+','+'pageSize:'+config.queryParams.pageSize+','+'q:'+config.queryParams.q+','+'searchType:'+config.queryParams.searchType+','+'sourceRecordId:'+config.queryParams.sourceRecordId+','+'objectApiName:'+config.urlParams.objectApiName+','+'fieldApiName:'+config.urlParams.fieldApiName+','+'targetApiName:'+config.urlParams.targetApiName+')';const headers={};return {path:'/services/data/v49.0/ui-api/lookups/'+config.urlParams.objectApiName+'/'+config.urlParams.fieldApiName+'/'+config.urlParams.targetApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$5,headers};}function coerceConfig$6(config){const coercedConfig={};const objectApiName=config.objectApiName;if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const fieldApiName=getFieldApiName(config.fieldApiName);if(fieldApiName!==undefined){coercedConfig.fieldApiName=fieldApiName;}const targetApiName=getObjectApiName(config.targetApiName);if(targetApiName!==undefined){coercedConfig.targetApiName=targetApiName;}const dependentFieldBindings=config.dependentFieldBindings;if(dependentFieldBindings!==undefined){coercedConfig.dependentFieldBindings=dependentFieldBindings;}const page=config.page;if(page!==undefined){coercedConfig.page=page;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const q=config.q;if(q!==undefined){coercedConfig.q=q;}const searchType=config.searchType;if(searchType!==undefined){coercedConfig.searchType=searchType;}const sourceRecordId=config.sourceRecordId;if(sourceRecordId!==undefined){coercedConfig.sourceRecordId=sourceRecordId;}return coercedConfig;}function typeCheckConfig$6(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_fieldApiName=untrustedConfig.fieldApiName;if(typeof untrustedConfig_fieldApiName==='string'){config.fieldApiName=untrustedConfig_fieldApiName;}const untrustedConfig_targetApiName=untrustedConfig.targetApiName;if(typeof untrustedConfig_targetApiName==='string'){config.targetApiName=untrustedConfig_targetApiName;}const untrustedConfig_dependentFieldBindings=untrustedConfig.dependentFieldBindings;if(ArrayIsArray$1$5(untrustedConfig_dependentFieldBindings)){const untrustedConfig_dependentFieldBindings_array=[];for(let i=0,arrayLength=untrustedConfig_dependentFieldBindings.length;i<arrayLength;i++){const untrustedConfig_dependentFieldBindings_item=untrustedConfig_dependentFieldBindings[i];if(typeof untrustedConfig_dependentFieldBindings_item==='string'){untrustedConfig_dependentFieldBindings_array.push(untrustedConfig_dependentFieldBindings_item);}}config.dependentFieldBindings=untrustedConfig_dependentFieldBindings_array;}const untrustedConfig_page=untrustedConfig.page;if(typeof untrustedConfig_page==='number'&&Math.floor(untrustedConfig_page)===untrustedConfig_page){config.page=untrustedConfig_page;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_q=untrustedConfig.q;if(typeof untrustedConfig_q==='string'){config.q=untrustedConfig_q;}const untrustedConfig_searchType=untrustedConfig.searchType;if(typeof untrustedConfig_searchType==='string'){config.searchType=untrustedConfig_searchType;}const untrustedConfig_sourceRecordId=untrustedConfig.sourceRecordId;if(typeof untrustedConfig_sourceRecordId==='string'){config.sourceRecordId=untrustedConfig_sourceRecordId;}return config;}function validateAdapterConfig$6(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$6(untrustedConfig);const config=typeCheckConfig$6(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}const paramNames={displayName:'getLookupRecords',parameters:{required:['fieldApiName','targetApiName'],optional:['requestParams']}};function coerceRequestParams(untrusted){if(!untrustedIsObject$5(untrusted)){return {};}const coercedConfig={};const requestParams=untrusted.requestParams||{};const dependentFieldBindings=requestParams.dependentFieldBindings;if(dependentFieldBindings!==undefined){coercedConfig.dependentFieldBindings=dependentFieldBindings;}const page=requestParams.page;if(page!==undefined){coercedConfig.page=page;}const pageSize=requestParams.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const q=requestParams.q;if(q!==undefined){coercedConfig.q=q;}const searchType=requestParams.searchType;if(searchType!==undefined){coercedConfig.searchType=searchType;}const sourceRecordId=requestParams.sourceRecordId;if(sourceRecordId!==undefined){coercedConfig.sourceRecordId=sourceRecordId;}return coercedConfig;}function coerceConfigWithDefaults$2(untrusted){const config=validateAdapterConfig$6(untrusted,paramNames);if(config===null){return config;}const coercedRequestParams=coerceRequestParams(untrusted);const{objectApiName,fieldApiName}=getFieldId(config.fieldApiName);return _objectSpread$1({},config,{objectApiName,fieldApiName},coercedRequestParams);}function removeEtags(recordRep){const{fields}=recordRep;delete recordRep.eTag;delete recordRep.weakEtag;Object.keys(fields).forEach(fieldName=>{const{value:nestedValue}=fields[fieldName];if(isSpanningRecord(nestedValue)){removeEtags(nestedValue);}});}function buildNetworkSnapshot$4$1(lds,config){const{objectApiName,fieldApiName,targetApiName}=config;const request=getUiApiLookupsByObjectApiNameAndFieldApiNameAndTargetApiName({urlParams:{objectApiName,fieldApiName,targetApiName},queryParams:{page:config.page,pageSize:config.pageSize,q:config.q,searchType:config.searchType,dependentFieldBindings:config.dependentFieldBindings,sourceRecordId:config.sourceRecordId}});return lds.dispatchResourceRequest(request).then(response=>{// TODO W-7235112 - remove this hack to never ingest lookup responses that
    // avoids issues caused by them not being real RecordRepresentations
    const{body}=response;const{records}=body;for(let i=0,len=records.length;i<len;i+=1){removeEtags(records[i]);}deepFreeze$9(body);return {state:'Fulfilled',recordId:request.key,variables:{},seenRecords:{},select:{recordId:request.key,node:{kind:'Fragment'},variables:{}},data:body};},err=>{return lds.errorSnapshot(err);});}const factory$5=lds=>{return refreshable$5(function(untrusted){const config=coerceConfigWithDefaults$2(untrusted);if(config===null){return null;}return buildNetworkSnapshot$4$1(lds,config);},untrusted=>{const config=coerceConfigWithDefaults$2(untrusted);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$4$1(lds,config);});};function toSortedStringArray(value){const valueArray=isArray$3(value)?value:[value];if(valueArray.length!==0&&isArrayOfNonEmptyStrings(valueArray)){return dedupe(valueArray).sort();}return undefined;}const oneOfConfigPropertiesIdentifier=['layoutTypes','fields','optionalFields'];function coerceConfig$7(config){const coercedConfig={};const recordId=getRecordId18(config.recordId);if(recordId!==undefined){coercedConfig.recordId=recordId;}const childRelationships=config.childRelationships;if(childRelationships!==undefined){coercedConfig.childRelationships=childRelationships;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const forms=config.forms;if(forms!==undefined){coercedConfig.forms=forms;}const layoutTypes=toSortedStringArray(config.layoutTypes);if(layoutTypes!==undefined){coercedConfig.layoutTypes=layoutTypes;}const modes=toSortedStringArray(config.modes);if(modes!==undefined){coercedConfig.modes=modes;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const updateMru=config.updateMru;if(updateMru!==undefined){coercedConfig.updateMru=updateMru;}return coercedConfig;}function typeCheckConfig$7(untrustedConfig){const config={};const untrustedConfig_recordId=untrustedConfig.recordId;if(typeof untrustedConfig_recordId==='string'){config.recordId=untrustedConfig_recordId;}const untrustedConfig_childRelationships=untrustedConfig.childRelationships;if(ArrayIsArray$1$5(untrustedConfig_childRelationships)){const untrustedConfig_childRelationships_array=[];for(let i=0,arrayLength=untrustedConfig_childRelationships.length;i<arrayLength;i++){const untrustedConfig_childRelationships_item=untrustedConfig_childRelationships[i];if(typeof untrustedConfig_childRelationships_item==='string'){untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);}}config.childRelationships=untrustedConfig_childRelationships_array;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$5(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_forms=untrustedConfig.forms;if(ArrayIsArray$1$5(untrustedConfig_forms)){const untrustedConfig_forms_array=[];for(let i=0,arrayLength=untrustedConfig_forms.length;i<arrayLength;i++){const untrustedConfig_forms_item=untrustedConfig_forms[i];if(typeof untrustedConfig_forms_item==='string'){untrustedConfig_forms_array.push(untrustedConfig_forms_item);}}config.forms=untrustedConfig_forms_array;}const untrustedConfig_layoutTypes=untrustedConfig.layoutTypes;if(ArrayIsArray$1$5(untrustedConfig_layoutTypes)){const untrustedConfig_layoutTypes_array=[];for(let i=0,arrayLength=untrustedConfig_layoutTypes.length;i<arrayLength;i++){const untrustedConfig_layoutTypes_item=untrustedConfig_layoutTypes[i];if(typeof untrustedConfig_layoutTypes_item==='string'){untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);}}config.layoutTypes=untrustedConfig_layoutTypes_array;}const untrustedConfig_modes=untrustedConfig.modes;if(ArrayIsArray$1$5(untrustedConfig_modes)){const untrustedConfig_modes_array=[];for(let i=0,arrayLength=untrustedConfig_modes.length;i<arrayLength;i++){const untrustedConfig_modes_item=untrustedConfig_modes[i];if(typeof untrustedConfig_modes_item==='string'){untrustedConfig_modes_array.push(untrustedConfig_modes_item);}}config.modes=untrustedConfig_modes_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$5(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_updateMru=untrustedConfig.updateMru;if(typeof untrustedConfig_updateMru==='boolean'){config.updateMru=untrustedConfig_updateMru;}return config;}function validateAdapterConfig$7(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames,oneOfConfigPropertiesIdentifier);}const coercedConfig=coerceConfig$7(untrustedConfig);const config=typeCheckConfig$7(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}if(config.layoutTypes===undefined&&config.fields===undefined&&config.optionalFields===undefined){return null;}return config;}function validate$l(obj,path='ChildRelationshipRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_childObjectApiName=obj.childObjectApiName;const path_childObjectApiName=path+'.childObjectApiName';if(typeof obj_childObjectApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_childObjectApiName+'" (at "'+path_childObjectApiName+'")');}const obj_fieldName=obj.fieldName;const path_fieldName=path+'.fieldName';if(typeof obj_fieldName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldName+'" (at "'+path_fieldName+'")');}const obj_junctionIdListNames=obj.junctionIdListNames;const path_junctionIdListNames=path+'.junctionIdListNames';if(!ArrayIsArray$6(obj_junctionIdListNames)){return new TypeError('Expected "array" but received "'+typeof obj_junctionIdListNames+'" (at "'+path_junctionIdListNames+'")');}for(let i=0;i<obj_junctionIdListNames.length;i++){const obj_junctionIdListNames_item=obj_junctionIdListNames[i];const path_junctionIdListNames_item=path_junctionIdListNames+'['+i+']';if(typeof obj_junctionIdListNames_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_junctionIdListNames_item+'" (at "'+path_junctionIdListNames_item+'")');}}const obj_junctionReferenceTo=obj.junctionReferenceTo;const path_junctionReferenceTo=path+'.junctionReferenceTo';if(!ArrayIsArray$6(obj_junctionReferenceTo)){return new TypeError('Expected "array" but received "'+typeof obj_junctionReferenceTo+'" (at "'+path_junctionReferenceTo+'")');}for(let i=0;i<obj_junctionReferenceTo.length;i++){const obj_junctionReferenceTo_item=obj_junctionReferenceTo[i];const path_junctionReferenceTo_item=path_junctionReferenceTo+'['+i+']';if(typeof obj_junctionReferenceTo_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_junctionReferenceTo_item+'" (at "'+path_junctionReferenceTo_item+'")');}}const obj_relationshipName=obj.relationshipName;const path_relationshipName=path+'.relationshipName';if(typeof obj_relationshipName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relationshipName+'" (at "'+path_relationshipName+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$9$1(input){const input_junctionIdListNames=input.junctionIdListNames;ObjectFreeze$5(input_junctionIdListNames);const input_junctionReferenceTo=input.junctionReferenceTo;ObjectFreeze$5(input_junctionReferenceTo);ObjectFreeze$5(input);}function validate$m(obj,path='FilteredLookupInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_controllingFields=obj.controllingFields;const path_controllingFields=path+'.controllingFields';if(!ArrayIsArray$6(obj_controllingFields)){return new TypeError('Expected "array" but received "'+typeof obj_controllingFields+'" (at "'+path_controllingFields+'")');}for(let i=0;i<obj_controllingFields.length;i++){const obj_controllingFields_item=obj_controllingFields[i];const path_controllingFields_item=path_controllingFields+'['+i+']';if(typeof obj_controllingFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_controllingFields_item+'" (at "'+path_controllingFields_item+'")');}}const obj_dependent=obj.dependent;const path_dependent=path+'.dependent';if(typeof obj_dependent!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_dependent+'" (at "'+path_dependent+'")');}const obj_optionalFilter=obj.optionalFilter;const path_optionalFilter=path+'.optionalFilter';if(typeof obj_optionalFilter!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_optionalFilter+'" (at "'+path_optionalFilter+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$a(input){const input_controllingFields=input.controllingFields;ObjectFreeze$5(input_controllingFields);ObjectFreeze$5(input);}function validate$n(obj,path='ReferenceToInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_nameFields=obj.nameFields;const path_nameFields=path+'.nameFields';if(!ArrayIsArray$6(obj_nameFields)){return new TypeError('Expected "array" but received "'+typeof obj_nameFields+'" (at "'+path_nameFields+'")');}for(let i=0;i<obj_nameFields.length;i++){const obj_nameFields_item=obj_nameFields[i];const path_nameFields_item=path_nameFields+'['+i+']';if(typeof obj_nameFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nameFields_item+'" (at "'+path_nameFields_item+'")');}}})();return v_error===undefined?null:v_error;}function deepFreeze$b(input){const input_nameFields=input.nameFields;ObjectFreeze$5(input_nameFields);ObjectFreeze$5(input);}function validate$o(obj,path='FieldRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_calculated=obj.calculated;const path_calculated=path+'.calculated';if(typeof obj_calculated!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_calculated+'" (at "'+path_calculated+'")');}const obj_compound=obj.compound;const path_compound=path+'.compound';if(typeof obj_compound!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_compound+'" (at "'+path_compound+'")');}const obj_compoundComponentName=obj.compoundComponentName;const path_compoundComponentName=path+'.compoundComponentName';let obj_compoundComponentName_union0=null;const obj_compoundComponentName_union0_error=(()=>{if(typeof obj_compoundComponentName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_compoundComponentName+'" (at "'+path_compoundComponentName+'")');}})();if(obj_compoundComponentName_union0_error!=null){obj_compoundComponentName_union0=obj_compoundComponentName_union0_error.message;}let obj_compoundComponentName_union1=null;const obj_compoundComponentName_union1_error=(()=>{if(obj_compoundComponentName!==null){return new TypeError('Expected "null" but received "'+typeof obj_compoundComponentName+'" (at "'+path_compoundComponentName+'")');}})();if(obj_compoundComponentName_union1_error!=null){obj_compoundComponentName_union1=obj_compoundComponentName_union1_error.message;}if(obj_compoundComponentName_union0&&obj_compoundComponentName_union1){let message='Object doesn\'t match union (at "'+path_compoundComponentName+'")';message+='\n'+obj_compoundComponentName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_compoundComponentName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_compoundFieldName=obj.compoundFieldName;const path_compoundFieldName=path+'.compoundFieldName';let obj_compoundFieldName_union0=null;const obj_compoundFieldName_union0_error=(()=>{if(typeof obj_compoundFieldName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_compoundFieldName+'" (at "'+path_compoundFieldName+'")');}})();if(obj_compoundFieldName_union0_error!=null){obj_compoundFieldName_union0=obj_compoundFieldName_union0_error.message;}let obj_compoundFieldName_union1=null;const obj_compoundFieldName_union1_error=(()=>{if(obj_compoundFieldName!==null){return new TypeError('Expected "null" but received "'+typeof obj_compoundFieldName+'" (at "'+path_compoundFieldName+'")');}})();if(obj_compoundFieldName_union1_error!=null){obj_compoundFieldName_union1=obj_compoundFieldName_union1_error.message;}if(obj_compoundFieldName_union0&&obj_compoundFieldName_union1){let message='Object doesn\'t match union (at "'+path_compoundFieldName+'")';message+='\n'+obj_compoundFieldName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_compoundFieldName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_controllerName=obj.controllerName;const path_controllerName=path+'.controllerName';let obj_controllerName_union0=null;const obj_controllerName_union0_error=(()=>{if(typeof obj_controllerName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_controllerName+'" (at "'+path_controllerName+'")');}})();if(obj_controllerName_union0_error!=null){obj_controllerName_union0=obj_controllerName_union0_error.message;}let obj_controllerName_union1=null;const obj_controllerName_union1_error=(()=>{if(obj_controllerName!==null){return new TypeError('Expected "null" but received "'+typeof obj_controllerName+'" (at "'+path_controllerName+'")');}})();if(obj_controllerName_union1_error!=null){obj_controllerName_union1=obj_controllerName_union1_error.message;}if(obj_controllerName_union0&&obj_controllerName_union1){let message='Object doesn\'t match union (at "'+path_controllerName+'")';message+='\n'+obj_controllerName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_controllerName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_controllingFields=obj.controllingFields;const path_controllingFields=path+'.controllingFields';if(!ArrayIsArray$6(obj_controllingFields)){return new TypeError('Expected "array" but received "'+typeof obj_controllingFields+'" (at "'+path_controllingFields+'")');}for(let i=0;i<obj_controllingFields.length;i++){const obj_controllingFields_item=obj_controllingFields[i];const path_controllingFields_item=path_controllingFields+'['+i+']';if(typeof obj_controllingFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_controllingFields_item+'" (at "'+path_controllingFields_item+'")');}}const obj_createable=obj.createable;const path_createable=path+'.createable';if(typeof obj_createable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_createable+'" (at "'+path_createable+'")');}const obj_custom=obj.custom;const path_custom=path+'.custom';if(typeof obj_custom!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_custom+'" (at "'+path_custom+'")');}const obj_dataType=obj.dataType;const path_dataType=path+'.dataType';if(typeof obj_dataType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_dataType+'" (at "'+path_dataType+'")');}const obj_extraTypeInfo=obj.extraTypeInfo;const path_extraTypeInfo=path+'.extraTypeInfo';let obj_extraTypeInfo_union0=null;const obj_extraTypeInfo_union0_error=(()=>{if(typeof obj_extraTypeInfo!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_extraTypeInfo+'" (at "'+path_extraTypeInfo+'")');}})();if(obj_extraTypeInfo_union0_error!=null){obj_extraTypeInfo_union0=obj_extraTypeInfo_union0_error.message;}let obj_extraTypeInfo_union1=null;const obj_extraTypeInfo_union1_error=(()=>{if(obj_extraTypeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_extraTypeInfo+'" (at "'+path_extraTypeInfo+'")');}})();if(obj_extraTypeInfo_union1_error!=null){obj_extraTypeInfo_union1=obj_extraTypeInfo_union1_error.message;}if(obj_extraTypeInfo_union0&&obj_extraTypeInfo_union1){let message='Object doesn\'t match union (at "'+path_extraTypeInfo+'")';message+='\n'+obj_extraTypeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_extraTypeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_filterable=obj.filterable;const path_filterable=path+'.filterable';if(typeof obj_filterable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_filterable+'" (at "'+path_filterable+'")');}const obj_filteredLookupInfo=obj.filteredLookupInfo;const path_filteredLookupInfo=path+'.filteredLookupInfo';let obj_filteredLookupInfo_union0=null;const obj_filteredLookupInfo_union0_error=(()=>{const referenceFilteredLookupInfoRepresentationValidationError=validate$m(obj_filteredLookupInfo,path_filteredLookupInfo);if(referenceFilteredLookupInfoRepresentationValidationError!==null){let message='Object doesn\'t match FilteredLookupInfoRepresentation (at "'+path_filteredLookupInfo+'")\n';message+=referenceFilteredLookupInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_filteredLookupInfo_union0_error!=null){obj_filteredLookupInfo_union0=obj_filteredLookupInfo_union0_error.message;}let obj_filteredLookupInfo_union1=null;const obj_filteredLookupInfo_union1_error=(()=>{if(obj_filteredLookupInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_filteredLookupInfo+'" (at "'+path_filteredLookupInfo+'")');}})();if(obj_filteredLookupInfo_union1_error!=null){obj_filteredLookupInfo_union1=obj_filteredLookupInfo_union1_error.message;}if(obj_filteredLookupInfo_union0&&obj_filteredLookupInfo_union1){let message='Object doesn\'t match union (at "'+path_filteredLookupInfo+'")';message+='\n'+obj_filteredLookupInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_filteredLookupInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_highScaleNumber=obj.highScaleNumber;const path_highScaleNumber=path+'.highScaleNumber';if(typeof obj_highScaleNumber!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_highScaleNumber+'" (at "'+path_highScaleNumber+'")');}const obj_htmlFormatted=obj.htmlFormatted;const path_htmlFormatted=path+'.htmlFormatted';if(typeof obj_htmlFormatted!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_htmlFormatted+'" (at "'+path_htmlFormatted+'")');}const obj_inlineHelpText=obj.inlineHelpText;const path_inlineHelpText=path+'.inlineHelpText';let obj_inlineHelpText_union0=null;const obj_inlineHelpText_union0_error=(()=>{if(typeof obj_inlineHelpText!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_inlineHelpText+'" (at "'+path_inlineHelpText+'")');}})();if(obj_inlineHelpText_union0_error!=null){obj_inlineHelpText_union0=obj_inlineHelpText_union0_error.message;}let obj_inlineHelpText_union1=null;const obj_inlineHelpText_union1_error=(()=>{if(obj_inlineHelpText!==null){return new TypeError('Expected "null" but received "'+typeof obj_inlineHelpText+'" (at "'+path_inlineHelpText+'")');}})();if(obj_inlineHelpText_union1_error!=null){obj_inlineHelpText_union1=obj_inlineHelpText_union1_error.message;}if(obj_inlineHelpText_union0&&obj_inlineHelpText_union1){let message='Object doesn\'t match union (at "'+path_inlineHelpText+'")';message+='\n'+obj_inlineHelpText_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_inlineHelpText_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_length=obj.length;const path_length=path+'.length';if(typeof obj_length!=='number'||typeof obj_length==='number'&&Math.floor(obj_length)!==obj_length){return new TypeError('Expected "integer" but received "'+typeof obj_length+'" (at "'+path_length+'")');}const obj_nameField=obj.nameField;const path_nameField=path+'.nameField';if(typeof obj_nameField!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_nameField+'" (at "'+path_nameField+'")');}const obj_polymorphicForeignKey=obj.polymorphicForeignKey;const path_polymorphicForeignKey=path+'.polymorphicForeignKey';if(typeof obj_polymorphicForeignKey!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_polymorphicForeignKey+'" (at "'+path_polymorphicForeignKey+'")');}const obj_precision=obj.precision;const path_precision=path+'.precision';if(typeof obj_precision!=='number'||typeof obj_precision==='number'&&Math.floor(obj_precision)!==obj_precision){return new TypeError('Expected "integer" but received "'+typeof obj_precision+'" (at "'+path_precision+'")');}const obj_reference=obj.reference;const path_reference=path+'.reference';if(typeof obj_reference!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_reference+'" (at "'+path_reference+'")');}const obj_referenceTargetField=obj.referenceTargetField;const path_referenceTargetField=path+'.referenceTargetField';let obj_referenceTargetField_union0=null;const obj_referenceTargetField_union0_error=(()=>{if(typeof obj_referenceTargetField!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_referenceTargetField+'" (at "'+path_referenceTargetField+'")');}})();if(obj_referenceTargetField_union0_error!=null){obj_referenceTargetField_union0=obj_referenceTargetField_union0_error.message;}let obj_referenceTargetField_union1=null;const obj_referenceTargetField_union1_error=(()=>{if(obj_referenceTargetField!==null){return new TypeError('Expected "null" but received "'+typeof obj_referenceTargetField+'" (at "'+path_referenceTargetField+'")');}})();if(obj_referenceTargetField_union1_error!=null){obj_referenceTargetField_union1=obj_referenceTargetField_union1_error.message;}if(obj_referenceTargetField_union0&&obj_referenceTargetField_union1){let message='Object doesn\'t match union (at "'+path_referenceTargetField+'")';message+='\n'+obj_referenceTargetField_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_referenceTargetField_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_referenceToInfos=obj.referenceToInfos;const path_referenceToInfos=path+'.referenceToInfos';if(!ArrayIsArray$6(obj_referenceToInfos)){return new TypeError('Expected "array" but received "'+typeof obj_referenceToInfos+'" (at "'+path_referenceToInfos+'")');}for(let i=0;i<obj_referenceToInfos.length;i++){const obj_referenceToInfos_item=obj_referenceToInfos[i];const path_referenceToInfos_item=path_referenceToInfos+'['+i+']';const referenceReferenceToInfoRepresentationValidationError=validate$n(obj_referenceToInfos_item,path_referenceToInfos_item);if(referenceReferenceToInfoRepresentationValidationError!==null){let message='Object doesn\'t match ReferenceToInfoRepresentation (at "'+path_referenceToInfos_item+'")\n';message+=referenceReferenceToInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_relationshipName=obj.relationshipName;const path_relationshipName=path+'.relationshipName';let obj_relationshipName_union0=null;const obj_relationshipName_union0_error=(()=>{if(typeof obj_relationshipName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relationshipName+'" (at "'+path_relationshipName+'")');}})();if(obj_relationshipName_union0_error!=null){obj_relationshipName_union0=obj_relationshipName_union0_error.message;}let obj_relationshipName_union1=null;const obj_relationshipName_union1_error=(()=>{if(obj_relationshipName!==null){return new TypeError('Expected "null" but received "'+typeof obj_relationshipName+'" (at "'+path_relationshipName+'")');}})();if(obj_relationshipName_union1_error!=null){obj_relationshipName_union1=obj_relationshipName_union1_error.message;}if(obj_relationshipName_union0&&obj_relationshipName_union1){let message='Object doesn\'t match union (at "'+path_relationshipName+'")';message+='\n'+obj_relationshipName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_relationshipName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_required=obj.required;const path_required=path+'.required';if(typeof obj_required!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_required+'" (at "'+path_required+'")');}const obj_scale=obj.scale;const path_scale=path+'.scale';if(typeof obj_scale!=='number'||typeof obj_scale==='number'&&Math.floor(obj_scale)!==obj_scale){return new TypeError('Expected "integer" but received "'+typeof obj_scale+'" (at "'+path_scale+'")');}const obj_searchPrefilterable=obj.searchPrefilterable;const path_searchPrefilterable=path+'.searchPrefilterable';if(typeof obj_searchPrefilterable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_searchPrefilterable+'" (at "'+path_searchPrefilterable+'")');}const obj_sortable=obj.sortable;const path_sortable=path+'.sortable';if(typeof obj_sortable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_sortable+'" (at "'+path_sortable+'")');}const obj_unique=obj.unique;const path_unique=path+'.unique';if(typeof obj_unique!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_unique+'" (at "'+path_unique+'")');}const obj_updateable=obj.updateable;const path_updateable=path+'.updateable';if(typeof obj_updateable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_updateable+'" (at "'+path_updateable+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$c(input){const input_controllingFields=input.controllingFields;ObjectFreeze$5(input_controllingFields);const input_filteredLookupInfo=input.filteredLookupInfo;if(input_filteredLookupInfo!==null&&typeof input_filteredLookupInfo==='object'){deepFreeze$a(input_filteredLookupInfo);}const input_referenceToInfos=input.referenceToInfos;for(let i=0;i<input_referenceToInfos.length;i++){const input_referenceToInfos_item=input_referenceToInfos[i];deepFreeze$b(input_referenceToInfos_item);}ObjectFreeze$5(input_referenceToInfos);ObjectFreeze$5(input);}function validate$p(obj,path='ThemeInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_color=obj.color;const path_color=path+'.color';if(typeof obj_color!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_color+'" (at "'+path_color+'")');}const obj_iconUrl=obj.iconUrl;const path_iconUrl=path+'.iconUrl';let obj_iconUrl_union0=null;const obj_iconUrl_union0_error=(()=>{if(typeof obj_iconUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union0_error!=null){obj_iconUrl_union0=obj_iconUrl_union0_error.message;}let obj_iconUrl_union1=null;const obj_iconUrl_union1_error=(()=>{if(obj_iconUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union1_error!=null){obj_iconUrl_union1=obj_iconUrl_union1_error.message;}if(obj_iconUrl_union0&&obj_iconUrl_union1){let message='Object doesn\'t match union (at "'+path_iconUrl+'")';message+='\n'+obj_iconUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_iconUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function deepFreeze$d(input){ObjectFreeze$5(input);}const TTL$1=900000;function validate$q(obj,path='ObjectInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_childRelationships=obj.childRelationships;const path_childRelationships=path+'.childRelationships';if(!ArrayIsArray$6(obj_childRelationships)){return new TypeError('Expected "array" but received "'+typeof obj_childRelationships+'" (at "'+path_childRelationships+'")');}for(let i=0;i<obj_childRelationships.length;i++){const obj_childRelationships_item=obj_childRelationships[i];const path_childRelationships_item=path_childRelationships+'['+i+']';const referenceChildRelationshipRepresentationValidationError=validate$l(obj_childRelationships_item,path_childRelationships_item);if(referenceChildRelationshipRepresentationValidationError!==null){let message='Object doesn\'t match ChildRelationshipRepresentation (at "'+path_childRelationships_item+'")\n';message+=referenceChildRelationshipRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_createable=obj.createable;const path_createable=path+'.createable';if(typeof obj_createable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_createable+'" (at "'+path_createable+'")');}const obj_custom=obj.custom;const path_custom=path+'.custom';if(typeof obj_custom!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_custom+'" (at "'+path_custom+'")');}const obj_defaultRecordTypeId=obj.defaultRecordTypeId;const path_defaultRecordTypeId=path+'.defaultRecordTypeId';let obj_defaultRecordTypeId_union0=null;const obj_defaultRecordTypeId_union0_error=(()=>{if(typeof obj_defaultRecordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_defaultRecordTypeId+'" (at "'+path_defaultRecordTypeId+'")');}})();if(obj_defaultRecordTypeId_union0_error!=null){obj_defaultRecordTypeId_union0=obj_defaultRecordTypeId_union0_error.message;}let obj_defaultRecordTypeId_union1=null;const obj_defaultRecordTypeId_union1_error=(()=>{if(obj_defaultRecordTypeId!==null){return new TypeError('Expected "null" but received "'+typeof obj_defaultRecordTypeId+'" (at "'+path_defaultRecordTypeId+'")');}})();if(obj_defaultRecordTypeId_union1_error!=null){obj_defaultRecordTypeId_union1=obj_defaultRecordTypeId_union1_error.message;}if(obj_defaultRecordTypeId_union0&&obj_defaultRecordTypeId_union1){let message='Object doesn\'t match union (at "'+path_defaultRecordTypeId+'")';message+='\n'+obj_defaultRecordTypeId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_defaultRecordTypeId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_deletable=obj.deletable;const path_deletable=path+'.deletable';if(typeof obj_deletable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_deletable+'" (at "'+path_deletable+'")');}const obj_dependentFields=obj.dependentFields;const path_dependentFields=path+'.dependentFields';if(typeof obj_dependentFields!=='object'||ArrayIsArray$6(obj_dependentFields)||obj_dependentFields===null){return new TypeError('Expected "object" but received "'+typeof obj_dependentFields+'" (at "'+path_dependentFields+'")');}const obj_dependentFields_keys=ObjectKeys$5(obj_dependentFields);for(let i=0;i<obj_dependentFields_keys.length;i++){const key=obj_dependentFields_keys[i];const obj_dependentFields_prop=obj_dependentFields[key];const path_dependentFields_prop=path_dependentFields+'["'+key+'"]';if(typeof obj_dependentFields_prop!=='object'||ArrayIsArray$6(obj_dependentFields_prop)||obj_dependentFields_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_dependentFields_prop+'" (at "'+path_dependentFields_prop+'")');}}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_feedEnabled=obj.feedEnabled;const path_feedEnabled=path+'.feedEnabled';if(typeof obj_feedEnabled!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_feedEnabled+'" (at "'+path_feedEnabled+'")');}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$6(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$5(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];const path_fields_prop=path_fields+'["'+key+'"]';const referenceFieldRepresentationValidationError=validate$o(obj_fields_prop,path_fields_prop);if(referenceFieldRepresentationValidationError!==null){let message='Object doesn\'t match FieldRepresentation (at "'+path_fields_prop+'")\n';message+=referenceFieldRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_keyPrefix=obj.keyPrefix;const path_keyPrefix=path+'.keyPrefix';let obj_keyPrefix_union0=null;const obj_keyPrefix_union0_error=(()=>{if(typeof obj_keyPrefix!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_keyPrefix+'" (at "'+path_keyPrefix+'")');}})();if(obj_keyPrefix_union0_error!=null){obj_keyPrefix_union0=obj_keyPrefix_union0_error.message;}let obj_keyPrefix_union1=null;const obj_keyPrefix_union1_error=(()=>{if(obj_keyPrefix!==null){return new TypeError('Expected "null" but received "'+typeof obj_keyPrefix+'" (at "'+path_keyPrefix+'")');}})();if(obj_keyPrefix_union1_error!=null){obj_keyPrefix_union1=obj_keyPrefix_union1_error.message;}if(obj_keyPrefix_union0&&obj_keyPrefix_union1){let message='Object doesn\'t match union (at "'+path_keyPrefix+'")';message+='\n'+obj_keyPrefix_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_keyPrefix_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_labelPlural=obj.labelPlural;const path_labelPlural=path+'.labelPlural';if(typeof obj_labelPlural!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_labelPlural+'" (at "'+path_labelPlural+'")');}const obj_layoutable=obj.layoutable;const path_layoutable=path+'.layoutable';if(typeof obj_layoutable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_layoutable+'" (at "'+path_layoutable+'")');}const obj_mruEnabled=obj.mruEnabled;const path_mruEnabled=path+'.mruEnabled';if(typeof obj_mruEnabled!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_mruEnabled+'" (at "'+path_mruEnabled+'")');}const obj_nameFields=obj.nameFields;const path_nameFields=path+'.nameFields';if(!ArrayIsArray$6(obj_nameFields)){return new TypeError('Expected "array" but received "'+typeof obj_nameFields+'" (at "'+path_nameFields+'")');}for(let i=0;i<obj_nameFields.length;i++){const obj_nameFields_item=obj_nameFields[i];const path_nameFields_item=path_nameFields+'['+i+']';if(typeof obj_nameFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nameFields_item+'" (at "'+path_nameFields_item+'")');}}const obj_queryable=obj.queryable;const path_queryable=path+'.queryable';if(typeof obj_queryable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_queryable+'" (at "'+path_queryable+'")');}const obj_recordTypeInfos=obj.recordTypeInfos;const path_recordTypeInfos=path+'.recordTypeInfos';if(typeof obj_recordTypeInfos!=='object'||ArrayIsArray$6(obj_recordTypeInfos)||obj_recordTypeInfos===null){return new TypeError('Expected "object" but received "'+typeof obj_recordTypeInfos+'" (at "'+path_recordTypeInfos+'")');}const obj_recordTypeInfos_keys=ObjectKeys$5(obj_recordTypeInfos);for(let i=0;i<obj_recordTypeInfos_keys.length;i++){const key=obj_recordTypeInfos_keys[i];const obj_recordTypeInfos_prop=obj_recordTypeInfos[key];const path_recordTypeInfos_prop=path_recordTypeInfos+'["'+key+'"]';const referenceRecordTypeInfoRepresentationValidationError=validate$9(obj_recordTypeInfos_prop,path_recordTypeInfos_prop);if(referenceRecordTypeInfoRepresentationValidationError!==null){let message='Object doesn\'t match RecordTypeInfoRepresentation (at "'+path_recordTypeInfos_prop+'")\n';message+=referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_searchable=obj.searchable;const path_searchable=path+'.searchable';if(typeof obj_searchable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_searchable+'" (at "'+path_searchable+'")');}const obj_themeInfo=obj.themeInfo;const path_themeInfo=path+'.themeInfo';let obj_themeInfo_union0=null;const obj_themeInfo_union0_error=(()=>{const referenceThemeInfoRepresentationValidationError=validate$p(obj_themeInfo,path_themeInfo);if(referenceThemeInfoRepresentationValidationError!==null){let message='Object doesn\'t match ThemeInfoRepresentation (at "'+path_themeInfo+'")\n';message+=referenceThemeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_themeInfo_union0_error!=null){obj_themeInfo_union0=obj_themeInfo_union0_error.message;}let obj_themeInfo_union1=null;const obj_themeInfo_union1_error=(()=>{if(obj_themeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_themeInfo+'" (at "'+path_themeInfo+'")');}})();if(obj_themeInfo_union1_error!=null){obj_themeInfo_union1=obj_themeInfo_union1_error.message;}if(obj_themeInfo_union0&&obj_themeInfo_union1){let message='Object doesn\'t match union (at "'+path_themeInfo+'")';message+='\n'+obj_themeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_themeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_updateable=obj.updateable;const path_updateable=path+'.updateable';if(typeof obj_updateable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_updateable+'" (at "'+path_updateable+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$8(config){return keyPrefix$4+'ObjectInfoRepresentation:'+config.apiName;}function normalize$a(input,existing,path,lds,store,timestamp){return input;}const select$9=function ObjectInfoRepresentationSelect(){return {kind:'Fragment',selections:[{name:'apiName',kind:'Scalar'},{name:'childRelationships',kind:'Object',opaque:true},{name:'createable',kind:'Scalar'},{name:'custom',kind:'Scalar'},{name:'defaultRecordTypeId',kind:'Scalar'},{name:'deletable',kind:'Scalar'},{name:'dependentFields',kind:'Object',opaque:true},{name:'feedEnabled',kind:'Scalar'},{name:'fields',kind:'Object',opaque:true},{name:'keyPrefix',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'labelPlural',kind:'Scalar'},{name:'layoutable',kind:'Scalar'},{name:'mruEnabled',kind:'Scalar'},{name:'nameFields',kind:'Object',opaque:true},{name:'queryable',kind:'Scalar'},{name:'recordTypeInfos',kind:'Object',opaque:true},{name:'searchable',kind:'Scalar'},{name:'themeInfo',kind:'Object',opaque:true},{name:'updateable',kind:'Scalar'}]};};function equals$c(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}function deepFreeze$e(input){const input_childRelationships=input.childRelationships;for(let i=0;i<input_childRelationships.length;i++){const input_childRelationships_item=input_childRelationships[i];deepFreeze$9$1(input_childRelationships_item);}ObjectFreeze$5(input_childRelationships);const input_dependentFields=input.dependentFields;const input_dependentFields_keys=Object.keys(input_dependentFields);const input_dependentFields_length=input_dependentFields_keys.length;for(let i=0;i<input_dependentFields_length;i++){const key=input_dependentFields_keys[i];const input_dependentFields_prop=input_dependentFields[key];ObjectFreeze$5(input_dependentFields_prop);}ObjectFreeze$5(input_dependentFields);const input_fields=input.fields;const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];const input_fields_prop=input_fields[key];deepFreeze$c(input_fields_prop);}ObjectFreeze$5(input_fields);const input_nameFields=input.nameFields;ObjectFreeze$5(input_nameFields);const input_recordTypeInfos=input.recordTypeInfos;const input_recordTypeInfos_keys=Object.keys(input_recordTypeInfos);const input_recordTypeInfos_length=input_recordTypeInfos_keys.length;for(let i=0;i<input_recordTypeInfos_length;i++){const key=input_recordTypeInfos_keys[i];const input_recordTypeInfos_prop=input_recordTypeInfos[key];deepFreeze$1$5(input_recordTypeInfos_prop);}ObjectFreeze$5(input_recordTypeInfos);const input_themeInfo=input.themeInfo;if(input_themeInfo!==null&&typeof input_themeInfo==='object'){deepFreeze$d(input_themeInfo);}ObjectFreeze$5(input);}const ingest$a=function ObjectInfoRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$q(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$8({apiName:input.apiName});let incomingRecord=normalize$a(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$e(input);if(existingRecord===undefined||equals$c(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return createLink$5(key);};function getUiApiObjectInfoByObjectApiName(config){const key=keyBuilder$8({apiName:config.urlParams.objectApiName});const headers={};return {path:'/services/data/v49.0/ui-api/object-info/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$a,headers};}const getObjectInfo_ConfigPropertyNames={displayName:'getObjectInfo',parameters:{required:['objectApiName'],optional:[]}};function coerceConfig$8(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}return coercedConfig;}function typeCheckConfig$8(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}return config;}function validateAdapterConfig$8(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$8(untrustedConfig);const config=typeCheckConfig$8(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$6(lds,config){const request=getUiApiObjectInfoByObjectApiName({urlParams:{objectApiName:config.objectApiName}});const selector={recordId:request.key,node:select$9(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$5$1(lds,config,override){const request=getUiApiObjectInfoByObjectApiName({urlParams:{objectApiName:config.objectApiName}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$6(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error,TTL$1);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getObjectInfoAdapterFactory=lds=>{return refreshable$5(// Create snapshot either via a cache hit or via the network
    function getObjectInfo(untrustedConfig){const config=validateAdapterConfig$8(untrustedConfig,getObjectInfo_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$6(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$4){return cacheSnapshot;}return buildNetworkSnapshot$5$1(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$8(untrustedConfig,getObjectInfo_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getObjectInfo" refresh function');}return buildNetworkSnapshot$5$1(lds,config,{headers:{'Cache-Control':'no-cache'}});});};const FIELD_ID='Id';const FIELD_NAME='Name';const COMPONENT_TYPE_FIELD='Field';function isFieldAReferenceWithRelationshipName(objectInfo,fieldApiName){const field=objectInfo.fields[fieldApiName];if(field===undefined){return false;}// TODO - can reference===true and relationshipName===null?
    return field.reference===true&&field.relationshipName!==null;}function getRelationshipName(objectInfo,fieldApiName){// TODO RAML - fix typing so isFieldAReferenceWithRelationshipName enables calling this without `relationshipName!`
    return objectInfo.fields[fieldApiName].relationshipName;}function getNameField(objectInfo,fieldApiName){// TODO - this logic is adopted from lds222. It searches
    // ObjectInfoRep.ReferenceToInfoRep[].nameFields[]:
    // 1. If any of the arrays are empty returns `Name`
    // 2. If `Name` is found in any array position then returns it
    // 2. Else returns ObjectInfoRep.ReferenceToInfoRep[0].nameFields[0]
    // Rationale for this is unclear and needs clarification.
    const referenceToInfos=objectInfo.fields[fieldApiName].referenceToInfos;if(referenceToInfos.length<1){return FIELD_NAME;}const firstReferenceNameFields=referenceToInfos[0].nameFields;if(firstReferenceNameFields.length<1){return FIELD_NAME;}for(let a=0,alen=referenceToInfos.length;a<alen;a++){const nameFields=referenceToInfos[a].nameFields;for(let b=0,blen=nameFields.length;b<blen;b++){const nameField=nameFields[b];if(nameField===FIELD_NAME){return nameField;}}}return firstReferenceNameFields[0];}function getQualifiedFieldApiNamesFromLayout(layout,objectInfo){const qualifiedFieldNames=[];for(let a=0,alen=layout.sections.length;a<alen;a++){const section=layout.sections[a];for(let b=0,blen=section.layoutRows.length;b<blen;b++){const row=section.layoutRows[b];for(let c=0,clen=row.layoutItems.length;c<clen;c++){const item=row.layoutItems[c];for(let d=0,dlen=item.layoutComponents.length;d<dlen;d++){const component=item.layoutComponents[d];const{apiName}=component;if(apiName&&component.componentType===COMPONENT_TYPE_FIELD){if(isFieldAReferenceWithRelationshipName(objectInfo,apiName)){const relationshipFieldApiName=getRelationshipName(objectInfo,apiName);// By default, include the "Id" field on spanning records that are on the layout.
    qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${FIELD_ID}`);const nameField=getNameField(objectInfo,apiName);qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${nameField}`);}qualifiedFieldNames.push(`${objectInfo.apiName}.${component.apiName}`);}}}}}return qualifiedFieldNames;}/**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */function getRecordId18Array(value){const valueArray=isArray$3(value)?value:[value];const array=[];for(let i=0,len=valueArray.length;i<len;i+=1){const item=valueArray[i];const apiName=getRecordId18(item);if(apiName===undefined){return undefined;}push$1.call(array,apiName);}if(array.length===0){return undefined;}return dedupe(array).sort();}const TTL$2=900000;function validate$r(obj,path='RecordUiRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_layoutUserStates=obj.layoutUserStates;const path_layoutUserStates=path+'.layoutUserStates';if(typeof obj_layoutUserStates!=='object'||ArrayIsArray$6(obj_layoutUserStates)||obj_layoutUserStates===null){return new TypeError('Expected "object" but received "'+typeof obj_layoutUserStates+'" (at "'+path_layoutUserStates+'")');}const obj_layoutUserStates_keys=ObjectKeys$5(obj_layoutUserStates);for(let i=0;i<obj_layoutUserStates_keys.length;i++){const key=obj_layoutUserStates_keys[i];const obj_layoutUserStates_prop=obj_layoutUserStates[key];const path_layoutUserStates_prop=path_layoutUserStates+'["'+key+'"]';if(typeof obj_layoutUserStates_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_layoutUserStates_prop+'" (at "'+path_layoutUserStates_prop+'")');}}const obj_layouts=obj.layouts;const path_layouts=path+'.layouts';if(typeof obj_layouts!=='object'||ArrayIsArray$6(obj_layouts)||obj_layouts===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts+'" (at "'+path_layouts+'")');}const obj_layouts_keys=ObjectKeys$5(obj_layouts);for(let i=0;i<obj_layouts_keys.length;i++){const key=obj_layouts_keys[i];const obj_layouts_prop=obj_layouts[key];const path_layouts_prop=path_layouts+'["'+key+'"]';if(typeof obj_layouts_prop!=='object'||ArrayIsArray$6(obj_layouts_prop)||obj_layouts_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts_prop+'" (at "'+path_layouts_prop+'")');}const obj_layouts_prop_keys=ObjectKeys$5(obj_layouts_prop);for(let i=0;i<obj_layouts_prop_keys.length;i++){const key=obj_layouts_prop_keys[i];const obj_layouts_prop_prop=obj_layouts_prop[key];const path_layouts_prop_prop=path_layouts_prop+'["'+key+'"]';if(typeof obj_layouts_prop_prop!=='object'||ArrayIsArray$6(obj_layouts_prop_prop)||obj_layouts_prop_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts_prop_prop+'" (at "'+path_layouts_prop_prop+'")');}const obj_layouts_prop_prop_keys=ObjectKeys$5(obj_layouts_prop_prop);for(let i=0;i<obj_layouts_prop_prop_keys.length;i++){const key=obj_layouts_prop_prop_keys[i];const obj_layouts_prop_prop_prop=obj_layouts_prop_prop[key];const path_layouts_prop_prop_prop=path_layouts_prop_prop+'["'+key+'"]';if(typeof obj_layouts_prop_prop_prop!=='object'||ArrayIsArray$6(obj_layouts_prop_prop_prop)||obj_layouts_prop_prop_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts_prop_prop_prop+'" (at "'+path_layouts_prop_prop_prop+'")');}const obj_layouts_prop_prop_prop_keys=ObjectKeys$5(obj_layouts_prop_prop_prop);for(let i=0;i<obj_layouts_prop_prop_prop_keys.length;i++){const key=obj_layouts_prop_prop_prop_keys[i];const obj_layouts_prop_prop_prop_prop=obj_layouts_prop_prop_prop[key];const path_layouts_prop_prop_prop_prop=path_layouts_prop_prop_prop+'["'+key+'"]';if(typeof obj_layouts_prop_prop_prop_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_layouts_prop_prop_prop_prop+'" (at "'+path_layouts_prop_prop_prop_prop+'")');}}}}}const obj_objectInfos=obj.objectInfos;const path_objectInfos=path+'.objectInfos';if(typeof obj_objectInfos!=='object'||ArrayIsArray$6(obj_objectInfos)||obj_objectInfos===null){return new TypeError('Expected "object" but received "'+typeof obj_objectInfos+'" (at "'+path_objectInfos+'")');}const obj_objectInfos_keys=ObjectKeys$5(obj_objectInfos);for(let i=0;i<obj_objectInfos_keys.length;i++){const key=obj_objectInfos_keys[i];const obj_objectInfos_prop=obj_objectInfos[key];const path_objectInfos_prop=path_objectInfos+'["'+key+'"]';if(typeof obj_objectInfos_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_objectInfos_prop+'" (at "'+path_objectInfos_prop+'")');}}const obj_records=obj.records;const path_records=path+'.records';if(typeof obj_records!=='object'||ArrayIsArray$6(obj_records)||obj_records===null){return new TypeError('Expected "object" but received "'+typeof obj_records+'" (at "'+path_records+'")');}const obj_records_keys=ObjectKeys$5(obj_records);for(let i=0;i<obj_records_keys.length;i++){const key=obj_records_keys[i];const obj_records_prop=obj_records[key];const path_records_prop=path_records+'["'+key+'"]';if(typeof obj_records_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_records_prop+'" (at "'+path_records_prop+'")');}}})();return v_error===undefined?null:v_error;}function normalize$b(input,existing,path,lds,store,timestamp){const input_layoutUserStates=input.layoutUserStates;const input_layoutUserStates_id=path.fullPath+'__layoutUserStates';const input_layoutUserStates_keys=Object.keys(input_layoutUserStates);const input_layoutUserStates_length=input_layoutUserStates_keys.length;for(let i=0;i<input_layoutUserStates_length;i++){const key=input_layoutUserStates_keys[i];const input_layoutUserStates_prop=input_layoutUserStates[key];const input_layoutUserStates_prop_id=input_layoutUserStates_id+'__'+key;input_layoutUserStates[key]=ingest$4$1(input_layoutUserStates_prop,{fullPath:input_layoutUserStates_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}const input_layouts=input.layouts;const input_layouts_id=path.fullPath+'__layouts';const input_layouts_keys=Object.keys(input_layouts);const input_layouts_length=input_layouts_keys.length;for(let i=0;i<input_layouts_length;i++){const key=input_layouts_keys[i];const input_layouts_prop=input_layouts[key];const input_layouts_prop_id=input_layouts_id+'__'+key;const input_layouts_prop_keys=Object.keys(input_layouts_prop);const input_layouts_prop_length=input_layouts_prop_keys.length;for(let i=0;i<input_layouts_prop_length;i++){const key=input_layouts_prop_keys[i];const input_layouts_prop_prop=input_layouts_prop[key];const input_layouts_prop_prop_id=input_layouts_prop_id+'__'+key;const input_layouts_prop_prop_keys=Object.keys(input_layouts_prop_prop);const input_layouts_prop_prop_length=input_layouts_prop_prop_keys.length;for(let i=0;i<input_layouts_prop_prop_length;i++){const key=input_layouts_prop_prop_keys[i];const input_layouts_prop_prop_prop=input_layouts_prop_prop[key];const input_layouts_prop_prop_prop_id=input_layouts_prop_prop_id+'__'+key;const input_layouts_prop_prop_prop_keys=Object.keys(input_layouts_prop_prop_prop);const input_layouts_prop_prop_prop_length=input_layouts_prop_prop_prop_keys.length;for(let i=0;i<input_layouts_prop_prop_prop_length;i++){const key=input_layouts_prop_prop_prop_keys[i];const input_layouts_prop_prop_prop_prop=input_layouts_prop_prop_prop[key];const input_layouts_prop_prop_prop_prop_id=input_layouts_prop_prop_prop_id+'__'+key;input_layouts_prop_prop_prop[key]=ingest$3$1(input_layouts_prop_prop_prop_prop,{fullPath:input_layouts_prop_prop_prop_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}}}}const input_objectInfos=input.objectInfos;const input_objectInfos_id=path.fullPath+'__objectInfos';const input_objectInfos_keys=Object.keys(input_objectInfos);const input_objectInfos_length=input_objectInfos_keys.length;for(let i=0;i<input_objectInfos_length;i++){const key=input_objectInfos_keys[i];const input_objectInfos_prop=input_objectInfos[key];const input_objectInfos_prop_id=input_objectInfos_id+'__'+key;input_objectInfos[key]=ingest$a(input_objectInfos_prop,{fullPath:input_objectInfos_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}const input_records=input.records;const input_records_id=path.fullPath+'__records';const input_records_keys=Object.keys(input_records);const input_records_length=input_records_keys.length;for(let i=0;i<input_records_length;i++){const key=input_records_keys[i];const input_records_prop=input_records[key];const input_records_prop_id=input_records_id+'__'+key;input_records[key]=ingest$2$1(input_records_prop,{fullPath:input_records_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}function equals$d(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_layoutUserStates=existing.layoutUserStates;const incoming_layoutUserStates=incoming.layoutUserStates;const equals_layoutUserStates_props=equalsObject(existing_layoutUserStates,incoming_layoutUserStates,(existing_layoutUserStates_prop,incoming_layoutUserStates_prop)=>{if(!(existing_layoutUserStates_prop.__ref===incoming_layoutUserStates_prop.__ref)){return false;}});if(equals_layoutUserStates_props===false){return false;}const existing_layouts=existing.layouts;const incoming_layouts=incoming.layouts;const equals_layouts_props=equalsObject(existing_layouts,incoming_layouts,(existing_layouts_prop,incoming_layouts_prop)=>{const equals_layouts_props=equalsObject(existing_layouts_prop,incoming_layouts_prop,(existing_layouts_prop_prop,incoming_layouts_prop_prop)=>{const equals_layouts_props=equalsObject(existing_layouts_prop_prop,incoming_layouts_prop_prop,(existing_layouts_prop_prop_prop,incoming_layouts_prop_prop_prop)=>{const equals_layouts_props=equalsObject(existing_layouts_prop_prop_prop,incoming_layouts_prop_prop_prop,(existing_layouts_prop_prop_prop_prop,incoming_layouts_prop_prop_prop_prop)=>{if(!(existing_layouts_prop_prop_prop_prop.__ref===incoming_layouts_prop_prop_prop_prop.__ref)){return false;}});if(equals_layouts_props===false){return false;}});if(equals_layouts_props===false){return false;}});if(equals_layouts_props===false){return false;}});if(equals_layouts_props===false){return false;}const existing_objectInfos=existing.objectInfos;const incoming_objectInfos=incoming.objectInfos;const equals_objectInfos_props=equalsObject(existing_objectInfos,incoming_objectInfos,(existing_objectInfos_prop,incoming_objectInfos_prop)=>{if(!(existing_objectInfos_prop.__ref===incoming_objectInfos_prop.__ref)){return false;}});if(equals_objectInfos_props===false){return false;}const existing_records=existing.records;const incoming_records=incoming.records;const equals_records_props=equalsObject(existing_records,incoming_records,(existing_records_prop,incoming_records_prop)=>{if(!(existing_records_prop.__ref===incoming_records_prop.__ref)){return false;}});if(equals_records_props===false){return false;}return true;}const ingest$b=function RecordUiRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$r(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$b(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$d(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return createLink$5(key);};function getUiApiRecordUiByRecordIds(config){const key=keyPrefix$4+'RecordUiRepresentation('+'childRelationships:'+config.queryParams.childRelationships+','+'formFactor:'+config.queryParams.formFactor+','+'layoutTypes:'+config.queryParams.layoutTypes+','+'modes:'+config.queryParams.modes+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'updateMru:'+config.queryParams.updateMru+','+'recordIds:'+config.urlParams.recordIds+')';const headers={};return {path:'/services/data/v49.0/ui-api/record-ui/'+config.urlParams.recordIds+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$b,headers};}function coerceConfig$9(config){const coercedConfig={};const recordIds=getRecordId18Array(config.recordIds);if(recordIds!==undefined){coercedConfig.recordIds=recordIds;}const childRelationships=config.childRelationships;if(childRelationships!==undefined){coercedConfig.childRelationships=childRelationships;}const formFactor=config.formFactor;if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const layoutTypes=toSortedStringArray(config.layoutTypes);if(layoutTypes!==undefined){coercedConfig.layoutTypes=layoutTypes;}const modes=toSortedStringArray(config.modes);if(modes!==undefined){coercedConfig.modes=modes;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const updateMru=config.updateMru;if(updateMru!==undefined){coercedConfig.updateMru=updateMru;}return coercedConfig;}function typeCheckConfig$9(untrustedConfig){const config={};const untrustedConfig_recordIds=untrustedConfig.recordIds;if(ArrayIsArray$1$5(untrustedConfig_recordIds)){const untrustedConfig_recordIds_array=[];for(let i=0,arrayLength=untrustedConfig_recordIds.length;i<arrayLength;i++){const untrustedConfig_recordIds_item=untrustedConfig_recordIds[i];if(typeof untrustedConfig_recordIds_item==='string'){untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);}}config.recordIds=untrustedConfig_recordIds_array;}const untrustedConfig_childRelationships=untrustedConfig.childRelationships;if(ArrayIsArray$1$5(untrustedConfig_childRelationships)){const untrustedConfig_childRelationships_array=[];for(let i=0,arrayLength=untrustedConfig_childRelationships.length;i<arrayLength;i++){const untrustedConfig_childRelationships_item=untrustedConfig_childRelationships[i];if(typeof untrustedConfig_childRelationships_item==='string'){untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);}}config.childRelationships=untrustedConfig_childRelationships_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_layoutTypes=untrustedConfig.layoutTypes;if(ArrayIsArray$1$5(untrustedConfig_layoutTypes)){const untrustedConfig_layoutTypes_array=[];for(let i=0,arrayLength=untrustedConfig_layoutTypes.length;i<arrayLength;i++){const untrustedConfig_layoutTypes_item=untrustedConfig_layoutTypes[i];if(typeof untrustedConfig_layoutTypes_item==='string'){untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);}}config.layoutTypes=untrustedConfig_layoutTypes_array;}const untrustedConfig_modes=untrustedConfig.modes;if(ArrayIsArray$1$5(untrustedConfig_modes)){const untrustedConfig_modes_array=[];for(let i=0,arrayLength=untrustedConfig_modes.length;i<arrayLength;i++){const untrustedConfig_modes_item=untrustedConfig_modes[i];if(typeof untrustedConfig_modes_item==='string'){untrustedConfig_modes_array.push(untrustedConfig_modes_item);}}config.modes=untrustedConfig_modes_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$5(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_updateMru=untrustedConfig.updateMru;if(typeof untrustedConfig_updateMru==='boolean'){config.updateMru=untrustedConfig_updateMru;}return config;}function validateAdapterConfig$9(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$9(untrustedConfig);const config=typeCheckConfig$9(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}const layoutSelections$1=select$5().selections;const objectInfoPathSelection=select$9().selections;const layoutUserStatePathSelector=select$1$1().selections;function buildRecordUiSelector(recordDefs,layoutTypes,modes,recordOptionalFields){const layoutTypeSelections=[];for(let i=0,len=layoutTypes.length;i<len;i+=1){const layoutType=layoutTypes[i];const modeSelections=[];const sel={kind:'Object',name:layoutType,selections:modeSelections};for(let m=0;m<modes.length;m+=1){const mode=modes[m];const modeSel={kind:'Link',name:mode,selections:layoutSelections$1};push$1.call(modeSelections,modeSel);}push$1.call(layoutTypeSelections,sel);}const recordLayoutSelections=[];const recordSelections=[];for(let i=0,len=recordDefs.length;i<len;i+=1){const{recordId,recordData}=recordDefs[i];push$1.call(recordLayoutSelections,{kind:'Object',name:recordData.apiName,required:false,map:true,selections:layoutTypeSelections});const optionalFields=recordOptionalFields[recordId];const fields=extractRecordFields(recordData);push$1.call(recordSelections,{kind:'Link',name:recordId,selections:buildSelectionFromFields(fields,optionalFields)});}return {kind:'Fragment',selections:[{kind:'Link',name:'layoutUserStates',map:true,selections:layoutUserStatePathSelector},{kind:'Object',name:'layouts',selections:recordLayoutSelections},{kind:'Link',name:'objectInfos',map:true,selections:objectInfoPathSelection},{name:'records',kind:'Object',selections:recordSelections}]};}function getMissingRecordLookupFields(record,objectInfo){const lookupFields={};const{apiName,fields:recordFields}=record;const{fields:objectInfoFields}=objectInfo;const objectInfoFieldNames=keys$3(objectInfoFields);for(let i=0,len=objectInfoFieldNames.length;i<len;i+=1){const fieldName=objectInfoFieldNames[i];const field=objectInfoFields[fieldName];const{relationshipName}=field;if(relationshipName===null){continue;}const recordFieldValue=recordFields[relationshipName];// Only interested in record fields that are present and that are null
    if(recordFieldValue===undefined||recordFieldValue.value!==null){continue;}const{referenceToInfos}=field;for(let r=0,referenceLen=referenceToInfos.length;r<referenceLen;r+=1){const referenceToInfo=referenceToInfos[r];// Include the Id field. Ex: Opportunity.Account.Id, Opportunity.relation1__r.Id
    const idFieldName=`${apiName}.${relationshipName}.Id`;lookupFields[idFieldName]=true;const{nameFields}=referenceToInfo;// Include all name fields so UIAPI populates the displayValue. Ex: Account.Owner.FirstName, Account.Owner.LastName. Or Account.custom__r.Name.
    for(let n=0,nameFieldsLen=nameFields.length;n<nameFieldsLen;n+=1){const nameField=nameFields[n];const nameFieldName=`${apiName}.${relationshipName}.${nameField}`;lookupFields[nameFieldName]=true;}}}return keys$3(lookupFields);}function getRecordUiMissingRecordLookupFields(recordUi){const{records,objectInfos}=recordUi;const recordLookupFields={};const recordIds=keys$3(records);for(let i=0,len=recordIds.length;i<len;i+=1){const recordId=recordIds[i];const recordData=records[recordId];const{apiName}=recordData;const objectInfo=objectInfos[apiName];recordLookupFields[recordId]=getMissingRecordLookupFields(recordData,objectInfo);}return recordLookupFields;}// Custom adapter config due to `unsupported` items
    const GET_RECORDUI_ADAPTER_CONFIG={displayName:'getRecordUi',parameters:{required:['recordIds','layoutTypes','modes'],optional:['optionalFields'],unsupported:['formFactor','childRelationships','pageSize','updateMru']}};function eachLayout(recordUi,cb){const{layouts}=recordUi;const layoutApiNames=keys$3(layouts);for(let a=0,len=layoutApiNames.length;a<len;a+=1){const apiName=layoutApiNames[a];const apiNameData=layouts[apiName];const recordTypeIds=keys$3(apiNameData);for(let b=0,recordTypeIdsLen=recordTypeIds.length;b<recordTypeIdsLen;b+=1){const recordTypeId=recordTypeIds[b];const recordTypeData=apiNameData[recordTypeId];const layoutTypes=keys$3(recordTypeData);for(let c=0,layoutTypesLen=layoutTypes.length;c<layoutTypesLen;c+=1){const layoutType=layoutTypes[c];const layoutTypeData=recordTypeData[layoutType];const modes=keys$3(layoutTypeData);for(let d=0,modesLen=modes.length;d<modesLen;d+=1){const mode=modes[d];const layout=layoutTypeData[mode];cb(apiName,recordTypeId,layout);}}}}}function collectRecordDefs(resp,recordIds){const recordDefs=[];for(let i=0,len=recordIds.length;i<len;i+=1){const recordId=recordIds[i];const recordData=resp.records[recordId];push$1.call(recordDefs,{recordId,recordData,recordTypeId:getRecordTypeId(recordData)});}return recordDefs;}function keyBuilder$9(recordIds,layoutTypes,modes,optionalFields){const joinedRecordIds=recordIds.sort().join(',');const joinedOptionalFields=optionalFields.sort().join(',');const joinedLayoutTypes=layoutTypes.sort().join(',');const joinedModes=modes.sort().join(',');return `${keyPrefix$4}RecordUiRepresentation:${joinedRecordIds}:${joinedLayoutTypes}:${joinedModes}:${joinedOptionalFields}`;}function buildInMemorySnapshot$7(lds,config){const{recordIds,layoutTypes,modes,optionalFields}=config;// TODO: a better hash function for config -> configKey
    const configKey=stringify$3(config);// check to see if we see the selector (config) before
    const selectorNode=getSelectorNode(lds,configKey);// if we do, return the same snapshot instance by calling storeLookupMemoize
    if(selectorNode!==null){const cacheData=lds.storeLookupMemoize(selectorNode);// CACHE HIT
    if(isFulfilledSnapshot$1(cacheData)||isErrorSnapshot$1(cacheData)){return cacheData;}}const key=keyBuilder$9(recordIds,layoutTypes,modes,optionalFields);const cachedSelectorKey=`${key}__selector`;const cacheSel=lds.storeLookup({recordId:cachedSelectorKey,node:{kind:'Fragment',opaque:true},variables:{}});if(isFulfilledSnapshot$1(cacheSel)){const cachedSelector=cacheSel.data;// publish the selector instance for later getNode check
    lds.storePublish(configKey,cachedSelector);const cacheData=lds.storeLookupMemoize(cachedSelector);// CACHE HIT
    if(isFulfilledSnapshot$1(cacheData)){return cacheData;}}return null;}function markRecordUiOptionalFields(lds,optionalFields,recordNodes){if(optionalFields.length===0){return;}for(let i=0,len=recordNodes.length;i<len;i++){markMissingOptionalFields(recordNodes[i],optionalFields);}}function getSelectorNode(lds,key){const selectorNode=lds.getNode(key);if(selectorNode!==null){return selectorNode.retrieve();}return null;}function buildNetworkSnapshot$6(lds,config){const{recordIds,layoutTypes,modes,optionalFields}=config;// TODO: a better hash function for config -> configKey
    const configKey=stringify$3(config);let allOptionalFields=[];for(let i=0,len=recordIds.length;i<len;i++){const recordId=recordIds[i];allOptionalFields=allOptionalFields.concat(getTrackedFields(lds,recordId,optionalFields));}const key=keyBuilder$9(recordIds,layoutTypes,modes,optionalFields);const resourceRequest=getUiApiRecordUiByRecordIds({urlParams:{recordIds},queryParams:{layoutTypes,modes,optionalFields:dedupe(allOptionalFields).sort()}});return lds.dispatchResourceRequest(resourceRequest).then(response=>{const{body}=response;// TODO fix API so we don't have to augment the response with request details in order
    // to support refresh. these are never emitted out per (private).
    eachLayout(body,(apiName,recordTypeId,layout)=>{layout.apiName=apiName;layout.recordTypeId=recordTypeId;if(layout.id===null){return;}const layoutUserState=body.layoutUserStates[layout.id];// Temporary hack since we can't match keys from getLayoutUserState response
    // to record ui's layout users states.
    if(layoutUserState===undefined){return;}layoutUserState.apiName=apiName;layoutUserState.recordTypeId=recordTypeId;layoutUserState.mode=layout.mode;layoutUserState.layoutType=layout.layoutType;});const cachedSelectorKey=`${key}__selector`;const recordLookupFields=getRecordUiMissingRecordLookupFields(body);const selPath=buildRecordUiSelector(collectRecordDefs(body,recordIds),layoutTypes,modes,recordLookupFields);const sel={recordId:key,node:selPath,variables:{}};lds.storePublish(cachedSelectorKey,sel);lds.storeIngest(key,resourceRequest,body);// During ingestion, only valid records are stored.
    const recordNodes=[];const validRecordIds=[];for(let i=0,len=recordIds.length;i<len;i+=1){const recordId=recordIds[i];const recordKey=keyBuilder({recordId});const node=lds.getNode(recordKey);if(isGraphNode(node)){recordNodes.push(node);validRecordIds.push(recordId);}}const{optionalFields}=config;if(optionalFields.length>0){markRecordUiOptionalFields(lds,optionalFields,recordNodes);}lds.storeBroadcast();lds.storePublish(configKey,sel);publishDependencies(lds,validRecordIds,[key,cachedSelectorKey,configKey]);return lds.storeLookupMemoize(sel);},err=>{lds.storeIngestFetchResponse(key,err,TTL$2);lds.storeBroadcast();const{status}=err;if(status===404){const sel={recordId:key,node:{kind:'Fragment',opaque:true},variables:{}};lds.storePublish(configKey,sel);return lds.storeLookupMemoize(sel);}return lds.errorSnapshot(err);});}function publishDependencies(lds,recordIds,depKeys){for(let i=0,len=recordIds.length;i<len;i+=1){const recordDepKey=depenpendencyKeyBuilder({recordId:recordIds[i]});const dependencies=create$1$1(null);for(let j=0,len=depKeys.length;j<len;j++){dependencies[depKeys[j]]=true;}const node=lds.getNode(recordDepKey);if(isGraphNode(node)){const recordDeps=node.retrieve();assign$1(dependencies,recordDeps);}lds.storePublish(recordDepKey,dependencies);}}function coerceConfigWithDefaults$3(untrustedConfig){const config=validateAdapterConfig$9(untrustedConfig,GET_RECORDUI_ADAPTER_CONFIG);if(config===null){return null;}const{layoutTypes,modes}=config;// custom config validation
    if(layoutTypes===undefined||modes===undefined){return null;}return _objectSpread$1({},config,{layoutTypes:layoutTypes,modes:modes,optionalFields:config.optionalFields===undefined?[]:config.optionalFields});}const factory$6=lds=>{return refreshable$5(function getRecordUi(untrustedConfig){// standard config validation and coercion
    const config=coerceConfigWithDefaults$3(untrustedConfig);if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$7(lds,config);if(cacheSnapshot!==null&&(isFulfilledSnapshot$1(cacheSnapshot)||isErrorSnapshot$1(cacheSnapshot))){return cacheSnapshot;}return buildNetworkSnapshot$6(lds,config);},untrustedConfig=>{const config=coerceConfigWithDefaults$3(untrustedConfig);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$6(lds,config);});};const DEFAULT_MODE$1=LayoutMode$1.View;const layoutSelections$2=select$5();function refresh(lds,config){const{recordId,layoutTypes,modes:configModes,optionalFields:configOptionalFields}=config;const modes=configModes===undefined?[DEFAULT_MODE$1]:configModes;const optionalFields=configOptionalFields===undefined?[]:configOptionalFields;const recordUiConfig={recordIds:[recordId],layoutTypes,modes,optionalFields};return buildNetworkSnapshot$6(lds,recordUiConfig).then(snapshot=>{if(isErrorSnapshot$1(snapshot)){return lds.errorSnapshot(snapshot.error);}if(isUnfulfilledSnapshot$1(snapshot)){throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys$3(snapshot.missingPaths)}`);}const{layoutMap,objectInfo}=getLayoutMapAndObjectInfo(recordId,snapshot.data);const fields=getFieldsFromLayoutMap(layoutMap,objectInfo);return buildInMemorySnapshot$5(lds,{recordId,fields,modes});});}// Makes a request directly to /record-ui/{recordIds}
    function fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields){const recordUiConfig={recordIds:[recordId],layoutTypes,modes,optionalFields};const recordUiAdapter=factory$6(lds);const recordUiSnapshotOrPromise=recordUiAdapter(recordUiConfig);if(isPromise$1$1(recordUiSnapshotOrPromise)){return recordUiSnapshotOrPromise.then(snapshot=>{return processRecordUiRepresentation(lds,recordId,modes,snapshot);});}{if(recordUiSnapshotOrPromise===null){throw new Error('RecordUi adapter synchronously resolved with a null snapshot');}}return processRecordUiRepresentation(lds,recordId,modes,recordUiSnapshotOrPromise);}function getLayoutMapAndObjectInfo(recordId,data){const{objectInfos,layouts,records}=data;const record=records[recordId];const{apiName}=record;const objectInfo=objectInfos[apiName];const recordTypeId=getRecordTypeId(record);const layoutMap=layouts[apiName][recordTypeId];return {layoutMap,objectInfo};}function processRecordUiRepresentation(lds,recordId,modes,snapshot){if(isErrorSnapshot$1(snapshot)){return lds.errorSnapshot(snapshot.error);}if(isUnfulfilledSnapshot$1(snapshot)){throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys$3(snapshot.missingPaths)}`);}const{layoutMap,objectInfo}=getLayoutMapAndObjectInfo(recordId,snapshot.data);return getRecord(lds,recordId,layoutMap,objectInfo);}function isPromise$1$1(value){// check for Thenable due to test frameworks using custom Promise impls
    return value!==null&&value.then!==undefined;}function lookupObjectInfo(lds,apiName){const snapshot=buildInMemorySnapshot$6(lds,{objectApiName:apiName});return isFulfilledSnapshot$1(snapshot)?snapshot.data:null;}function lookupLayouts(lds,apiName,recordTypeId,layoutTypes,modes){const map={};for(let i=0;i<layoutTypes.length;i+=1){const layoutType=layoutTypes[i];let layoutMap=map[layoutType];if(layoutMap===undefined){layoutMap=map[layoutType]={};}for(let m=0;m<modes.length;m+=1){const mode=modes[m];const key=keyBuilder$1({apiName,recordTypeId,layoutType,mode});const snapshot=lds.storeLookup({recordId:key,node:layoutSelections$2,variables:{}});// Cache hit
    if(isFulfilledSnapshot$1(snapshot)){layoutMap[mode]=snapshot.data;}else {return null;}}}return map;}const recordLayoutFragmentSelector=[{name:'apiName',kind:'Scalar'},{name:'recordTypeId',kind:'Scalar'}];function getFieldsFromLayoutMap(layoutMap,objectInfo){let fields=[];const layoutTypes=Object.keys(layoutMap);for(let i=0,layoutTypesLen=layoutTypes.length;i<layoutTypesLen;i+=1){const layoutType=layoutTypes[i];const modesMap=layoutMap[layoutType];const modes=Object.keys(modesMap);for(let m=0,modesLen=modes.length;m<modesLen;m+=1){const mode=modes[m];const modeKeys=getQualifiedFieldApiNamesFromLayout(modesMap[mode],objectInfo);fields=fields.concat(modeKeys);}}return dedupe(fields).sort();}function getRecord(lds,recordId,layoutMap,objectInfo){const fields=getFieldsFromLayoutMap(layoutMap,objectInfo);// We know what fields we need so delegate to getRecordByFields
    // This should be a cache hit because we just fetched the record-ui
    return getRecordByFields(lds,{recordId,fields});}function getRecordLayoutType(lds,config){const{recordId,layoutTypes,modes:configModes,optionalFields}=config;const modes=configModes===undefined?[DEFAULT_MODE$1]:configModes;const storeKey=keyBuilder({recordId});const recordSnapshot=lds.storeLookup({recordId:storeKey,node:{kind:'Fragment',selections:recordLayoutFragmentSelector},variables:{}});// If we haven't seen the record then go to the server
    if(!isFulfilledSnapshot$1(recordSnapshot)){return fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields);}const record=recordSnapshot.data;const{apiName}=record;const objectInfo=lookupObjectInfo(lds,apiName);// If we do not have object info in cache, call record-ui endpoint directly
    if(objectInfo===null){return fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields);}const recordTypeId=getRecordTypeId(record);const layoutMap=lookupLayouts(lds,apiName,recordTypeId,layoutTypes,modes);// It takes one xhr per layout to load so if there are missing layouts
    // give up and call record-ui endpoint directly
    if(layoutMap===null){return fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields);}return getRecord(lds,recordId,layoutMap,objectInfo);}// Custom adapter config due to `unsupported` items
    const GET_RECORD_ADAPTER_CONFIG={displayName:'getRecord',parameters:{required:['recordId'],optional:['fields','layoutTypes','modes','optionalFields'],unsupported:['childRelationships','pageSize','updateMru']}};function hasLayoutTypes(config){return 'layoutTypes'in config;}function hasFieldsOrOptionalFields(config){return 'fields'in config||'optionalFields'in config;}function createResourceRequestFromRepresentation(representation,optionalFields){const config={urlParams:{recordId:representation.id},queryParams:{optionalFields}};return getUiApiRecordsByRecordId(config);}// TODO: this should probably be code generated in RecordRepresentation
    function coerceKeyParams(config){const coercedConfig={};const recordId=getRecordId18(config.recordId);if(recordId!==undefined){coercedConfig.recordId=recordId;}return coercedConfig;}const NOTIFY_CHANGE_NETWORK_KEY='notify-change-network';const notifyChangeNetworkRejectInstrumentParamBuilder=()=>{return {[NOTIFY_CHANGE_NETWORK_KEY]:'error'};};const notifyChangeFactory=lds=>{return function getUiApiRecordsByRecordIdNotifyChange(configs){for(let i=0,len=configs.length;i<len;i++){// build key from input
    const coercedConfig=coerceKeyParams(configs[i]);const key=keyBuilder(coercedConfig);// lookup GraphNode from store
    const node=lds.getNode(key);if(node===null||node.type==='Error'){continue;}// retrieve data (Representation) from GraphNode and use createResourceRequestFromRepresentation to build refresh resource request from Representation
    const representation=node.retrieve();const optionalFields=getTrackedFields(lds,representation.id);const refreshRequest=createResourceRequestFromRepresentation(representation,optionalFields);const existingWeakEtag=representation.weakEtag;// dispatch resource request, then ingest and broadcast
    lds.dispatchResourceRequest(refreshRequest).then(response=>{const{body}=response;lds.storeIngest(refreshRequest.key,refreshRequest,body);const recordNode=lds.getNode(refreshRequest.key);markMissingOptionalFields(recordNode,optionalFields);lds.storeBroadcast();const notifyChangeNetworkResolveInstrumentParamBuilder=()=>{return {[NOTIFY_CHANGE_NETWORK_KEY]:existingWeakEtag!==body.weakEtag};};lds.instrument(notifyChangeNetworkResolveInstrumentParamBuilder);},error=>{lds.storeIngestFetchResponse(refreshRequest.key,error,TTL);lds.storeBroadcast();lds.instrument(notifyChangeNetworkRejectInstrumentParamBuilder);});}};};const factory$7=lds=>{return refreshable$5(function getRecord(untrustedConfig){// standard config validation and coercion
    const config=validateAdapterConfig$7(untrustedConfig,GET_RECORD_ADAPTER_CONFIG);if(config===null){return null;}if(hasLayoutTypes(config)){return getRecordLayoutType(lds,config);}else if(hasFieldsOrOptionalFields(config)){return getRecordByFields(lds,config);}return null;},untrustedConfig=>{const config=validateAdapterConfig$7(untrustedConfig,GET_RECORD_ADAPTER_CONFIG);if(config===null){throw new Error('Refresh should not be called with partial configuration');}if(hasLayoutTypes(config)){return refresh(lds,config);}else if(hasFieldsOrOptionalFields(config)){return buildNetworkSnapshot$5(lds,config);}throw new Error('Refresh should be called with either record fields configuration or record by layout configuration');});};function validate$s(obj,path='PhotoMetadataRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_companyBluemasterId=obj.companyBluemasterId;const path_companyBluemasterId=path+'.companyBluemasterId';let obj_companyBluemasterId_union0=null;const obj_companyBluemasterId_union0_error=(()=>{if(typeof obj_companyBluemasterId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_companyBluemasterId+'" (at "'+path_companyBluemasterId+'")');}})();if(obj_companyBluemasterId_union0_error!=null){obj_companyBluemasterId_union0=obj_companyBluemasterId_union0_error.message;}let obj_companyBluemasterId_union1=null;const obj_companyBluemasterId_union1_error=(()=>{if(obj_companyBluemasterId!==null){return new TypeError('Expected "null" but received "'+typeof obj_companyBluemasterId+'" (at "'+path_companyBluemasterId+'")');}})();if(obj_companyBluemasterId_union1_error!=null){obj_companyBluemasterId_union1=obj_companyBluemasterId_union1_error.message;}if(obj_companyBluemasterId_union0&&obj_companyBluemasterId_union1){let message='Object doesn\'t match union (at "'+path_companyBluemasterId+'")';message+='\n'+obj_companyBluemasterId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_companyBluemasterId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_responseId=obj.responseId;const path_responseId=path+'.responseId';let obj_responseId_union0=null;const obj_responseId_union0_error=(()=>{if(typeof obj_responseId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_responseId+'" (at "'+path_responseId+'")');}})();if(obj_responseId_union0_error!=null){obj_responseId_union0=obj_responseId_union0_error.message;}let obj_responseId_union1=null;const obj_responseId_union1_error=(()=>{if(obj_responseId!==null){return new TypeError('Expected "null" but received "'+typeof obj_responseId+'" (at "'+path_responseId+'")');}})();if(obj_responseId_union1_error!=null){obj_responseId_union1=obj_responseId_union1_error.message;}if(obj_responseId_union0&&obj_responseId_union1){let message='Object doesn\'t match union (at "'+path_responseId+'")';message+='\n'+obj_responseId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_responseId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}const select$a=function PhotoMetadataRepresentationSelect(){return {kind:'Fragment',selections:[{name:'companyBluemasterId',kind:'Scalar'},{name:'responseId',kind:'Scalar'}]};};function equals$e(existing,incoming){const existing_companyBluemasterId=existing.companyBluemasterId;const incoming_companyBluemasterId=incoming.companyBluemasterId;if(!(existing_companyBluemasterId===incoming_companyBluemasterId)){return false;}const existing_responseId=existing.responseId;const incoming_responseId=incoming.responseId;if(!(existing_responseId===incoming_responseId)){return false;}return true;}function validate$t(obj,path='PhotoRecordAvatarRepresentation'){const validateAbstractRecordAvatarRepresentation_validateError=validate$v(obj,path);if(validateAbstractRecordAvatarRepresentation_validateError!==null){return validateAbstractRecordAvatarRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_backgroundColor=obj.backgroundColor;const path_backgroundColor=path+'.backgroundColor';let obj_backgroundColor_union0=null;const obj_backgroundColor_union0_error=(()=>{if(typeof obj_backgroundColor!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union0_error!=null){obj_backgroundColor_union0=obj_backgroundColor_union0_error.message;}let obj_backgroundColor_union1=null;const obj_backgroundColor_union1_error=(()=>{if(obj_backgroundColor!==null){return new TypeError('Expected "null" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union1_error!=null){obj_backgroundColor_union1=obj_backgroundColor_union1_error.message;}if(obj_backgroundColor_union0&&obj_backgroundColor_union1){let message='Object doesn\'t match union (at "'+path_backgroundColor+'")';message+='\n'+obj_backgroundColor_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_backgroundColor_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_height=obj.height;const path_height=path+'.height';let obj_height_union0=null;const obj_height_union0_error=(()=>{if(typeof obj_height!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_height+'" (at "'+path_height+'")');}})();if(obj_height_union0_error!=null){obj_height_union0=obj_height_union0_error.message;}let obj_height_union1=null;const obj_height_union1_error=(()=>{if(obj_height!==null){return new TypeError('Expected "null" but received "'+typeof obj_height+'" (at "'+path_height+'")');}})();if(obj_height_union1_error!=null){obj_height_union1=obj_height_union1_error.message;}if(obj_height_union0&&obj_height_union1){let message='Object doesn\'t match union (at "'+path_height+'")';message+='\n'+obj_height_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_height_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_photoMetadata=obj.photoMetadata;const path_photoMetadata=path+'.photoMetadata';const referencePhotoMetadataRepresentationValidationError=validate$s(obj_photoMetadata,path_photoMetadata);if(referencePhotoMetadataRepresentationValidationError!==null){let message='Object doesn\'t match PhotoMetadataRepresentation (at "'+path_photoMetadata+'")\n';message+=referencePhotoMetadataRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_photoUrl=obj.photoUrl;const path_photoUrl=path+'.photoUrl';if(typeof obj_photoUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_photoUrl+'" (at "'+path_photoUrl+'")');}const obj_provider=obj.provider;const path_provider=path+'.provider';let obj_provider_union0=null;const obj_provider_union0_error=(()=>{if(typeof obj_provider!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_provider+'" (at "'+path_provider+'")');}})();if(obj_provider_union0_error!=null){obj_provider_union0=obj_provider_union0_error.message;}let obj_provider_union1=null;const obj_provider_union1_error=(()=>{if(obj_provider!==null){return new TypeError('Expected "null" but received "'+typeof obj_provider+'" (at "'+path_provider+'")');}})();if(obj_provider_union1_error!=null){obj_provider_union1=obj_provider_union1_error.message;}if(obj_provider_union0&&obj_provider_union1){let message='Object doesn\'t match union (at "'+path_provider+'")';message+='\n'+obj_provider_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_provider_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_width=obj.width;const path_width=path+'.width';let obj_width_union0=null;const obj_width_union0_error=(()=>{if(typeof obj_width!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_width+'" (at "'+path_width+'")');}})();if(obj_width_union0_error!=null){obj_width_union0=obj_width_union0_error.message;}let obj_width_union1=null;const obj_width_union1_error=(()=>{if(obj_width!==null){return new TypeError('Expected "null" but received "'+typeof obj_width+'" (at "'+path_width+'")');}})();if(obj_width_union1_error!=null){obj_width_union1=obj_width_union1_error.message;}if(obj_width_union0&&obj_width_union1){let message='Object doesn\'t match union (at "'+path_width+'")';message+='\n'+obj_width_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_width_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function keyBuilder$a(config){return keyBuilder$c(config);}function normalize$c(input,existing,path,lds,store,timestamp){return input;}const select$b=function PhotoRecordAvatarRepresentationSelect(){const{selections:AbstractRecordAvatarRepresentationSelections}=select$d();const{selections:PhotoMetadataRepresentation__selections,opaque:PhotoMetadataRepresentation__opaque}=select$a();return {kind:'Fragment',selections:[...AbstractRecordAvatarRepresentationSelections,{name:'backgroundColor',kind:'Scalar'},{name:'height',kind:'Scalar'},{name:'photoMetadata',kind:'Object',selections:PhotoMetadataRepresentation__selections},{name:'photoUrl',kind:'Scalar'},{name:'provider',kind:'Scalar'},{name:'width',kind:'Scalar'}]};};function equals$f(existing,incoming){if(equals$h(existing,incoming)===false){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_photoUrl=existing.photoUrl;const incoming_photoUrl=incoming.photoUrl;if(!(existing_photoUrl===incoming_photoUrl)){return false;}const existing_backgroundColor=existing.backgroundColor;const incoming_backgroundColor=incoming.backgroundColor;if(!(existing_backgroundColor===incoming_backgroundColor)){return false;}const existing_height=existing.height;const incoming_height=incoming.height;if(!(existing_height===incoming_height)){return false;}const existing_photoMetadata=existing.photoMetadata;const incoming_photoMetadata=incoming.photoMetadata;if(!equals$e(existing_photoMetadata,incoming_photoMetadata)){return false;}const existing_provider=existing.provider;const incoming_provider=incoming.provider;if(!(existing_provider===incoming_provider)){return false;}const existing_width=existing.width;const incoming_width=incoming.width;if(!(existing_width===incoming_width)){return false;}return true;}const ingest$c=function PhotoRecordAvatarRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$t(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$a({recordId:input.recordId});let incomingRecord=normalize$c(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$f(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$u(obj,path='ThemeRecordAvatarRepresentation'){const validateAbstractRecordAvatarRepresentation_validateError=validate$v(obj,path);if(validateAbstractRecordAvatarRepresentation_validateError!==null){return validateAbstractRecordAvatarRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_backgroundColor=obj.backgroundColor;const path_backgroundColor=path+'.backgroundColor';let obj_backgroundColor_union0=null;const obj_backgroundColor_union0_error=(()=>{if(typeof obj_backgroundColor!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union0_error!=null){obj_backgroundColor_union0=obj_backgroundColor_union0_error.message;}let obj_backgroundColor_union1=null;const obj_backgroundColor_union1_error=(()=>{if(obj_backgroundColor!==null){return new TypeError('Expected "null" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union1_error!=null){obj_backgroundColor_union1=obj_backgroundColor_union1_error.message;}if(obj_backgroundColor_union0&&obj_backgroundColor_union1){let message='Object doesn\'t match union (at "'+path_backgroundColor+'")';message+='\n'+obj_backgroundColor_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_backgroundColor_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_iconUrl=obj.iconUrl;const path_iconUrl=path+'.iconUrl';let obj_iconUrl_union0=null;const obj_iconUrl_union0_error=(()=>{if(typeof obj_iconUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union0_error!=null){obj_iconUrl_union0=obj_iconUrl_union0_error.message;}let obj_iconUrl_union1=null;const obj_iconUrl_union1_error=(()=>{if(obj_iconUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union1_error!=null){obj_iconUrl_union1=obj_iconUrl_union1_error.message;}if(obj_iconUrl_union0&&obj_iconUrl_union1){let message='Object doesn\'t match union (at "'+path_iconUrl+'")';message+='\n'+obj_iconUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_iconUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function keyBuilder$b(config){return keyBuilder$c(config);}function normalize$d(input,existing,path,lds,store,timestamp){return input;}const select$c=function ThemeRecordAvatarRepresentationSelect(){const{selections:AbstractRecordAvatarRepresentationSelections}=select$d();return {kind:'Fragment',selections:[...AbstractRecordAvatarRepresentationSelections,{name:'backgroundColor',kind:'Scalar'},{name:'iconUrl',kind:'Scalar'}]};};function equals$g(existing,incoming){if(equals$h(existing,incoming)===false){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_backgroundColor=existing.backgroundColor;const incoming_backgroundColor=incoming.backgroundColor;if(!(existing_backgroundColor===incoming_backgroundColor)){return false;}const existing_iconUrl=existing.iconUrl;const incoming_iconUrl=incoming.iconUrl;if(!(existing_iconUrl===incoming_iconUrl)){return false;}return true;}const ingest$d=function ThemeRecordAvatarRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$u(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$b({recordId:input.recordId});let incomingRecord=normalize$d(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$g(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};var DiscriminatorValues$1;(function(DiscriminatorValues){DiscriminatorValues["Photo"]="Photo";DiscriminatorValues["Theme"]="Theme";})(DiscriminatorValues$1||(DiscriminatorValues$1={}));function validate$v(obj,path='AbstractRecordAvatarRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_recordId=obj.recordId;const path_recordId=path+'.recordId';if(typeof obj_recordId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordId+'" (at "'+path_recordId+'")');}const obj_type=obj.type;const path_type=path+'.type';if(typeof obj_type!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_type+'" (at "'+path_type+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$c(config){return keyPrefix$4+'AbstractRecordAvatarRepresentation:'+config.recordId;}const selectChildren=function AbstractRecordAvatarRepresentationSelectChildren(params){const{selections:PhotoRecordAvatarRepresentationSelections}=select$b();const{selections:ThemeRecordAvatarRepresentationSelections}=select$c();return {kind:'Link',name:params.propertyName,nullable:params.nullable,union:true,discriminator:'type',unionSelections:{[DiscriminatorValues$1.Photo]:PhotoRecordAvatarRepresentationSelections,[DiscriminatorValues$1.Theme]:ThemeRecordAvatarRepresentationSelections}};};const select$d=function AbstractRecordAvatarRepresentationSelect(){return {kind:'Fragment',selections:[{name:'recordId',kind:'Scalar'},{name:'type',kind:'Scalar'}]};};function equals$h(existing,incoming){const existing_recordId=existing.recordId;const incoming_recordId=incoming.recordId;if(!(existing_recordId===incoming_recordId)){return false;}const existing_type=existing.type;const incoming_type=incoming.type;if(!(existing_type===incoming_type)){return false;}return true;}const discriminatorIngest=function AbstractRecordAvatarRepresentationDiscriminatorIngest(input,path,lds,store,timestamp){const discriminatorValue=input.type;if(discriminatorValue==='Photo'){return ingest$c(input,path,lds,store);}if(discriminatorValue==='Theme'){return ingest$d(input,path,lds,store);}throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "Photo","Theme"`);};function validate$w(obj,path='RecordAvatarBatchRepresentation'){const validateAbstractRecordAvatarBatchRepresentation_validateError=validate$A(obj,path);if(validateAbstractRecordAvatarBatchRepresentation_validateError!==null){return validateAbstractRecordAvatarBatchRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_result=obj.result;const path_result=path+'.result';if(typeof obj_result!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_result+'" (at "'+path_result+'")');}})();return v_error===undefined?null:v_error;}function normalize$f(input,existing,path,lds,store,timestamp){const input_result=input.result;const input_result_id=path.fullPath+'__result';input.result=discriminatorIngest(input_result,{fullPath:input_result_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store);return input;}const select$e=function RecordAvatarBatchRepresentationSelect(){const{selections:AbstractRecordAvatarBatchRepresentationSelections}=select$i();const AbstractRecordAvatarRepresentation__unionSelections=selectChildren({propertyName:'result',nullable:false});return {kind:'Fragment',selections:[...AbstractRecordAvatarBatchRepresentationSelections,AbstractRecordAvatarRepresentation__unionSelections]};};function equals$i(existing,incoming){if(equals$m(existing,incoming)===false){return false;}const existing_result=existing.result;const incoming_result=incoming.result;if(!(existing_result.__ref===incoming_result.__ref)){return false;}return true;}const ingest$f=function RecordAvatarBatchRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$w(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$f(input,store.records[key],{fullPath:key,parent:path.parent},lds,store);const existingRecord=store.records[key];if(existingRecord===undefined||equals$i(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$x(obj,path='ErrorSingleRecordAvatarRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_errorCode=obj.errorCode;const path_errorCode=path+'.errorCode';if(typeof obj_errorCode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_errorCode+'" (at "'+path_errorCode+'")');}const obj_message=obj.message;const path_message=path+'.message';if(typeof obj_message!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_message+'" (at "'+path_message+'")');}})();return v_error===undefined?null:v_error;}const select$f=function ErrorSingleRecordAvatarRepresentationSelect(){return {kind:'Fragment',selections:[{name:'errorCode',kind:'Scalar'},{name:'message',kind:'Scalar'}]};};function equals$j(existing,incoming){const existing_errorCode=existing.errorCode;const incoming_errorCode=incoming.errorCode;if(!(existing_errorCode===incoming_errorCode)){return false;}const existing_message=existing.message;const incoming_message=incoming.message;if(!(existing_message===incoming_message)){return false;}return true;}function validate$y(obj,path='ErrorBadRequestRecordAvatarBatchRepresentation'){const validateAbstractRecordAvatarBatchRepresentation_validateError=validate$A(obj,path);if(validateAbstractRecordAvatarBatchRepresentation_validateError!==null){return validateAbstractRecordAvatarBatchRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_result=obj.result;const path_result=path+'.result';if(!ArrayIsArray$6(obj_result)){return new TypeError('Expected "array" but received "'+typeof obj_result+'" (at "'+path_result+'")');}for(let i=0;i<obj_result.length;i++){const obj_result_item=obj_result[i];const path_result_item=path_result+'['+i+']';const referenceErrorSingleRecordAvatarRepresentationValidationError=validate$x(obj_result_item,path_result_item);if(referenceErrorSingleRecordAvatarRepresentationValidationError!==null){let message='Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "'+path_result_item+'")\n';message+=referenceErrorSingleRecordAvatarRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function normalize$g(input,existing,path,lds,store,timestamp){return input;}const select$g=function ErrorBadRequestRecordAvatarBatchRepresentationSelect(){const{selections:AbstractRecordAvatarBatchRepresentationSelections}=select$i();const{selections:ErrorSingleRecordAvatarRepresentation__selections,opaque:ErrorSingleRecordAvatarRepresentation__opaque}=select$f();return {kind:'Fragment',selections:[...AbstractRecordAvatarBatchRepresentationSelections,{name:'result',kind:'Object',plural:true,selections:ErrorSingleRecordAvatarRepresentation__selections}]};};function equals$k(existing,incoming){if(equals$m(existing,incoming)===false){return false;}const existing_result=existing.result;const incoming_result=incoming.result;const equals_result_items=equalsArray(existing_result,incoming_result,(existing_result_item,incoming_result_item)=>{if(!equals$j(existing_result_item,incoming_result_item)){return false;}});if(equals_result_items===false){return false;}return true;}const ingest$g=function ErrorBadRequestRecordAvatarBatchRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$y(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$g(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$k(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$z(obj,path='ErrorRecordAvatarBatchRepresentation'){const validateAbstractRecordAvatarBatchRepresentation_validateError=validate$A(obj,path);if(validateAbstractRecordAvatarBatchRepresentation_validateError!==null){return validateAbstractRecordAvatarBatchRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_result=obj.result;const path_result=path+'.result';if(!ArrayIsArray$6(obj_result)){return new TypeError('Expected "array" but received "'+typeof obj_result+'" (at "'+path_result+'")');}for(let i=0;i<obj_result.length;i++){const obj_result_item=obj_result[i];const path_result_item=path_result+'['+i+']';const referenceErrorSingleRecordAvatarRepresentationValidationError=validate$x(obj_result_item,path_result_item);if(referenceErrorSingleRecordAvatarRepresentationValidationError!==null){let message='Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "'+path_result_item+'")\n';message+=referenceErrorSingleRecordAvatarRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function normalize$h(input,existing,path,lds,store,timestamp){return input;}const select$h=function ErrorRecordAvatarBatchRepresentationSelect(){const{selections:AbstractRecordAvatarBatchRepresentationSelections}=select$i();const{selections:ErrorSingleRecordAvatarRepresentation__selections,opaque:ErrorSingleRecordAvatarRepresentation__opaque}=select$f();return {kind:'Fragment',selections:[...AbstractRecordAvatarBatchRepresentationSelections,{name:'result',kind:'Object',plural:true,selections:ErrorSingleRecordAvatarRepresentation__selections}]};};function equals$l(existing,incoming){if(equals$m(existing,incoming)===false){return false;}const existing_result=existing.result;const incoming_result=incoming.result;const equals_result_items=equalsArray(existing_result,incoming_result,(existing_result_item,incoming_result_item)=>{if(!equals$j(existing_result_item,incoming_result_item)){return false;}});if(equals_result_items===false){return false;}return true;}const ingest$h=function ErrorRecordAvatarBatchRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$z(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$h(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$l(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};const DiscriminatorValues$1$1={'200':200,'400':400,'404':404};function validate$A(obj,path='AbstractRecordAvatarBatchRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_statusCode=obj.statusCode;const path_statusCode=path+'.statusCode';if(typeof obj_statusCode!=='number'){return new TypeError('Expected "number" but received "'+typeof obj_statusCode+'" (at "'+path_statusCode+'")');}})();return v_error===undefined?null:v_error;}const selectChildren$1=function AbstractRecordAvatarBatchRepresentationSelectChildren(params){const{selections:RecordAvatarBatchRepresentationSelections}=select$e();const{selections:ErrorBadRequestRecordAvatarBatchRepresentationSelections}=select$g();const{selections:ErrorRecordAvatarBatchRepresentationSelections}=select$h();return {kind:'Link',name:params.propertyName,nullable:params.nullable,union:true,discriminator:'statusCode',unionSelections:{[DiscriminatorValues$1$1['200']]:RecordAvatarBatchRepresentationSelections,[DiscriminatorValues$1$1['400']]:ErrorBadRequestRecordAvatarBatchRepresentationSelections,[DiscriminatorValues$1$1['404']]:ErrorRecordAvatarBatchRepresentationSelections}};};const select$i=function AbstractRecordAvatarBatchRepresentationSelect(){return {kind:'Fragment',selections:[{name:'statusCode',kind:'Scalar'}]};};function equals$m(existing,incoming){const existing_statusCode=existing.statusCode;const incoming_statusCode=incoming.statusCode;if(!(existing_statusCode===incoming_statusCode)){return false;}return true;}const discriminatorIngest$1=function AbstractRecordAvatarBatchRepresentationDiscriminatorIngest(input,path,lds,store,timestamp){const discriminatorValue=input.statusCode;if(discriminatorValue===200){return ingest$f(input,path,lds,store);}if(discriminatorValue===400){return ingest$g(input,path,lds,store);}if(discriminatorValue===404){return ingest$h(input,path,lds,store);}throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "200","400","404"`);};function merge$2(existing,incoming,_lds,_path){if(existing===undefined){return incoming;}// Merge RecordRepresentation field values together
    return _objectSpread$1({},existing,incoming);}function validate$B(obj,path='RecordAvatarBulkMapRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_keys=ObjectKeys$5(obj);for(let i=0;i<obj_keys.length;i++){const key=obj_keys[i];const obj_prop=obj[key];const path_prop=path+'["'+key+'"]';if(typeof obj_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_prop+'" (at "'+path_prop+'")');}}})();return v_error===undefined?null:v_error;}function normalize$i(input,existing,path,lds,store,timestamp){const input_keys=Object.keys(input);const input_length=input_keys.length;for(let i=0;i<input_length;i++){const key=input_keys[i];const input_prop=input[key];const input_prop_id=path.fullPath+'__'+key;input[key]=discriminatorIngest$1(input_prop,{fullPath:input_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store);}return input;}function equals$n(existing,incoming){const equals_props=equalsObject(existing,incoming,(existing_prop,incoming_prop)=>{if(!(existing_prop.__ref===incoming_prop.__ref)){return false;}});if(equals_props===false){return false;}return true;}const ingest$i=function RecordAvatarBulkMapRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$B(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$i(input,store.records[key],{fullPath:key,parent:path.parent},lds,store);const existingRecord=store.records[key];incomingRecord=merge$2(existingRecord,incomingRecord);if(existingRecord===undefined||equals$n(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return createLink$5(key);};function getUiApiRecordAvatarsBatchByRecordIds(config){const key=keyPrefix$4+'RecordAvatarBulkMapRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'recordIds:'+config.urlParams.recordIds+')';const headers={};return {path:'/services/data/v49.0/ui-api/record-avatars/batch/'+config.urlParams.recordIds+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$i,headers};}var FormFactor$1;(function(FormFactor){FormFactor["Large"]="Large";FormFactor["Medium"]="Medium";FormFactor["Small"]="Small";})(FormFactor$1||(FormFactor$1={}));function coerceFormFactor(form){if(form===FormFactor$1.Large||form===FormFactor$1.Medium||form===FormFactor$1.Small){return form;}return undefined;}const getRecordAvatars_ConfigPropertyNames={displayName:'getRecordAvatars',parameters:{required:['recordIds'],optional:['formFactor']}};function coerceConfig$a(config){const coercedConfig={};const recordIds=getRecordId18Array(config.recordIds);if(recordIds!==undefined){coercedConfig.recordIds=recordIds;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}return coercedConfig;}function typeCheckConfig$a(untrustedConfig){const config={};const untrustedConfig_recordIds=untrustedConfig.recordIds;if(ArrayIsArray$1$5(untrustedConfig_recordIds)){const untrustedConfig_recordIds_array=[];for(let i=0,arrayLength=untrustedConfig_recordIds.length;i<arrayLength;i++){const untrustedConfig_recordIds_item=untrustedConfig_recordIds[i];if(typeof untrustedConfig_recordIds_item==='string'){untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);}}config.recordIds=untrustedConfig_recordIds_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}return config;}function validateAdapterConfig$a(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$a(untrustedConfig);const config=typeCheckConfig$a(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function selectAvatars(recordIds){return recordIds.map(recordId=>{return selectChildren$1({propertyName:recordId});});}// All of the avatars are ingested into
    // the same top level object
    const KEY=`${keyPrefix$4}RecordAvatarsBulk`;function buildInMemorySnapshot$8(lds,config){const sel=selectAvatars(config.recordIds);return lds.storeLookup({recordId:KEY,node:{kind:'Fragment',selections:sel},variables:{}});}/**
     *
     * The third argument, "recordIds", is here because
     * We only want to fetch avatars that are actually missing
     * This list will be a subset of the recordIds that are on the adapter config.
     *
     */function buildNetworkSnapshot$7(lds,config,recordIds){const resourceRequest=getUiApiRecordAvatarsBatchByRecordIds({urlParams:{recordIds},queryParams:{}});return lds.dispatchResourceRequest(resourceRequest).then(response=>{const formatted=response.body.results.reduce((seed,avatar,index)=>{const recordId=recordIds[index];seed[recordId]=avatar;return seed;},{});lds.storeIngest(KEY,resourceRequest,formatted);lds.storeBroadcast();return buildInMemorySnapshot$8(lds,config);},err=>{lds.storeIngestFetchResponse(KEY,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}// We have to type guard against pending snapshots
    // We should only ever get UnfulfilledSnapshot here
    function getRecordIds(config,snapshot){{if(isUnfulfilledSnapshot$1(snapshot)===false){throw new Error('Unexpected snapshot state in "getRecordIds" in "getRecordAvatars"');}}// Missing all avatars
    if(snapshot.data===undefined){return config.recordIds;}return keys$3(snapshot.missingPaths).sort();}const factory$8=lds=>{return refreshable$5(function(unknown){const config=validateAdapterConfig$a(unknown,getRecordAvatars_ConfigPropertyNames);if(config===null){return null;}const cacheLookup=buildInMemorySnapshot$8(lds,config);// CACHE HIT
    if(isFulfilledSnapshot$1(cacheLookup)){return cacheLookup;}// CACHE MISS
    // Only fetch avatars that are missing
    const recordIds=getRecordIds(config,cacheLookup);return buildNetworkSnapshot$7(lds,config,recordIds);},untrusted=>{const config=validateAdapterConfig$a(untrusted,getRecordAvatars_ConfigPropertyNames);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$7(lds,config,config.recordIds);});};const select$j$1=function LeadStatusPicklistValueAttributesRepresentationSelect(){const{selections:AbstractPicklistValueAttributesRepresentationSelections}=select$m$1();return {kind:'Fragment',selections:[...AbstractPicklistValueAttributesRepresentationSelections,{name:'converted',kind:'Scalar'}]};};const select$k$1=function CaseStatusPicklistValueAttributesRepresentationSelect(){const{selections:AbstractPicklistValueAttributesRepresentationSelections}=select$m$1();return {kind:'Fragment',selections:[...AbstractPicklistValueAttributesRepresentationSelections,{name:'closed',kind:'Scalar'}]};};const select$l$1=function OpportunityStagePicklistValueAttributesRepresentationSelect(){const{selections:AbstractPicklistValueAttributesRepresentationSelections}=select$m$1();return {kind:'Fragment',selections:[...AbstractPicklistValueAttributesRepresentationSelections,{name:'closed',kind:'Scalar'},{name:'defaultProbability',kind:'Scalar'},{name:'forecastCategoryName',kind:'Scalar'},{name:'won',kind:'Scalar'}]};};var DiscriminatorValues$2$1;(function(DiscriminatorValues){DiscriminatorValues["LeadStatus"]="LeadStatus";DiscriminatorValues["CaseStatus"]="CaseStatus";DiscriminatorValues["OpportunityStage"]="OpportunityStage";})(DiscriminatorValues$2$1||(DiscriminatorValues$2$1={}));function validate$C(obj,path='AbstractPicklistValueAttributesRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_picklistAtrributesValueType=obj.picklistAtrributesValueType;const path_picklistAtrributesValueType=path+'.picklistAtrributesValueType';if(typeof obj_picklistAtrributesValueType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_picklistAtrributesValueType+'" (at "'+path_picklistAtrributesValueType+'")');}})();return v_error===undefined?null:v_error;}const selectChildren$2$1=function AbstractPicklistValueAttributesRepresentationSelectChildren(params){const{selections:LeadStatusPicklistValueAttributesRepresentationSelections}=select$j$1();const{selections:CaseStatusPicklistValueAttributesRepresentationSelections}=select$k$1();const{selections:OpportunityStagePicklistValueAttributesRepresentationSelections}=select$l$1();return {kind:'Object',name:params.propertyName,nullable:params.nullable,union:true,discriminator:'picklistAtrributesValueType',unionSelections:{[DiscriminatorValues$2$1.LeadStatus]:LeadStatusPicklistValueAttributesRepresentationSelections,[DiscriminatorValues$2$1.CaseStatus]:CaseStatusPicklistValueAttributesRepresentationSelections,[DiscriminatorValues$2$1.OpportunityStage]:OpportunityStagePicklistValueAttributesRepresentationSelections}};};const select$m$1=function AbstractPicklistValueAttributesRepresentationSelect(){return {kind:'Fragment',selections:[{name:'picklistAtrributesValueType',kind:'Scalar'}]};};function validate$D(obj,path='PicklistValueRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_attributes=obj.attributes;const path_attributes=path+'.attributes';let obj_attributes_union0=null;const obj_attributes_union0_error=(()=>{const referenceAbstractPicklistValueAttributesRepresentationValidationError=validate$C(obj_attributes,path_attributes);if(referenceAbstractPicklistValueAttributesRepresentationValidationError!==null){let message='Object doesn\'t match AbstractPicklistValueAttributesRepresentation (at "'+path_attributes+'")\n';message+=referenceAbstractPicklistValueAttributesRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_attributes_union0_error!=null){obj_attributes_union0=obj_attributes_union0_error.message;}let obj_attributes_union1=null;const obj_attributes_union1_error=(()=>{if(obj_attributes!==null){return new TypeError('Expected "null" but received "'+typeof obj_attributes+'" (at "'+path_attributes+'")');}})();if(obj_attributes_union1_error!=null){obj_attributes_union1=obj_attributes_union1_error.message;}if(obj_attributes_union0&&obj_attributes_union1){let message='Object doesn\'t match union (at "'+path_attributes+'")';message+='\n'+obj_attributes_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_attributes_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_validFor=obj.validFor;const path_validFor=path+'.validFor';if(!ArrayIsArray$6(obj_validFor)){return new TypeError('Expected "array" but received "'+typeof obj_validFor+'" (at "'+path_validFor+'")');}for(let i=0;i<obj_validFor.length;i++){const obj_validFor_item=obj_validFor[i];const path_validFor_item=path_validFor+'['+i+']';if(typeof obj_validFor_item!=='number'||typeof obj_validFor_item==='number'&&Math.floor(obj_validFor_item)!==obj_validFor_item){return new TypeError('Expected "integer" but received "'+typeof obj_validFor_item+'" (at "'+path_validFor_item+'")');}}const obj_value=obj.value;const path_value=path+'.value';if(typeof obj_value!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();return v_error===undefined?null:v_error;}const select$n$1=function PicklistValueRepresentationSelect(){const AbstractPicklistValueAttributesRepresentation__unionSelections=selectChildren$2$1({propertyName:'attributes',nullable:true});return {kind:'Fragment',selections:[AbstractPicklistValueAttributesRepresentation__unionSelections,{name:'label',kind:'Scalar'},{name:'validFor',kind:'Scalar',plural:true},{name:'value',kind:'Scalar'}]};};function validate$E(obj,path='PicklistValuesRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_controllerValues=obj.controllerValues;const path_controllerValues=path+'.controllerValues';if(typeof obj_controllerValues!=='object'||ArrayIsArray$6(obj_controllerValues)||obj_controllerValues===null){return new TypeError('Expected "object" but received "'+typeof obj_controllerValues+'" (at "'+path_controllerValues+'")');}const obj_controllerValues_keys=ObjectKeys$5(obj_controllerValues);for(let i=0;i<obj_controllerValues_keys.length;i++){const key=obj_controllerValues_keys[i];const obj_controllerValues_prop=obj_controllerValues[key];const path_controllerValues_prop=path_controllerValues+'["'+key+'"]';if(typeof obj_controllerValues_prop!=='number'||typeof obj_controllerValues_prop==='number'&&Math.floor(obj_controllerValues_prop)!==obj_controllerValues_prop){return new TypeError('Expected "integer" but received "'+typeof obj_controllerValues_prop+'" (at "'+path_controllerValues_prop+'")');}}const obj_defaultValue=obj.defaultValue;const path_defaultValue=path+'.defaultValue';let obj_defaultValue_union0=null;const obj_defaultValue_union0_error=(()=>{const referencePicklistValueRepresentationValidationError=validate$D(obj_defaultValue,path_defaultValue);if(referencePicklistValueRepresentationValidationError!==null){let message='Object doesn\'t match PicklistValueRepresentation (at "'+path_defaultValue+'")\n';message+=referencePicklistValueRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_defaultValue_union0_error!=null){obj_defaultValue_union0=obj_defaultValue_union0_error.message;}let obj_defaultValue_union1=null;const obj_defaultValue_union1_error=(()=>{if(obj_defaultValue!==null){return new TypeError('Expected "null" but received "'+typeof obj_defaultValue+'" (at "'+path_defaultValue+'")');}})();if(obj_defaultValue_union1_error!=null){obj_defaultValue_union1=obj_defaultValue_union1_error.message;}if(obj_defaultValue_union0&&obj_defaultValue_union1){let message='Object doesn\'t match union (at "'+path_defaultValue+'")';message+='\n'+obj_defaultValue_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_defaultValue_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_url=obj.url;const path_url=path+'.url';if(typeof obj_url!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_url+'" (at "'+path_url+'")');}const obj_values=obj.values;const path_values=path+'.values';if(!ArrayIsArray$6(obj_values)){return new TypeError('Expected "array" but received "'+typeof obj_values+'" (at "'+path_values+'")');}for(let i=0;i<obj_values.length;i++){const obj_values_item=obj_values[i];const path_values_item=path_values+'['+i+']';const referencePicklistValueRepresentationValidationError=validate$D(obj_values_item,path_values_item);if(referencePicklistValueRepresentationValidationError!==null){let message='Object doesn\'t match PicklistValueRepresentation (at "'+path_values_item+'")\n';message+=referencePicklistValueRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function keyBuilder$d(config){return keyPrefix$4+'PicklistValuesRepresentation:'+config.id;}function normalize$j(input,existing,path,lds,store,timestamp){return input;}const select$o$1=function PicklistValuesRepresentationSelect(){const{selections:PicklistValueRepresentation__selections,opaque:PicklistValueRepresentation__opaque}=select$n$1();return {kind:'Fragment',selections:[{name:'controllerValues',kind:'Scalar',map:true},{name:'defaultValue',kind:'Object',nullable:true,selections:PicklistValueRepresentation__selections},{name:'url',kind:'Scalar'},{name:'values',kind:'Object',plural:true,selections:PicklistValueRepresentation__selections}]};};function equals$o(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}const ingest$j=function PicklistValuesRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$E(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$d({id:input.url});let incomingRecord=normalize$j(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$o(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return createLink$5(key);};function getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeIdAndFieldApiName(config){const key=keyPrefix$4+'PicklistValuesRepresentation('+'objectApiName:'+config.urlParams.objectApiName+','+'recordTypeId:'+config.urlParams.recordTypeId+','+'fieldApiName:'+config.urlParams.fieldApiName+')';const headers={};return {path:'/services/data/v49.0/ui-api/object-info/'+config.urlParams.objectApiName+'/picklist-values/'+config.urlParams.recordTypeId+'/'+config.urlParams.fieldApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$j,headers};}const adapterName$b='getPicklistValues';function coerceConfig$b(config){const coercedConfig={};const objectApiName=config.objectApiName;if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}const fieldApiName=getFieldApiName(config.fieldApiName);if(fieldApiName!==undefined){coercedConfig.fieldApiName=fieldApiName;}return coercedConfig;}function typeCheckConfig$b(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}const untrustedConfig_fieldApiName=untrustedConfig.fieldApiName;if(typeof untrustedConfig_fieldApiName==='string'){config.fieldApiName=untrustedConfig_fieldApiName;}return config;}function validateAdapterConfig$b(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$b(untrustedConfig);const config=typeCheckConfig$b(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}const path$1=select$o$1().selections;function buildNetworkSnapshot$8(lds,config){const{recordTypeId,fieldApiName}=config;const fieldNames=getFieldId(fieldApiName);const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeIdAndFieldApiName({urlParams:{objectApiName:fieldNames.objectApiName,fieldApiName:fieldNames.fieldApiName,recordTypeId}});const key=keyBuilder$d({id:request.path});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;lds.storeIngest(key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$9(lds,config);},err=>{lds.storeIngestFetchResponse(key,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}function buildInMemorySnapshot$9(lds,config){const fieldNames=getFieldId(config.fieldApiName);const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeIdAndFieldApiName({urlParams:{objectApiName:fieldNames.objectApiName,fieldApiName:fieldNames.fieldApiName,recordTypeId:config.recordTypeId}});const key=keyBuilder$d({id:request.path});return lds.storeLookup({recordId:key,node:{kind:'Fragment',selections:path$1},variables:{}});}const picklistValuesConfigPropertyNames={displayName:adapterName$b,parameters:{required:['recordTypeId','fieldApiName'],optional:[]}};const factory$9=lds=>{return refreshable$5(function(untrusted){const config=validateAdapterConfig$b(untrusted,picklistValuesConfigPropertyNames);if(config===null){return null;}const snapshot=buildInMemorySnapshot$9(lds,config);if(isFulfilledSnapshot$1(snapshot)){return snapshot;}return buildNetworkSnapshot$8(lds,config);},untrusted=>{const config=validateAdapterConfig$b(untrusted,picklistValuesConfigPropertyNames);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$8(lds,config);});};function validate$F(obj,path='PicklistValuesCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_picklistFieldValues=obj.picklistFieldValues;const path_picklistFieldValues=path+'.picklistFieldValues';if(typeof obj_picklistFieldValues!=='object'||ArrayIsArray$6(obj_picklistFieldValues)||obj_picklistFieldValues===null){return new TypeError('Expected "object" but received "'+typeof obj_picklistFieldValues+'" (at "'+path_picklistFieldValues+'")');}const obj_picklistFieldValues_keys=ObjectKeys$5(obj_picklistFieldValues);for(let i=0;i<obj_picklistFieldValues_keys.length;i++){const key=obj_picklistFieldValues_keys[i];const obj_picklistFieldValues_prop=obj_picklistFieldValues[key];const path_picklistFieldValues_prop=path_picklistFieldValues+'["'+key+'"]';if(typeof obj_picklistFieldValues_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_picklistFieldValues_prop+'" (at "'+path_picklistFieldValues_prop+'")');}}})();return v_error===undefined?null:v_error;}function normalize$k(input,existing,path,lds,store,timestamp){const input_picklistFieldValues=input.picklistFieldValues;const input_picklistFieldValues_id=path.fullPath+'__picklistFieldValues';const input_picklistFieldValues_keys=Object.keys(input_picklistFieldValues);const input_picklistFieldValues_length=input_picklistFieldValues_keys.length;for(let i=0;i<input_picklistFieldValues_length;i++){const key=input_picklistFieldValues_keys[i];const input_picklistFieldValues_prop=input_picklistFieldValues[key];const input_picklistFieldValues_prop_id=input_picklistFieldValues_id+'__'+key;input_picklistFieldValues[key]=ingest$j(input_picklistFieldValues_prop,{fullPath:input_picklistFieldValues_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}function equals$p(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_picklistFieldValues=existing.picklistFieldValues;const incoming_picklistFieldValues=incoming.picklistFieldValues;const equals_picklistFieldValues_props=equalsObject(existing_picklistFieldValues,incoming_picklistFieldValues,(existing_picklistFieldValues_prop,incoming_picklistFieldValues_prop)=>{if(!(existing_picklistFieldValues_prop.__ref===incoming_picklistFieldValues_prop.__ref)){return false;}});if(equals_picklistFieldValues_props===false){return false;}return true;}const ingest$k=function PicklistValuesCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$F(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$k(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$p(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return createLink$5(key);};function getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeId(config){const key=keyPrefix$4+'PicklistValuesCollectionRepresentation('+'objectApiName:'+config.urlParams.objectApiName+','+'recordTypeId:'+config.urlParams.recordTypeId+')';const headers={};return {path:'/services/data/v49.0/ui-api/object-info/'+config.urlParams.objectApiName+'/picklist-values/'+config.urlParams.recordTypeId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$k,headers};}const getPicklistValuesByRecordType_ConfigPropertyNames={displayName:'getPicklistValuesByRecordType',parameters:{required:['objectApiName','recordTypeId'],optional:[]}};function coerceConfig$c(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig$c(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$c(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$c(untrustedConfig);const config=typeCheckConfig$c(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function select$p(picklistNames){return [{kind:'Object',name:'picklistFieldValues',selections:picklistNames.map(name=>{return {kind:'Link',name,selections:path$1};})}];}function buildNetworkSnapshot$9(lds,config){const{objectApiName,recordTypeId}=config;const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeId({urlParams:{objectApiName,recordTypeId}});const selectorKey=request.key+'__selector';return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const picklistFieldValueNames=keys$3(body.picklistFieldValues);const sel={recordId:request.key,node:{kind:'Fragment',selections:select$p(picklistFieldValueNames)},variables:{}};// Remember the selector
    lds.storePublish(selectorKey,sel);lds.storeIngest(request.key,request,body);lds.storeBroadcast();return lds.storeLookup(sel);},err=>{lds.storeIngestFetchResponse(request.key,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}function buildInMemorySnapshot$a(lds,config){const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeId({urlParams:{objectApiName:config.objectApiName,recordTypeId:config.recordTypeId}});const selectorKey=request.key+'__selector';const selectorSnapshot=lds.storeLookup({recordId:selectorKey,node:{kind:'Fragment',opaque:true},variables:{}});// We've seen the response for this request before
    if(isFulfilledSnapshot$1(selectorSnapshot)){const cacheSnapshot=lds.storeLookup(selectorSnapshot.data);// Cache hit
    if(isFulfilledSnapshot$1(cacheSnapshot)){return cacheSnapshot;}}return null;}const factory$a=lds=>{return refreshable$5(untrusted=>{const config=validateAdapterConfig$c(untrusted,getPicklistValuesByRecordType_ConfigPropertyNames);if(config===null){return null;}const snapshot=buildInMemorySnapshot$a(lds,config);if(snapshot!==null){return snapshot;}return buildNetworkSnapshot$9(lds,config);},untrusted=>{const config=validateAdapterConfig$c(untrusted,getPicklistValuesByRecordType_ConfigPropertyNames);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$9(lds,config);});};function patchUiApiRecordsByRecordId(config){const key=keyPrefix$4+'RecordRepresentation('+'recordId:'+config.urlParams.recordId+')';const headers={};const header_ifUnmodifiedSince=config.headers.ifUnmodifiedSince;if(header_ifUnmodifiedSince!==undefined){headers['If-Unmodified-Since']=header_ifUnmodifiedSince;}return {path:'/services/data/v49.0/ui-api/records/'+config.urlParams.recordId+'',method:'patch',body:config.body,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$2$1,headers};}const updateRecord_ConfigPropertyNames={displayName:'updateRecord',parameters:{required:['recordId','fields'],optional:['allowSaveOnDuplicate','apiName','ifUnmodifiedSince']}};function coerceConfig$d(config){const coercedConfig={};const recordId=getRecordId18(config.recordId);if(recordId!==undefined){coercedConfig.recordId=recordId;}const allowSaveOnDuplicate=config.allowSaveOnDuplicate;if(allowSaveOnDuplicate!==undefined){coercedConfig.allowSaveOnDuplicate=allowSaveOnDuplicate;}const apiName=config.apiName;if(apiName!==undefined){coercedConfig.apiName=apiName;}const fields=config.fields;if(fields!==undefined){coercedConfig.fields=fields;}const ifUnmodifiedSince=config.ifUnmodifiedSince;if(ifUnmodifiedSince!==undefined){coercedConfig.ifUnmodifiedSince=ifUnmodifiedSince;}return coercedConfig;}function typeCheckConfig$d(untrustedConfig){const config={};const untrustedConfig_recordId=untrustedConfig.recordId;if(typeof untrustedConfig_recordId==='string'){config.recordId=untrustedConfig_recordId;}const untrustedConfig_allowSaveOnDuplicate=untrustedConfig.allowSaveOnDuplicate;if(typeof untrustedConfig_allowSaveOnDuplicate==='boolean'){config.allowSaveOnDuplicate=untrustedConfig_allowSaveOnDuplicate;}const untrustedConfig_apiName=untrustedConfig.apiName;if(typeof untrustedConfig_apiName==='string'){config.apiName=untrustedConfig_apiName;}const untrustedConfig_fields=untrustedConfig.fields;if(untrustedIsObject$5(untrustedConfig_fields)){const untrustedConfig_fields_object={};const untrustedConfig_fields_keys=Object.keys(untrustedConfig_fields);for(let i=0,arrayLength=untrustedConfig_fields_keys.length;i<arrayLength;i++){const key=untrustedConfig_fields_keys[i];const untrustedConfig_fields_prop=untrustedConfig_fields[key];if(typeof untrustedConfig_fields_prop==='string'){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}if(typeof untrustedConfig_fields_prop==='number'){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}if(untrustedConfig_fields_prop===null){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}if(typeof untrustedConfig_fields_prop==='boolean'){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}}if(Object.keys(untrustedConfig_fields_object).length>0){config.fields=untrustedConfig_fields_object;}}const untrustedConfig_ifUnmodifiedSince=untrustedConfig.ifUnmodifiedSince;if(typeof untrustedConfig_ifUnmodifiedSince==='string'){config.ifUnmodifiedSince=untrustedConfig_ifUnmodifiedSince;}return config;}function validateAdapterConfig$d(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$d(untrustedConfig);const config=typeCheckConfig$d(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function getHeaders(clientOptions){const headers={};if(untrustedIsObject$5(clientOptions)){if(typeof clientOptions.ifUnmodifiedSince==='string'){headers.ifUnmodifiedSince=clientOptions.ifUnmodifiedSince;}}return headers;}const factory$b=lds=>{return (untrusted,clientOptions)=>{let config=null;if(untrustedIsObject$5(untrusted)&&untrustedIsObject$5(untrusted.fields)){config=validateAdapterConfig$d(_objectSpread$1({recordId:untrusted.fields.Id},untrusted),updateRecord_ConfigPropertyNames);}// Invalid or incomplete config
    if(config===null){throw new Error('Invalid recordInput');}const{recordId}=config;const headers=getHeaders(clientOptions);const request=patchUiApiRecordsByRecordId({urlParams:{recordId},body:{apiName:config.apiName,fields:config.fields,allowSaveOnDuplicate:config.allowSaveOnDuplicate},headers});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const sel=buildSelectionFromRecord(body);const key=keyBuilder({recordId});lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:key,node:{kind:'Fragment',selections:sel},variables:{}});},err=>{deepFreeze$9(err);throw err;});};};function merge$3(existing,incoming,_lds,_path){if(existing===undefined){return incoming;}// Merge RecordCreateDefaultRecordRepresentationNormalized record field values together
    return _objectSpread$1({},incoming,{fields:_objectSpread$1({},existing.fields,incoming.fields)});}function validate$H(obj,path='RecordCreateDefaultRecordRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_childRelationships=obj.childRelationships;const path_childRelationships=path+'.childRelationships';if(typeof obj_childRelationships!=='object'||ArrayIsArray$6(obj_childRelationships)||obj_childRelationships===null){return new TypeError('Expected "object" but received "'+typeof obj_childRelationships+'" (at "'+path_childRelationships+'")');}const obj_childRelationships_keys=ObjectKeys$5(obj_childRelationships);for(let i=0;i<obj_childRelationships_keys.length;i++){const key=obj_childRelationships_keys[i];const obj_childRelationships_prop=obj_childRelationships[key];const path_childRelationships_prop=path_childRelationships+'["'+key+'"]';if(typeof obj_childRelationships_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_childRelationships_prop+'" (at "'+path_childRelationships_prop+'")');}}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$6(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$5(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];const path_fields_prop=path_fields+'["'+key+'"]';if(typeof obj_fields_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_fields_prop+'" (at "'+path_fields_prop+'")');}}const obj_id=obj.id;const path_id=path+'.id';if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_lastModifiedById=obj.lastModifiedById;const path_lastModifiedById=path+'.lastModifiedById';let obj_lastModifiedById_union0=null;const obj_lastModifiedById_union0_error=(()=>{if(typeof obj_lastModifiedById!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union0_error!=null){obj_lastModifiedById_union0=obj_lastModifiedById_union0_error.message;}let obj_lastModifiedById_union1=null;const obj_lastModifiedById_union1_error=(()=>{if(obj_lastModifiedById!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union1_error!=null){obj_lastModifiedById_union1=obj_lastModifiedById_union1_error.message;}if(obj_lastModifiedById_union0&&obj_lastModifiedById_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedById+'")';message+='\n'+obj_lastModifiedById_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedById_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_lastModifiedDate=obj.lastModifiedDate;const path_lastModifiedDate=path+'.lastModifiedDate';let obj_lastModifiedDate_union0=null;const obj_lastModifiedDate_union0_error=(()=>{if(typeof obj_lastModifiedDate!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union0_error!=null){obj_lastModifiedDate_union0=obj_lastModifiedDate_union0_error.message;}let obj_lastModifiedDate_union1=null;const obj_lastModifiedDate_union1_error=(()=>{if(obj_lastModifiedDate!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union1_error!=null){obj_lastModifiedDate_union1=obj_lastModifiedDate_union1_error.message;}if(obj_lastModifiedDate_union0&&obj_lastModifiedDate_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedDate+'")';message+='\n'+obj_lastModifiedDate_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedDate_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';let obj_recordTypeId_union0=null;const obj_recordTypeId_union0_error=(()=>{if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();if(obj_recordTypeId_union0_error!=null){obj_recordTypeId_union0=obj_recordTypeId_union0_error.message;}let obj_recordTypeId_union1=null;const obj_recordTypeId_union1_error=(()=>{if(obj_recordTypeId!==null){return new TypeError('Expected "null" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();if(obj_recordTypeId_union1_error!=null){obj_recordTypeId_union1=obj_recordTypeId_union1_error.message;}if(obj_recordTypeId_union0&&obj_recordTypeId_union1){let message='Object doesn\'t match union (at "'+path_recordTypeId+'")';message+='\n'+obj_recordTypeId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_recordTypeId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recordTypeInfo=obj.recordTypeInfo;const path_recordTypeInfo=path+'.recordTypeInfo';let obj_recordTypeInfo_union0=null;const obj_recordTypeInfo_union0_error=(()=>{const referenceRecordTypeInfoRepresentationValidationError=validate$9(obj_recordTypeInfo,path_recordTypeInfo);if(referenceRecordTypeInfoRepresentationValidationError!==null){let message='Object doesn\'t match RecordTypeInfoRepresentation (at "'+path_recordTypeInfo+'")\n';message+=referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_recordTypeInfo_union0_error!=null){obj_recordTypeInfo_union0=obj_recordTypeInfo_union0_error.message;}let obj_recordTypeInfo_union1=null;const obj_recordTypeInfo_union1_error=(()=>{if(obj_recordTypeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_recordTypeInfo+'" (at "'+path_recordTypeInfo+'")');}})();if(obj_recordTypeInfo_union1_error!=null){obj_recordTypeInfo_union1=obj_recordTypeInfo_union1_error.message;}if(obj_recordTypeInfo_union0&&obj_recordTypeInfo_union1){let message='Object doesn\'t match union (at "'+path_recordTypeInfo+'")';message+='\n'+obj_recordTypeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_recordTypeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_systemModstamp=obj.systemModstamp;const path_systemModstamp=path+'.systemModstamp';let obj_systemModstamp_union0=null;const obj_systemModstamp_union0_error=(()=>{if(typeof obj_systemModstamp!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union0_error!=null){obj_systemModstamp_union0=obj_systemModstamp_union0_error.message;}let obj_systemModstamp_union1=null;const obj_systemModstamp_union1_error=(()=>{if(obj_systemModstamp!==null){return new TypeError('Expected "null" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union1_error!=null){obj_systemModstamp_union1=obj_systemModstamp_union1_error.message;}if(obj_systemModstamp_union0&&obj_systemModstamp_union1){let message='Object doesn\'t match union (at "'+path_systemModstamp+'")';message+='\n'+obj_systemModstamp_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_systemModstamp_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_weakEtag=obj.weakEtag;const path_weakEtag=path+'.weakEtag';if(typeof obj_weakEtag!=='number'||typeof obj_weakEtag==='number'&&Math.floor(obj_weakEtag)!==obj_weakEtag){return new TypeError('Expected "integer" but received "'+typeof obj_weakEtag+'" (at "'+path_weakEtag+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$e(config){return keyPrefix$4+'RecordCreateDefaultRecordRepresentation:'+config.apiName+':'+(config.recordTypeId===null?'':config.recordTypeId);}function normalize$l(input,existing,path,lds,store,timestamp){const input_childRelationships=input.childRelationships;const input_childRelationships_id=path.fullPath+'__childRelationships';const input_childRelationships_keys=Object.keys(input_childRelationships);const input_childRelationships_length=input_childRelationships_keys.length;for(let i=0;i<input_childRelationships_length;i++){const key=input_childRelationships_keys[i];const input_childRelationships_prop=input_childRelationships[key];const input_childRelationships_prop_id=input_childRelationships_id+'__'+key;input_childRelationships[key]=ingest$5(input_childRelationships_prop,{fullPath:input_childRelationships_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}const input_fields=input.fields;const input_fields_id=path.fullPath+'__fields';const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];const input_fields_prop=input_fields[key];const input_fields_prop_id=input_fields_id+'__'+key;input_fields[key]=ingest$1$1(input_fields_prop,{fullPath:input_fields_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}function equals$q(existing,incoming){const existing_weakEtag=existing.weakEtag;const incoming_weakEtag=incoming.weakEtag;if(!(existing_weakEtag===incoming_weakEtag)){return false;}const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_childRelationships=existing.childRelationships;const incoming_childRelationships=incoming.childRelationships;const equals_childRelationships_props=equalsObject(existing_childRelationships,incoming_childRelationships,(existing_childRelationships_prop,incoming_childRelationships_prop)=>{if(!(existing_childRelationships_prop.__ref===incoming_childRelationships_prop.__ref)){return false;}});if(equals_childRelationships_props===false){return false;}const existing_fields=existing.fields;const incoming_fields=incoming.fields;const equals_fields_props=equalsObject(existing_fields,incoming_fields,(existing_fields_prop,incoming_fields_prop)=>{if(!(existing_fields_prop.__ref===incoming_fields_prop.__ref)){return false;}});if(equals_fields_props===false){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_lastModifiedById=existing.lastModifiedById;const incoming_lastModifiedById=incoming.lastModifiedById;if(!(existing_lastModifiedById===incoming_lastModifiedById)){return false;}const existing_lastModifiedDate=existing.lastModifiedDate;const incoming_lastModifiedDate=incoming.lastModifiedDate;if(!(existing_lastModifiedDate===incoming_lastModifiedDate)){return false;}const existing_recordTypeId=existing.recordTypeId;const incoming_recordTypeId=incoming.recordTypeId;if(!(existing_recordTypeId===incoming_recordTypeId)){return false;}const existing_recordTypeInfo=existing.recordTypeInfo;const incoming_recordTypeInfo=incoming.recordTypeInfo;if(!(existing_recordTypeInfo===incoming_recordTypeInfo||existing_recordTypeInfo!=null&&incoming_recordTypeInfo!=null&&equals$5(existing_recordTypeInfo,incoming_recordTypeInfo))){return false;}const existing_systemModstamp=existing.systemModstamp;const incoming_systemModstamp=incoming.systemModstamp;if(!(existing_systemModstamp===incoming_systemModstamp)){return false;}return true;}const ingest$l=function RecordCreateDefaultRecordRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$H(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$e({apiName:input.apiName,recordTypeId:input.recordTypeId});let incomingRecord=normalize$l(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];incomingRecord=merge$3(existingRecord,incomingRecord);if(existingRecord===undefined||equals$q(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$I(obj,path='RecordDefaultsRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_layout=obj.layout;const path_layout=path+'.layout';let obj_layout_union0=null;const obj_layout_union0_error=(()=>{if(typeof obj_layout!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_layout+'" (at "'+path_layout+'")');}})();if(obj_layout_union0_error!=null){obj_layout_union0=obj_layout_union0_error.message;}let obj_layout_union1=null;const obj_layout_union1_error=(()=>{if(obj_layout!==null){return new TypeError('Expected "null" but received "'+typeof obj_layout+'" (at "'+path_layout+'")');}})();if(obj_layout_union1_error!=null){obj_layout_union1=obj_layout_union1_error.message;}if(obj_layout_union0&&obj_layout_union1){let message='Object doesn\'t match union (at "'+path_layout+'")';message+='\n'+obj_layout_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_layout_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_objectInfos=obj.objectInfos;const path_objectInfos=path+'.objectInfos';if(typeof obj_objectInfos!=='object'||ArrayIsArray$6(obj_objectInfos)||obj_objectInfos===null){return new TypeError('Expected "object" but received "'+typeof obj_objectInfos+'" (at "'+path_objectInfos+'")');}const obj_objectInfos_keys=ObjectKeys$5(obj_objectInfos);for(let i=0;i<obj_objectInfos_keys.length;i++){const key=obj_objectInfos_keys[i];const obj_objectInfos_prop=obj_objectInfos[key];const path_objectInfos_prop=path_objectInfos+'["'+key+'"]';if(typeof obj_objectInfos_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_objectInfos_prop+'" (at "'+path_objectInfos_prop+'")');}}const obj_record=obj.record;const path_record=path+'.record';if(typeof obj_record!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_record+'" (at "'+path_record+'")');}})();return v_error===undefined?null:v_error;}function normalize$m(input,existing,path,lds,store,timestamp){const input_layout=input.layout;const input_layout_id=path.fullPath+'__layout';if(input_layout!==null&&typeof input_layout==='object'){input.layout=ingest$3$1(input_layout,{fullPath:input_layout_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}const input_objectInfos=input.objectInfos;const input_objectInfos_id=path.fullPath+'__objectInfos';const input_objectInfos_keys=Object.keys(input_objectInfos);const input_objectInfos_length=input_objectInfos_keys.length;for(let i=0;i<input_objectInfos_length;i++){const key=input_objectInfos_keys[i];const input_objectInfos_prop=input_objectInfos[key];const input_objectInfos_prop_id=input_objectInfos_id+'__'+key;input_objectInfos[key]=ingest$a(input_objectInfos_prop,{fullPath:input_objectInfos_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}const input_record=input.record;const input_record_id=path.fullPath+'__record';input.record=ingest$l(input_record,{fullPath:input_record_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);return input;}function equals$r(existing,incoming){const existing_layout=existing.layout;const incoming_layout=incoming.layout;if(!(existing_layout===incoming_layout||existing_layout!=null&&incoming_layout!=null&&existing_layout.__ref!=null&&incoming_layout.__ref!=null&&existing_layout.__ref===incoming_layout.__ref)){return false;}const existing_objectInfos=existing.objectInfos;const incoming_objectInfos=incoming.objectInfos;const equals_objectInfos_props=equalsObject(existing_objectInfos,incoming_objectInfos,(existing_objectInfos_prop,incoming_objectInfos_prop)=>{if(!(existing_objectInfos_prop.__ref===incoming_objectInfos_prop.__ref)){return false;}});if(equals_objectInfos_props===false){return false;}const existing_record=existing.record;const incoming_record=incoming.record;if(!(existing_record.__ref===incoming_record.__ref)){return false;}return true;}const ingest$m=function RecordDefaultsRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$I(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$m(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$r(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return createLink$5(key);};function getUiApiRecordDefaultsCreateByObjectApiName(config){const key=keyPrefix$4+'RecordDefaultsRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'optionalFields:'+config.queryParams.optionalFields+','+'recordTypeId:'+config.queryParams.recordTypeId+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v49.0/ui-api/record-defaults/create/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$m,headers};}const getRecordCreateDefaults_ConfigPropertyNames={displayName:'getRecordCreateDefaults',parameters:{required:['objectApiName'],optional:['formFactor','optionalFields','recordTypeId']}};function coerceConfig$e(config){const coercedConfig={};const objectApiName=getObjectApiName(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig$f(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$5(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$f(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$e(untrustedConfig);const config=typeCheckConfig$f(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}const layoutSelections$3=select$5();const objectInfoSelections=select$9();function buildSelector(resp){const recordSelections=buildSelectionFromRecord(resp.record);return [{kind:'Link',name:'layout',nullable:true,selections:layoutSelections$3.selections},{kind:'Link',name:'objectInfos',map:true,selections:objectInfoSelections.selections},{kind:'Link',name:'record',selections:recordSelections}];}function buildNetworkSnapshot$a(lds,config){const{formFactor,optionalFields,recordTypeId}=config;const request=getUiApiRecordDefaultsCreateByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{formFactor,optionalFields,recordTypeId}});const{key}=request;const selectorKey=`${key}__selector`;return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;// TODO W-6399239 - fix API so we don't have to augment the response with request details in order
    // to support refresh. these are never emitted out per (private).
    if(body.layout!==null){body.layout.apiName=config.objectApiName;body.layout.recordTypeId=recordTypeId;}const cacheSelector={recordId:key,node:{kind:'Fragment',selections:buildSelector(body)},variables:{}};lds.storePublish(selectorKey,cacheSelector);lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup(cacheSelector);},err=>{lds.storeIngestFetchResponse(key,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}function coerceConfigWithDefaults$5(untrusted){const config=validateAdapterConfig$f(untrusted,getRecordCreateDefaults_ConfigPropertyNames);if(config===null){return null;}let formFactor=config.formFactor;if(formFactor===undefined){if(untrusted.formFactor===undefined){formFactor=FormFactor$1.Large;}else {return null;}}const recordTypeId=config.recordTypeId===undefined?MASTER_RECORD_TYPE_ID:config.recordTypeId;const optionalFields=config.optionalFields===undefined?[]:config.optionalFields;return _objectSpread$1({},config,{formFactor,recordTypeId,optionalFields});}function buildInMemorySnapshot$b(lds,config){const{formFactor,optionalFields,recordTypeId}=config;const request=getUiApiRecordDefaultsCreateByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{formFactor,optionalFields,recordTypeId}});const{key}=request;const selectorKey=`${key}__selector`;/**
         * getRecordCreateDefaults returns a value that includes a map of ObjectInfos,
         * a layout and a record. The returned record includes fields that are not
         * known to the client. Because we don't know what the return shape will be,
         * we have to store a selector from a previous response and see if we can
         * extract those values back out.
         *
         * cacheSnapshot is the cached selector from a previous request. It is just
         * a stashed selector
         */const cacheSnapshot=lds.storeLookup({recordId:selectorKey,node:{kind:'Fragment',opaque:true},variables:{}});// We've seen this request before
    if(isFulfilledSnapshot$1(cacheSnapshot)){const snapshot=lds.storeLookup(cacheSnapshot.data);// Cache hit
    if(isFulfilledSnapshot$1(snapshot)){return snapshot;}}return null;}const factory$e=lds=>{return refreshable$5(untrusted=>{const config=coerceConfigWithDefaults$5(untrusted);if(config===null){return null;}const snapshot=buildInMemorySnapshot$b(lds,config);if(snapshot!==null){return snapshot;}return buildNetworkSnapshot$a(lds,config);},untrusted=>{const config=coerceConfigWithDefaults$5(untrusted);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return buildNetworkSnapshot$a(lds,config);});};/**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */function getObjectApiNamesArray(value){const valueArray=isArray$3(value)?value:[value];const array=[];for(let i=0,len=valueArray.length;i<len;i+=1){const item=valueArray[i];const apiName=getObjectApiName(item);if(apiName===undefined){return undefined;}push$1.call(array,apiName);}if(array.length===0){return undefined;}return dedupe(array).sort();}function validate$J(obj,path='PlatformActionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_actionListContext=obj.actionListContext;const path_actionListContext=path+'.actionListContext';if(typeof obj_actionListContext!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionListContext+'" (at "'+path_actionListContext+'")');}const obj_actionTarget=obj.actionTarget;const path_actionTarget=path+'.actionTarget';let obj_actionTarget_union0=null;const obj_actionTarget_union0_error=(()=>{if(typeof obj_actionTarget!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionTarget+'" (at "'+path_actionTarget+'")');}})();if(obj_actionTarget_union0_error!=null){obj_actionTarget_union0=obj_actionTarget_union0_error.message;}let obj_actionTarget_union1=null;const obj_actionTarget_union1_error=(()=>{if(obj_actionTarget!==null){return new TypeError('Expected "null" but received "'+typeof obj_actionTarget+'" (at "'+path_actionTarget+'")');}})();if(obj_actionTarget_union1_error!=null){obj_actionTarget_union1=obj_actionTarget_union1_error.message;}if(obj_actionTarget_union0&&obj_actionTarget_union1){let message='Object doesn\'t match union (at "'+path_actionTarget+'")';message+='\n'+obj_actionTarget_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_actionTarget_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_actionTargetType=obj.actionTargetType;const path_actionTargetType=path+'.actionTargetType';let obj_actionTargetType_union0=null;const obj_actionTargetType_union0_error=(()=>{if(typeof obj_actionTargetType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionTargetType+'" (at "'+path_actionTargetType+'")');}})();if(obj_actionTargetType_union0_error!=null){obj_actionTargetType_union0=obj_actionTargetType_union0_error.message;}let obj_actionTargetType_union1=null;const obj_actionTargetType_union1_error=(()=>{if(obj_actionTargetType!==null){return new TypeError('Expected "null" but received "'+typeof obj_actionTargetType+'" (at "'+path_actionTargetType+'")');}})();if(obj_actionTargetType_union1_error!=null){obj_actionTargetType_union1=obj_actionTargetType_union1_error.message;}if(obj_actionTargetType_union0&&obj_actionTargetType_union1){let message='Object doesn\'t match union (at "'+path_actionTargetType+'")';message+='\n'+obj_actionTargetType_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_actionTargetType_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_externalId=obj.externalId;const path_externalId=path+'.externalId';if(typeof obj_externalId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_externalId+'" (at "'+path_externalId+'")');}const obj_iconUrl=obj.iconUrl;const path_iconUrl=path+'.iconUrl';let obj_iconUrl_union0=null;const obj_iconUrl_union0_error=(()=>{if(typeof obj_iconUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union0_error!=null){obj_iconUrl_union0=obj_iconUrl_union0_error.message;}let obj_iconUrl_union1=null;const obj_iconUrl_union1_error=(()=>{if(obj_iconUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union1_error!=null){obj_iconUrl_union1=obj_iconUrl_union1_error.message;}if(obj_iconUrl_union0&&obj_iconUrl_union1){let message='Object doesn\'t match union (at "'+path_iconUrl+'")';message+='\n'+obj_iconUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_iconUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_isMassAction=obj.isMassAction;const path_isMassAction=path+'.isMassAction';if(typeof obj_isMassAction!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_isMassAction+'" (at "'+path_isMassAction+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_primaryColor=obj.primaryColor;const path_primaryColor=path+'.primaryColor';let obj_primaryColor_union0=null;const obj_primaryColor_union0_error=(()=>{if(typeof obj_primaryColor!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_primaryColor+'" (at "'+path_primaryColor+'")');}})();if(obj_primaryColor_union0_error!=null){obj_primaryColor_union0=obj_primaryColor_union0_error.message;}let obj_primaryColor_union1=null;const obj_primaryColor_union1_error=(()=>{if(obj_primaryColor!==null){return new TypeError('Expected "null" but received "'+typeof obj_primaryColor+'" (at "'+path_primaryColor+'")');}})();if(obj_primaryColor_union1_error!=null){obj_primaryColor_union1=obj_primaryColor_union1_error.message;}if(obj_primaryColor_union0&&obj_primaryColor_union1){let message='Object doesn\'t match union (at "'+path_primaryColor+'")';message+='\n'+obj_primaryColor_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_primaryColor_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_relatedListRecordId=obj.relatedListRecordId;const path_relatedListRecordId=path+'.relatedListRecordId';let obj_relatedListRecordId_union0=null;const obj_relatedListRecordId_union0_error=(()=>{if(typeof obj_relatedListRecordId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relatedListRecordId+'" (at "'+path_relatedListRecordId+'")');}})();if(obj_relatedListRecordId_union0_error!=null){obj_relatedListRecordId_union0=obj_relatedListRecordId_union0_error.message;}let obj_relatedListRecordId_union1=null;const obj_relatedListRecordId_union1_error=(()=>{if(obj_relatedListRecordId!==null){return new TypeError('Expected "null" but received "'+typeof obj_relatedListRecordId+'" (at "'+path_relatedListRecordId+'")');}})();if(obj_relatedListRecordId_union1_error!=null){obj_relatedListRecordId_union1=obj_relatedListRecordId_union1_error.message;}if(obj_relatedListRecordId_union0&&obj_relatedListRecordId_union1){let message='Object doesn\'t match union (at "'+path_relatedListRecordId+'")';message+='\n'+obj_relatedListRecordId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_relatedListRecordId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_relatedSourceObject=obj.relatedSourceObject;const path_relatedSourceObject=path+'.relatedSourceObject';let obj_relatedSourceObject_union0=null;const obj_relatedSourceObject_union0_error=(()=>{if(typeof obj_relatedSourceObject!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relatedSourceObject+'" (at "'+path_relatedSourceObject+'")');}})();if(obj_relatedSourceObject_union0_error!=null){obj_relatedSourceObject_union0=obj_relatedSourceObject_union0_error.message;}let obj_relatedSourceObject_union1=null;const obj_relatedSourceObject_union1_error=(()=>{if(obj_relatedSourceObject!==null){return new TypeError('Expected "null" but received "'+typeof obj_relatedSourceObject+'" (at "'+path_relatedSourceObject+'")');}})();if(obj_relatedSourceObject_union1_error!=null){obj_relatedSourceObject_union1=obj_relatedSourceObject_union1_error.message;}if(obj_relatedSourceObject_union0&&obj_relatedSourceObject_union1){let message='Object doesn\'t match union (at "'+path_relatedSourceObject+'")';message+='\n'+obj_relatedSourceObject_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_relatedSourceObject_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_section=obj.section;const path_section=path+'.section';let obj_section_union0=null;const obj_section_union0_error=(()=>{if(typeof obj_section!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_section+'" (at "'+path_section+'")');}})();if(obj_section_union0_error!=null){obj_section_union0=obj_section_union0_error.message;}let obj_section_union1=null;const obj_section_union1_error=(()=>{if(obj_section!==null){return new TypeError('Expected "null" but received "'+typeof obj_section+'" (at "'+path_section+'")');}})();if(obj_section_union1_error!=null){obj_section_union1=obj_section_union1_error.message;}if(obj_section_union0&&obj_section_union1){let message='Object doesn\'t match union (at "'+path_section+'")';message+='\n'+obj_section_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_section_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_sourceObject=obj.sourceObject;const path_sourceObject=path+'.sourceObject';if(typeof obj_sourceObject!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_sourceObject+'" (at "'+path_sourceObject+'")');}const obj_subtype=obj.subtype;const path_subtype=path+'.subtype';let obj_subtype_union0=null;const obj_subtype_union0_error=(()=>{if(typeof obj_subtype!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_subtype+'" (at "'+path_subtype+'")');}})();if(obj_subtype_union0_error!=null){obj_subtype_union0=obj_subtype_union0_error.message;}let obj_subtype_union1=null;const obj_subtype_union1_error=(()=>{if(obj_subtype!==null){return new TypeError('Expected "null" but received "'+typeof obj_subtype+'" (at "'+path_subtype+'")');}})();if(obj_subtype_union1_error!=null){obj_subtype_union1=obj_subtype_union1_error.message;}if(obj_subtype_union0&&obj_subtype_union1){let message='Object doesn\'t match union (at "'+path_subtype+'")';message+='\n'+obj_subtype_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_subtype_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_targetObject=obj.targetObject;const path_targetObject=path+'.targetObject';let obj_targetObject_union0=null;const obj_targetObject_union0_error=(()=>{if(typeof obj_targetObject!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_targetObject+'" (at "'+path_targetObject+'")');}})();if(obj_targetObject_union0_error!=null){obj_targetObject_union0=obj_targetObject_union0_error.message;}let obj_targetObject_union1=null;const obj_targetObject_union1_error=(()=>{if(obj_targetObject!==null){return new TypeError('Expected "null" but received "'+typeof obj_targetObject+'" (at "'+path_targetObject+'")');}})();if(obj_targetObject_union1_error!=null){obj_targetObject_union1=obj_targetObject_union1_error.message;}if(obj_targetObject_union0&&obj_targetObject_union1){let message='Object doesn\'t match union (at "'+path_targetObject+'")';message+='\n'+obj_targetObject_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_targetObject_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_targetUrl=obj.targetUrl;const path_targetUrl=path+'.targetUrl';let obj_targetUrl_union0=null;const obj_targetUrl_union0_error=(()=>{if(typeof obj_targetUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_targetUrl+'" (at "'+path_targetUrl+'")');}})();if(obj_targetUrl_union0_error!=null){obj_targetUrl_union0=obj_targetUrl_union0_error.message;}let obj_targetUrl_union1=null;const obj_targetUrl_union1_error=(()=>{if(obj_targetUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_targetUrl+'" (at "'+path_targetUrl+'")');}})();if(obj_targetUrl_union1_error!=null){obj_targetUrl_union1=obj_targetUrl_union1_error.message;}if(obj_targetUrl_union0&&obj_targetUrl_union1){let message='Object doesn\'t match union (at "'+path_targetUrl+'")';message+='\n'+obj_targetUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_targetUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_type=obj.type;const path_type=path+'.type';if(typeof obj_type!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_type+'" (at "'+path_type+'")');}})();return v_error===undefined?null:v_error;}const select$q=function PlatformActionRepresentationSelect(){return {kind:'Fragment',selections:[{name:'actionListContext',kind:'Scalar'},{name:'actionTarget',kind:'Scalar'},{name:'actionTargetType',kind:'Scalar'},{name:'apiName',kind:'Scalar'},{name:'externalId',kind:'Scalar'},{name:'iconUrl',kind:'Scalar'},{name:'id',kind:'Scalar'},{name:'isMassAction',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'primaryColor',kind:'Scalar'},{name:'relatedListRecordId',kind:'Scalar'},{name:'relatedSourceObject',kind:'Scalar'},{name:'section',kind:'Scalar'},{name:'sourceObject',kind:'Scalar'},{name:'subtype',kind:'Scalar'},{name:'targetObject',kind:'Scalar'},{name:'targetUrl',kind:'Scalar'},{name:'type',kind:'Scalar'}]};};function equals$s(existing,incoming){const existing_actionListContext=existing.actionListContext;const incoming_actionListContext=incoming.actionListContext;if(!(existing_actionListContext===incoming_actionListContext)){return false;}const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_externalId=existing.externalId;const incoming_externalId=incoming.externalId;if(!(existing_externalId===incoming_externalId)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_isMassAction=existing.isMassAction;const incoming_isMassAction=incoming.isMassAction;if(!(existing_isMassAction===incoming_isMassAction)){return false;}const existing_label=existing.label;const incoming_label=incoming.label;if(!(existing_label===incoming_label)){return false;}const existing_sourceObject=existing.sourceObject;const incoming_sourceObject=incoming.sourceObject;if(!(existing_sourceObject===incoming_sourceObject)){return false;}const existing_type=existing.type;const incoming_type=incoming.type;if(!(existing_type===incoming_type)){return false;}const existing_actionTarget=existing.actionTarget;const incoming_actionTarget=incoming.actionTarget;if(!(existing_actionTarget===incoming_actionTarget)){return false;}const existing_actionTargetType=existing.actionTargetType;const incoming_actionTargetType=incoming.actionTargetType;if(!(existing_actionTargetType===incoming_actionTargetType)){return false;}const existing_iconUrl=existing.iconUrl;const incoming_iconUrl=incoming.iconUrl;if(!(existing_iconUrl===incoming_iconUrl)){return false;}const existing_primaryColor=existing.primaryColor;const incoming_primaryColor=incoming.primaryColor;if(!(existing_primaryColor===incoming_primaryColor)){return false;}const existing_relatedListRecordId=existing.relatedListRecordId;const incoming_relatedListRecordId=incoming.relatedListRecordId;if(!(existing_relatedListRecordId===incoming_relatedListRecordId)){return false;}const existing_relatedSourceObject=existing.relatedSourceObject;const incoming_relatedSourceObject=incoming.relatedSourceObject;if(!(existing_relatedSourceObject===incoming_relatedSourceObject)){return false;}const existing_section=existing.section;const incoming_section=incoming.section;if(!(existing_section===incoming_section)){return false;}const existing_subtype=existing.subtype;const incoming_subtype=incoming.subtype;if(!(existing_subtype===incoming_subtype)){return false;}const existing_targetObject=existing.targetObject;const incoming_targetObject=incoming.targetObject;if(!(existing_targetObject===incoming_targetObject)){return false;}const existing_targetUrl=existing.targetUrl;const incoming_targetUrl=incoming.targetUrl;if(!(existing_targetUrl===incoming_targetUrl)){return false;}return true;}function validate$K(obj,path='EntityActionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_actions=obj.actions;const path_actions=path+'.actions';if(!ArrayIsArray$6(obj_actions)){return new TypeError('Expected "array" but received "'+typeof obj_actions+'" (at "'+path_actions+'")');}for(let i=0;i<obj_actions.length;i++){const obj_actions_item=obj_actions[i];const path_actions_item=path_actions+'['+i+']';const referencePlatformActionRepresentationValidationError=validate$J(obj_actions_item,path_actions_item);if(referencePlatformActionRepresentationValidationError!==null){let message='Object doesn\'t match PlatformActionRepresentation (at "'+path_actions_item+'")\n';message+=referencePlatformActionRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_links=obj.links;const path_links=path+'.links';if(!ArrayIsArray$6(obj_links)){return new TypeError('Expected "array" but received "'+typeof obj_links+'" (at "'+path_links+'")');}for(let i=0;i<obj_links.length;i++){const obj_links_item=obj_links[i];const path_links_item=path_links+'['+i+']';if(typeof obj_links_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_links_item+'" (at "'+path_links_item+'")');}}const obj_url=obj.url;const path_url=path+'.url';if(typeof obj_url!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_url+'" (at "'+path_url+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$f(config){return keyPrefix$4+'EntityActionRepresentation:'+config.url;}function normalize$n(input,existing,path,lds,store,timestamp){return input;}const select$r=function EntityActionRepresentationSelect(){const{selections:PlatformActionRepresentation__selections,opaque:PlatformActionRepresentation__opaque}=select$q();return {kind:'Fragment',selections:[{name:'actions',kind:'Object',plural:true,selections:PlatformActionRepresentation__selections}]};};function equals$t(existing,incoming){const existing_url=existing.url;const incoming_url=incoming.url;if(!(existing_url===incoming_url)){return false;}const existing_actions=existing.actions;const incoming_actions=incoming.actions;const equals_actions_items=equalsArray(existing_actions,incoming_actions,(existing_actions_item,incoming_actions_item)=>{if(!equals$s(existing_actions_item,incoming_actions_item)){return false;}});if(equals_actions_items===false){return false;}const existing_links=existing.links;const incoming_links=incoming.links;const equals_links_items=equalsArray(existing_links,incoming_links,(existing_links_item,incoming_links_item)=>{if(!(existing_links_item===incoming_links_item)){return false;}});if(equals_links_items===false){return false;}return true;}const ingest$n=function EntityActionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$K(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$f({url:input.url});let incomingRecord=normalize$n(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$t(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};const TTL$3=300000;function validate$L(obj,path='ActionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_actions=obj.actions;const path_actions=path+'.actions';if(typeof obj_actions!=='object'||ArrayIsArray$6(obj_actions)||obj_actions===null){return new TypeError('Expected "object" but received "'+typeof obj_actions+'" (at "'+path_actions+'")');}const obj_actions_keys=ObjectKeys$5(obj_actions);for(let i=0;i<obj_actions_keys.length;i++){const key=obj_actions_keys[i];const obj_actions_prop=obj_actions[key];const path_actions_prop=path_actions+'["'+key+'"]';if(typeof obj_actions_prop!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_actions_prop+'" (at "'+path_actions_prop+'")');}}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_url=obj.url;const path_url=path+'.url';if(typeof obj_url!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_url+'" (at "'+path_url+'")');}})();return v_error===undefined?null:v_error;}function normalize$o(input,existing,path,lds,store,timestamp){const input_actions=input.actions;const input_actions_id=path.fullPath+'__actions';const input_actions_keys=Object.keys(input_actions);const input_actions_length=input_actions_keys.length;for(let i=0;i<input_actions_length;i++){const key=input_actions_keys[i];const input_actions_prop=input_actions[key];const input_actions_prop_id=input_actions_id+'__'+key;input_actions[key]=ingest$n(input_actions_prop,{fullPath:input_actions_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store);}return input;}const select$s=function ActionRepresentationSelect(){const{selections:EntityActionRepresentation__selections,opaque:EntityActionRepresentation__opaque}=select$r();return {kind:'Fragment',selections:[{name:'actions',kind:'Link',map:true,selections:EntityActionRepresentation__selections}]};};function equals$u(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_url=existing.url;const incoming_url=incoming.url;if(!(existing_url===incoming_url)){return false;}const existing_actions=existing.actions;const incoming_actions=incoming.actions;const equals_actions_props=equalsObject(existing_actions,incoming_actions,(existing_actions_prop,incoming_actions_prop)=>{if(!(existing_actions_prop.__ref===incoming_actions_prop.__ref)){return false;}});if(equals_actions_props===false){return false;}return true;}const ingest$o=function ActionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$L(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$o(input,store.records[key],{fullPath:key,parent:path.parent},lds,store);const existingRecord=store.records[key];if(existingRecord===undefined||equals$u(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return createLink$5(key);};function getUiApiActionsLookupByObjectApiNames(config){const key=keyPrefix$4+'ActionRepresentation('+'actionTypes:'+config.queryParams.actionTypes+','+'formFactor:'+config.queryParams.formFactor+','+'sections:'+config.queryParams.sections+','+'objectApiNames:'+config.urlParams.objectApiNames+')';const headers={};return {path:'/services/data/v49.0/ui-api/actions/lookup/'+config.urlParams.objectApiNames+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$o,headers};}const getLookupActions_ConfigPropertyNames={displayName:'getLookupActions',parameters:{required:['objectApiNames'],optional:['actionTypes','formFactor','sections']}};function coerceConfig$f(config){const coercedConfig={};const objectApiNames=getObjectApiNamesArray(config.objectApiNames);if(objectApiNames!==undefined){coercedConfig.objectApiNames=objectApiNames;}const actionTypes=toSortedStringArray(config.actionTypes);if(actionTypes!==undefined){coercedConfig.actionTypes=actionTypes;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const sections=toSortedStringArray(config.sections);if(sections!==undefined){coercedConfig.sections=sections;}return coercedConfig;}function typeCheckConfig$h(untrustedConfig){const config={};const untrustedConfig_objectApiNames=untrustedConfig.objectApiNames;if(ArrayIsArray$1$5(untrustedConfig_objectApiNames)){const untrustedConfig_objectApiNames_array=[];for(let i=0,arrayLength=untrustedConfig_objectApiNames.length;i<arrayLength;i++){const untrustedConfig_objectApiNames_item=untrustedConfig_objectApiNames[i];if(typeof untrustedConfig_objectApiNames_item==='string'){untrustedConfig_objectApiNames_array.push(untrustedConfig_objectApiNames_item);}}config.objectApiNames=untrustedConfig_objectApiNames_array;}const untrustedConfig_actionTypes=untrustedConfig.actionTypes;if(ArrayIsArray$1$5(untrustedConfig_actionTypes)){const untrustedConfig_actionTypes_array=[];for(let i=0,arrayLength=untrustedConfig_actionTypes.length;i<arrayLength;i++){const untrustedConfig_actionTypes_item=untrustedConfig_actionTypes[i];if(typeof untrustedConfig_actionTypes_item==='string'){untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);}}config.actionTypes=untrustedConfig_actionTypes_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_sections=untrustedConfig.sections;if(ArrayIsArray$1$5(untrustedConfig_sections)){const untrustedConfig_sections_array=[];for(let i=0,arrayLength=untrustedConfig_sections.length;i<arrayLength;i++){const untrustedConfig_sections_item=untrustedConfig_sections[i];if(typeof untrustedConfig_sections_item==='string'){untrustedConfig_sections_array.push(untrustedConfig_sections_item);}}config.sections=untrustedConfig_sections_array;}return config;}function validateAdapterConfig$h(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$f(untrustedConfig);const config=typeCheckConfig$h(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$c(lds,config){const request=getUiApiActionsLookupByObjectApiNames({urlParams:{objectApiNames:config.objectApiNames},queryParams:{actionTypes:config.actionTypes,formFactor:config.formFactor,sections:config.sections}});const selector={recordId:request.key,node:select$s(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$b(lds,config,override){const request=getUiApiActionsLookupByObjectApiNames({urlParams:{objectApiNames:config.objectApiNames},queryParams:{actionTypes:config.actionTypes,formFactor:config.formFactor,sections:config.sections}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$c(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error,TTL$3);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getLookupActionsAdapterFactory=lds=>{return refreshable$5(// Create snapshot either via a cache hit or via the network
    function getLookupActions(untrustedConfig){const config=validateAdapterConfig$h(untrustedConfig,getLookupActions_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$c(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$4){return cacheSnapshot;}return buildNetworkSnapshot$b(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$h(untrustedConfig,getLookupActions_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getLookupActions" refresh function');}return buildNetworkSnapshot$b(lds,config,{headers:{'Cache-Control':'no-cache'}});});};function toSortedStringArrayAllowEmpty(value){const valueArray=isArray$3(value)?value:[value];if(valueArray.length===0){return valueArray;}return toSortedStringArray(valueArray);}function getUiApiActionsRecordByRecordIds(config){const key=keyPrefix$4+'ActionRepresentation('+'actionTypes:'+config.queryParams.actionTypes+','+'apiNames:'+config.queryParams.apiNames+','+'formFactor:'+config.queryParams.formFactor+','+'retrievalMode:'+config.queryParams.retrievalMode+','+'sections:'+config.queryParams.sections+','+'recordIds:'+config.urlParams.recordIds+')';const headers={};return {path:'/services/data/v49.0/ui-api/actions/record/'+config.urlParams.recordIds+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$o,headers};}const oneOfConfigPropertiesIdentifier$1=['sections','apiNames'];const getRecordActions_ConfigPropertyNames={displayName:'getRecordActions',parameters:{required:['recordIds'],optional:['actionTypes','apiNames','formFactor','retrievalMode','sections']}};function coerceConfig$g(config){const coercedConfig={};const recordIds=getRecordId18Array(config.recordIds);if(recordIds!==undefined){coercedConfig.recordIds=recordIds;}const actionTypes=config.actionTypes;if(actionTypes!==undefined){coercedConfig.actionTypes=actionTypes;}const apiNames=toSortedStringArrayAllowEmpty(config.apiNames);if(apiNames!==undefined){coercedConfig.apiNames=apiNames;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const retrievalMode=config.retrievalMode;if(retrievalMode!==undefined){coercedConfig.retrievalMode=retrievalMode;}const sections=toSortedStringArray(config.sections);if(sections!==undefined){coercedConfig.sections=sections;}return coercedConfig;}function typeCheckConfig$i(untrustedConfig){const config={};const untrustedConfig_recordIds=untrustedConfig.recordIds;if(ArrayIsArray$1$5(untrustedConfig_recordIds)){const untrustedConfig_recordIds_array=[];for(let i=0,arrayLength=untrustedConfig_recordIds.length;i<arrayLength;i++){const untrustedConfig_recordIds_item=untrustedConfig_recordIds[i];if(typeof untrustedConfig_recordIds_item==='string'){untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);}}config.recordIds=untrustedConfig_recordIds_array;}const untrustedConfig_actionTypes=untrustedConfig.actionTypes;if(ArrayIsArray$1$5(untrustedConfig_actionTypes)){const untrustedConfig_actionTypes_array=[];for(let i=0,arrayLength=untrustedConfig_actionTypes.length;i<arrayLength;i++){const untrustedConfig_actionTypes_item=untrustedConfig_actionTypes[i];if(typeof untrustedConfig_actionTypes_item==='string'){untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);}}config.actionTypes=untrustedConfig_actionTypes_array;}const untrustedConfig_apiNames=untrustedConfig.apiNames;if(ArrayIsArray$1$5(untrustedConfig_apiNames)){const untrustedConfig_apiNames_array=[];for(let i=0,arrayLength=untrustedConfig_apiNames.length;i<arrayLength;i++){const untrustedConfig_apiNames_item=untrustedConfig_apiNames[i];if(typeof untrustedConfig_apiNames_item==='string'){untrustedConfig_apiNames_array.push(untrustedConfig_apiNames_item);}}config.apiNames=untrustedConfig_apiNames_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_retrievalMode=untrustedConfig.retrievalMode;if(typeof untrustedConfig_retrievalMode==='string'){config.retrievalMode=untrustedConfig_retrievalMode;}const untrustedConfig_sections=untrustedConfig.sections;if(ArrayIsArray$1$5(untrustedConfig_sections)){const untrustedConfig_sections_array=[];for(let i=0,arrayLength=untrustedConfig_sections.length;i<arrayLength;i++){const untrustedConfig_sections_item=untrustedConfig_sections[i];if(typeof untrustedConfig_sections_item==='string'){untrustedConfig_sections_array.push(untrustedConfig_sections_item);}}config.sections=untrustedConfig_sections_array;}return config;}function validateAdapterConfig$i(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames,oneOfConfigPropertiesIdentifier$1);}const coercedConfig=coerceConfig$g(untrustedConfig);const config=typeCheckConfig$i(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}if(config.sections===undefined&&config.apiNames===undefined){return null;}return config;}function buildInMemorySnapshot$d(lds,config){const request=getUiApiActionsRecordByRecordIds({urlParams:{recordIds:config.recordIds},queryParams:{actionTypes:config.actionTypes,apiNames:config.apiNames,formFactor:config.formFactor,retrievalMode:config.retrievalMode,sections:config.sections}});const selector={recordId:request.key,node:select$s(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$c(lds,config,override){const request=getUiApiActionsRecordByRecordIds({urlParams:{recordIds:config.recordIds},queryParams:{actionTypes:config.actionTypes,apiNames:config.apiNames,formFactor:config.formFactor,retrievalMode:config.retrievalMode,sections:config.sections}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$d(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error,TTL$3);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getRecordActionsAdapterFactory=lds=>{return refreshable$5(// Create snapshot either via a cache hit or via the network
    function getRecordActions(untrustedConfig){const config=validateAdapterConfig$i(untrustedConfig,getRecordActions_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$d(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$4){return cacheSnapshot;}return buildNetworkSnapshot$c(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$i(untrustedConfig,getRecordActions_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getRecordActions" refresh function');}return buildNetworkSnapshot$c(lds,config,{headers:{'Cache-Control':'no-cache'}});});};function getUiApiActionsRecordRecordEditByRecordIds(config){const key=keyPrefix$4+'ActionRepresentation('+'actionTypes:'+config.queryParams.actionTypes+','+'formFactor:'+config.queryParams.formFactor+','+'sections:'+config.queryParams.sections+','+'recordIds:'+config.urlParams.recordIds+')';const headers={};return {path:'/services/data/v49.0/ui-api/actions/record/'+config.urlParams.recordIds+'/record-edit',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$o,headers};}const getRecordEditActions_ConfigPropertyNames={displayName:'getRecordEditActions',parameters:{required:['recordIds'],optional:['actionTypes','formFactor','sections']}};function typeCheckConfig$j(untrustedConfig){const config={};const untrustedConfig_recordIds=untrustedConfig.recordIds;if(ArrayIsArray$1$5(untrustedConfig_recordIds)){const untrustedConfig_recordIds_array=[];for(let i=0,arrayLength=untrustedConfig_recordIds.length;i<arrayLength;i++){const untrustedConfig_recordIds_item=untrustedConfig_recordIds[i];if(typeof untrustedConfig_recordIds_item==='string'){untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);}}config.recordIds=untrustedConfig_recordIds_array;}const untrustedConfig_actionTypes=untrustedConfig.actionTypes;if(ArrayIsArray$1$5(untrustedConfig_actionTypes)){const untrustedConfig_actionTypes_array=[];for(let i=0,arrayLength=untrustedConfig_actionTypes.length;i<arrayLength;i++){const untrustedConfig_actionTypes_item=untrustedConfig_actionTypes[i];if(typeof untrustedConfig_actionTypes_item==='string'){untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);}}config.actionTypes=untrustedConfig_actionTypes_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_sections=untrustedConfig.sections;if(ArrayIsArray$1$5(untrustedConfig_sections)){const untrustedConfig_sections_array=[];for(let i=0,arrayLength=untrustedConfig_sections.length;i<arrayLength;i++){const untrustedConfig_sections_item=untrustedConfig_sections[i];if(typeof untrustedConfig_sections_item==='string'){untrustedConfig_sections_array.push(untrustedConfig_sections_item);}}config.sections=untrustedConfig_sections_array;}return config;}function validateAdapterConfig$j(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const config=typeCheckConfig$j(untrustedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$e(lds,config){const request=getUiApiActionsRecordRecordEditByRecordIds({urlParams:{recordIds:config.recordIds},queryParams:{actionTypes:config.actionTypes,formFactor:config.formFactor,sections:config.sections}});const selector={recordId:request.key,node:select$s(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$d(lds,config,override){const request=getUiApiActionsRecordRecordEditByRecordIds({urlParams:{recordIds:config.recordIds},queryParams:{actionTypes:config.actionTypes,formFactor:config.formFactor,sections:config.sections}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$e(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error,TTL$3);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getRecordEditActionsAdapterFactory=lds=>{return refreshable$5(// Create snapshot either via a cache hit or via the network
    function getRecordEditActions(untrustedConfig){const config=validateAdapterConfig$j(untrustedConfig,getRecordEditActions_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$e(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$4){return cacheSnapshot;}return buildNetworkSnapshot$d(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$j(untrustedConfig,getRecordEditActions_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getRecordEditActions" refresh function');}return buildNetworkSnapshot$d(lds,config,{headers:{'Cache-Control':'no-cache'}});});};function validate$M(obj,path='AbstractSimplifiedBatchResultRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_statusCode=obj.statusCode;const path_statusCode=path+'.statusCode';if(typeof obj_statusCode!=='number'){return new TypeError('Expected "number" but received "'+typeof obj_statusCode+'" (at "'+path_statusCode+'")');}})();return v_error===undefined?null:v_error;}const select$t=function AbstractSimplifiedBatchResultRepresentationSelect(){return {kind:'Fragment',selections:[{name:'statusCode',kind:'Scalar'}]};};function equals$v(existing,incoming){const existing_statusCode=existing.statusCode;const incoming_statusCode=incoming.statusCode;if(!(existing_statusCode===incoming_statusCode)){return false;}return true;}function validate$N(obj,path='SimplifiedBatchResultRepresentation'){const validateAbstractSimplifiedBatchResultRepresentation_validateError=validate$M(obj,path);if(validateAbstractSimplifiedBatchResultRepresentation_validateError!==null){return validateAbstractSimplifiedBatchResultRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_result=obj.result;const path_result=path+'.result';if(typeof obj_result!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_result+'" (at "'+path_result+'")');}})();return v_error===undefined?null:v_error;}function normalize$p(input,existing,path,lds,store,timestamp){const input_result=input.result;const input_result_id=path.fullPath+'__result';input.result=ingest$a(input_result,{fullPath:input_result_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);return input;}const select$u=function SimplifiedBatchResultRepresentationSelect(){const{selections:AbstractSimplifiedBatchResultRepresentationSelections}=select$t();const{selections:ObjectInfoRepresentation__selections,opaque:ObjectInfoRepresentation__opaque}=select$9();return {kind:'Fragment',selections:[...AbstractSimplifiedBatchResultRepresentationSelections,{name:'result',kind:'Link',selections:ObjectInfoRepresentation__selections}]};};function equals$w(existing,incoming){if(equals$v(existing,incoming)===false){return false;}const existing_result=existing.result;const incoming_result=incoming.result;if(!(existing_result.__ref===incoming_result.__ref)){return false;}return true;}const ingest$p=function SimplifiedBatchResultRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$N(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$p(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$w(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function validate$O(obj,path='SimplifiedBatchRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$6(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_results=obj.results;const path_results=path+'.results';if(!ArrayIsArray$6(obj_results)){return new TypeError('Expected "array" but received "'+typeof obj_results+'" (at "'+path_results+'")');}for(let i=0;i<obj_results.length;i++){const obj_results_item=obj_results[i];const path_results_item=path_results+'['+i+']';if(typeof obj_results_item!=='object'){return new TypeError('Expected "object" but received "'+typeof obj_results_item+'" (at "'+path_results_item+'")');}}})();return v_error===undefined?null:v_error;}function normalize$q(input,existing,path,lds,store,timestamp){const input_results=input.results;const input_results_id=path.fullPath+'__results';for(let i=0;i<input_results.length;i++){const input_results_item=input_results[i];let input_results_item_id=input_results_id+'__'+i;input_results[i]=ingest$p(input_results_item,{fullPath:input_results_item_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp);}return input;}const select$v=function SimplifiedBatchRepresentationSelect(){const{selections:SimplifiedBatchResultRepresentation__selections,opaque:SimplifiedBatchResultRepresentation__opaque}=select$u();return {kind:'Fragment',selections:[{name:'results',kind:'Link',plural:true,selections:SimplifiedBatchResultRepresentation__selections}]};};function equals$x(existing,incoming){const existing_results=existing.results;const incoming_results=incoming.results;const equals_results_items=equalsArray(existing_results,incoming_results,(existing_results_item,incoming_results_item)=>{if(!(existing_results_item.__ref===incoming_results_item.__ref)){return false;}});if(equals_results_items===false){return false;}return true;}const ingest$q=function SimplifiedBatchRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$O(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$q(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$x(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return createLink$5(key);};function getUiApiObjectInfoBatchByObjectApiNames(config){const key=keyPrefix$4+'SimplifiedBatchRepresentation('+'objectApiNames:'+config.urlParams.objectApiNames+')';const headers={};return {path:'/services/data/v49.0/ui-api/object-info/batch/'+config.urlParams.objectApiNames+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$q,headers};}const getObjectInfos_ConfigPropertyNames={displayName:'getObjectInfos',parameters:{required:['objectApiNames'],optional:[]}};function coerceConfig$h(config){const coercedConfig={};const objectApiNames=getObjectApiNamesArray(config.objectApiNames);if(objectApiNames!==undefined){coercedConfig.objectApiNames=objectApiNames;}return coercedConfig;}function typeCheckConfig$k(untrustedConfig){const config={};const untrustedConfig_objectApiNames=untrustedConfig.objectApiNames;if(ArrayIsArray$1$5(untrustedConfig_objectApiNames)){const untrustedConfig_objectApiNames_array=[];for(let i=0,arrayLength=untrustedConfig_objectApiNames.length;i<arrayLength;i++){const untrustedConfig_objectApiNames_item=untrustedConfig_objectApiNames[i];if(typeof untrustedConfig_objectApiNames_item==='string'){untrustedConfig_objectApiNames_array.push(untrustedConfig_objectApiNames_item);}}config.objectApiNames=untrustedConfig_objectApiNames_array;}return config;}function validateAdapterConfig$k(untrustedConfig,configPropertyNames){if(!untrustedIsObject$5(untrustedConfig)){return null;}{validateConfig$4(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$h(untrustedConfig);const config=typeCheckConfig$k(coercedConfig);if(!areRequiredParametersPresent$4(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$f(lds,config){const request=getUiApiObjectInfoBatchByObjectApiNames({urlParams:{objectApiNames:config.objectApiNames}});const selector={recordId:request.key,node:select$v(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$e(lds,config,override){const request=getUiApiObjectInfoBatchByObjectApiNames({urlParams:{objectApiNames:config.objectApiNames}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$f(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getObjectInfosAdapterFactory=lds=>{return refreshable$5(// Create snapshot either via a cache hit or via the network
    function getObjectInfos(untrustedConfig){const config=validateAdapterConfig$k(untrustedConfig,getObjectInfos_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$f(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED$4){return cacheSnapshot;}return buildNetworkSnapshot$e(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$k(untrustedConfig,getObjectInfos_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getObjectInfos" refresh function');}return buildNetworkSnapshot$e(lds,config,{headers:{'Cache-Control':'no-cache'}});});};/**
     * Limit the frequency and the duration that a function is invoked.
     *
     * @param invokeLimit The frequency a function could be invoked.
     * @param timeLimit The duration a function could be invoked with the rate limit, in milliseconds.
     * @param fn The function to be invoked.
     * @param options Extra options for instrumentation, logging, or bookkeeping purposes.
     * @returns The wrapped rate limited function.
     */function throttle(invokeLimit,timeLimit,fn,options){if(invokeLimit<=0||timeLimit<=0){throw new Error('only supports throttling with positive invokeLimit and timeLimit');}let invokeCount=0;let time=Date.now();const allowFunction=options&&options.allowFunction?options.allowFunction:()=>{};const dropFunction=options&&options.dropFunction?options.dropFunction:()=>{};return (...args)=>{const calledTime=Date.now();if(calledTime-time<=timeLimit){if(invokeCount<invokeLimit){invokeCount+=1;allowFunction();return fn(...args);}else {dropFunction();}}else {time=calledTime;invokeCount=1;allowFunction();return fn(...args);}};}const{push:push$2,reduce,join}=Array.prototype;const{entries,keys:keys$4}=Object;const{hasOwnProperty:hasOwnProperty$2}=Object.prototype;const{parse:parse$1,stringify:stringify$4}=JSON;const{isArray:isArray$4}=Array;const METRIC_KEY_OWNER='lds';/**
     * Note: This implementation of Metric Keys is a workaround due to @salesforce imports not currently working within LDS context.
     * To be changed in the future if that is fixed. Approved by @relango from Instrumentation team.
     */const ADS_BRIDGE_ADD_RECORDS_DURATION={get(){return {owner:METRIC_KEY_OWNER,name:'ads-bridge-add-records-duration'};}};const ADS_BRIDGE_EMIT_RECORD_CHANGED_DURATION={get(){return {owner:METRIC_KEY_OWNER,name:'ads-bridge-emit-record-changed-duration'};}};const ADS_BRIDGE_EVICT_DURATION={get(){return {owner:METRIC_KEY_OWNER,name:'ads-bridge-evict-duration'};}};const CACHE_HIT_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'cache-hit-count'};}};const CACHE_MISS_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'cache-miss-count'};}};/**
     * W-7667066
     * This count represents the number of times getRecord() was invoked, but not including
     * executeAggregateUi calls.  It can be represented as the sum of the Aura Action invocations
     * GetRecordWithLayouts and GetRecordWithFields.
     */const GET_RECORD_NORMAL_INVOKE_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'get-record-normal-invoke-count'};}};/**
     * W-7667066
     * This count represents the number of times getRecord() was invoked, with a large enough payload
     * that executeAggregateUi was used.
     */const GET_RECORD_AGGREGATE_INVOKE_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'get-record-aggregate-invoke-count'};}};const GET_RECORD_NOTIFY_CHANGE_ALLOW_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'get-record-notify-change-allow-count'};}};const GET_RECORD_NOTIFY_CHANGE_DROP_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'get-record-notify-change-drop-count'};}};const STORE_BROADCAST_DURATION={get(){return {owner:METRIC_KEY_OWNER,name:'store-broadcast-duration'};}};const STORE_INGEST_DURATION={get(){return {owner:METRIC_KEY_OWNER,name:'store-ingest-duration'};}};const STORE_LOOKUP_DURATION={get(){return {owner:METRIC_KEY_OWNER,name:'store-lookup-duration'};}};const STORE_SIZE_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'store-size-count'};}};const STORE_SNAPSHOT_SUBSCRIPTIONS_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'store-snapshot-subscriptions-count'};}};const STORE_WATCH_SUBSCRIPTIONS_COUNT={get(){return {owner:METRIC_KEY_OWNER,name:'store-watch-subscriptions-count'};}};const INCOMING_WEAKETAG_0_KEY$1='incoming-weaketag-0';const EXISTING_WEAKETAG_0_KEY$1='existing-weaketag-0';const NAMESPACE='lds';const STORE_STATS_MARK_NAME='store-stats';const RUNTIME_PERF_MARK_NAME='runtime-perf';const NETWORK_TRANSACTION_NAME='lds-network';const cacheHitMetric=service.counter(CACHE_HIT_COUNT);const cacheMissMetric=service.counter(CACHE_MISS_COUNT);const getRecordAggregateInvokeMetric=service.counter(GET_RECORD_AGGREGATE_INVOKE_COUNT);const getRecordNormalInvokeMetric=service.counter(GET_RECORD_NORMAL_INVOKE_COUNT);const getRecordNotifyChangeAllowMetric=service.counter(GET_RECORD_NOTIFY_CHANGE_ALLOW_COUNT);const getRecordNotifyChangeDropMetric=service.counter(GET_RECORD_NOTIFY_CHANGE_DROP_COUNT);const storeSizeMetric=service.percentileHistogram(STORE_SIZE_COUNT);const storeWatchSubscriptionsMetric=service.percentileHistogram(STORE_WATCH_SUBSCRIPTIONS_COUNT);const storeSnapshotSubscriptionsMetric=service.percentileHistogram(STORE_SNAPSHOT_SUBSCRIPTIONS_COUNT);class Instrumentation{constructor(){this.weakEtagZeroEvents={};if(window&&window.addEventListener){window.addEventListener('beforeunload',()=>{if(Object.keys(this.weakEtagZeroEvents).length>0){service.perfStart(NETWORK_TRANSACTION_NAME);service.perfEnd(NETWORK_TRANSACTION_NAME,this.weakEtagZeroEvents);}});}}/**
         * Add a network transaction to the metrics service.
         * Injected to LDS for network handling instrumentation.
         *
         * @param context The transaction context.
         */instrumentNetwork(context){if(this.isWeakETagEvent(context)){this.aggregateWeakETagEvents(context);}else {service.perfStart(NETWORK_TRANSACTION_NAME);service.perfEnd(NETWORK_TRANSACTION_NAME,context);}}/**
         * Returns via duck-typing whether or not this is a weakETagZeroEvent.
         * @param context The transaction context.
         * @returns Whether or not this is a weakETagZeroEvent.
         */isWeakETagEvent(context){return typeof context[EXISTING_WEAKETAG_0_KEY$1]==='boolean'&&typeof context[INCOMING_WEAKETAG_0_KEY$1]==='boolean';}/**
         * Parses and aggregates weakETagZero events to be sent in summarized log line.
         * @param context The transaction context.
         */aggregateWeakETagEvents(context){const{apiName}=context;const key='weaketag-0-'+apiName;if(this.weakEtagZeroEvents[key]===undefined){this.weakEtagZeroEvents[key]={[EXISTING_WEAKETAG_0_KEY$1]:0,[INCOMING_WEAKETAG_0_KEY$1]:0};}if(context[EXISTING_WEAKETAG_0_KEY$1]!==undefined){this.weakEtagZeroEvents[key][EXISTING_WEAKETAG_0_KEY$1]+=1;}if(context[INCOMING_WEAKETAG_0_KEY$1]!==undefined){this.weakEtagZeroEvents[key][INCOMING_WEAKETAG_0_KEY$1]+=1;}}}/**
     * Aura Metrics Service plugin in charge of aggregating all the LDS performance marks before they
     * get sent to the server. All the marks are summed by operation type and the aggregated result
     * is then stored an a new mark.
     */const markAggregatorPlugin={name:NAMESPACE,enabled:true,initialize(){/* noop */},postProcess(marks){const postProcessedMarks=[];let shouldLogAggregated=false;const startTs={};const aggregated={};for(let i=0,len=marks.length;i<len;i++){const mark=marks[i];const{name,phase,ts}=mark;if(phase==='start'){startTs[name]=ts;}else if(phase==='end'){if(aggregated[name]===undefined){aggregated[name]=0;}shouldLogAggregated=true;aggregated[name]+=ts-startTs[name];}else {postProcessedMarks.push(mark);}}if(shouldLogAggregated){postProcessedMarks.push({ns:NAMESPACE,name:RUNTIME_PERF_MARK_NAME,phase:'stamp',ts:service.time(),context:aggregated});}return postProcessedMarks;}};function instrumentMethod(obj,methods){for(let i=0,len=methods.length;i<len;i++){const method=methods[i];const methodName=method.methodName;const originalMethod=obj[methodName];const methodTimer=service.timer(method.metricKey);obj[methodName]=function(...args){service.markStart(NAMESPACE,methodName);const startTime=Date.now();const res=originalMethod.call(this,...args);timerMetricAddDuration(methodTimer,Date.now()-startTime);service.markEnd(NAMESPACE,methodName);return res;};}}function createMetricsKey(owner,name,unit){let metricName=name;if(unit){metricName=metricName+'.'+unit;}return {get(){return {owner:owner,name:metricName};}};}function timerMetricAddDuration(timer,duration){// Guard against negative values since it causes error to be thrown by MetricsService
    if(duration>=0){timer.addDuration(duration);}}function getStoreStats(store){const{records,snapshotSubscriptions,watchSubscriptions}=store;const recordCount=keys$4(records).length;const snapshotSubscriptionCount=keys$4(snapshotSubscriptions).length;const watchSubscriptionCount=keys$4(watchSubscriptions).length;const subscriptionCount=snapshotSubscriptionCount+watchSubscriptionCount;return {recordCount,subscriptionCount,snapshotSubscriptionCount,watchSubscriptionCount};}/**
     * Add a mark to the metrics service.
     *
     * @param name The mark name.
     * @param content The mark content.
     */function mark(name,content){service.mark(NAMESPACE,name,content);}/**
     * Create a new instrumentation cache stats and return it.
     *
     * @param name The cache logger name.
     */function registerLdsCacheStats(name){return service.registerCacheStats(`${NAMESPACE}:${name}`);}/**
     * Initialize the instrumentation and instrument the LDS instance and the Store.
     *
     * @param lds The LDS to instrument.
     * @param store The Store to instrument.
     */function setupInstrumentation(lds,store){service.registerPlugin({name:NAMESPACE,plugin:markAggregatorPlugin});instrumentMethod(lds,[{methodName:'storeBroadcast',metricKey:STORE_BROADCAST_DURATION},{methodName:'storeIngest',metricKey:STORE_INGEST_DURATION},{methodName:'storeLookup',metricKey:STORE_LOOKUP_DURATION}]);service.registerPeriodicLogger(NAMESPACE,()=>{const storeStats=getStoreStats(store);service.mark(NAMESPACE,STORE_STATS_MARK_NAME,storeStats);storeSizeMetric.update(storeStats.recordCount);storeSnapshotSubscriptionsMetric.update(storeStats.snapshotSubscriptionCount);storeWatchSubscriptionsMetric.update(storeStats.watchSubscriptionCount);});}/**
     * Instrument an existing adapter that would logs the cache hits and misses.
     *
     * @param name The adapter name.
     * @param adapter The adapter function.
     * @returns The wrapped adapter.
     */function instrumentAdapter(name,adapter){const stats=registerLdsCacheStats(name);const cacheMissByAdapterMetric=service.counter(createMetricsKey(NAMESPACE,'cache-miss-count',name));const cacheHitByAdapterMetric=service.counter(createMetricsKey(NAMESPACE,'cache-hit-count',name));return config=>{const result=adapter(config);// In the case where the adapter returns a Snapshot it is constructed out of the store
    // (cache hit) whereas a Promise<Snapshot> indicates a network request (cache miss).
    //
    // Note: we can't do a plain instanceof check for a promise here since the Promise may
    // originate from another javascript realm (for example: in jest test). Instead we use a
    // duck-typing approach by checking is the result has a then property.
    //
    // For adapters without persistent store:
    //  - total cache hit ratio:
    //      [in-memory cache hit count] / ([in-memory cache hit count] + [in-memory cache miss count])
    // For adapters with persistent store:
    //  - in-memory cache hit ratio:
    //      [in-memory cache hit count] / ([in-memory cache hit count] + [in-memory cache miss count])
    //  - total cache hit ratio:
    //      ([in-memory cache hit count] + [store cache hit count]) / ([in-memory cache hit count] + [in-memory cache miss count])
    //
    // if result === null then config is insufficient/invalid so do not log
    if(result!==null){if('then'in result){stats.logMisses();cacheMissMetric.increment(1);cacheMissByAdapterMetric.increment(1);}else {stats.logHits();cacheHitMetric.increment(1);cacheHitByAdapterMetric.increment(1);}}return result;};}function incrementGetRecordNormalInvokeCount(){getRecordNormalInvokeMetric.increment(1);}function incrementGetRecordAggregateInvokeCount(){getRecordAggregateInvokeMetric.increment(1);}function incrementGetRecordNotifyChangeAllowCount(){getRecordNotifyChangeAllowMetric.increment(1);}function incrementGetRecordNotifyChangeDropCount(){getRecordNotifyChangeDropMetric.increment(1);}// No need to pass the actual record key `lds.ingestStore`. The `RecordRepresentation.ts#ingest`
    // function extracts the appropriate record id from the ingested record.
    const INGEST_KEY='';// A fake record resource request to trick the LDS engine to ingest records coming from ADS.
    const FAKE_RECORD_REQUEST={ingest:ingest$2$1};const RECORD_ID_PREFIX='UiApi::RecordRepresentation:';const RECORD_ID_REGEXP=/^UiApi::RecordRepresentation:([a-zA-Z0-9])+$/;const MASTER_RECORD_TYPE_ID$1='012000000000000AAA';function isGraphNode$1(node){return node!==null&&node.type==='Node';}function isSpanningRecord$1(fieldValue){return fieldValue!==null&&typeof fieldValue==='object';}/**
     * Returns a shallow copy of a record with its field values if it is a scalar and a reference and a
     * a RecordRepresentation with no field if the value if a spanning record.
     * It returns null if the record contains any pending field.
     */function getShallowRecord(lds,storeRecordId){const recordNode=lds.getNode(storeRecordId);if(!isGraphNode$1(recordNode)){return null;}const fieldsCopy={};const copy=_objectSpread$1({},recordNode.retrieve(),{fields:fieldsCopy,childRelationships:{}});const fieldsNode=recordNode.object('fields');const fieldNames=fieldsNode.keys();for(let i=0,len=fieldNames.length;i<len;i++){let fieldCopy;const fieldName=fieldNames[i];const fieldLink=fieldsNode.link(fieldName);if(fieldLink.isPending()===true){return null;}const fieldNode=fieldLink.follow();if(!isGraphNode$1(fieldNode)){continue;}const{displayValue,value}=fieldNode.retrieve();if(fieldNode.isScalar('value')){fieldCopy={displayValue:displayValue,value:value};}else {const spanningRecordLink=fieldNode.link('value');if(spanningRecordLink.isPending()===true){return null;}const spanningRecordNode=spanningRecordLink.follow();if(!isGraphNode$1(spanningRecordNode)){continue;}fieldCopy={displayValue,value:_objectSpread$1({},spanningRecordNode.retrieve(),{fields:{},childRelationships:{}})};}fieldsCopy[fieldName]=fieldCopy;}return copy;}/**
     * Returns the ADS object metadata representation for a specific record.
     */function getObjectMetadata(lds,record){const{data:objectInfo}=lds.storeLookup({recordId:keyBuilder$8({apiName:record.apiName}),node:{kind:'Fragment',opaque:true},variables:{}});if(objectInfo!==undefined){let nameField='Name';// Extract the entity name field from the object info. In the case where there are multiple
    // field names then pick up the first one.
    if(objectInfo.nameFields.length!==0&&objectInfo.nameFields.indexOf('Name')===-1){nameField=objectInfo.nameFields[0];}return {_nameField:nameField,_entityLabel:objectInfo.label,_keyPrefix:objectInfo.keyPrefix};}return {_nameField:'Name',_entityLabel:record.apiName,_keyPrefix:record.id.substring(0,3)};}/**
     * RecordGvp can send records back to ADS with record types incorrectly set to the master
     * record type. Since there are no known legitimate scenarios where a record can change from a
     * non-master record type back to the master record type, we assume such a transition
     * indicates a RecordGvp mistake. This function checks for that scenario and overwrites the
     * incoming ADS record type information with what we already have in the store when it
     * occurs.
     *
     * @param lds LDS
     * @param record record from ADS, will be fixed in situ
     */function fixRecordTypes(lds,record){// non-master record types should always be correct
    if(record.recordTypeId===MASTER_RECORD_TYPE_ID$1){const key=keyBuilder({recordId:record.id});const recordNode=lds.getNode(key);if(isGraphNode$1(recordNode)&&recordNode.scalar('recordTypeId')!==MASTER_RECORD_TYPE_ID$1){// ignore bogus incoming record type information & keep what we have
    record.recordTypeId=recordNode.scalar('recordTypeId');record.recordTypeInfo=recordNode.object('recordTypeInfo').data;}}// recurse on nested records
    const fieldKeys=keys$4(record.fields);const fieldKeysLen=fieldKeys.length;for(let i=0;i<fieldKeysLen;++i){const fieldValue=record.fields[fieldKeys[i]].value;if(isSpanningRecord$1(fieldValue)){fixRecordTypes(lds,fieldValue);}}}class AdsBridge{constructor(lds){this.lds=lds;this.isRecordEmitLocked=false;this.addRecordsTimerMetric=service.timer(ADS_BRIDGE_ADD_RECORDS_DURATION);this.evictTimerMetric=service.timer(ADS_BRIDGE_EVICT_DURATION);this.emitRecordChangedTimerMetric=service.timer(ADS_BRIDGE_EMIT_RECORD_CHANGED_DURATION);}/**
         * This setter invoked by recordLibrary to listen for records ingested by LDS. The passed method
         * is invoked whenever a record is ingested. It may be via getRecord, getRecordUi, getListUi, ...
         */set receiveFromLdsCallback(callback){// Unsubscribe if there is an existing subscription.
    if(this.watchUnsubscribe!==undefined){this.watchUnsubscribe();this.watchUnsubscribe=undefined;}if(callback!==undefined){this.watchUnsubscribe=this.lds.storeWatch(RECORD_ID_PREFIX,entries=>{if(this.isRecordEmitLocked===true){return;}this.emitRecordChanged(entries,callback);});}}/**
         * This method is invoked when a record has been ingested by ADS.
         *
         * ADS may invoke this method with records that are not UIAPI whitelisted so not refreshable by
         * LDS. LDS filters the provided list so it ingests only UIAPI whitelisted records.
         */addRecords(records,uiApiEntityWhitelist){const startTime=Date.now();const{lds}=this;let didIngestRecord=false;return this.lockLdsRecordEmit(()=>{for(let i=0;i<records.length;i++){const record=records[i];const{apiName}=record;// Ingest the record if no whitelist is passed or the entity name is whitelisted.
    if(uiApiEntityWhitelist===undefined||uiApiEntityWhitelist[apiName]!=='false'){didIngestRecord=true;// Deep-copy the record to ingest and ingest the record copy. This avoids
    // corrupting the ADS cache since ingestion mutates the passed record.
    const recordCopy=parse$1(stringify$4(record));// Don't let incorrect ADS/RecordGVP recordTypeIds replace a valid record type in our store
    // with the master record type. See W-7302870 for details.
    fixRecordTypes(lds,recordCopy);lds.storeIngest(INGEST_KEY,FAKE_RECORD_REQUEST,recordCopy);}}if(didIngestRecord===true){lds.storeBroadcast();}timerMetricAddDuration(this.addRecordsTimerMetric,Date.now()-startTime);});}/**
         * This method is invoked whenever a record has been evicted from ADS.
         */evict(recordId){const startTime=Date.now();const{lds}=this;const key=keyBuilder({recordId});return this.lockLdsRecordEmit(()=>{lds.storeEvict(key);lds.storeBroadcast();timerMetricAddDuration(this.evictTimerMetric,Date.now()-startTime);return Promise.resolve();});}/**
         * Gets the list of fields of a record that LDS has in its store. The field list doesn't
         * contains the spanning record fields. ADS uses this list when it loads a record from the
         * server. This is an optimization to make a single roundtrip it queries for all fields required
         * by ADS and LDS.
         */getTrackedFieldsForRecord(recordId){const{lds}=this;const storeRecordId=keyBuilder({recordId});const recordNode=lds.getNode(storeRecordId);if(!isGraphNode$1(recordNode)){return Promise.resolve([]);}const apiName=recordNode.scalar('apiName');const fieldNames=recordNode.object('fields').keys();// Prefix all the fields with the record API name.
    const qualifiedFieldNames=[];for(let i=0,len=fieldNames.length;i<len;i++){push$2.call(qualifiedFieldNames,`${apiName}.${fieldNames[i]}`);}return Promise.resolve(qualifiedFieldNames);}/**
         * Prevents the bridge to emit record change during the execution of the callback.
         * This methods should wrap all the LDS store mutation done by the bridge. It prevents LDS store
         * mutations triggered by ADS to be emit back to ADS.
         */lockLdsRecordEmit(callback){this.isRecordEmitLocked=true;try{return callback();}finally{this.isRecordEmitLocked=false;}}/**
         * This method retrieves queries the store with with passed record ids to retrieve their
         * associated records and object info. Note that the passed ids are not Salesforce record id
         * but rather LDS internals store ids.
         */emitRecordChanged(updatedEntries,callback){const startTime=Date.now();const{lds}=this;let shouldEmit=false;const adsRecordMap={};const adsObjectMap={};for(let i=0;i<updatedEntries.length;i++){const storeRecordId=updatedEntries[i].id;// Exclude all the store record ids not matching with the record id pattern.
    // Note: FieldValueRepresentation have the same prefix than RecordRepresentation so we
    // need to filter them out.
    if(!storeRecordId.match(RECORD_ID_REGEXP)){continue;}const record=getShallowRecord(lds,storeRecordId);if(record===null){continue;}const{id,apiName}=record;shouldEmit=true;adsRecordMap[id]={[apiName]:{isPrimary:true,record}};// Extract and add the object metadata to the map if not already present.
    if(!hasOwnProperty$2.call(adsObjectMap,apiName)){adsObjectMap[apiName]=getObjectMetadata(lds,record);}}if(shouldEmit===true){callback(adsRecordMap,adsObjectMap);}timerMetricAddDuration(this.emitRecordChangedTimerMetric,Date.now()-startTime);}}// The VERSION environment variable is replaced by rollup during the bundling and replaces it with
    // the commit hash. This avoid having a cache hit on data that has been stored by a previous
    // version of LDS.
    const STORAGE_VERSION="cc85835";// AuraStorage treats `secure` as a must-have whereas `persistent` is a nice-to-have. Secure and
    // persistent storage is only possible with CryptoAdapter. Availability of that adapter is
    // controlled by the application.
    const STORAGE_CONFIG={persistent:true,secure:true,maxSize:5*1024*1024,clearOnInit:false,debugLogging:false,version:STORAGE_VERSION};const STORAGE_INSTANCES=[];function createStorage(config){if(auraStorage.initStorage===undefined){return null;}const storageConfig=_objectSpread$1({},STORAGE_CONFIG,config);const storage=auraStorage.initStorage(storageConfig);if(!storage.isPersistent()){if(auraStorage.deleteStorage!==undefined){auraStorage.deleteStorage(storageConfig.name).catch(()=>{});// intentional noop on error
    }return null;}STORAGE_INSTANCES.push(storage);return storage;}function clearStorages(){return Promise.all(STORAGE_INSTANCES.map(storage=>storage.clear()));}const OBJECT_INFO_PREFIX='UiApi::ObjectInfoRepresentation:';const STORAGE_DROP_MARK_NAME='storage-drop';const STORAGE_DROP_MARK_CONTEXT={reason:'Object info changed'};/**
     * Watch an LDS instance for metadata changes.
     */function setupMetadataWatcher(lds){// Watch for object info changes. Since we don't have enough information to understand to which
    // extent an object info change may impact the application the only thing we do is to clear all
    // the  persistent storages.
    lds.storeWatch(OBJECT_INFO_PREFIX,entries=>{for(let i=0,len=entries.length;i<len;i++){const entry=entries[i];const isObjectInfoUpdated=entry.inserted===false;if(isObjectInfoUpdated){mark(STORAGE_DROP_MARK_NAME,STORAGE_DROP_MARK_CONTEXT);clearStorages().catch(()=>{/* noop */});break;}}});}class AuraFetchResponse{constructor(status,body,headers){this.status=status;this.body=body;this.headers=headers||{};}get statusText(){const{status}=this;switch(status){case HttpStatusCode.Ok:return 'OK';case HttpStatusCode.NotModified:return 'Not Modified';case HttpStatusCode.NotFound:return 'Not Found';case HttpStatusCode.BadRequest:return 'Bad Request';case HttpStatusCode.ServerError:return 'Server Error';default:return `Unexpected HTTP Status Code: ${status}`;}}get ok(){return this.status===200;}}const APEX_BASE_URI='/apex';const ApexController='ApexActionController.execute';function executeApex(resourceRequest){const{body}=resourceRequest;return dispatchApexAction(ApexController,body,{background:false,hotspot:false,longRunning:body.isContinuation});}function dispatchApexAction(endpoint,params,config){return aura.executeGlobalController(endpoint,params,config).then(body=>{// massage aura action response to
    //  headers: { cacheable }
    //  body: returnValue
    return new AuraFetchResponse(HttpStatusCode.Ok,body.returnValue===undefined?null:body.returnValue,// Headers expects properties of [name: string]: string
    // However this is a synthetic header and we want to keep the boolean
    {cacheable:body.cacheable});},err=>{// Handle ConnectedInJava exception shapes
    if(err.data!==undefined&&err.data.statusCode!==undefined){const{data}=err;throw new AuraFetchResponse(data.statusCode,data);}// Handle all the other kind of errors
    throw new AuraFetchResponse(HttpStatusCode.ServerError,err);});}const UI_API_BASE_URI='/services/data/v49.0/ui-api';const ACTION_CONFIG={background:false,hotspot:true,longRunning:false};const actionConfig={action:ACTION_CONFIG};function createOkResponse(body){return new AuraFetchResponse(HttpStatusCode.Ok,body);}/** Invoke an Aura controller with the pass parameters. */function dispatchAction(endpoint,params,config={}){const{action:actionConfig,cache:cacheConfig}=config;const fetchFromNetwork=()=>{return aura.executeGlobalController(endpoint,params,actionConfig).then(body=>{// If a cache is passed, store the action body in the cache before returning the
    // value. Even though `AuraStorage.set` is an asynchronous operation we don't
    // need to wait for the store to resolve/reject before returning the value.
    // Swallow the error to not have an unhandled promise rejection.
    if(cacheConfig!==undefined&&cacheConfig.storage!==null){cacheConfig.storage.set(cacheConfig.key,body).catch(_error=>{});}return createOkResponse(body);},err=>{// Handle ConnectedInJava exception shapes
    if(err.data!==undefined&&err.data.statusCode!==undefined){const{data}=err;throw new AuraFetchResponse(data.statusCode,data);}// Handle all the other kind of errors
    throw new AuraFetchResponse(HttpStatusCode.ServerError,{error:err.message});});};// If no cache is passed or if the action should be refreshed, directly fetch the action from
    // the server.
    if(cacheConfig===undefined||cacheConfig.forceRefresh===true||cacheConfig.storage===null){return fetchFromNetwork();}// Otherwise check for the action body in the cache. If action is not present in the cache or if
    // the cache lookup fails for any reason fallback to the network.
    return cacheConfig.storage.get(cacheConfig.key).then(cacheResult=>{if(cacheResult!==undefined){cacheConfig.statsLogger.logHits();return createOkResponse(cacheResult);}cacheConfig.statsLogger.logMisses();return fetchFromNetwork();},()=>{return fetchFromNetwork();});}/**
     * All the methods exposed out of the UiApiController accept a clientOption config. This method
     * adds methods returns a new params object with the client option if necessary, otherwise it
     * returns the passed params object.
     */function buildUiApiParams(params,resourceRequest){const ifModifiedSince=resourceRequest.headers['If-Modified-Since'];const ifUnmodifiedSince=resourceRequest.headers['If-Unmodified-Since'];let clientOptions={};if(ifModifiedSince!==undefined){clientOptions.ifModifiedSince=ifModifiedSince;}if(ifUnmodifiedSince!==undefined){clientOptions.ifUnmodifiedSince=ifUnmodifiedSince;}return Object.keys(clientOptions).length>0?_objectSpread$1({},params,{clientOptions:clientOptions}):params;}/** Returns true if an action should ignore the network cache data. */function shouldForceRefresh(resourceRequest){const cacheControl=resourceRequest.headers['Cache-Control'];return cacheControl!==undefined||cacheControl==='no-cache';}var UiApiActionsController;(function(UiApiActionsController){UiApiActionsController["GetLookupActions"]="ActionsController.getLookupActions";UiApiActionsController["GetRecordActions"]="ActionsController.getRecordActions";UiApiActionsController["GetRecordEditActions"]="ActionsController.getRecordEditActions";})(UiApiActionsController||(UiApiActionsController={}));const UIAPI_ACTIONS_LOOKUP_PATH=`${UI_API_BASE_URI}/actions/lookup/`;const UIAPI_ACTIONS_RECORD_PATH=`${UI_API_BASE_URI}/actions/record/`;const UIAPI_ACTIONS_RECORD_EDIT='/record-edit';function getLookupActions(resourceRequest){const{urlParams:{objectApiNames},queryParams}=resourceRequest;const parameters=buildUiApiParams(_objectSpread$1({objectApiNames},queryParams),resourceRequest);return dispatchAction(UiApiActionsController.GetLookupActions,parameters);}function getRecordActions(resourceRequest){const{urlParams:{recordIds},queryParams}=resourceRequest;const parameters=buildUiApiParams(_objectSpread$1({recordIds},queryParams),resourceRequest);return dispatchAction(UiApiActionsController.GetRecordActions,parameters);}function getRecordEditActions(resourceRequest){const{urlParams:{recordIds},queryParams}=resourceRequest;const parameters=buildUiApiParams(_objectSpread$1({recordIds},queryParams),resourceRequest);return dispatchAction(UiApiActionsController.GetRecordEditActions,parameters);}var UiApiListsController;(function(UiApiListsController){UiApiListsController["GetListsByObjectName"]="ListUiController.getListsByObjectName";UiApiListsController["GetListUiById"]="ListUiController.getListUiById";UiApiListsController["GetListRecordsById"]="ListUiController.getListRecordsById";UiApiListsController["GetListUiByName"]="ListUiController.getListUiByName";UiApiListsController["GetListRecordsByName"]="ListUiController.getListRecordsByName";})(UiApiListsController||(UiApiListsController={}));const UIAPI_LIST_RECORDS_PATH=`${UI_API_BASE_URI}/list-records/`;const UIAPI_LIST_UI_PATH=`${UI_API_BASE_URI}/list-ui/`;function getListRecordsByName(resourceRequest){const{urlParams:{objectApiName,listViewApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,listViewApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListRecordsByName,params);}function getListRecordsById(resourceRequest){const{urlParams:{listViewId},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({listViewId,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListRecordsById,params);}function getListUiByName(resourceRequest){const{urlParams:{objectApiName,listViewApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,listViewApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListUiByName,params);}function getListUiById(resourceRequest){const{urlParams:{listViewId},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({listViewId,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListUiById,params);}function getListsByObjectName(resourceRequest){const{urlParams:{objectApiName},queryParams:{pageSize,pageToken,q,recentListsOnly}}=resourceRequest;const params=buildUiApiParams({objectApiName,pageSize,pageToken,q,recentListsOnly},resourceRequest);return dispatchAction(UiApiListsController.GetListsByObjectName,params);}const UIAPI_LOOKUP_RECORDS=`${UI_API_BASE_URI}/lookups`;const LookupRecords='LookupController.getLookupRecords';function lookupRecords(resourceRequest){const{urlParams,queryParams}=resourceRequest;const params=buildUiApiParams(_objectSpread$1({},urlParams,queryParams),resourceRequest);return dispatchAction(LookupRecords,params);}var UiApiMruListsController;(function(UiApiMruListsController){UiApiMruListsController["GetMruListUi"]="MruListUiController.getMruListUi";UiApiMruListsController["GetMruListRecords"]="MruListUiController.getMruListRecords";})(UiApiMruListsController||(UiApiMruListsController={}));const UIAPI_MRU_LIST_RECORDS_PATH=`${UI_API_BASE_URI}/mru-list-records/`;const UIAPI_MRU_LIST_UI_PATH=`${UI_API_BASE_URI}/mru-list-ui/`;function getMruListRecords(resourceRequest){const{urlParams:{objectApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiMruListsController.GetMruListRecords,params);}function getMruListUi(resourceRequest){const{urlParams:{objectApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiMruListsController.GetMruListUi,params);}// Boundary which represents the limit that we start chunking at,
    // determined by comma separated string length of fields
    const MAX_STRING_LENGTH_PER_CHUNK=10000;const referenceId='LDS_Records_AggregateUi';function createOkResponse$1(body){return new AuraFetchResponse(HttpStatusCode.Ok,body);}function isSpanningRecord$2(fieldValue){return fieldValue!==null&&typeof fieldValue==='object';}function mergeRecordFields$1(first,second){const{fields:targetFields}=first;const{fields:sourceFields}=second;const fieldNames=keys$4(sourceFields);for(let i=0,len=fieldNames.length;i<len;i+=1){const fieldName=fieldNames[i];const sourceField=sourceFields[fieldName];const targetField=targetFields[fieldName];if(isSpanningRecord$2(sourceField.value)){if(targetField===undefined){targetFields[fieldName]=sourceFields[fieldName];continue;}mergeRecordFields$1(targetField.value,sourceField.value);continue;}targetFields[fieldName]=sourceFields[fieldName];}return first;}/** Invoke executeAggregateUi Aura controller.  This is only to be used with large getRecord requests that
     *  would otherwise cause a query length exception.
     */function dispatchSplitRecordAggregateUiAction(endpoint,params,config={}){const{action:actionConfig}=config;return aura.executeGlobalController(endpoint,params,actionConfig).then(body=>{// This response body could be an executeAggregateUi, which we don't natively support.
    // Massage it into looking like a getRecord response.
    if(body===null||body===undefined||body.compositeResponse===undefined||body.compositeResponse.length===0){// We shouldn't even get into this state - a 200 with no body?
    throw new AuraFetchResponse(HttpStatusCode.ServerError,{error:'No response body in executeAggregateUi found'});}const merged=body.compositeResponse.reduce((seed,response)=>{if(response.httpStatusCode!==HttpStatusCode.Ok){throw new AuraFetchResponse(HttpStatusCode.ServerError,{error:response.message});}if(seed===null){return response.body;}return mergeRecordFields$1(seed,response.body);},null);return createOkResponse$1(merged);},err=>{// Handle ConnectedInJava exception shapes
    if(err.data!==undefined&&err.data.statusCode!==undefined){const{data}=err;throw new AuraFetchResponse(data.statusCode,data);}// Handle all the other kind of errors
    throw new AuraFetchResponse(HttpStatusCode.ServerError,{error:err.message});});}function buildAggregateUiUrl(params,resourceRequest){const{fields,optionalFields}=params;const queryString=[];if(fields!==undefined&&fields.length>0){const fieldString=join.call(fields,',');push$2.call(queryString,`fields=${fieldString}`);}if(optionalFields!==undefined&&optionalFields.length>0){const optionalFieldString=join.call(optionalFields,',');push$2.call(queryString,`optionalFields=${optionalFieldString}`);}return `${resourceRequest.path}?${join.call(queryString,'&')}`;}function buildGetRecordByFieldsCompositeRequest(recordId,resourceRequest,recordsCompositeRequest){const{fieldsArray,optionalFieldsArray,fieldsLength,optionalFieldsLength}=recordsCompositeRequest;// Formula:  # of fields per chunk = floor(avg field length / max length per chunk)
    const averageFieldStringLength=Math.floor((fieldsLength+optionalFieldsLength)/(fieldsArray.length+optionalFieldsArray.length));const fieldsPerChunk=Math.floor(MAX_STRING_LENGTH_PER_CHUNK/averageFieldStringLength);const fieldsChunks=[];const optionalFieldsChunks=[];for(let i=0,j=fieldsArray.length;i<j;i+=fieldsPerChunk){const newChunk=fieldsArray.slice(i,i+fieldsPerChunk);push$2.call(fieldsChunks,newChunk);}for(let i=0,j=optionalFieldsArray.length;i<j;i+=fieldsPerChunk){const newChunk=optionalFieldsArray.slice(i,i+fieldsPerChunk);push$2.call(optionalFieldsChunks,newChunk);}const compositeRequest=[];for(let i=0,len=fieldsChunks.length;i<len;i+=1){const fieldChunk=fieldsChunks[i];const url=buildAggregateUiUrl({recordId,fields:fieldChunk},resourceRequest);push$2.call(compositeRequest,{url,referenceId:`${referenceId}_fields_${i}`});}for(let i=0,len=optionalFieldsChunks.length;i<len;i+=1){const fieldChunk=optionalFieldsChunks[i];const url=buildAggregateUiUrl({recordId,optionalFields:fieldChunk},resourceRequest);push$2.call(compositeRequest,{url,referenceId:`${referenceId}_optionalFields_${i}`});}return compositeRequest;}function shouldUseAggregateUiForGetRecord(fieldsArray,optionalFieldsArray){return fieldsArray.length+optionalFieldsArray.length>=MAX_STRING_LENGTH_PER_CHUNK;}var UiApiRecordController;(function(UiApiRecordController){UiApiRecordController["CreateRecord"]="RecordUiController.createRecord";UiApiRecordController["DeleteRecord"]="RecordUiController.deleteRecord";UiApiRecordController["ExecuteAggregateUi"]="RecordUiController.executeAggregateUi";UiApiRecordController["GetLayout"]="RecordUiController.getLayout";UiApiRecordController["GetLayoutUserState"]="RecordUiController.getLayoutUserState";UiApiRecordController["GetRecordAvatars"]="RecordUiController.getRecordAvatars";UiApiRecordController["GetRecordCreateDefaults"]="RecordUiController.getRecordCreateDefaults";UiApiRecordController["GetRecordUi"]="RecordUiController.getRecordUis";UiApiRecordController["GetRecordWithFields"]="RecordUiController.getRecordWithFields";UiApiRecordController["GetRecordWithLayouts"]="RecordUiController.getRecordWithLayouts";UiApiRecordController["GetObjectInfo"]="RecordUiController.getObjectInfo";UiApiRecordController["GetObjectInfos"]="RecordUiController.getObjectInfos";UiApiRecordController["GetPicklistValues"]="RecordUiController.getPicklistValues";UiApiRecordController["GetPicklistValuesByRecordType"]="RecordUiController.getPicklistValuesByRecordType";UiApiRecordController["UpdateRecord"]="RecordUiController.updateRecord";UiApiRecordController["UpdateRecordAvatar"]="RecordUiController.postRecordAvatarAssociation";UiApiRecordController["UpdateLayoutUserState"]="RecordUiController.updateLayoutUserState";})(UiApiRecordController||(UiApiRecordController={}));const UIAPI_GET_LAYOUT=`${UI_API_BASE_URI}/layout/`;const UIAPI_RECORDS_PATH=`${UI_API_BASE_URI}/records`;const UIAPI_RECORD_AVATARS_BASE=`${UI_API_BASE_URI}/record-avatars/`;const UIAPI_RECORD_AVATARS_BATCH_PATH=`${UI_API_BASE_URI}/record-avatars/batch/`;const UIAPI_RECORD_AVATAR_UPDATE=`/association`;const UIAPI_RECORD_CREATE_DEFAULTS_PATH=`${UI_API_BASE_URI}/record-defaults/create/`;const UIAPI_RECORD_UI_PATH=`${UI_API_BASE_URI}/record-ui/`;const UIAPI_GET_LAYOUT_USER_STATE='/user-state';const UIAPI_OBJECT_INFO_PATH=`${UI_API_BASE_URI}/object-info/`;const UIAPI_OBJECT_INFO_BATCH_PATH=`${UI_API_BASE_URI}/object-info/batch/`;const objectInfoStorage=createStorage({name:'ldsObjectInfo',expiration:5*60});const objectInfoStorageStatsLogger=registerLdsCacheStats('getObjectInfo:storage');const layoutStorage=createStorage({name:'ldsLayout',expiration:15*60});const layoutStorageStatsLogger=registerLdsCacheStats('getLayout:storage');const layoutUserStateStorage=createStorage({name:'ldsLayoutUserState',expiration:15*60});const layoutUserStateStorageStatsLogger=registerLdsCacheStats('getLayoutUserState:storage');function getObjectInfo(resourceRequest,cacheKey){const params=buildUiApiParams({objectApiName:resourceRequest.urlParams.objectApiName},resourceRequest);const config=_objectSpread$1({},actionConfig);if(objectInfoStorage!==null){config.cache={storage:objectInfoStorage,key:cacheKey,statsLogger:objectInfoStorageStatsLogger,forceRefresh:shouldForceRefresh(resourceRequest)};}return dispatchAction(UiApiRecordController.GetObjectInfo,params,config);}function getObjectInfos(resourceRequest,cacheKey){const params=buildUiApiParams({objectApiNames:resourceRequest.urlParams.objectApiNames},resourceRequest);const config=_objectSpread$1({},actionConfig);if(objectInfoStorage!==null){config.cache={storage:objectInfoStorage,key:cacheKey,statsLogger:objectInfoStorageStatsLogger,forceRefresh:shouldForceRefresh(resourceRequest)};}return dispatchAction(UiApiRecordController.GetObjectInfos,params,config);}function getRecord$1(resourceRequest){const{urlParams,queryParams}=resourceRequest;const{recordId}=urlParams;const{fields,layoutTypes,modes,optionalFields}=queryParams;const fieldsArray=fields!==undefined&&isArray$4(fields)?fields:[];const optionalFieldsArray=optionalFields!==undefined&&Array.isArray(optionalFields)?optionalFields:[];const fieldsString=fieldsArray.join(',');const optionalFieldsString=optionalFieldsArray.join(',');// Don't submit a megarequest to UIAPI due to SOQL limit reasons.
    // Split and aggregate if needed
    const useAggregateUi=shouldUseAggregateUiForGetRecord(fieldsString,optionalFieldsString);if(useAggregateUi){incrementGetRecordAggregateInvokeCount();const compositeRequest=buildGetRecordByFieldsCompositeRequest(recordId,resourceRequest,{fieldsArray,optionalFieldsArray,fieldsLength:fieldsString.length,optionalFieldsLength:optionalFieldsString.length});const aggregateUiParams={input:{compositeRequest}};return dispatchSplitRecordAggregateUiAction(UiApiRecordController.ExecuteAggregateUi,aggregateUiParams,actionConfig);}let getRecordParams={};let controller;incrementGetRecordNormalInvokeCount();if(layoutTypes!==undefined){getRecordParams={recordId,layoutTypes,modes,optionalFields};controller=UiApiRecordController.GetRecordWithLayouts;}else {getRecordParams={recordId,fields,optionalFields};controller=UiApiRecordController.GetRecordWithFields;}const params=buildUiApiParams(getRecordParams,resourceRequest);return dispatchAction(controller,params,actionConfig);}function createRecord(resourceRequest){const params=buildUiApiParams({recordInput:resourceRequest.body},resourceRequest);return dispatchAction(UiApiRecordController.CreateRecord,params,actionConfig);}function deleteRecord(resourceRequest){const{urlParams}=resourceRequest;const params=buildUiApiParams({recordId:urlParams.recordId},resourceRequest);return dispatchAction(UiApiRecordController.DeleteRecord,params,actionConfig);}function updateRecord(resourceRequest){const{body,urlParams}=resourceRequest;const params=buildUiApiParams({recordId:urlParams.recordId,recordInput:body},resourceRequest);return dispatchAction(UiApiRecordController.UpdateRecord,params,actionConfig);}function updateLayoutUserState$1(resourceRequest){const{body,urlParams:{objectApiName},queryParams:{layoutType,mode,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,layoutType,mode,recordTypeId,userState:body},resourceRequest);return dispatchAction(UiApiRecordController.UpdateLayoutUserState,params,actionConfig).then(response=>{// TODO: Instead of surgically evicting the record that has been updated in the cache we
    // currently dump all the entries. We need a way to recreate the same cache key between
    // getLayoutUserState and updateLayoutUserState.
    if(layoutUserStateStorage!==null){layoutUserStateStorage.clear();}return response;});}function getRecordAvatars(resourceRequest){const{urlParams}=resourceRequest;const recordIds=urlParams.recordIds;const params=buildUiApiParams({recordIds},resourceRequest);return dispatchAction(UiApiRecordController.GetRecordAvatars,params,actionConfig);}function updateRecordAvatar(resourceRequest){const{urlParams,body}=resourceRequest;const params=buildUiApiParams({input:body,recordId:urlParams.recordId},resourceRequest);return dispatchAction(UiApiRecordController.UpdateRecordAvatar,params,actionConfig);}function getRecordUi(resourceRequest){const{urlParams:{recordIds},queryParams:{layoutTypes,modes,optionalFields}}=resourceRequest;const params=buildUiApiParams({layoutTypes,modes,optionalFields,recordIds},resourceRequest);return dispatchAction(UiApiRecordController.GetRecordUi,params,actionConfig);}function getPicklistValues(resourceRequest){const{urlParams}=resourceRequest;const params=buildUiApiParams({objectApiName:urlParams.objectApiName,recordTypeId:urlParams.recordTypeId,fieldApiName:urlParams.fieldApiName},resourceRequest);return dispatchAction(UiApiRecordController.GetPicklistValues,params,actionConfig);}function getPicklistValuesByRecordType(resourceRequest){const{urlParams:{objectApiName,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,recordTypeId},resourceRequest);return dispatchAction(UiApiRecordController.GetPicklistValuesByRecordType,params,actionConfig);}function getLayout(resourceRequest,cacheKey){const{urlParams:{objectApiName},queryParams:{layoutType,mode,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,layoutType,mode,recordTypeId},resourceRequest);const config=_objectSpread$1({},actionConfig);if(layoutStorage!==null){config.cache={storage:layoutStorage,key:cacheKey,statsLogger:layoutStorageStatsLogger,forceRefresh:shouldForceRefresh(resourceRequest)};}return dispatchAction(UiApiRecordController.GetLayout,params,config);}function getLayoutUserState(resourceRequest,cacheKey){const{urlParams:{objectApiName},queryParams:{layoutType,mode,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,layoutType,mode,recordTypeId},resourceRequest);const config=_objectSpread$1({},actionConfig);if(layoutUserStateStorage!==null){config.cache={storage:layoutUserStateStorage,key:cacheKey,statsLogger:layoutUserStateStorageStatsLogger,forceRefresh:shouldForceRefresh(resourceRequest)};}return dispatchAction(UiApiRecordController.GetLayoutUserState,params,config);}function getRecordCreateDefaults(resourceRequest){const{urlParams:{objectApiName},queryParams:{formFactor,optionalFields,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,formFactor,recordTypeId,optionalFields},resourceRequest);return dispatchAction(UiApiRecordController.GetRecordCreateDefaults,params,actionConfig);}const ACTION_CONFIG$1={background:false,hotspot:true,longRunning:false};const BASE_URI='/services/data/v49.0';const CONNECT_BASE_URI=`${BASE_URI}/connect`;const COMMERCE_BASE_URI=`${BASE_URI}/commerce`;var ConnectController;(function(ConnectController){ConnectController["GetCommunityNavigationMenu"]="NavigationMenuController.getCommunityNavigationMenu";ConnectController["GetProduct"]="CommerceCatalogController.getProduct";ConnectController["GetProductCategoryPath"]="CommerceCatalogController.getProductCategoryPath";ConnectController["ProductSearch"]="CommerceProductSearchController.productSearch";ConnectController["GetProductPrice"]="CommerceStorePricingController.getProductPrice";})(ConnectController||(ConnectController={}));const COMMUNITIES_NAVIGATION_MENU_PATH=new RegExp(`${CONNECT_BASE_URI}/communities/([A-Z0-9]){15,18}/navigation-menu`,'i');const GET_PRODUCT_PATH=new RegExp(`${COMMERCE_BASE_URI}/webstores/([A-Z0-9]){15,18}/products/([A-Z0-9]){15,18}`,'i');const GET_PRODUCT_CATEGORY_PATH_PATH=new RegExp(`${COMMERCE_BASE_URI}/webstores/([A-Z0-9]){15,18}/product-category-path/product-categories/([A-Z0-9]){15,18}`,'i');const PRODUCT_SEARCH_PATH=new RegExp(`${COMMERCE_BASE_URI}/webstores/([A-Z0-9]){15,18}/search/product-search`,'i');const GET_PRODUCT_PRICE_PATH=new RegExp(`${COMMERCE_BASE_URI}/webstores/([A-Z0-9]){15,18}/pricing/products/([A-Z0-9]){15,18}`,'i');function getCommunityNavigationMenu(resourceRequest){return dispatchConnectAction(ConnectController.GetCommunityNavigationMenu,resourceRequest);}function getProduct(resourceRequest){return dispatchConnectAction(ConnectController.GetProduct,resourceRequest);}function getProductCategoryPath(resourceRequest){return dispatchConnectAction(ConnectController.GetProductCategoryPath,resourceRequest);}function productSearch(resourceRequest){return dispatchConnectAction(ConnectController.ProductSearch,resourceRequest);}function getProductPrice(resourceRequest){return dispatchConnectAction(ConnectController.GetProductPrice,resourceRequest);}function dispatchConnectAction(controller,resourceRequest){const actionConfig={action:ACTION_CONFIG$1};const{urlParams,queryParams}=resourceRequest;const params=_objectSpread$1({},urlParams,queryParams);return dispatchAction(controller,params,actionConfig);}function controllerInvokerFactory(resourceRequest){const{path,method}=resourceRequest;switch(method){case'delete':if(path.startsWith(UIAPI_RECORDS_PATH)){return deleteRecord;}break;case'post':if(path===UIAPI_RECORDS_PATH){return createRecord;}if(path===APEX_BASE_URI){return executeApex;}if(path.startsWith(UIAPI_RECORD_AVATARS_BASE)){if(path.endsWith(UIAPI_RECORD_AVATAR_UPDATE)){return updateRecordAvatar;}}if(path.startsWith(COMMERCE_BASE_URI)){if(PRODUCT_SEARCH_PATH.test(path)){return productSearch;}}break;case'patch':if(path.startsWith(UIAPI_RECORDS_PATH)){return updateRecord;}if(path.startsWith(UIAPI_GET_LAYOUT)){if(path.endsWith(UIAPI_GET_LAYOUT_USER_STATE)){return updateLayoutUserState$1;}}break;case'get':if(path.startsWith(UIAPI_ACTIONS_LOOKUP_PATH)){return getLookupActions;}if(path.startsWith(UIAPI_ACTIONS_RECORD_PATH)){if(path.endsWith(UIAPI_ACTIONS_RECORD_EDIT)){return getRecordEditActions;}else {return getRecordActions;}}if(path.startsWith(UIAPI_LIST_RECORDS_PATH)){if(/list-records\/.*\//.test(path)){// .../list-records/${objectApiName}/${listViewApiName}
    return getListRecordsByName;}else {// .../list-records/${listViewId}
    return getListRecordsById;}}if(path.startsWith(UIAPI_LIST_UI_PATH)){if(/list-ui\/.*\//.test(path)){// .../list-ui/${objectApiName}/${listViewApiName}
    return getListUiByName;}else if(/00B[a-zA-Z\d]{15}$/.test(path)){// .../list-ui/${listViewId}
    return getListUiById;}else {// .../list-ui/${objectApiName}
    return getListsByObjectName;}}if(path.startsWith(UIAPI_MRU_LIST_RECORDS_PATH)){return getMruListRecords;}if(path.startsWith(UIAPI_MRU_LIST_UI_PATH)){return getMruListUi;}if(path.startsWith(UIAPI_OBJECT_INFO_PATH)){if(path.startsWith(UIAPI_OBJECT_INFO_BATCH_PATH)){// object-info/batch/
    return getObjectInfos;}else if(/picklist-values\/[a-zA-Z\d]+\/[a-zA-Z\d]+/.test(path)){// object-info/API_NAME/picklist-values/RECORD_TYPE_ID/FIELD_API_NAME
    return getPicklistValues;}else if(/picklist-values\/[a-zA-Z\d]+/.test(path)){// object-info/API_NAME/picklist-values/RECORD_TYPE_ID
    return getPicklistValuesByRecordType;}return getObjectInfo;}if(path.startsWith(UIAPI_RECORDS_PATH)){return getRecord$1;}if(path.startsWith(UIAPI_RECORD_CREATE_DEFAULTS_PATH)){return getRecordCreateDefaults;}if(path.startsWith(UIAPI_RECORD_AVATARS_BATCH_PATH)){return getRecordAvatars;}if(path.startsWith(UIAPI_RECORD_UI_PATH)){return getRecordUi;}if(path.startsWith(UIAPI_LOOKUP_RECORDS)){return lookupRecords;}if(path.startsWith(UIAPI_GET_LAYOUT)){if(path.endsWith(UIAPI_GET_LAYOUT_USER_STATE)){return getLayoutUserState;}return getLayout;}// All connect APIs
    if(path.startsWith(CONNECT_BASE_URI)){if(COMMUNITIES_NAVIGATION_MENU_PATH.test(path)){return getCommunityNavigationMenu;}}// All commerce APIs
    if(path.startsWith(COMMERCE_BASE_URI)){if(GET_PRODUCT_PATH.test(path)){return getProduct;}if(GET_PRODUCT_CATEGORY_PATH_PATH.test(path)){return getProductCategoryPath;}if(GET_PRODUCT_CATEGORY_PATH_PATH.test(path)){return getProductCategoryPath;}if(GET_PRODUCT_PRICE_PATH.test(path)){return getProductPrice;}}break;}throw new Error(`No invoker matching controller factory: ${path} ${method}.`);}function getFulfillingRequest(inflightRequests,resourceRequest){const{fulfill}=resourceRequest;if(fulfill===undefined){return null;}const handlersMap=entries(inflightRequests);for(let i=0,len=handlersMap.length;i<len;i+=1){const[transactionKey,handlers]=handlersMap[i];// check fulfillment against only the first handler ([0]) because it's equal or
    // fulfills all subsequent handlers in the array
    const existing=handlers[0].resourceRequest;if(fulfill(existing,resourceRequest)===true){return transactionKey;}}return null;}function getTransactionKey(resourceRequest){const{path,key,queryParams,headers}=resourceRequest;return `${path}::${stringify$4(headers)}::${queryParams?stringify$4(queryParams):''}::${key}`;}const inflightRequests=Object.create(null);function networkAdapter(resourceRequest){const{method}=resourceRequest;const transactionKey=getTransactionKey(resourceRequest);const controllerInvoker=controllerInvokerFactory(resourceRequest);if(method!=='get'){return controllerInvoker(resourceRequest,transactionKey);}// if an identical request is in-flight then queue for its response (do not re-issue the request)
    if(transactionKey in inflightRequests){return new Promise((resolve,reject)=>{push$2.call(inflightRequests[transactionKey],{resolve,reject,resourceRequest});});}// fallback to checking a custom deduper to find a similar (but not identical) request
    const similarTransactionKey=getFulfillingRequest(inflightRequests,resourceRequest);if(similarTransactionKey!==null){return new Promise(resolve=>{// custom dedupers find similar (not identical) requests. if the similar request fails
    // there's no guarantee the deduped request should fail. thus we re-issue the
    // original request in the case of a failure
    function reissueRequest(){resolve(networkAdapter(resourceRequest));}push$2.call(inflightRequests[similarTransactionKey],{resolve,reject:reissueRequest,resourceRequest});});}// not a duplicate request so invoke the network
    // when it resolves, clear the queue then invoke queued handlers
    // (must clear the queue first in case handlers re-invoke the network)
    controllerInvoker(resourceRequest,transactionKey).then(response=>{const handlers=inflightRequests[transactionKey];delete inflightRequests[transactionKey];// handlers mutate responses so must clone the response for each.
    // the first handler is given the original version to avoid an
    // extra clone (particularly when there's only 1 handler).
    for(let i=1,len=handlers.length;i<len;i++){const handler=handlers[i];handler.resolve(parse$1(stringify$4(response)));}handlers[0].resolve(response);},error=>{const handlers=inflightRequests[transactionKey];delete inflightRequests[transactionKey];for(let i=0,len=handlers.length;i<len;i++){const handler=handlers[i];handler.reject(error);}});// rely on sync behavior of Promise creation to create the list for handlers
    return new Promise((resolve,reject)=>{inflightRequests[transactionKey]=[{resolve,reject,resourceRequest}];});}const store=new Store();const instrumentation=new Instrumentation();const lds=new LDS(store,networkAdapter,{instrument:instrumentation.instrumentNetwork.bind(instrumentation)});setupInstrumentation(lds,store);setupMetadataWatcher(lds);/** Create a new LDS adapter from an adapter factory. */const createLdsAdapter=(name,factory)=>{return instrumentAdapter(name,factory(lds));};/** Register an LDS adapter to the LWC Wire Service */const registerWireAdapter=adapter=>{return register(lds,wireService,adapter);};/** Create and register an LDS adapter factory. */const setupWireAdapter=(name,factory)=>{const adapter=createLdsAdapter(name,factory);return registerWireAdapter(adapter);};const getObjectInfoLdsAdapter=createLdsAdapter('getObjectInfo',getObjectInfoAdapterFactory);const getObjectInfosLdsAdapter=createLdsAdapter('getObjectInfos',getObjectInfosAdapterFactory);const getLayoutLdsAdapter=createLdsAdapter('getLayout',factory$2);const getRecordLdsAdapter=createLdsAdapter('getRecord',factory$7);const getRecordActionsLdsAdapter=getRecordActionsAdapterFactory(lds);const getRecordAvatarsLdsAdapter=createLdsAdapter('getRecordAvatars',factory$8);const getRecordUiLdsAdapter=createLdsAdapter('getRecordUi',factory$6);const getLayoutUserStateLdsAdapter=createLdsAdapter('getLayoutUserState',factory$3);const baseCreateRecord=factory$1(lds);const createRecord$1=(...config)=>{return baseCreateRecord(...config).then(snapshot=>snapshot.data);};const getLayout$1=registerWireAdapter(getLayoutLdsAdapter);const getLayoutUserState$1=registerWireAdapter(getLayoutUserStateLdsAdapter);const getListUi=setupWireAdapter('getListUi',factory$4);const getLookupActions$1=setupWireAdapter('getLookupActions',getLookupActionsAdapterFactory);const getLookupRecords=setupWireAdapter('getLookupRecords',factory$5);const getObjectInfo$1=registerWireAdapter(getObjectInfoLdsAdapter);const getObjectInfos$1=registerWireAdapter(getObjectInfosLdsAdapter);const getPicklistValues$1=setupWireAdapter('getPicklistValues',factory$9);const getPicklistValuesByRecordType$1=setupWireAdapter('getPicklistValuesByRecordType',factory$a);const getRecord$2=registerWireAdapter(getRecordLdsAdapter);const getRecordActions$1=registerWireAdapter(getRecordActionsLdsAdapter);const getRecordAvatars$1=registerWireAdapter(getRecordAvatarsLdsAdapter);const getRecordCreateDefaults$1=setupWireAdapter('getRecordCreateDefaults',factory$e);const getRecordEditActions$1=setupWireAdapter('getRecordEditActions',getRecordEditActionsAdapterFactory);const getRecordUi$1=registerWireAdapter(getRecordUiLdsAdapter);const baseUpdateRecord=factory$b(lds);const updateRecord$1=(...config)=>{return baseUpdateRecord(...config).then(snapshot=>snapshot.data);};/**
     * Connect
     */const getCommunityNavigationMenuAdapter=createLdsAdapter('getCommunityNavigationMenu',getCommunityNavigationMenuAdapterFactory);const getCommunityNavigationMenu$1=registerWireAdapter(getCommunityNavigationMenuAdapter);/**
     * Commerce
     */const getProductAdapter=createLdsAdapter('getProduct',getProductAdapterFactory);const getProduct$1=registerWireAdapter(getProductAdapter);const getProductCategoryPathAdapter=createLdsAdapter('getProductCategoryPath',getProductCategoryPathAdapterFactory);const getProductCategoryPath$1=registerWireAdapter(getProductCategoryPathAdapter);const getProductPriceAdapter=createLdsAdapter('getProductPrice',getProductPriceAdapterFactory);const getProductPrice$1=registerWireAdapter(getProductPriceAdapter);const productSearchAdapter=createLdsAdapter('productSearch',productSearchAdapterFactory);const productSearch$1=registerWireAdapter(productSearchAdapter);const adsBridge=new AdsBridge(lds);const getRecordNotifyChange=throttle(60,60000,notifyChangeFactory(lds),{allowFunction:incrementGetRecordNotifyChangeAllowCount,dropFunction:incrementGetRecordNotifyChangeDropCount});/** UI API exports */const createRecord$2=createRecord$1;const getLookupActions$2=getLookupActions$1;const getLookupRecords$1=getLookupRecords;const getPicklistValuesByRecordType$2=getPicklistValuesByRecordType$1;const getRecordCreateDefaults$2=getRecordCreateDefaults$1;const getRecordUi$2=getRecordUi$1;const updateRecord$2=updateRecord$1;/** Record Util Pure Functions */const createRecordInputFilteredByEditedFields$1=createRecordInputFilteredByEditedFields;const generateRecordInputForCreate$1=generateRecordInputForCreate;const generateRecordInputForUpdate$1=generateRecordInputForUpdate;// version: 0.1.10-cc85835

    /*
     * Constants to use UI API.
     *
     * The values must match those used in UI API responses.
     */
    const DensityValues = {
      COMFY: 'comfy',
      COMPACT: 'compact',
      AUTO: 'auto'
    };
    const LabelAlignValues = {
      STACKED: 'stacked',
      HORIZONTAL: 'horizontal'
    };
    /**
     * Field types.
     * source: TODO - add ui sdk java class
     */

    const FieldTypes = {
      ADDRESS: 'Address',
      BASE64: 'Base64',
      BOOLEAN: 'Boolean',
      COMPLEX_VALUE: 'ComplexValue',
      CURRENCY: 'Currency',
      DATE: 'Date',
      DATETIME: 'DateTime',
      DOUBLE: 'Double',
      RICH_TEXTAREA: 'RichTextArea',
      DECIMAL: 'Decimal',
      EMAIL: 'Email',
      ENCRYPTED_STRING: 'EncryptedString',
      INT: 'Int',
      LOCATION: 'Location',
      MULTI_PICKLIST: 'MultiPicklist',
      PLAIN_TEXTAREA: 'PlainTextArea',
      PERCENT: 'Percent',
      PHONE: 'Phone',
      PICKLIST: 'Picklist',
      REFERENCE: 'Reference',
      STRING: 'String',
      TEXT: 'Text',
      TEXTAREA: 'TextArea',
      TIME: 'Time',
      URL: 'Url',
      PERSON_NAME: 'PersonName',
      SWITCHABLE_PERSON_NAME: 'SwitchablePersonName'
    };
    /**
     * Localized field types.
     * source: com.force.util.soql.functions.SoqlFunctions.fieldSupportsToLabel(String, String)
     */

    const LocalizedFieldTypes = [FieldTypes.MULTI_PICKLIST, FieldTypes.PICKLIST, FieldTypes.CURRENCY, FieldTypes.DATE, FieldTypes.DATETIME];

    const Fields = FieldTypes;
    const UNSUPPORTED_REFERENCE_FIELDS = ['OwnerId', 'CreatedById', 'LastModifiedById'];
    const labelAlignValues = LabelAlignValues;
    const densityValues = DensityValues;

    const getCompoundValue = (field, record, fieldInfo, objectInfo) => {
      if (FieldTypes.LOCATION === fieldInfo.dataType) {
        const prefix = field.slice(0, field.indexOf('__c'));
        const longitude = record.fields[prefix + '__Longitude__s'].value;
        const latitude = record.fields[prefix + '__Latitude__s'].value;
        return {
          longitude,
          latitude
        };
      } // fields with no value, it must be derived from the constituant fields


      const compoundFields = getCompoundFields(field, record, objectInfo);
      const ret = {};
      compoundFields.forEach(childField => {
        if (record.fields[childField]) {
          ret[childField] = record.fields[childField].value;
        }
      });
      return ret;
    };
    /**
     * Given a record will determine if it is a PersonAccount or not
     * @param {Object} record the record to check
     *
     * @returns {boolean} true if the record is a personAccount
     */


    function isPersonAccount(record) {
      if (record.apiName !== 'Account' && record.apiName !== 'PersonAccount') {
        return false;
      }

      return record.fields.IsPersonAccount ? record.fields.IsPersonAccount.value : false;
    }
    /**
    /**
     *
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} record the record
     * @param {object} objectInfo a single object info defining the field
     * @return {array} a list of constituent fields
     */

    function getCompoundFields(field, record, objectInfo) {
      return Object.keys(objectInfo.fields).filter(key => {
        return key !== field && record.fields[key] && objectInfo.fields[key].compoundFieldName === field;
      });
    }

    const getReferenceInfo = (record, fieldInfo) => {
      const relationshipName = fieldInfo.relationshipName; // TODO: handle multiple referenceToInfos

      const relationshipNameFields = fieldInfo.referenceToInfos[0].nameFields;
      const relationship = record.fields[relationshipName];

      if (!relationship || !relationship.value) {
        return {
          referenceId: null,
          displayValue: null
        };
      } // TODO: Should references support localized fields and thus return a value to complement their displayValue?


      const referenceField = relationship.value.fields;
      const displayValue = relationship.displayValue || relationshipNameFields.reduce((acc, nameField) => {
        const thisField = referenceField[nameField];

        if (thisField) {
          return acc + ' ' + thisField.value;
        }

        return acc;
      }, '').trim();
      return {
        referenceId: referenceField.Id.value,
        displayValue
      };
    };
    /**
     * Get a UiField from a field on a record.
     * objectInfo and objectInfos are optional but at least one must be present
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} record the record
     * @param {object} objectInfo a single object info defining the field
     * @return {array} a UiField representing the field.
     */


    const getUiField = (field, record, objectInfo) => {
      const fieldInfo = objectInfo.fields[field];

      if (!fieldInfo) {
        throw new Error(`Field [${field}] was not found`);
      }

      const personAccount = isPersonAccount(record);
      const value = isCompoundField(field, objectInfo, personAccount) ? getCompoundValue(field, record, fieldInfo, objectInfo) : record.fields[field] && record.fields[field].value; // TODO - handle formatting
      // ui sdk formats these field types: currency, date, datetime, time (/ui-services-api/java/src/ui/services/api/soql/FormatFunctionHelper.java
      // ui sdk localizes based on com.force.util.soql.functions.SoqlFunctions.fieldSupportsToLabel(String, String)
      // thomas will expose this in objectInfo but until then i can pivot on that logic
      // - if [currency date datetime time] use value
      // - else if diplayValue is present use it
      // - else use value

      let result = {
        type: fieldInfo.dataType,
        extraTypeInfo: fieldInfo.extraTypeInfo,
        label: fieldInfo.label,
        inlineHelpText: fieldInfo.inlineHelpText,
        value
      };
      result = Object.assign(result, fieldInfo);

      if (fieldInfo.reference) {
        const referenceInfo = getReferenceInfo(record, fieldInfo);
        result.value = referenceInfo.referenceId;
        result.displayValue = referenceInfo.displayValue;
      } else {
        // provide the display value for localizable field types
        const includeDisplayValue = LocalizedFieldTypes.includes(fieldInfo.dataType);

        if (includeDisplayValue) {
          result.displayValue = record.fields[field].displayValue;
        }
      }

      return result;
    };
    /**
     * Determine if any field in a list of fields
     * is updateable
     * @param {array} fields list of constituent fields
     * @param {object} record the record
     * @param {object} objectInfo object info
     *
     * @returns {Boolean} true if any of the fields are updateable, otherwise false
     */

    function compoundFieldIsUpdateable(fields, record, objectInfo) {
      return fieldAttributesTruthy('updateable', fields, objectInfo);
    }
    /**
     * Determine if any field in a list of fields
     * is createable
     * @param {array} fields list of constituent fields
     * @param {object} record the record
     * @param {object} objectInfo object info
     *
     * @returns {Boolean} true if any of the fields are updateable, otherwise false
     */

    function compoundFieldIsCreateable(fields, record, objectInfo) {
      return fieldAttributesTruthy('createable', fields, objectInfo);
    }
    /**
     * Checks is the attribute in a list of fields is truthy for all
     * fields
     * @param {String} attribute The attribute to check
     * @param {Array} fields List of fields to check
     * @param {Object} objectInfo ObjectInfo to check in
     *
     * @returns {Boolean} true if any of the fields are truthy, false otherwise
     */

    function fieldAttributesTruthy(attribute, fields, objectInfo) {
      for (let i = 0; i < fields.length; i++) {
        if (!objectInfo.fields[fields[i]]) {
          throw new Error(`Constituent field "${fields[i]}" does not exist`);
        }

        if (objectInfo.fields[fields[i]][attribute]) {
          return true;
        }
      }

      return false;
    }
    /**
     *
     * Determines if a field actually has contituent fields,
     * because some fields might identify themselves as compound
     * but without constituent fields we can't treat them as compound
     *
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} objectInfo a single object info defining the field
     * @param {boolean} personAccount if this object is a PersonAccount (Name is compound)
     *                                  https://help.salesforce.com/articleView?id=account_person.htm&type=5
     * @returns {boolean} true if the field is a compound field, false if it is not
     */


    function isCompoundField(field, objectInfo, personAccount = false) {
      const fieldInfo = objectInfo.fields[field];

      if (!fieldInfo) {
        // a field that does not exist is not compound
        // this is safety to prevent gacks and probably should not generally happen
        return false;
      }

      if (fieldInfo.compound === false) {
        return false;
      }

      const keys = Object.keys(objectInfo.fields);

      for (let i = 0; i < keys.length; i++) {
        if (keys[i] !== field && objectInfo.fields[keys[i]].compoundFieldName === field) {
          // special case for when person accounts are enabled, but this is not a personAccount. In this case
          // the Name field of an account looks like a compound field but is not.
          if (objectInfo.apiName === 'Account' && objectInfo.fields[keys[i]].compoundFieldName === 'Name' && !personAccount) {
            return false;
          }

          return true;
        }
      }

      return false;
    }
    /**
     * Normalize the given error object.
     * @param  {Error | Object} err This could be a javascript Error or an error emitted from LDS (ErrorResponse).
     * @return {Object} An object with a string message and a string detail
     */

    function parseError(err) {
      let message = '',
          output = {},
          detail = '';

      if (err) {
        if (err.body && err.body.output) {
          // ErrorResponse with Record Output Error
          // https://developer.salesforce.com/docs/atlas.en-us.uiapi.meta/uiapi/ui_api_responses_error_with_output.htm
          message = err.body.message;

          if (err.body.output.errors.length > 0) {
            detail = err.body.output.errors[0].message;
          } // output is part of the recordUi error response,
          // so we will include it.


          output = JSON.parse(JSON.stringify(err.body.output));
        } else if (Array.isArray(err.body) && err.body.length > 0) {
          // ErrorResponse with normal UIAPI error.
          message = err.body[0].message;
          detail = err.body[0].errorCode;
        } else if (err.body && err.body.message) {
          // ErrorResponse with body that has a message.
          message = err.body.message;
        } else if (err.body) {
          // ErrorResponse with unknown body.
          message = err.body;
        } else if (err.statusText) {
          // ErrorResponse with no body.
          message.err = err.statusText;
        } else if (err.message) {
          // Vanilla js error.
          message = err.message;
        } else {
          // Unknown error.
          message = err;
        }
      }

      return {
        message,
        detail,
        output
      };
    }

    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    function filterByPicklistsInForm(objectInfo, picklistValues, fields) {
      const picklistsInForm = getPicklistFields(objectInfo, fields);
      return filterPicklistValues(picklistValues, picklistsInForm);
    }
    function formHasPicklists(objectInfo, fields) {
      return getPicklistFields(objectInfo, fields).size > 0;
    }

    function getPicklistFields(objectInfo, fields) {
      const picklistFields = new Set();

      for (const fieldName in objectInfo.fields) {
        // eslint-disable-next-line no-prototype-builtins
        if (objectInfo.fields.hasOwnProperty(fieldName)) {
          const field = objectInfo.fields[fieldName];

          if (field.dataType === Fields.PICKLIST || field.dataType === Fields.MULTI_PICKLIST) {
            // need to check the parent for compound fields
            const fieldNameToCheck = field.compoundFieldName || fieldName;

            if (fields.includes(`${objectInfo.apiName}.${fieldNameToCheck}`)) {
              picklistFields.add(field.apiName);
            }
          }
        }
      }

      return picklistFields;
    }

    function filterPicklistValues(picklistsByRecordType, picklistsInForm) {
      return Object.keys(picklistsByRecordType).filter(key => picklistsInForm.has(key)).reduce((obj, key) => {
        return _objectSpread$2({}, obj, {
          [key]: picklistsByRecordType[key]
        });
      }, {});
    }

    /**
     * This file exists just to reduce code duplication
     * between the aura and raptor implementations
     * of record-edit-form
     */
    const OUTPUT_FIELD_TAGNAME = 'LIGHTNING-OUTPUT-FIELD'; // This is the default master recordTypeId in salesforce

    const MASTER_RECORD_TYPE_ID$2 = '012000000000000AAA';

    function normalizeRecord(newRecord) {
      const normalizedRecord = Object.assign({}, newRecord);
      normalizedRecord.fields = {};
      Object.keys(newRecord.fields).forEach(field => {
        if (newRecord.fields[field] && typeof newRecord.fields[field] === 'object') {
          normalizedRecord.fields[field] = newRecord.fields[field];
        } else {
          normalizedRecord.fields[field] = {
            value: newRecord.fields[field]
          };
        }
      });
      return normalizedRecord;
    } // eslint-disable-next-line @lwc/lwc/no-async-await


    async function ldsUpdateRecord(newRecord, originalRecord, objectInfo) {
      newRecord.id = originalRecord.id;
      newRecord.apiName = null;
      const newRecordEdit = generateRecordInputForUpdate$1(normalizeRecord(newRecord), objectInfo);
      const recordToSave = createRecordInputFilteredByEditedFields$1(newRecordEdit, originalRecord);
      return updateRecord$2(recordToSave);
    } // eslint-disable-next-line @lwc/lwc/no-async-await

    async function ldsCreateRecord(newRecord, objectInfo) {
      const normalizedRecord = normalizeRecord(newRecord);
      const recordToSave = generateRecordInputForCreate$1(normalizedRecord, objectInfo);
      return createRecord$2(recordToSave);
    }
    /**
     *
     * Create or edit a record. If no original record is
     * specified create the record, otherwise update it
     * @param {recordInput} newRecord the dirty fields to change
     * @param {recordInput} originalRecord the original record
     * @param {objectInfo} objectInfo info about the object
     * @returns {Promise} Resovled when record is created or saved
     */
    // eslint-disable-next-line @lwc/lwc/no-async-await

    async function createOrSaveRecord(newRecord, originalRecord, objectInfo) {
      if (originalRecord) {
        return ldsUpdateRecord(newRecord, originalRecord, objectInfo);
      }

      return ldsCreateRecord(newRecord, objectInfo);
    }
    /**
     * Returns a map of fieldNames : values
     * for an *array* of inputField components
     *
     * @param {lightningInputField[]} inputFields components
     * @returns {Object} map of fieldNames: values
     */

    function getFormValues(inputFields) {
      const values = {};
      inputFields.forEach(field => {
        if (field.readonly) {
          return;
        } // compound fields need to be flattened


        if (field.value && typeof field.value === 'object') {
          // geoloc compounds have weird field names
          if (field.value.longitude) {
            const prefix = field.fieldName.slice(0, field.fieldName.indexOf('__c'));
            values[prefix + '__Longitude__s'] = field.value.longitude;
            values[prefix + '__Latitude__s'] = field.value.latitude;
          } else {
            Object.assign(values, field.value);
          }
        } else {
          values[field.fieldName] = field.value;
        }
      });
      return values;
    }
    /**
     * Normalize the given error object.
     * @param  {Error | Object} err This could be a javascript Error or an error emitted from LDS (ErrorResponse).
     * @return {Object} An object with a string message and a string detail
     */

    function parseError$1(err) {
      let message = '',
          output = {},
          detail = '';

      if (err) {
        if (err.body && err.body.output) {
          // ErrorResponse with Record Output Error
          // https://developer.salesforce.com/docs/atlas.en-us.uiapi.meta/uiapi/ui_api_responses_error_with_output.htm
          message = err.body.message;

          if (err.body.output.errors.length > 0) {
            detail = err.body.output.errors[0].message;
          } else if (err.body.detail) {
            detail = err.body.detail;
          } // output is part of the recordUi error response,
          // so we will include it.


          output = JSON.parse(JSON.stringify(err.body.output));
        } else if (Array.isArray(err.body) && err.body.length > 0) {
          // ErrorResponse with normal UIAPI error.
          message = err.body[0].message;
          detail = err.body[0].errorCode;
        } else if (err.body && err.body.message) {
          // ErrorResponse with body that has a message.
          message = err.body.message;
          detail = err.body.detail ? err.body.detail : '';
        } else if (err.body) {
          // ErrorResponse with unknown body.
          message = err.body;
        } else if (err.statusText) {
          // ErrorResponse with no body.
          message.err = err.statusText;
        } else if (err.message) {
          // Vanilla js error.
          message = err.message;
        } else {
          // Unknown error.
          message = err;
        }
      }

      return {
        message,
        detail,
        output
      };
    }
    function createErrorEvent(err) {
      const parsed = parseError$1(err);
      return new CustomEvent('error', {
        detail: parsed
      });
    }
    /**
     * Creates a list of fully qualified
     * fieldnames with no duplicates
     */

    class FieldSet {
      /**
       *
       * @param {String} objectApiName The object name
       */
      constructor(objectApiName) {
        this._set = new Set();
        this._apiName = objectApiName;
      }

      set objectApiName(objectApiName) {
        this._apiName = objectApiName;
      }
      /**
       * Add a single field
       * @param {String} val unqualified field name
       */


      add(val) {
        this._set.add(val);
      }
      /**
       * Add a list of fieldnames
       * @param {Array} arr Array of unqualified field names
       */


      concat(arr) {
        arr.forEach(item => {
          this.add(item);
        });
      } // using a method here rather than a getter
      // because this seemed clearer

      /**
       * @returns {Array} a list of fully qualified field names
       */


      getList() {
        const apiName = this._apiName;
        return [...this._set].map(field => {
          return `${apiName}.${field}`;
        });
      }
      /**
       * @returns {Array} a list of unqualified field names
       */


      getUnqualifiedList() {
        return [...this._set];
      }

    }
    /**
     *
     * Calls `reportValidity` on every input field, returns true
     * if all fields are valid, false if any are not
     *
     * @param {Array} inputFields list of input fields to validate
     * @returns {Boolean} true if all fields are false, true otherwise
     */


    function validateForm(inputFields) {
      let isValid = true;
      inputFields.forEach(cmp => {
        // output fields are always valid, the second clause is defensive in case
        // somebody passes the wrong type of component in this array
        if (cmp.tagName === OUTPUT_FIELD_TAGNAME || !cmp.reportValidity) {
          return;
        }

        if (!cmp.reportValidity()) {
          isValid = false;
        }
      });
      return isValid;
    }
    /**
     * Convenience function because you can't use
     * Set() in aura directly, also this
     * puts the "qualification" of fields in one place
     *
     * @param {String} objectApiName An object api name (entity name) to qualify fields
     * @returns {FieldSet} Field set has one method: add() to add a fieldname and one attribute list,
     *                     which you can use to get the qualified list of api names (an array)
     */

    function getFieldSet(objectApiName) {
      return new FieldSet(objectApiName);
    }
    function getDefaultRecordTypeId(objectInfo) {
      // check if a default was available in metadata, use that if it was
      const metadataDefaultRecordTypeId = objectInfo && objectInfo.defaultRecordTypeId;
      return metadataDefaultRecordTypeId || MASTER_RECORD_TYPE_ID$2;
    }

    function assert(condition, message) {
      {
        if (!condition) {
          throw new Error(message);
        }
      }
    }

    /**
    An emitter implementation based on the Node.js EventEmitter API:
    https://nodejs.org/dist/latest-v6.x/docs/api/events.html#events_class_eventemitter
    **/
    class EventEmitter {
      constructor() {
        this.registry = {};
      }
      /**
      Registers a listener on the emitter
      @method EventEmitter#on
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      on(name, listener) {
        this.registry[name] = this.registry[name] || [];
        this.registry[name].push(listener);
        return this;
      }
      /**
      Registers a listener on the emitter that only executes once
      @method EventEmitter#once
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      once(name, listener) {
        const doOnce = function () {
          listener.apply(null, arguments);
          this.removeListener(name, doOnce);
        }.bind(this);

        this.on(name, doOnce);
        return this;
      }
      /**
      Synchronously calls each listener registered with the specified event
      @method EventEmitter#emit
      @param {String} name - The name of the event
      @return {Boolean} - Returns `true` if the event had listeners, `false` otherwise
      **/


      emit(name) {
        const args = Array.prototype.slice.call(arguments, 1);
        const listeners = this.registry[name];
        let count = 0;

        if (listeners) {
          listeners.forEach(listener => {
            count += 1;
            listener.apply(null, args);
          });
        }

        return count > 0;
      }
      /**
      Removes the specified `listener` from the listener array for the event named `name`
      @method EventEmitter#removeListener
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      removeListener(name, listener) {
        const listeners = this.registry[name];

        if (listeners) {
          for (let i = 0, len = listeners.length; i < len; i += 1) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              return this;
            }
          }
        }

        return this;
      }

    }

    var locale = 'en-US';

    const urlRegexString = "((?:(?:https?|ftp):\\/\\/(?:[\\w\\-\\|=%~#\\/+*@\\.,;:\\?!']|&){0,2047}(?:[\\(\\)\\.\\w=\\/+#-]*)[^\\s()\\.<>,;\\[\\]`'\"])|(?:\\b(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW)(?!@(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW))(?:/[\\w\\-=?/.&;:%~,+@#*]{0,2048}(?:[\\w=/+#-]|\\([^\\s()]*\\)))?(?:$|(?=\\.$)|(?=\\.\\s)|(?=[^\\w\\.]))))";
    const emailRegexString = '([\\w-\\.\\+_]{1,64}@(?:[\\w-]){1,255}(?:\\.[\\w-]{1,255}){1,10})';
    const newLineRegexString = '(\r\n|\r|\n)';
    const tagRegexString = '(<a[\\s]+[^>]+[^/]>[\\s\\S]*?</a>|<a[\\s]+[^>]+/>|' + '<i?frame[\\s]+[^>]+[^/]>[\\s\\S]*?</i?frame>|<i?frame[\\s]+[^>]+/>|' + '<area[\\s]+[^>]+[^/]>[\\s\\S]*?</area>|<area[\\s]+[^>]+/>|' + '<link[\\s]+[^>]+[^/]>[\\s\\S]*?</link>|<link[\\s]+[^>]+/>|' + '<img[\\s]+[^>]+[^/]>[\\s\\S]*?</img>|<img[\\s]+[^>]+>|' + '<form[\\s]+[^>]+[^/]>[\\s\\S]*?</form>|<form[\\s]+[^>]+/>|' + '<body[\\s]+[^>]+[^/]>[\\s\\S]*?</body>|<body[\\s]+[^>]+/>|' + '<head[\\s]+[^>]+[^/]>[\\s\\S]*?</head>|<head[\\s]+[^>]+/>|' + '<input[\\s]+[^>]+[^/]>[\\s\\S]*?</input>|<input[\\s]+[^>]+/>|' + '<button[\\s]+[^>]+[^/]>[\\s\\S]*?</button>|<button[\\s]+[^>]+/>|' + '<blockquote[\\s]+[^>]+[^/]>[\\s\\S]*?</blockquote>|<blockquote[\\s]+[^>]+/>|' + '<q[\\s]+[^>]+[^/]>[\\s\\S]*?</q>|<q[\\s]+[^>]+/>|' + '<del[\\s]+[^>]+[^/]>[\\s\\S]*?</del>|<del[\\s]+[^>]+/>|' + '<ins[\\s]+[^>]+[^/]>[\\s\\S]*?</ins>|<ins[\\s]+[^>]+/>)';
    const createHttpHref = function (url) {
      let href = url;

      if (url.toLowerCase().lastIndexOf('http', 0) !== 0 && url.toLowerCase().lastIndexOf('ftp', 0) !== 0) {
        href = `http://${href}`;
      }

      return href;
    };
    const createEmailHref = function (email) {
      return `mailto:${email}`;
    };

    /**
     * Create a deep copy of an object or array
     * @param {object|array} obj - item to be copied
     * @returns {object|array} copy of the item
     */
    function deepCopy(obj) {
      if (Object(obj) !== obj) {
        // primitives
        return obj;
      }

      if (obj instanceof Set) {
        return new Set(obj);
      }

      if (obj instanceof Date) {
        return new Date(obj);
      }

      if (typeof obj === 'function') {
        return obj.bind({});
      }

      if (Array.isArray(obj)) {
        const obj2 = [];
        const len = obj.length;

        for (let i = 0; i < len; i++) {
          obj2.push(deepCopy(obj[i]));
        }

        return obj2;
      }

      const result = Object.create({});
      let keys = Object.keys(obj);

      if (obj instanceof Error) {
        // Error properties are non-enumerable
        keys = Object.getOwnPropertyNames(obj);
      }

      const len = keys.length;

      for (let i = 0; i < len; i++) {
        const key = keys[i];
        result[key] = deepCopy(obj[key]);
      }

      return result;
    }
    /**
     * Compare two arrays and return true if they are equal
     * @param {array} array1 - first array to compare
     * @param {array} array2 - second array to compare
     * @returns {boolean} if the arrays are identical
     */

    function arraysEqual(array1, array2) {
      // if either array is falsey, return false
      if (!array1 || !array2) {
        return false;
      } // if array lengths don't match, return false


      if (array1.length !== array2.length) {
        return false;
      }

      for (let index = 0; index < array1.length; index++) {
        // Check if we have nested arrays
        if (array1[index] instanceof Array && array2[index] instanceof Array) {
          // recurse into the nested arrays
          if (!arraysEqual(array1[index], array2[index])) {
            return false;
          }
        } else if (array1[index] !== array2[index]) {
          // Warning - two different object instances will never be equal: {x:20} != {x:20}
          return false;
        }
      }

      return true;
    }
    const ArraySlice = Array.prototype.slice;

    /**
     * Utility function to generate an unique guid.
     * used on state objects to provide a performance aid when iterating
     * through the items and marking them for render
     * @returns {String} an unique string ID
     */
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }

    function classListMutation(classList, config) {
      Object.keys(config).forEach(key => {
        if (typeof key === 'string' && key.length) {
          if (config[key]) {
            classList.add(key);
          } else {
            classList.remove(key);
          }
        }
      });
    }

    /**
    A string normalization utility for attributes.
    @param {String} value - The value to normalize.
    @param {Object} config - The optional configuration object.
    @param {String} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or invalid. Defaults to an empty string.
    @param {Array} [config.validValues] - An optional array of valid values. Assumes all input is valid if not provided.
    @return {String} - The normalized value.
    **/
    function normalizeString(value, config = {}) {
      const {
        fallbackValue = '',
        validValues,
        toLowerCase = true
      } = config;
      let normalized = typeof value === 'string' && value.trim() || '';
      normalized = toLowerCase ? normalized.toLowerCase() : normalized;

      if (validValues && validValues.indexOf(normalized) === -1) {
        normalized = fallbackValue;
      }

      return normalized;
    }
    /**
    A boolean normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeBoolean(value) {
      return typeof value === 'string' || !!value;
    }
    function normalizeArray(value) {
      if (Array.isArray(value)) {
        return value;
      }

      return [];
    }
    /**
    A aria attribute normalization utility.
    @param {Any} value - A single aria value or an array of aria values
    @return {String} - A space separated list of aria values
    **/

    function normalizeAriaAttribute(value) {
      let arias = Array.isArray(value) ? value : [value];
      arias = arias.map(ariaValue => {
        if (typeof ariaValue === 'string') {
          return ariaValue.replace(/\s+/g, ' ').trim();
        }

        return '';
      }).filter(ariaValue => !!ariaValue);
      return arias.length > 0 ? arias.join(' ') : null;
    }

    const keyCodes = {
      tab: 9,
      backspace: 8,
      enter: 13,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      delete: 46,
      shift: 16
    }; // Acceptable values are defined here: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
    // remove this function when IE11 support is dropped

    function normalizeKeyValue(value) {
      switch (value) {
        case 'Spacebar':
          return ' ';

        case 'Esc':
          return 'Escape';

        case 'Del':
          return 'Delete';

        case 'Left':
          return 'ArrowLeft';

        case 'Right':
          return 'ArrowRight';

        case 'Down':
          return 'ArrowDown';

        case 'Up':
          return 'ArrowUp';

        default:
          return value;
      }
    }
    const buffer = {};
    /**
     * Runs an action and passes the string of buffered keys typed within a short time period.
     * Use for type-ahead like functionality in menus, lists, comboboxes, and similar components.
     *
     * @param {CustomEvent} event A keyboard event
     * @param {Function} action function to run, it's passed the buffered text
     */

    function runActionOnBufferedTypedCharacters(event, action) {
      const letter = event.key;

      if (letter.length > 1) {
        // Not an individual character/letter, but rather a special code (like Shift, Backspace, etc.)
        return;
      } // If we were going to clear what keys were typed, don't yet.


      if (buffer._clearBufferId) {
        clearTimeout(buffer._clearBufferId);
      }

      buffer._keyBuffer = buffer._keyBuffer || [];

      buffer._keyBuffer.push(letter);

      const matchText = buffer._keyBuffer.join('').toLowerCase();

      action(matchText); // eslint-disable-next-line @lwc/lwc/no-async-operation

      buffer._clearBufferId = setTimeout(() => {
        buffer._keyBuffer = [];
      }, 700);
    }

    const isIE11 = isIE11Test(navigator);
    const isChrome = isChromeTest(navigator);
    const isSafari = isSafariTest(navigator); // The following functions are for tests only

    function isIE11Test(navigator) {
      // https://stackoverflow.com/questions/17447373/how-can-i-target-only-internet-explorer-11-with-javascript
      return /Trident.*rv[ :]*11\./.test(navigator.userAgent);
    }
    function isChromeTest(navigator) {
      // https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
      return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }
    function isSafariTest(navigator) {
      // via https://stackoverflow.com/questions/49872111/detect-safari-and-stop-script
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }

    /**
     * Set an attribute on an element, if it's a normal element
     * it will use setAttribute, if it's an LWC component
     * it will use the public property
     *
     * @param {HTMLElement} element The element to act on
     * @param {String} attribute the attribute to set
     * @param {Any} value the value to set
     */
    function smartSetAttribute(element, attribute, value) {
      if (element.tagName.match(/^LIGHTNING/i)) {
        attribute = attribute.replace(/-\w/g, m => m[1].toUpperCase());
        element[attribute] = value ? value : null;
      } else if (value) {
        element.setAttribute(attribute, value);
      } else {
        element.removeAttribute(attribute);
      }
    }

    const CONTENT_SEPARATOR = '\n';
    /**
    <template>
        <span lwc:dom="manual" class="visually-hidden"></span>
        <input>
    </template>

    class Foo extends LightningElement {
        constructor() {
            super();
            this.ariaObserver = new ContentMutation(this);
        }

        @track ariaLabeledbyValue = '';

        @api
        get ariaLabeledby() {
            return this.ariaLabeledbyValue; // whatever they set, is what they get back.
        }
        set ariaLabeledby(refs) {
            this.ariaLabeledbyValue = refs;
            this.ariaObserver.link('input', 'aria-labeledby', refs, 'span.visually-hidden');
        }

        renderedCallback() {
            this.ariaObserver.sync();
        }
    }
    **/

    function getAttr(elm, attr) {
      if (elm.tagName.match(/lightning/i)) {
        return elm[attr];
      }

      return elm.getAttribute(attr);
    }

    function extractElements(root, selector) {
      if (typeof selector !== 'string' || selector === '') {
        return [];
      }

      return [].slice.call(root.querySelectorAll(selector));
    }

    function extractContent(elements) {
      return elements.map(element => element.textContent).filter(text => text.length).join(CONTENT_SEPARATOR);
    }

    function splitIds(ids) {
      return (ids + '').trim().split(/\s+/);
    }

    function hashIds(ids) {
      return (ids + '').trim().split(/\s+/).reduce((r, v) => {
        r[v] = 1;
        return r;
      }, {});
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and dupe
    // them, and add the new ones.


    function addAriaRefWhenNeeded(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const suffix = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          suffix.push(newIds[i]);
        }
      }

      if (suffix.length !== 0) {
        smartSetAttribute(elm, attrName, oldIds + (oldIds.length === 0 ? '' : ' ') + suffix.join(' '));
      }
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and remove
    // them when possible in preparation for some new values.


    function removeAriaRefWhenPossible(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const newValues = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          newValues.push(newIds[i]);
        }
      }

      smartSetAttribute(elm, attrName, newValues.join(' '));
    }

    class ContentMutation {
      constructor(component) {
        this.template = component.template;
        this.isNative = this.template.constructor.toString().match(/\[native code\]/);
        this.state = {};
        this.liveIds = {};
        this.guid = guid();
      }

      connectLiveIdRef(refs, callback) {
        const selector = (refs + '').trim().split(/\s+/).map(ref => `[id*="${ref}"]`).join(',');
        const liveId = {
          selector,
          callback
        };
        this.liveIds[refs] = liveId;
      }

      link(innerSelector, attrName, ids, placeholderContainerSelector) {
        let attrState = this.state[attrName];

        if (attrState) {
          // note: we don't support linking to a different innerSelector,
          // attrName, or placeholderContainerSelector
          if (!this.isNative) {
            const elm = this.template.querySelector(innerSelector);

            if (elm) {
              // removing the old ids if possible before setting the new ones
              removeAriaRefWhenPossible(elm, attrName, attrState.ids);
            }

            attrState.ids = ids;
          }
        } else {
          attrState = this.state[attrName] = {
            ids,
            innerSelector,
            placeholderContainerSelector
          };
        }

        if (this.isNative) {
          attrState.outerSelector = (ids + '').trim().split(/\s+/).map(ref => `#${ref}`).join(',');
          attrState.placeholder = document.createElement('span');
          attrState.placeholder.id = `auto-link-${attrName}-${this.guid}`;
        }

        if (this.template.host.parentNode) {
          this.privateUpdate(attrName);
        }
      }

      sync() {
        if (!this.template.host.parentNode) {
          throw new Error(`Invalid sync invocation. It can only be invoked during renderedCallback().`);
        }

        if (this.isNative && !this.mo) {
          this.privateConnect();
        }

        for (const attrName in this.state) {
          if (Object.prototype.hasOwnProperty.call(this.state, attrName)) {
            this.privateUpdate(attrName);
          }
        } // live idRef feature is a no-op in native


        if (!this.isNative) {
          this.privateUpdateLiveIds();
        }
      }

      privateExtractIds(elements) {
        return elements.map(el => {
          return el.getAttribute('id');
        }).join(' ');
      }

      privateUpdateLiveIds() {
        const root = this.template.host.getRootNode(); // if not connected do nothing

        if (!root) {
          return;
        }

        for (const liveId in this.liveIds) {
          if (Object.prototype.hasOwnProperty.call(this.liveIds, liveId)) {
            const thisId = this.liveIds[liveId];

            if (!thisId.elements) {
              // element refs are cached
              thisId.elements = Array.prototype.slice.call(root.querySelectorAll(thisId.selector));
            }

            const newIds = this.privateExtractIds(thisId.elements); // only fire calback if the value changed

            if (newIds !== thisId.ids) {
              thisId.callback(newIds);
              thisId.ids = newIds;
            }
          }
        }
      }

      privateUpdate(attrName) {
        const {
          innerSelector
        } = this.state[attrName];
        const elm = this.template.querySelector(innerSelector);

        if (!elm) {
          return; // nothing to update
        }

        let computedIds;

        if (this.isNative) {
          const {
            outerSelector,
            content,
            placeholder,
            placeholderContainerSelector
          } = this.state[attrName];
          const newContent = extractContent(extractElements(this.root, outerSelector));

          if (content !== newContent) {
            this.state[attrName].content = placeholder.textContent = newContent;
          }

          if (!placeholder.parentNode) {
            // inserting the placeholder once
            const container = this.template.querySelector(placeholderContainerSelector);

            if (container) {
              container.appendChild(placeholder);
            }
          }

          computedIds = placeholder.id;
        } else {
          computedIds = this.state[attrName].ids;
        }

        addAriaRefWhenNeeded(elm, attrName, computedIds);
      }

      privateConnect() {
        // caching root ref
        this.root = this.template.host.getRootNode(); // creating the observer once

        const mo = new MutationObserver(() => {
          if (!this.template.host.parentNode) {
            return; // do nothing when the template is not connected
          }

          this.sync();
        });
        mo.observe(this.root, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }

    }

    const ALLOWED_DOMAINS = new Set(['www.youtube.com', 'player.vimeo.com', 'play.vidyard.com', 'players.brightcove.net', 'bcove.video', 'player.cloudinary.com', 'fast.wistia.net', 'i1.adis.ws', 's1.adis.ws']);
    function hasOnlyAllowedVideoIframes(htmlString) {
      if (htmlString && htmlString.indexOf('<iframe') > -1) {
        const parsedHtml = new DOMParser().parseFromString(htmlString, 'text/html');
        const iframesList = Array.prototype.slice.call(parsedHtml.querySelectorAll('iframe'));
        return iframesList.length > 0 && !iframesList.some(iframe => !isUrlAllowed(iframe.src));
      }

      return false;
    }

    function isUrlAllowed(url) {
      const anchor = document.createElement('a');
      anchor.href = url;
      return anchor.protocol === 'https:' && ALLOWED_DOMAINS.has(anchor.hostname);
    }

    /*
     * Regex was taken from aura lib and refactored
     */

    const linkRegex = new RegExp(`(${newLineRegexString})|${urlRegexString}|${emailRegexString}`, 'gi');
    const linkRegexNoNewLine = new RegExp(`${urlRegexString}|${emailRegexString}`, 'gi');
    const emailRegex = new RegExp(emailRegexString, 'gi');
    const newLineRegex = new RegExp(newLineRegexString, 'gi');

    function getTextPart(text) {
      return {
        isText: true,
        value: text
      };
    }

    function getUrlPart(url, index) {
      return {
        isLink: true,
        value: url,
        href: createHttpHref(url),
        key: `${url}-${index}`
      };
    }

    function getEmailPart(email, index) {
      return {
        isLink: true,
        value: email,
        href: createEmailHref(email),
        key: `${email}-${index}`
      };
    }

    function getNewlinePart(index) {
      return {
        isNewline: true,
        key: index
      };
    }

    function getLinkPart(link, index, ignoreNewLines) {
      if (!ignoreNewLines && link.match(newLineRegex)) {
        return getNewlinePart(index);
      } else if (link.match(emailRegex)) {
        return getEmailPart(link, index);
      }

      return getUrlPart(link, index);
    }
    /**
     * Parse text into parts of text, links, emails, new lines
     * @param text {string} Text to parse into linkified parts
     * @param ignoreNewLines {boolean} Boolean indicating whether to return new line parts or not
     * if true new lines are included in text/url/email parts otherwise they are returned in their
     * own parts by default
     * @returns {[]}
     */


    function parseToFormattedLinkifiedParts(text, ignoreNewLines = false) {
      const parts = [];
      const re = ignoreNewLines ? linkRegexNoNewLine : linkRegex;
      let match;
      let index = 0;

      while ((match = re.exec(text)) !== null) {
        let link = match[0];
        const endsWithQuote = link && link.endsWith('&quot'); // If we found an email or url match, then create a text part for everything
        // up to the match and then create the part for the email or url

        if (match.index > 0) {
          parts.push(getTextPart(text.slice(0, match.index)));
        }

        if (endsWithQuote) {
          link = link.slice(0, link.lastIndexOf('&quot'));
        }

        parts.push(getLinkPart(link, index, ignoreNewLines));

        if (endsWithQuote) {
          parts.push(getTextPart('&quot'));
        }

        text = text.substring(re.lastIndex);
        re.lastIndex = 0;
        index = index + 1;
      }

      if (text != null && text !== '') {
        parts.push(getTextPart(text));
      }

      return parts;
    }
    /**
     * Parse text into parts of text and new lines
     * @param text {string} Text to parse into parts
     * @returns {[]}
     */

    function parseToFormattedParts(text) {
      return text.split(newLineRegex).map((part, index) => {
        return index % 2 === 0 ? getTextPart(part) : getNewlinePart();
      });
    }

    /**
     * @param {HTMLElement} element Element to act on
     * @param {Object} values values and attributes to set, if the value is
     *                        falsy it the attribute will be removed
     */

    function synchronizeAttrs(element, values) {
      if (!element) {
        return;
      }

      const attributes = Object.keys(values);
      attributes.forEach(attribute => {
        smartSetAttribute(element, attribute, values[attribute]);
      });
    }
    /**
     * Get the actual DOM id for an element
     * @param {HTMLElement|String} el The element to get the id for (string will just be returned)
     *
     * @returns {String} The DOM id or null
     */

    function getRealDOMId(el) {
      if (el && typeof el === 'string') {
        return el;
      } else if (el) {
        return el.getAttribute('id');
      }

      return null;
    }
    const URL_CHECK_REGEX = /^(\/+|\.+|ftp|http(s?):\/\/)/i;
    function isAbsoluteUrl(url) {
      return URL_CHECK_REGEX.test(url);
    }
    function isRTL() {
      return document.dir === 'rtl';
    }
    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }
    function isNotUndefinedOrNull(value) {
      return !isUndefinedOrNull(value);
    }
    const DEFAULT_ZINDEX_BASELINE = 9000;
    /**
     * Returns the zIndex baseline from slds zIndex variable --lwc-zIndexModal.
     * @returns {Number} zIndex baseline
     */

    function getZIndexBaseline() {
      const value = (window.getComputedStyle(document.documentElement) || document.documentElement.style).getPropertyValue('--lwc-zIndexModal');
      const base = parseInt(value, 10);
      return isNaN(base) ? DEFAULT_ZINDEX_BASELINE : base;
    }
    function timeout(interval) {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(resolve, interval);
      });
    }
    function animationFrame() {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        window.requestAnimationFrame(resolve);
      });
    }
    /**
     *
     * Decorates an input element to fire an "input"
     * event when the value is directly set.
     *
     * @param {HTMLElement} element The element to decorate.
     *
     */

    function decorateInputForDragon(element) {
      const valuePropertyDescriptor = getInputValuePropertyDescriptor(element);
      Object.defineProperty(element, 'value', {
        set(value) {
          valuePropertyDescriptor.set.call(this, value);
          this.dispatchEvent(new CustomEvent('input'));
        },

        get: valuePropertyDescriptor.get,
        enumerable: true,
        configurable: true
      });
    }

    function getInputValuePropertyDescriptor(element) {
      return Object.getOwnPropertyDescriptor(Object.getPrototypeOf(element), 'value');
    }

    function setDecoratedDragonInputValueWithoutEvent(element, value) {
      const valuePropertyDescriptor = getInputValuePropertyDescriptor(element);
      return valuePropertyDescriptor.set.call(element, value);
    }

    const DELAY_TIMEOUT = 200;
    class LightningResizeObserver {
      constructor(resizeCallback) {
        this._resizeObserverAvailable = typeof ResizeObserver === 'function';

        const delayedCallback = callback => {
          if (this._running) {
            return;
          }

          this._running = true;
          timeout(DELAY_TIMEOUT) // requestAnimationFrame is used to guard against the callback directly reading layout dimensions
          // which may be mutating at the same time leading to layout thrashing
          .then(() => animationFrame()).then(() => {
            callback();
            this._running = false;
          });
        };

        this._delayedResizeCallback = delayedCallback.bind(this, resizeCallback);

        if (this._resizeObserverAvailable) {
          this._resizeObserver = new ResizeObserver(this._delayedResizeCallback);
        }
      }

      observe(lightningElement) {
        // Using requestAnimationFrame as the element may not be physically in the DOM yet.
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        this._requestAnimationId = requestAnimationFrame(() => {
          if (this._resizeObserverAvailable) {
            this._resizeObserver.observe(lightningElement);
          } else if (!this._hasWindowResizeHandler) {
            window.addEventListener('resize', this._delayedResizeCallback);
            this._hasWindowResizeHandler = true;
          }
        });
      }

      disconnect() {
        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }

        if (this._requestAnimationId) {
          cancelAnimationFrame(this._requestAnimationId);
        }

        window.removeEventListener('resize', this._delayedResizeCallback);
        this._hasWindowResizeHandler = false;
      }

    }

    /**
     * Width breakpoint for changing desnification setting
     */
    const APP_DENSIFICATION_BREAKPOINT = 650;
    const appDensityValues = {
      COMFY: 'VIEW_ONE',
      COMPACT_AUTO: 'VIEW_TWO'
    };

    function doNormalization(val, cmpInterface) {
      const normalized = normalizeString(val, {
        fallbackValue: densityValues.AUTO,
        validValues: [densityValues.AUTO, densityValues.COMPACT, densityValues.COMFY]
      });
      cmpInterface.setDensityPrivate(normalized);
      setLabelAlignment(cmpInterface);
    }
    function setLabelAlignment(cmpInterface) {
      const fieldLabelAlignment = cmpInterface.getLabelAlignmentPrivate();

      if (isDensityComfy(cmpInterface)) {
        if (fieldLabelAlignment !== labelAlignValues.STACKED) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.STACKED);
          wireLabelAlignment(cmpInterface);
        }
      } else if (isDensityCompact(cmpInterface)) {
        if (fieldLabelAlignment !== labelAlignValues.HORIZONTAL) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.HORIZONTAL);
          wireLabelAlignment(cmpInterface);
        }
      }
    } // Only density auto with wired density compact needs resize observer
    // If density is auto with wired comfy we can disconnect the observer or not connect it

    function resetResizeObserver(cmp, cmpInterface, isInitialRender) {
      if (cmp._resizeObserver && !isWiredDensityAuto(cmpInterface)) {
        // If we have a resize observer and the density is not auto it means it was changed
        // to not auto, we should disconnect the resize observer.
        cmp._resizeObserver.disconnect();

        cmp._resizeObserver = undefined;
      } else if (isWiredDensityAuto(cmpInterface)) {
        // if this is initialRender we should call the resize observer callback
        // since the browsers not supporting ResizeObserver need this for initial render
        if (isInitialRender) {
          resizeObserverCallback(cmpInterface);
        } // No resize observer and density is auto, we should setup the resize observer


        cmp._resizeObserver = setupResizeObserver(cmpInterface);
      }
    } // Destroy resizeObserver

    function disconnectResizeObserver(cmp) {
      if (cmp._resizeObserver) {
        cmp._resizeObserver.disconnect();

        cmp._resizeObserver = undefined;
      }
    }

    function isWiredDensityAuto(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      const wiredDensity = configProvider.getOneConfig().densitySetting;
      return density === densityValues.AUTO && wiredDensity !== appDensityValues.COMFY;
    }

    function isDensityComfy(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      return density === densityValues.AUTO && configProvider.getOneConfig().densitySetting === appDensityValues.COMFY || density === densityValues.COMFY;
    }

    function isDensityCompact(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      return isWiredDensityAuto(cmpInterface) || density === densityValues.COMPACT;
    }

    function setupResizeObserver(cmpInterface) {
      const containerEle = cmpInterface.getContainerElement();
      const resizeObserver = new LightningResizeObserver(cmpInterface.getResizeObserverCallback(resizeObserverCallback));
      resizeObserver.observe(containerEle);
      return resizeObserver;
    }

    function resizeObserverCallback(cmpInterface) {
      const containerEle = cmpInterface.getContainerElement();

      if (containerEle) {
        const containerWidth = containerEle.getBoundingClientRect().width;
        const fieldLabelAlignment = cmpInterface.getLabelAlignmentPrivate();
        let alignmentChanged = false;

        if (containerWidth < APP_DENSIFICATION_BREAKPOINT && fieldLabelAlignment !== labelAlignValues.STACKED) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.STACKED);
          alignmentChanged = true;
        }

        if (containerWidth >= APP_DENSIFICATION_BREAKPOINT && fieldLabelAlignment !== labelAlignValues.HORIZONTAL) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.HORIZONTAL);
          alignmentChanged = true;
        }

        if (alignmentChanged) {
          wireLabelAlignment(cmpInterface);
        }
      }
    }

    function wireLabelAlignment(cmpInterface) {
      const recordUi = cmpInterface.getRecordUi();

      if (recordUi) {
        const fields = cmpInterface.getInputOutputFields();
        recordUi.labelAlignment = cmpInterface.getLabelAlignmentPrivate();

        for (let i = 0; i < fields.length; i += 1) {
          fields[i].wireRecordUi(recordUi);
        }
      }
    }

    let idCounter = 0;
    function generateUniqueId(prefix = 'input') {
      idCounter++;
      return `${prefix}-${idCounter}`;
    }

    /**
     Represents an object which keeps track of a user's interacting state.
     @constructor InteractingState
     @param {Object} options - The options object.
     @param {Object} [options.duration=2000] - The number of milliseconds of idle time to wait before exiting the interacting state.
     @param {Object} [options.debounceInteraction=false] - Whether to debounce interaction to ignore consecutive leave-enter interactions.
     **/

    class InteractingState {
      constructor(options) {
        const duration = options && options.duration >= 0 ? options.duration : 2000;
        this.eventemitter = new EventEmitter();
        this._interacting = false;
        this._debouncedLeave = debounce(this.leave.bind(this), duration);
        this._debounceInteraction = options && options.debounceInteraction;
        this._interactedRecently = false;

        if (this._debounceInteraction) {
          // debounce leave until a short time later
          this._debouncedEmitLeave = debounce(() => {
            if (!this._interacting) {
              this._interactedRecently = false;
              this.eventemitter.emit('leave');
            }
          }, 200); // debounce enter until left

          this._debouncedEmitEnter = () => {
            if (!this._interactedRecently) {
              this._interactedRecently = true;
              this.eventemitter.emit('enter');
            }
          };
        }
      }
      /**
       Checks whether or not we are in the interacting state.
       @method InteractingState#isInteracting
       @return {Boolean} - Whether or not we are interacting.
       **/


      isInteracting() {
        return this._interacting;
      }
      /**
       Enters the interacting state.
       @method InteractingState#enter
       @returns {void}
       **/


      enter() {
        if (!this._interacting) {
          this._interacting = true;

          if (this._debounceInteraction) {
            this._debouncedEmitEnter();
          } else {
            this.eventemitter.emit('enter');
          }
        }
      }
      /**
       Registers a handler to execute when we enter the interacting state.
       @method InteractingState#onenter
       @param {Function} handler - The callback function.
       **/


      onenter(handler) {
        this.eventemitter.on('enter', handler);
      }
      /**
       Leaves the interacting state.
       @method InteractingState#leave
       @returns {void}
       **/


      leave() {
        if (this._interacting) {
          this._interacting = false;

          if (this._debounceInteraction) {
            this._debouncedEmitLeave();
          } else {
            this.eventemitter.emit('leave');
          }
        }
      }
      /**
       Registers a handler to execute when we leave the interacting state.
       @method InteractingState#onleave
       @param {Function} handler - The callback function.
       **/


      onleave(handler) {
        this.eventemitter.on('leave', handler);
      }
      /**
       Signals the start of the transition into the interacting state and
       schedules a transition out of the interacting state after an idle
       duration. Calling this method multiple times will reset the timer.
       @method InteractingState#interacting
       @returns {void}
       **/


      interacting() {
        this.enter();

        this._debouncedLeave();
      }

    }
    /**
     Creates a debounced function that delays invoking `func` until after
     `delay` milliseconds have elapsed since the last time the debounced
     function was invoked.
     @function debounce
     @param {Function} func - The function to debounce
     @param {Number} delay - The number of milliseconds to delay
     @param {Object} options - The options object
     @param {Boolean} options.leading - Specify invoking on the leading edge of the timeout
     @return {Function} - debounced function
     **/

    function debounce(func, delay, options) {
      const _options = options || {};

      let invokeLeading = _options.leading;
      let timer;
      return function debounced() {
        const args = Array.prototype.slice.apply(arguments);

        if (invokeLeading) {
          func.apply(this, args);
          invokeLeading = false;
        }

        clearTimeout(timer); // eslint-disable-next-line @lwc/lwc/no-async-operation

        timer = setTimeout(function () {
          func.apply(this, args);
          invokeLeading = _options.leading; // reset for next debounce sequence
        }, delay);
      };
    }

    var labelBadInput = 'Enter a valid value.';

    var labelPatternMismatch = 'Your entry does not match the allowed pattern.';

    var labelRangeOverflow = 'The number is too high.';

    var labelRangeUnderflow = 'The number is too low.';

    var labelStepMismatch = 'Your entry isn\'t a valid increment.';

    var labelTooLong = 'Your entry is too long.';

    var labelTooShort = 'Your entry is too short.';

    var labelTypeMismatch = 'You have entered an invalid format.';

    var labelValueMissing = 'Complete this field.';

    const constraintsSortedByPriority = ['customError', 'badInput', 'patternMismatch', 'rangeOverflow', 'rangeUnderflow', 'stepMismatch', 'tooLong', 'tooShort', 'typeMismatch', 'valueMissing'];
    const defaultLabels = {
      badInput: labelBadInput,
      customError: labelBadInput,
      patternMismatch: labelPatternMismatch,
      rangeOverflow: labelRangeOverflow,
      rangeUnderflow: labelRangeUnderflow,
      stepMismatch: labelStepMismatch,
      tooLong: labelTooLong,
      tooShort: labelTooShort,
      typeMismatch: labelTypeMismatch,
      valueMissing: labelValueMissing
    };

    function resolveBestMatch(validity) {
      let validityState;

      if (validity && validity.valid === false) {
        validityState = 'badInput';
        constraintsSortedByPriority.some(stateName => {
          if (validity[stateName] === true) {
            validityState = stateName;
            return true;
          }

          return false;
        });
      }

      return validityState;
    }

    function computeConstraint(valueProvider, constraint) {
      const provider = valueProvider[constraint];

      if (typeof provider === 'function') {
        return provider();
      }

      if (typeof provider === 'boolean') {
        return provider;
      }

      return false;
    } // We're doing the below to avoid exposing the constraintsProvider in the ValidityState


    function newValidityState(constraintsProvider) {
      class ValidityState {
        get valueMissing() {
          return computeConstraint(constraintsProvider, 'valueMissing');
        }

        get typeMismatch() {
          return computeConstraint(constraintsProvider, 'typeMismatch');
        }

        get patternMismatch() {
          return computeConstraint(constraintsProvider, 'patternMismatch');
        }

        get tooLong() {
          return computeConstraint(constraintsProvider, 'tooLong');
        }

        get tooShort() {
          return computeConstraint(constraintsProvider, 'tooShort');
        }

        get rangeUnderflow() {
          return computeConstraint(constraintsProvider, 'rangeUnderflow');
        }

        get rangeOverflow() {
          return computeConstraint(constraintsProvider, 'rangeOverflow');
        }

        get stepMismatch() {
          return computeConstraint(constraintsProvider, 'stepMismatch');
        }

        get customError() {
          return computeConstraint(constraintsProvider, 'customError');
        }

        get badInput() {
          return computeConstraint(constraintsProvider, 'badInput');
        }

        get valid() {
          return !(this.valueMissing || this.typeMismatch || this.patternMismatch || this.tooLong || this.tooShort || this.rangeUnderflow || this.rangeOverflow || this.stepMismatch || this.customError || this.badInput);
        }

      }

      return new ValidityState();
    }

    function buildSyntheticValidity(constraintProvider) {
      return Object.freeze(newValidityState(constraintProvider));
    }
    function getErrorMessage(validity, labelMap) {
      const key = resolveBestMatch(validity);

      if (key) {
        return labelMap[key] ? labelMap[key] : defaultLabels[key];
      }

      return '';
    }
    class FieldConstraintApi {
      constructor(inputComponentProvider, constraintProviders) {
        assert(typeof inputComponentProvider === 'function');
        this._inputComponentProvider = inputComponentProvider;
        this._constraintsProvider = Object.assign({}, constraintProviders);

        if (!this._constraintsProvider.customError) {
          this._constraintsProvider.customError = () => typeof this._customValidityMessage === 'string' && this._customValidityMessage !== '';
        }
      }

      get validity() {
        if (!this._constraint) {
          this._constraint = buildSyntheticValidity(this._constraintsProvider);
        }

        return this._constraint;
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          if (this.inputComponent) {
            this.inputComponent.dispatchEvent(new CustomEvent('invalid', {
              cancellable: true
            }));
          }
        }

        return isValid;
      }

      reportValidity(callback) {
        const valid = this.checkValidity(); // the input might have been removed from the DOM by the time we query it

        if (this.inputComponent) {
          this.inputComponent.classList.toggle('slds-has-error', !valid);

          if (callback) {
            callback(this.validationMessage);
          }
        }

        return valid;
      }

      setCustomValidity(message) {
        this._customValidityMessage = message;
      }

      get validationMessage() {
        return getErrorMessage(this.validity, {
          customError: this._customValidityMessage,
          badInput: this.inputComponent.messageWhenBadInput,
          patternMismatch: this.inputComponent.messageWhenPatternMismatch,
          rangeOverflow: this.inputComponent.messageWhenRangeOverflow,
          rangeUnderflow: this.inputComponent.messageWhenRangeUnderflow,
          stepMismatch: this.inputComponent.messageWhenStepMismatch,
          tooShort: this.inputComponent.messageWhenTooShort,
          tooLong: this.inputComponent.messageWhenTooLong,
          typeMismatch: this.inputComponent.messageWhenTypeMismatch,
          valueMissing: this.inputComponent.messageWhenValueMissing
        });
      }

      get inputComponent() {
        if (!this._inputComponentElement) {
          this._inputComponentElement = this._inputComponentProvider();
        }

        return this._inputComponentElement;
      }

    }
    class FieldConstraintApiWithProxyInput {
      constructor(inputComponent, overrides = {}, inputElementName = 'input') {
        this._inputComponent = inputComponent;
        this._overrides = overrides;
        this._proxyInput = document.createElement(inputElementName);
      }

      setInputAttributes(attributes) {
        this._attributes = attributes;

        this._attributeUpdater = attributeNames => {
          if (!attributes) {
            return;
          }

          if (typeof attributeNames === 'string') {
            this._setAttribute(attributeNames, attributes[attributeNames]());
          } else {
            attributeNames.forEach(attributeName => {
              this._setAttribute(attributeName, attributes[attributeName]());
            });
          }
        };

        return this._attributeUpdater;
      }

      get validity() {
        return this._constraintApi.validity;
      }

      checkValidity() {
        return this._constraintApi.checkValidity();
      }

      reportValidity(callback) {
        return this._constraintApi.reportValidity(callback);
      }

      setCustomValidity(message) {
        this._constraintApi.setCustomValidity(message);

        this._proxyInput.setCustomValidity(message);
      }

      get validationMessage() {
        return this._constraintApi.validationMessage;
      }

      _setAttribute(attributeName, value) {
        if (value !== null && value !== undefined && value !== false) {
          if (attributeName === 'value') {
            if (this._proxyInput.type === 'file') {
              // Can't set value on file
              return;
            }

            this._proxyInput.value = value;
          } else {
            this._proxyInput.setAttribute(attributeName, value);
          }
        } else {
          this._removeAttribute(attributeName);
        }
      }

      _removeAttribute(attributeName) {
        this._proxyInput.removeAttribute(attributeName);
      }

      get _constraintApi() {
        if (!this._privateConstraintApi) {
          this._updateAllAttributes();

          const computeConstraintWithProxyInput = constraintName => {
            const constraintOverride = this._overrides[constraintName];

            const isDisabledOrReadOnly = this._proxyInput.hasAttribute('disabled') || this._proxyInput.hasAttribute('readonly');

            if (typeof constraintOverride === 'function') {
              return !isDisabledOrReadOnly && constraintOverride();
            } // Firefox incorrectly computes rangeUnderflow for disabled and readonly inputs, so we're adding
            // a check here instead to always return false when the input has readonly or disabled attributes set


            return !isDisabledOrReadOnly && this._proxyInput.validity[constraintName];
          };

          const constraintsProvider = constraintsSortedByPriority.reduce((provider, constraint) => {
            provider[constraint] = computeConstraintWithProxyInput.bind(this, constraint);
            return provider;
          }, {});
          this._privateConstraintApi = new FieldConstraintApi(this._inputComponent, constraintsProvider);
        }

        return this._privateConstraintApi;
      }

      _updateAllAttributes() {
        if (this._attributes) {
          Object.entries(this._attributes).forEach(([key, valueFunction]) => {
            this._setAttribute(key, valueFunction());
          });
        }
      }

    }

    const VARIANT = {
      STANDARD: 'standard',
      LABEL_HIDDEN: 'label-hidden',
      LABEL_STACKED: 'label-stacked',
      LABEL_INLINE: 'label-inline'
    };
    /**
    A variant normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeVariant(value) {
      return normalizeString(value, {
        fallbackValue: VARIANT.STANDARD,
        validValues: [VARIANT.STANDARD, VARIANT.LABEL_HIDDEN, VARIANT.LABEL_STACKED, VARIANT.LABEL_INLINE]
      });
    }

    function isEmptyString(s) {
      return s === undefined || s === null || typeof s === 'string' && s.trim() === '';
    }

    // NOTE: lightning-record-utils is a public library. adding new utils here means we
    // will have to support it until the end of time. Consider adding the util to
    // lightning-utils-private instead if it's something we can live with as
    // internal-only.

    /**
     * This is a prettified copy-paste of the force:records#to18 method.
     * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
     *
     * @param {String} recordId - a 15- or 18-char record id.
     * @return {String|null} - an 18-char record id, null if an invalid record id was provided.
     */
    function normalizeRecordId(recordId) {
      if (!recordId) {
        return null;
      }

      if (recordId.length === 15) {
        let suffix = '';
        const CASE_DECODE_STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456'; // Build the 3 character suffix

        for (let set = 0; set < 3; ++set) {
          let decodeValue = 0;

          for (let bit = 0; bit < 5; bit++) {
            const c = recordId.charAt(set * 5 + bit);

            if (c >= 'A' && c <= 'Z') {
              decodeValue += 1 << bit;
            }
          }

          suffix += CASE_DECODE_STRING.charAt(decodeValue);
        }

        return recordId + suffix;
      } else if (recordId.length === 18) {
        return recordId;
      }

      return null;
    }

    class DependencyManager {
      // map of fieldName -> {fieldElement, controllerName}
      // map of controllerFieldName -> [dependentFieldNames]
      // map of picklist fieldName -> picklistValues
      // cache of picklist options, fieldName-controllerValue -> picklistOptions
      constructor(dependencyInfo) {
        this._fieldValues = {};
        this._dependencyMap = {};
        this._picklistMap = {};
        this._optionsCache = {};

        if (dependencyInfo) {
          registerDependencyInfo.call(this, dependencyInfo);
        }
      }

      registerDependencyInfo(dependencyInfo) {
        registerDependencyInfo.call(this, dependencyInfo);
      }

      registerField(fieldInfo) {
        registerField.call(this, fieldInfo);
      }

      handleFieldValueChange(fieldName, fieldValue) {
        handleFieldValueChange.call(this, fieldName, fieldValue);
      }

    }

    lwc.registerDecorators(DependencyManager, {
      fields: ["_fieldValues", "_dependencyMap", "_picklistMap", "_optionsCache"]
    });

    function registerDependencyInfo({
      dependentFields,
      picklistValues
    }) {
      // mainly needed for tests to clear the existing maps before each test
      clearMaps.call(this);

      if (dependentFields) {
        buildDependencyMap.call(this, dependentFields);
      }

      if (picklistValues) {
        Object.assign(this._picklistMap, picklistValues);
      }
    }

    function buildDependencyMap(config) {
      for (const prop in config) {
        if (Object.prototype.hasOwnProperty.call(config, prop)) {
          const result = Object.keys(config[prop]).reduce((prev, key) => {
            prev.push(key);
            return prev;
          }, []);

          if (result.length > 0) {
            this._dependencyMap[prop] = result;
          }

          buildDependencyMap.call(this, config[prop]);
        }
      }
    }

    function registerField({
      fieldName,
      fieldElement
    }) {
      // add field to fieldValues map
      if (!(fieldName in this._fieldValues)) {
        this._fieldValues[fieldName] = {
          controllerName: getControllerName.call(this, fieldName),
          fieldElement
        };
      }

      initializeField.call(this, fieldName);
    }

    function initializeField(fieldName) {
      const field = this._fieldValues[fieldName];
      const hasController = field.controllerName !== undefined; // controller could be registered after the dependent field. Avoid initializing the dependent before the controller is registered.

      const controllerNotRegistered = hasController && this._fieldValues[field.controllerName] === undefined;

      if (controllerNotRegistered) {
        return;
      } // checkbox fields don't have options, only need to update its dependents


      if (this._picklistMap[fieldName] !== undefined) {
        const controllerValue = getControllerValue.call(this, fieldName);
        const picklistOptions = getPicklistOptions.call(this, fieldName, controllerValue);
        updateFieldOptions(fieldName, field.fieldElement, picklistOptions);
      } // If controller field is registered after the dependent field, we have to update the dependents with the correct controller value


      const fieldValue = getFieldValue(fieldName, field.fieldElement);
      updateDependentFields.call(this, fieldName, fieldValue);
    }

    function handleFieldValueChange(fieldName, fieldValue) {
      updateDependentFields.call(this, fieldName, fieldValue);
    }

    function updateDependentFields(fieldName, fieldValue) {
      const dependentFieldNames = this._dependencyMap[fieldName] || [];

      if (!dependentFieldNames.length) {
        return;
      } // update the options on all of the fields that depend on the field


      for (let i = 0, len = dependentFieldNames.length; i < len; i++) {
        const dependentFieldName = dependentFieldNames[i];
        const field = this._fieldValues[dependentFieldName];

        if (field) {
          const newOptions = getPicklistOptions.call(this, dependentFieldName, fieldValue);
          updateFieldOptions(dependentFieldName, field.fieldElement, newOptions);
        }
      }
    }

    function getControllerName(fieldName) {
      return Object.keys(this._dependencyMap).find(key => this._dependencyMap[key].includes(fieldName));
    }

    function getControllerValue(fieldName) {
      const field = this._fieldValues[fieldName];
      const controllerField = this._fieldValues[field.controllerName]; // Value on the controller field could have been set to the picklist default value.
      // However, initially we may not have access to the controller field depending on the order that the fields are registered.

      let controllerValue;

      if (controllerField) {
        controllerValue = getFieldValue(field.controllerName, controllerField.fieldElement);
      }

      return controllerValue;
    }

    function getFieldValue(fieldName, fieldElement) {
      const fieldValue = fieldElement.getFieldValue(); // for compound fields like address, the value is an object

      if (typeof fieldValue === 'object' && fieldValue !== null) {
        return fieldValue[fieldName];
      }

      return fieldValue;
    }

    function getPicklistOptions(fieldName, controllerValue) {
      const cacheKey = getOptionsUniqueKey({
        fieldName,
        controllerValue
      });

      if (cacheKey in this._optionsCache) {
        return this._optionsCache[cacheKey];
      }

      const field = this._fieldValues[fieldName];
      const picklistInfo = this._picklistMap[fieldName];
      let picklistValues = picklistInfo && picklistInfo.values;
      const hasController = field.controllerName !== undefined;

      if (hasController) {
        if (controllerValue !== undefined && controllerValue !== null) {
          picklistValues = getDependentPicklistOptions(picklistInfo, controllerValue);
        } else {
          picklistValues = [];
        }
      }

      this._optionsCache[cacheKey] = picklistValues;
      return picklistValues;
    }

    function getDependentPicklistOptions(picklistOptions, controllerValue) {
      const controllerIndex = picklistOptions.controllerValues[controllerValue];
      const allPicklistOptions = picklistOptions.values;
      const options = [];

      for (let i = 0, len = allPicklistOptions.length; i < len; i++) {
        const option = allPicklistOptions[i];

        if (option.validFor.includes(controllerIndex)) {
          options.push(option);
        }
      }

      return options;
    }

    function updateFieldOptions(fieldName, fieldElement, options) {
      fieldElement.updateFieldOptions(fieldName, options);
    }

    function getOptionsUniqueKey(options) {
      return Object.keys(options).reduce((prev, optionName) => {
        const option = options[optionName];
        return option !== undefined && option !== '' ? prev + (prev !== '' ? '-' : '') + option + '' : prev + '';
      }, '');
    }

    function clearMaps() {
      this._fieldValues = {};
      this._dependencyMap = {};
      this._picklistMap = {};
      this._optionsCache = {};
    }

    function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } return target; }

    function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    /**
     * Represents a record edit layout that displays one or more fields, provided by lightning-input-field.
     * @slot default Placeholder for form components like lightning-messages, lightning-button, lightning-input-field and lightning-output-field.
     * Use lightning-input-field to display an editable field.
     */

    class LightningRecordEditForm extends lwc.LightningElement {
      /**
       * Reserved for internal use. Names of the fields to include in the form.
       * @type {string[]}
       */

      /**
       * The ID of the record type, which is required if you created
       * multiple record types but don't have a default.
       * @type {string}
       */

      /**
       * A CSS class for the form element.
       * @type {string}
       */
      // no optional fields!
      // used to trigger picklist values wire

      /**
       * switch between edit and create mode,
       * triggering correct wires
       */
      checkMode() {
        if (this._recordId) {
          this._createMode = false; // trigger record ui wire

          this._wiredRecordId = [this._recordId];
          this._wiredApiName = null;
        } else if (!this._recordIdError && this.objectApiName) {
          this._createMode = true; // trigger record create defaults wire

          this._wiredApiName = this.objectApiName;
          this._wiredRecordId = null;
        }

        if (this._layout) {
          this._wiredLayoutTypes = [this._layout];
          this._layoutMode = true;
        } else {
          this._layoutMode = false;
          this._wiredLayoutTypes = ['Full']; // default to full layout
        }
      }

      constructor() {
        super();
        this.fieldNames = void 0;
        this.recordTypeId = void 0;
        this.formClass = void 0;
        this.optionalFields = [];
        this.fieldSet = void 0;
        this._recordId = void 0;
        this._layout = void 0;
        this._pendingAction = false;
        this._wiredApiName = null;
        this._wiredRecordId = null;
        this._wiredLayoutTypes = null;
        this._createMode = false;
        this._layoutMode = false;
        this._objectApiName = null;
        this._connected = false;
        this._recordIdError = false;
        this._rendered = false;
        this._pendingError = void 0;
        this._inServerErrorState = false;
        this._density = densityValues.AUTO;
        this._fieldLabelAlignment = labelAlignValues.HORIZONTAL;
        this._initialRender = true;
        this._wiredPicklistApiName = null;
        this._wiredRecordTypeId = null;
        this.recordUi = void 0;
        this.errors = void 0;
        this._fields = void 0;
        this._inputComponents = void 0;
        this.rewireData = debounce(() => {
          this.handleData({
            data: this.wiredRecord
          });
        }, 0);
        this.registerOptionalFields = debounce(fields => {
          this.optionalFields = fields;
        }, 0);
        this._formLayoutInterface = this.formLayoutInterface();
      }

      connectedCallback() {
        this.fieldSet = getFieldSet(this.objectApiName); // special case for person accounts

        if (this.objectApiName === 'Account' || this.objectApiName === 'PersonAccount') {
          this.fieldSet.add('IsPersonAccount');
        }

        this.checkMode(); // make sure mode check happens only when needed
        // not all the time

        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
        disconnectResizeObserver(this);
      }

      renderedCallback() {
        this._rendered = true;

        if (this._pendingError) {
          this.handleErrors(this._pendingError);
        }

        if (this._initialRender) {
          setLabelAlignment(this._formLayoutInterface);
          resetResizeObserver(this, this._formLayoutInterface, this._initialRender);
        }

        this._initialRender = false;
      }

      set layoutType(val) {
        this._layout = val;
        this.checkMode();
      }
      /**
       * The type of layout to use to display the form fields. Possible values: Compact, Full.
       * @type {string}
       */


      get layoutType() {
        return this._layout;
      }
      /**
       * Sets the arrangement style of fields and labels in the form.
       * Accepted values are compact, comfy, and auto (default).
       * Use compact to display fields and their labels on the same line.
       * Use comfy to display fields below their labels.
       * Use auto to let the component dynamically set
       * the density according to the user's Display Density setting
       * and the width of the form.
       * @type {string}
       */


      get density() {
        return this._density;
      }

      set density(val) {
        doNormalization(val, this._formLayoutInterface);

        if (!this._initialRender) {
          resetResizeObserver(this, this._formLayoutInterface);
        }
      }

      set recordId(id) {
        if (!id) {
          this._createMode = true;
          this._recordId = null; // normalize falsy to null
        }

        this._recordId = normalizeRecordId(id);

        if (!this._recordId && !this._createMode) {
          const error = {
            message: labelInvalidId
          };
          this.handleErrors(error);
          this._recordIdError = true;
          return;
        }

        this._recordIdError = false; // switch to edit mode

        this._wiredApiName = null;
        this._createMode = false;
        this._wiredRecordId = [this._recordId];

        if (this._connected) {
          this.checkMode();
        }
      }
      /**
       * The ID of the record to be displayed.
       * @type {string}
       */


      get recordId() {
        return this._recordId;
      }

      set objectApiName(val) {
        let apiName; // duck typing for string vs object

        if (val.objectApiName) {
          apiName = val.objectApiName;
        } else {
          apiName = val;
        }

        this._objectApiName = apiName;

        if (this.fieldSet) {
          this.fieldSet.objectApiName = apiName;
        }

        if (this._connected) {
          this.checkMode();
        }
      }
      /**
       * The API name of the object.
       * @type {string}
       * @required
       */


      get objectApiName() {
        return this._objectApiName;
      }

      wiredRecordUi(value) {
        this.handleData(value);
      }

      wiredRecordCreateDefaults(value) {
        this.handleData(value);
      }

      wiredPicklistValuesByRecordType(value) {
        this.handlePicklistValues(value);
      }

      handleChange() {
        if (!this._inServerErrorState) {
          return;
        }

        this.inServerErrorState = false;
        const inputComponents = this.getInputFieldComponents();
        inputComponents.forEach(field => {
          field.setErrors({});
        });
      }

      handleData({
        error,
        data
      }) {
        if (error) {
          this.handleErrors(error);
          return;
        } else if (!data) {
          return;
        }

        this.wiredRecord = data;
        const record = data.records ? data.records[this._recordId] : data.record;

        if (record.apiName !== this.objectApiName) {
          const message = labelApiNameMismatch.replace('{0}', this.objectApiName).replace('{1}', record.apiName);
          this.handleErrors({
            message
          });
          return;
        }

        const viewData = {
          record,
          objectInfo: data.objectInfos[this.objectApiName],
          objectInfos: data.objectInfos,
          createMode: !this._recordId,
          labelAlignment: this._fieldLabelAlignment
        };
        this.recordUi = viewData;
        this.getInputAndOutputComponents().forEach(field => {
          field.wireRecordUi(viewData);
        });

        if (formHasPicklists(viewData.objectInfo, this.optionalFields)) {
          // trigger picklist values wire and then fire load event
          this.triggerPicklistWire();
        } else {
          // no picklists, fire load event
          this.dispatchLoadEvent();
        }
      }

      triggerPicklistWire() {
        const oldRecordTypeId = this._wiredRecordTypeId;
        const oldObjectApiName = this._wiredPicklistApiName;
        this._wiredPicklistApiName = this.objectApiName;
        this._wiredRecordTypeId = this.recordTypeId || getDefaultRecordTypeId(this.recordUi); // if apiName and recordTypeId haven't changed, use the same picklist values. Wire service will not fetch the values again.

        if (oldObjectApiName === this._wiredPicklistApiName && oldRecordTypeId === this._wiredRecordTypeId) {
          this.handlePicklistValues(this._picklistValues);
        }
      }

      handlePicklistValues(value) {
        this._picklistValues = value;
        const {
          error,
          data
        } = value;

        if (error) {
          this.handleErrors(error);
        }

        if (!data) {
          return;
        }

        const filteredPicklistValues = filterByPicklistsInForm(this.recordUi.objectInfo, data.picklistFieldValues || data, this.optionalFields);
        this._picklistValuesInForm = filteredPicklistValues;
        this.initDependencyManager({
          dependentFields: this.recordUi.objectInfo.dependentFields,
          picklistValues: filteredPicklistValues
        });
        this.getInputFieldComponents().forEach(field => {
          field.wirePicklistValues(filteredPicklistValues);
        }); // picklist values are loaded at the end, after record data are wired

        this.dispatchLoadEvent();
      }

      validateForm() {
        const cmps = this.getInputFieldComponents();
        return validateForm(cmps);
      }
      /**
       * Submits the form using an array of record fields or field IDs.
       * The field ID is provisioned from @salesforce/schema/.
       * Invoke this method only after the load event.
       * @param {string[]|FieldId[]} fields - Array of record field names or field IDs.
       */


      submit(fields) {
        this.doSubmit(fields).catch(err => {
          this.handleErrors(err);
        });
      }

      doSubmit(fields) {
        return new Promise((resolve, reject) => {
          this._pendingAction = true;
          const originalRecord = this._createMode ? null : this.recordUi.record;
          const newRecord = {
            fields: fields ? fields : this.getFormValues(),
            // api gets mad if you have an api name for edit, don't have one for create
            apiName: this._createMode ? this._objectApiName : null
          }; // add recordTypeId if it is provided

          if (this.recordTypeId) {
            newRecord.fields.RecordTypeId = this.recordTypeId;
          }

          createOrSaveRecord(newRecord, originalRecord, this.recordUi.objectInfo).then(savedRecord => {
            this._pendingAction = false;
            const lightningMessages = this.querySelector('lightning-messages');

            if (lightningMessages) {
              lightningMessages.setError(null);
            } // the change event needs to propagate to elements outside of the light-DOM, hence making it composed.


            this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
            new CustomEvent('success', {
              composed: true,
              bubbles: true,
              detail: savedRecord
            }));
            resolve();
          }, err => {
            this._pendingAction = false;
            reject(err);
          });
        });
      }

      getFormValues() {
        return getFormValues(this.getInputFieldComponents());
      }

      handleError(err) {
        err.stopPropagation();
        this.handleErrors(err.detail.error);
      }

      handleErrors(error) {
        const messages = this.querySelector('lightning-messages');
        const err = deepCopy(error); // error arrived before render so we'll have to handle it later

        if (!this._rendered) {
          this._pendingError = err;
          return;
        }

        this._pendingError = null;
        const inputComponents = this.getInputFieldComponents();

        if (err.body && err.body.output && err.body.output.fieldErrors) {
          this._inServerErrorState = true;
          const fieldNames = inputComponents.map(field => {
            return field.fieldName;
          });
          Object.keys(err.body.output.fieldErrors).forEach(field => {
            if (fieldNames.indexOf(field) === -1) {
              // field error on missing field!
              err.body.detail = err.body.output.fieldErrors[field][0].message;
            }
          });
        }

        if (messages) {
          messages.setError(err);
        }

        inputComponents.forEach(field => {
          field.setErrors(err);
        });
        this.dispatchEvent(createErrorEvent(err));
      }

      dispatchLoadEvent() {
        this.dispatchEvent(new CustomEvent('load', {
          detail: _objectSpread$3({}, this.wiredRecord, {
            picklistValues: this._picklistValuesInForm
          })
        }));
      } // don't rewire all the fields each time a new field is registered


      handleRegister() {
        if (this.fieldSet) {
          this.fieldSet.concat(this.getFields());
          const newList = this.fieldSet.getList().sort(); // sort doesn't need to be perfect, just deterministic;

          if (!arraysEqual(newList, this.optionalFields)) {
            this.registerOptionalFields(newList);
          } else {
            // we need to rewire data so that fields update properly if they have changed from input to output,
            // or moved around
            this.rewireData();
          }
        }
      }

      registerDependentField(e) {
        e.stopPropagation();
        const {
          fieldName,
          fieldElement
        } = e.detail;

        this._depManager.registerField({
          fieldName,
          fieldElement
        });
      }

      updateDependentFields(e) {
        e.stopPropagation();

        if (this._depManager) {
          this._depManager.handleFieldValueChange(e.detail.fieldName, e.detail.value);
        }
      }

      handleSubmit(e) {
        // This is a workaround for a firefox bug where a click event may end up
        // having 'composed' set to false resulting in an empty target
        // (a repro involves clicking on the year select of the datepicker)
        const eventHasNoTarget = e.target === undefined || e.target === null; // submit buttons can't work in slots,
        // so we listen for clicks on submit buttons
        // TODO discuss with A11Y team

        if (eventHasNoTarget || e.target.type !== 'submit') {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        if (!this.validateForm()) {
          // trigger native validation popups
          const form = this.template.querySelector('form'); // IE 11 does not support this method, but
          // also has no native popups, so this has no visible impact

          if (form.reportValidity) {
            form.reportValidity();
          }

          return;
        } // cleanly clone and unwrap fields


        const fields = JSON.parse(JSON.stringify(this.getFormValues())); // the change event needs to propagate to elements outside of the light-DOM, hence making it composed.
        // eslint-disable-next-line lightning-global/no-custom-event-bubbling

        const evt = new CustomEvent('submit', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            fields
          }
        });
        this.dispatchEvent(evt); // I think this should work, because events always
        // execute in the same stack, so tailing this
        // handler with setTimeout will cause it to wait until
        // the event has propogated to check for prevent default
        // there are some hacks with stopImmediatePropogation,
        // but they rely on re-firing the event, which won't work in
        // this situation
        // eslint-disable-next-line @lwc/lwc/no-async-operation

        setTimeout(() => {
          if (this._pendingAction) {
            return;
          }

          if (evt.defaultPrevented) {
            return;
          }

          this._pendingAction = true;
          this.doSubmit().catch(err => {
            this.handleErrors(err);
          });
        }, 0);
      }

      getInputFieldComponents() {
        return [...this.querySelectorAll('lightning-input-field')];
      }

      getInputAndOutputComponents() {
        return [...this.querySelectorAll('lightning-input-field,lightning-output-field')];
      }

      getFields() {
        return this.getInputAndOutputComponents().map(field => {
          return field.fieldName;
        });
      }

      initDependencyManager(dependencyInfo) {
        if (!this._depManager) {
          this._depManager = new DependencyManager(dependencyInfo);
        } else {
          this._depManager.registerDependencyInfo(dependencyInfo);
        }
      }

      formLayoutInterface() {
        const that = this;
        return {
          getDensityPrivate() {
            return that._density;
          },

          setDensityPrivate(value) {
            that._density = value;
          },

          getDensity() {
            return that.density;
          },

          getLabelAlignmentPrivate() {
            return that._fieldLabelAlignment;
          },

          getContainerElement() {
            return that.template.querySelector('form');
          },

          getInputOutputFields() {
            return that.getInputAndOutputComponents();
          },

          setLabelAlignmentPrivate(value) {
            that._fieldLabelAlignment = value;
          },

          getRecordUi() {
            return that.recordUi;
          },

          getResizeObserverCallback(callback) {
            return () => {
              callback(that._formLayoutInterface);
            };
          }

        };
      }

    }

    lwc.registerDecorators(LightningRecordEditForm, {
      publicProps: {
        fieldNames: {
          config: 0
        },
        recordTypeId: {
          config: 0
        },
        formClass: {
          config: 0
        },
        layoutType: {
          config: 3
        },
        density: {
          config: 3
        },
        recordId: {
          config: 3
        },
        objectApiName: {
          config: 3
        }
      },
      publicMethods: ["submit"],
      wire: {
        wiredRecordUi: {
          adapter: getRecordUi$2,
          params: {
            recordIds: "_wiredRecordId",
            layoutTypes: "_wiredLayoutTypes",
            optionalFields: "optionalFields"
          },
          static: {
            modes: ['View']
          },
          method: 1
        },
        wiredRecordCreateDefaults: {
          adapter: getRecordCreateDefaults$2,
          params: {
            objectApiName: "_wiredApiName",
            recordTypeId: "recordTypeId",
            optionalFields: "optionalFields"
          },
          static: {},
          method: 1
        },
        wiredPicklistValuesByRecordType: {
          adapter: getPicklistValuesByRecordType$2,
          params: {
            objectApiName: "_wiredPicklistApiName",
            recordTypeId: "_wiredRecordTypeId"
          },
          static: {},
          method: 1
        }
      },
      track: {
        recordUi: 1,
        errors: 1
      },
      fields: ["optionalFields", "fieldSet", "_recordId", "_layout", "_pendingAction", "_wiredApiName", "_wiredRecordId", "_wiredLayoutTypes", "_createMode", "_layoutMode", "_objectApiName", "_connected", "_recordIdError", "_rendered", "_pendingError", "_inServerErrorState", "_density", "_fieldLabelAlignment", "_initialRender", "_wiredPicklistApiName", "_wiredRecordTypeId", "_fields", "_inputComponents", "rewireData", "registerOptionalFields"]
    });

    var _lightningRecordEditForm = lwc.registerComponent(LightningRecordEditForm, {
      tmpl: _tmpl
    });

    function tmpl$1($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element
      } = $api;
      return [$cmp.hasError ? api_element("div", {
        classMap: {
          "slds-notify_container": true,
          "slds-is-relative": true
        },
        key: 4
      }, [api_element("div", {
        classMap: {
          "slds-notify": true,
          "slds-notify_toast": true,
          "slds-theme_error": true
        },
        attrs: {
          "role": "alert"
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-notify__content": true
        },
        key: 2
      }, [api_element("h2", {
        classMap: {
          "slds-text-heading_small": true
        },
        key: 0
      }, [api_dynamic($cmp.err.message)]), $cmp.err.detail ? api_element("p", {
        key: 1
      }, [api_dynamic($cmp.err.detail)]) : null])])]) : null];
    }

    var _tmpl$1 = lwc.registerTemplate(tmpl$1);
    tmpl$1.stylesheets = [];
    tmpl$1.stylesheetTokens = {
      hostAttribute: "lightning-messages_messages-host",
      shadowAttribute: "lightning-messages_messages"
    };

    class LightningMessages extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.err = {};
        this.hasError = false;
      }

      // err is one of several error formats
      // returned by ui api, parseError normalizes them
      setError(err) {
        const parsedError = parseError$1(err);
        this.hasError = !!err;
        this.err = parsedError;
      }

      get error() {
        return this.err;
      } // alias to setError method, the
      // other method kept for backward compat


      set error(val) {
        this.setError(val);
      }

    }

    lwc.registerDecorators(LightningMessages, {
      publicProps: {
        error: {
          config: 3
        }
      },
      publicMethods: ["setError"],
      track: {
        err: 1,
        hasError: 1
      }
    });

    var _lightningMessages = lwc.registerComponent(LightningMessages, {
      tmpl: _tmpl$1
    });

    function stylesheet(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets = [stylesheet];

    function stylesheet$1(hostSelector, shadowSelector, nativeShadow) {
      return "_:-ms-lang(x)" + shadowSelector + ", svg" + shadowSelector + " {pointer-events: none;}\n";
    }
    var _implicitStylesheets$1 = [stylesheet$1];

    function tmpl$2($api, $cmp, $slotset, $ctx) {
      const {
        fid: api_scoped_frag_id,
        h: api_element
      } = $api;
      return [api_element("svg", {
        className: $cmp.computedClass,
        attrs: {
          "focusable": "false",
          "data-key": $cmp.name,
          "aria-hidden": "true"
        },
        key: 1
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", api_scoped_frag_id($cmp.href))
        },
        key: 0
      }, [])])];
    }

    var _tmpl$2 = lwc.registerTemplate(tmpl$2);
    tmpl$2.stylesheets = [];

    if (_implicitStylesheets$1) {
      tmpl$2.stylesheets.push.apply(tmpl$2.stylesheets, _implicitStylesheets$1);
    }
    tmpl$2.stylesheetTokens = {
      hostAttribute: "lightning-primitiveIcon_primitiveIcon-host",
      shadowAttribute: "lightning-primitiveIcon_primitiveIcon"
    };

    var dir = 'ltr';

    const proto = {
      add(className) {
        if (typeof className === 'string') {
          this[className] = true;
        } else {
          Object.assign(this, className);
        }

        return this;
      },

      invert() {
        Object.keys(this).forEach(key => {
          this[key] = !this[key];
        });
        return this;
      },

      toString() {
        return Object.keys(this).filter(key => this[key]).join(' ');
      }

    };
    function classSet(config) {
      if (typeof config === 'string') {
        const key = config;
        config = {};
        config[key] = true;
      }

      return Object.assign(Object.create(proto), config);
    }

    /**
     * Takes label strings with placeholder params (`{0}`) and updates the label with given `args`
     * @param {string} str - any label string requiring injections of other strings/params (e.g., 'foo {0}')
     * @param  {string|array} arguments - string(s) to be injected into the `string` param
     * @returns {string} fully replaced string, e.g., '{0} is a {1}' -> 'Hal Jordan is a Green Lantern'
     */
    function formatLabel(str) {
      const args = Array.prototype.slice.call(arguments, 1);
      let replacements = args;

      if (Array.isArray(args[0])) {
        [replacements] = args;
      }

      return str.replace(/{(\d+)}/g, (match, i) => {
        return replacements[i];
      });
    }

    var _tmpl$3 = void 0;

    // Taken from https://github.com/jonathantneal/svg4everybody/pull/139
    // Remove this iframe-in-edge check once the following is resolved https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8323875/
    const isEdgeUA = /\bEdge\/.(\d+)\b/.test(navigator.userAgent);
    const inIframe = window.top !== window.self;
    const isIframeInEdge = isEdgeUA && inIframe;
    var isIframeInEdge$1 = lwc.registerComponent(isIframeInEdge, {
      tmpl: _tmpl$3
    });

    // Taken from https://git.soma.salesforce.com/aura/lightning-global/blob/999dc35f948246181510df6e56f45ad4955032c2/src/main/components/lightning/SVGLibrary/stamper.js#L38-L60
    function fetchSvg(url) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();

        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              resolve(xhr.responseText);
            } else {
              reject(xhr);
            }
          }
        };
      });
    }

    // Which looks like it was inspired by https://github.com/jonathantneal/svg4everybody/blob/377d27208fcad3671ed466e9511556cb9c8b5bd8/lib/svg4everybody.js#L92-L107
    // Modify at your own risk!

    const newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
    const webkitUA = /\bAppleWebKit\/(\d+)\b/;
    const olderEdgeUA = /\bEdge\/12\.(\d+)\b/;
    const isIE = newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537;
    const supportsSvg = !isIE && !isIframeInEdge$1;
    var supportsSvg$1 = lwc.registerComponent(supportsSvg, {
      tmpl: _tmpl$3
    });

    /**
    This polyfill injects SVG sprites into the document for clients that don't
    fully support SVG. We do this globally at the document level for performance
    reasons. This causes us to lose namespacing of IDs across sprites. For example,
    if both #image from utility sprite and #image from doctype sprite need to be
    rendered on the page, both end up as #image from the doctype sprite (last one
    wins). SLDS cannot change their image IDs due to backwards-compatibility
    reasons so we take care of this issue at runtime by adding namespacing as we
    polyfill SVG elements.

    For example, given "/assets/icons/action-sprite/svg/symbols.svg#approval", we
    replace the "#approval" id with "#${namespace}-approval" and a similar
    operation is done on the corresponding symbol element.
    **/
    const svgTagName = /svg/i;

    const isSvgElement = el => el && svgTagName.test(el.nodeName);

    const requestCache = {};
    const symbolEls = {};
    const svgFragments = {};
    const spritesContainerId = 'slds-svg-sprites';
    let spritesEl;
    function polyfill(el) {
      if (!supportsSvg$1 && isSvgElement(el)) {
        if (!spritesEl) {
          spritesEl = document.createElement('svg');
          spritesEl.xmlns = 'http://www.w3.org/2000/svg';
          spritesEl['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';
          spritesEl.style.display = 'none';
          spritesEl.id = spritesContainerId;
          document.body.insertBefore(spritesEl, document.body.childNodes[0]);
        }

        Array.from(el.getElementsByTagName('use')).forEach(use => {
          // We access the href differently in raptor and in aura, probably
          // due to difference in the way the svg is constructed.
          const src = use.getAttribute('xlink:href') || use.getAttribute('href');

          if (src) {
            // "/assets/icons/action-sprite/svg/symbols.svg#approval" =>
            // ["/assets/icons/action-sprite/svg/symbols.svg", "approval"]
            const parts = src.split('#');
            const url = parts[0];
            const id = parts[1];
            const namespace = url.replace(/[^\w]/g, '-');
            const href = `#${namespace}-${id}`;

            if (url.length) {
              // set the HREF value to no longer be an external reference
              if (use.getAttribute('xlink:href')) {
                use.setAttribute('xlink:href', href);
              } else {
                use.setAttribute('href', href);
              } // only insert SVG content if it hasn't already been retrieved


              if (!requestCache[url]) {
                requestCache[url] = fetchSvg(url);
              }

              requestCache[url].then(svgContent => {
                // create a document fragment from the svgContent returned (is parsed by HTML parser)
                if (!svgFragments[url]) {
                  const svgFragment = document.createRange().createContextualFragment(svgContent);
                  svgFragments[url] = svgFragment;
                }

                if (!symbolEls[href]) {
                  const svgFragment = svgFragments[url];
                  const symbolEl = svgFragment.querySelector(`#${id}`);
                  symbolEls[href] = true;
                  symbolEl.id = `${namespace}-${id}`;
                  spritesEl.appendChild(symbolEl);
                }
              });
            }
          }
        });
      }
    }

    const validNameRe = /^([a-zA-Z]+):([a-zA-Z]\w*)$/;
    const underscoreRe = /_/g;
    let pathPrefix;
    const tokenNameMap = Object.assign(Object.create(null), {
      action: 'lightning.actionSprite',
      custom: 'lightning.customSprite',
      doctype: 'lightning.doctypeSprite',
      standard: 'lightning.standardSprite',
      utility: 'lightning.utilitySprite'
    });
    const tokenNameMapRtl = Object.assign(Object.create(null), {
      action: 'lightning.actionSpriteRtl',
      custom: 'lightning.customSpriteRtl',
      doctype: 'lightning.doctypeSpriteRtl',
      standard: 'lightning.standardSpriteRtl',
      utility: 'lightning.utilitySpriteRtl'
    });
    const defaultTokenValueMap = Object.assign(Object.create(null), {
      'lightning.actionSprite': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.actionSpriteRtl': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.customSprite': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.customSpriteRtl': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.doctypeSprite': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.doctypeSpriteRtl': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.standardSprite': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.standardSpriteRtl': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.utilitySprite': '/assets/icons/utility-sprite/svg/symbols.svg',
      'lightning.utilitySpriteRtl': '/assets/icons/utility-sprite/svg/symbols.svg'
    });

    const getDefaultBaseIconPath = (category, nameMap) => defaultTokenValueMap[nameMap[category]];

    const getBaseIconPath = (category, direction) => {
      const nameMap = direction === 'rtl' ? tokenNameMapRtl : tokenNameMap;
      return configProvider.getToken(nameMap[category]) || getDefaultBaseIconPath(category, nameMap);
    };

    const getMatchAtIndex = index => iconName => {
      const result = validNameRe.exec(iconName);
      return result ? result[index] : '';
    };

    const getCategory = getMatchAtIndex(1);
    const getName = getMatchAtIndex(2);
    const isValidName = iconName => validNameRe.test(iconName);
    const getIconPath = (iconName, direction = 'ltr') => {
      pathPrefix = pathPrefix !== undefined ? pathPrefix : configProvider.getPathPrefix();

      if (isValidName(iconName)) {
        const baseIconPath = getBaseIconPath(getCategory(iconName), direction);

        if (baseIconPath) {
          // This check was introduced the following MS-Edge issue:
          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9655192/
          // If and when this get fixed, we can safely remove this block of code.
          if (isIframeInEdge$1) {
            // protocol => 'https:' or 'http:'
            // host => hostname + port
            const origin = `${window.location.protocol}//${window.location.host}`;
            return `${origin}${pathPrefix}${baseIconPath}#${getName(iconName)}`;
          }

          return `${pathPrefix}${baseIconPath}#${getName(iconName)}`;
        }
      }

      return '';
    };
    const computeSldsClass = iconName => {
      if (isValidName(iconName)) {
        const category = getCategory(iconName);
        const name = getName(iconName).replace(underscoreRe, '-');
        return `slds-icon-${category}-${name}`;
      }

      return '';
    };

    class LightningPrimitiveIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.iconName = void 0;
        this.src = void 0;
        this.svgClass = void 0;
        this.size = 'medium';
        this.variant = void 0;
        this.privateIconSvgTemplates = configProvider.getIconSvgTemplates();
      }

      get inlineSvgProvided() {
        return !!this.privateIconSvgTemplates;
      }

      renderedCallback() {
        if (this.iconName !== this.prevIconName && !this.inlineSvgProvided) {
          this.prevIconName = this.iconName;
          const svgElement = this.template.querySelector('svg');
          polyfill(svgElement);
        }
      }

      get href() {
        return this.src || getIconPath(this.iconName, dir);
      }

      get name() {
        return getName(this.iconName);
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      get normalizedVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.variant, {
          fallbackValue: '',
          validValues: ['bare', 'error', 'inverse', 'warning', 'success']
        });
      }

      get computedClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const classes = classSet(this.svgClass);

        if (normalizedVariant !== 'bare') {
          classes.add('slds-icon');
        }

        switch (normalizedVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'success':
            classes.add('slds-icon-text-success');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            if (!this.src) {
              classes.add('slds-icon-text-default');
            }

        }

        if (normalizedSize !== 'medium') {
          classes.add(`slds-icon_${normalizedSize}`);
        }

        return classes.toString();
      }

      resolveTemplate() {
        const name = this.iconName;

        if (isValidName(name)) {
          const [spriteName, iconName] = name.split(':');
          const template = this.privateIconSvgTemplates[`${spriteName}_${iconName}`];

          if (template) {
            return template;
          }
        }

        return _tmpl$2;
      }

      render() {
        if (this.inlineSvgProvided) {
          return this.resolveTemplate();
        }

        return _tmpl$2;
      }

    }

    lwc.registerDecorators(LightningPrimitiveIcon, {
      publicProps: {
        iconName: {
          config: 0
        },
        src: {
          config: 0
        },
        svgClass: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      },
      fields: ["privateIconSvgTemplates"]
    });

    var _lightningPrimitiveIcon = lwc.registerComponent(LightningPrimitiveIcon, {
      tmpl: _tmpl$2
    });

    function tmpl$3($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        classMap: {
          "slds-form-element__icon": true
        },
        key: 3
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "type": "button"
        },
        key: 2
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "svgClass": $cmp.computedSvgClass,
          "iconName": $cmp.iconName,
          "variant": "bare"
        },
        key: 0
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.i18n.buttonAlternativeText)])])])];
    }

    var _tmpl$4 = lwc.registerTemplate(tmpl$3);
    tmpl$3.stylesheets = [];
    tmpl$3.stylesheetTokens = {
      hostAttribute: "lightning-helptext_helptext-host",
      shadowAttribute: "lightning-helptext_helptext"
    };

    var labelButtonAlternativeText = 'Help';

    const POSITION_ATTR_NAME = 'data-position-id';

    class BrowserWindow {
      get window() {
        if (!this._window) {
          this._window = window; // JTEST/Ingtegration: getComputedStyle may be null

          if (!this.window.getComputedStyle) {
            this.window.getComputedStyle = node => {
              return node.style;
            };
          }
        }

        return this._window;
      }

      mockWindow(value) {
        // For test, allow mock window.
        this._window = value;
      }

      get documentElement() {
        assert(this.window.document, 'Missing window.document');
        return this.window.document.documentElement;
      }

      get MutationObserver() {
        return this.window.MutationObserver;
      }

      isWindow(element) {
        return element && element.toString() === '[object Window]';
      }

    }

    const WindowManager = new BrowserWindow();

    function isShadowRoot(node) {
      return node && node.nodeType === 11;
    }

    function enumerateParent(elem, stopEl, checker) {
      // document.body is not necessarily a body tag, because of the (very rare)
      // case of a frameset.
      if (!elem || elem === stopEl || elem === document.body) {
        return null;
      } // if overflow is auto and overflow-y is also auto,
      // however in firefox the opposite is not true


      try {
        // getComputedStyle throws an exception
        // if elem is not an element
        // (can happen during unrender)
        const computedStyle = WindowManager.window.getComputedStyle(elem);

        if (!computedStyle) {
          return null;
        }

        if (checker(computedStyle)) {
          return elem;
        }

        return enumerateParent(isShadowRoot(elem.parentNode) ? elem.parentNode.host : elem.parentNode, stopEl, checker);
      } catch (e) {
        return null;
      }
    }

    function getScrollableParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        const overflow = computedStyle['overflow-y'];
        return overflow === 'auto' || overflow === 'scroll';
      });
    }

    function queryOverflowHiddenParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        return computedStyle['overflow-x'] === 'hidden' || computedStyle['overflow-y'] === 'hidden';
      });
    }

    function isInDom(el) {
      if (el === WindowManager.window) {
        return true;
      }

      if (!isShadowRoot(el.parentNode) && el.parentNode && el.parentNode.tagName && el.parentNode.tagName.toUpperCase() === 'BODY') {
        return true;
      }

      if (isShadowRoot(el.parentNode) && el.parentNode.host) {
        return isInDom(el.parentNode.host);
      }

      if (el.parentNode) {
        return isInDom(el.parentNode);
      }

      return false;
    }
    function isDomNode(obj) {
      return obj.nodeType && (obj.nodeType === 1 || obj.nodeType === 11);
    }
    function timeout$1(time) {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          resolve();
        }, time);
      });
    }
    function getPositionTarget(element) {
      return element.tagName === 'TEXTAREA' ? isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode : element;
    }
    let lastId = 1000000;
    function generateUniqueSelector() {
      return `lgcp-${lastId++}`;
    }
    function normalizeElement(element) {
      const selector = generateUniqueSelector();
      element.setAttribute(POSITION_ATTR_NAME, selector);
      element = // eslint-disable-next-line @lwc/lwc/no-document-query
      document.querySelector(`[${POSITION_ATTR_NAME}="${selector}"]`) || element;
      return element;
    }

    function isInsideOverlay(element, modalOnly) {
      if (!element) {
        return {
          isInside: false,
          overlay: null
        };
      }

      if (element.classList && (element.classList.contains('uiModal') || element.localName === 'lightning-dialog' || !modalOnly && element.classList.contains('uiPanel'))) {
        return {
          isInside: true,
          overlay: element
        };
      }

      if (!element.parentNode) {
        return {
          isInside: false,
          overlay: null
        };
      }

      return isInsideOverlay(isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode, modalOnly);
    }

    function isInsideModal(element) {
      return isInsideOverlay(element, true);
    }
    function normalizePosition(element, nextIndex, target, alignWidth) {
      // Set element position to fixed
      // 1. element is inside overlay
      // or 2. When element isn't align with target's width, and target's parent has overflow-x:hidden setting.
      const isFixed = isInsideOverlay(element).isInside || !alignWidth && queryOverflowHiddenParent(target, WindowManager.window);
      element.style.position = isFixed ? 'fixed' : 'absolute';
      element.style.zIndex = nextIndex || 0;
      element.style.left = '-9999px'; // Avoid flicker
      // we always position from the left, but in RTL mode Omakase swaps left and right properties.
      // To always allow positioning from the left we set right to auto so position library can do its work.

      element.style.right = 'auto';
      element.style.top = '0px'; // Avoid flicker

      return element;
    }
    function requestAnimationFrameAsPromise() {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => resolve());
      });
    }

    const Direction = {
      Center: 'center',
      Middle: 'middle',
      Right: 'right',
      Left: 'left',
      Bottom: 'bottom',
      Top: 'top',
      Default: 'default'
    };
    const VerticalMap = {
      top: Direction.Top,
      bottom: Direction.Bottom,
      center: Direction.Middle
    };
    const HorizontalMap = {
      left: Direction.Left,
      right: Direction.Right,
      center: Direction.Center
    };
    const FlipMap = {
      left: Direction.Right,
      right: Direction.Left,
      top: Direction.Bottom,
      bottom: Direction.Top,
      center: Direction.Center,
      default: Direction.Right
    };

    function getWindowSize() {
      return {
        width: WindowManager.window.innerWidth || document.body.clientWidth || 0,
        height: WindowManager.window.innerHeight || document.body.clientHeight || 0
      };
    }

    function normalizeDirection(direction, defaultValue) {
      return normalizeString(direction, {
        fallbackValue: defaultValue || Direction.Default,
        validValues: [Direction.Center, Direction.Right, Direction.Left, Direction.Bottom, Direction.Top, Direction.Middle, Direction.Default]
      });
    }
    function mapToHorizontal(value) {
      value = normalizeDirection(value, Direction.Left);
      return HorizontalMap[value];
    }
    function mapToVertical(value) {
      value = normalizeDirection(value, Direction.Left);
      return VerticalMap[value];
    }
    function flipDirection(value) {
      value = normalizeDirection(value, Direction.Left);
      return FlipMap[value];
    } // TODO: Remove, not currently in use.
    function checkFlipPossibility(element, target, leftAsBoundary) {
      const viewPort = getWindowSize();
      const elemRect = element.getBoundingClientRect();
      const referenceElemRect = target.getBoundingClientRect();
      const height = typeof elemRect.height !== 'undefined' ? elemRect.height : elemRect.bottom - elemRect.top;
      const width = typeof elemRect.width !== 'undefined' ? elemRect.width : elemRect.right - elemRect.left; // TODO: We'll need to revisit the leftAsBoundary config property. Either we'll need a better
      // name to cover the RTL language cases and maybe open up the possibility of bounding the
      // element to the target in both the horizontal and vertical directions.
      // The boundary shrinks the available area to the edge of the target rather than the viewport.

      let rightAsBoundary = false;

      if (document.dir === 'rtl') {
        rightAsBoundary = leftAsBoundary;
        leftAsBoundary = false;
      }

      const hasSpaceAbove = referenceElemRect.top >= height;
      const hasSpaceBelow = viewPort.height - referenceElemRect.bottom >= height; // Assuming left alignment is specified this tests if:
      // - there's room to accommodate the element with right alignment
      // - there's not enough room to accommodate the element with left alignment

      const shouldAlignToRight = referenceElemRect.right >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width); // Assuming right alignment is specified this tests if:
      // - there's room to accommodate the element with left alignment
      // - there's not enough room to accommodate the element with right alignment

      const shouldAlignToLeft = referenceElemRect.left + width <= viewPort.width && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0); // Assuming center alignment, does the viewport have space to fit half of the element around
      // the target?

      const centerOverflow = {
        left: referenceElemRect.left - width * 0.5 < 0,
        right: referenceElemRect.right + width * 0.5 > viewPort.width,
        top: referenceElemRect.top - height * 0.5 < 0,
        bottom: referenceElemRect.bottom + height * 0.5 > viewPort.height
      };
      return {
        shouldAlignToLeft,
        shouldAlignToRight,
        hasSpaceAbove,
        hasSpaceBelow,
        centerOverflow
      };
    }

    class Transformer {
      constructor(pad, boxDirections, transformX, transformY) {
        this.pad = pad || 0;
        this.boxDirections = boxDirections || {
          left: true,
          right: true
        };

        this.transformX = transformX || function () {};

        this.transformY = transformY || function () {};
      }

      transform() {// no-op
      }

    }

    class TopTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) + this.pad
        };
      }

    }

    class BottomTransFormer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) - elementBox.height - this.pad
        };
      }

    }

    class CenterTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - 0.5 * elementBox.width)
        };
      }

    }

    class MiddleTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: Math.floor(0.5 * (2 * targetBox.top + targetBox.height - elementBox.height))
        };
      }

    }

    class LeftTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) + this.pad
        };
      }

    }

    class RightTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) - elementBox.width - this.pad
        };
      }

    }

    class BelowTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const top = targetBox.top + targetBox.height + this.pad;
        return elementBox.top < top ? {
          top
        } : {};
      }

    }

    const MIN_HEIGHT = 36; // Minimum Line Height

    const MIN_WIDTH = 36;

    class ShrinkingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
          retBox.height = Math.max(elementBox.height - (retBox.top - elementBox.top), MIN_HEIGHT);
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
          retBox.width = Math.max(elementBox.width - (retBox.left - elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.right = targetBox.left + targetBox.width - this.pad;
          retBox.width = Math.max(retBox.right - (retBox.left || elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.bottom = targetBox.top + targetBox.height - this.pad;
          retBox.height = Math.max(retBox.bottom - (retBox.top || elementBox.top), MIN_HEIGHT);
        }

        return retBox;
      }

    }

    class BoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.left = targetBox.left + targetBox.width - elementBox.width - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.top = targetBox.top + targetBox.height - elementBox.height - this.pad;
        }

        return retBox;
      }

    }

    class InverseBoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.left && targetBox.left - this.pad < elementBox.left) {
          retBox.left = targetBox.left - this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width < targetBox.left + targetBox.width + this.pad) {
          retBox.left = targetBox.width + this.pad - elementBox.width + targetBox.left;
        }

        if (this.boxDirections.top && targetBox.top < elementBox.top + this.pad) {
          retBox.top = targetBox.top - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height < targetBox.top + targetBox.height + this.pad) {
          retBox.top = targetBox.height + this.pad - elementBox.height + targetBox.top;
        }

        return retBox;
      }

    }

    const TransformFunctions = {
      center(input, targetBox) {
        return Math.floor(input + 0.5 * targetBox.width);
      },

      right(input, targetBox) {
        return input + targetBox.width;
      },

      left(input) {
        return input;
      },

      bottom(input, targetBox) {
        return input + targetBox.height;
      }

    };
    const Transformers = {
      top: TopTransformer,
      bottom: BottomTransFormer,
      center: CenterTransformer,
      middle: MiddleTransformer,
      left: LeftTransformer,
      right: RightTransformer,
      below: BelowTransformer,
      'bounding box': BoundingBoxTransformer,
      'shrinking box': ShrinkingBoxTransformer,
      'inverse bounding box': InverseBoundingBoxTransformer,
      default: Transformer
    };
    function toTransformFunctions(value) {
      return TransformFunctions[value] || TransformFunctions.left;
    }

    class TransformBuilder {
      type(value) {
        this._type = value;
        return this;
      }

      align(horizontal, vertical) {
        this._transformX = toTransformFunctions(horizontal);
        this._transformY = toTransformFunctions(vertical);
        return this;
      }

      pad(value) {
        this._pad = parseInt(value, 10);
        return this;
      }

      boxDirections(value) {
        this._boxDirections = value;
        return this;
      }

      build() {
        const AConstructor = Transformers[this._type] ? Transformers[this._type] : Transformers[Direction.Default];
        return new AConstructor(this._pad || 0, this._boxDirections || {}, this._transformX || toTransformFunctions(Direction.left), this._transformY || toTransformFunctions(Direction.left));
      }

    }

    class Constraint {
      constructor(type, config) {
        const {
          target,
          element,
          pad,
          boxDirections
        } = config;
        const {
          horizontal,
          vertical
        } = config.targetAlign;
        this._element = element;
        this._targetElement = target;
        this.destroyed = false;
        this._transformer = new TransformBuilder().type(type).align(horizontal, vertical).pad(pad).boxDirections(boxDirections).build();
      }

      detach() {
        this._disabled = true;
      }

      attach() {
        this._disabled = false;
      }

      computeDisplacement() {
        if (!this._disabled) {
          this._targetElement.refresh();

          this._element.refresh();

          this._pendingBox = this._transformer.transform(this._targetElement, this._element);
        }

        return this;
      }

      computePosition() {
        const el = this._element;

        if (!this._disabled) {
          Object.keys(this._pendingBox).forEach(key => {
            el.setDirection(key, this._pendingBox[key]);
          });
        }

        return this;
      }

      destroy() {
        this._element.release();

        this._targetElement.release();

        this._disabled = true;
        this.destroyed = true;
      }

    }

    class ElementProxy {
      constructor(el, id) {
        this.id = id;
        this.width = 0;
        this.height = 0;
        this.left = 0;
        this.top = 0;
        this.right = 0;
        this.bottom = 0;
        this._dirty = false;
        this._node = null;
        this._releaseCb = null;

        if (!el) {
          throw new Error('Element missing');
        } // W-3262919
        // for some reason I cannot figure out sometimes the
        // window, which clearly a window object, is not the window object
        // this will correct that. It might be related to locker


        if (WindowManager.isWindow(el)) {
          el = WindowManager.window;
        }

        this._node = el;
        this.setupObserver();
        this.refresh();
      }

      setupObserver() {
        // this check is because phantomjs does not support
        // mutation observers. The consqeuence here
        // is that any browser without mutation observers will
        // fail to update dimensions if they changwe after the proxy
        // is created and the proxy is not not refreshed
        if (WindowManager.MutationObserver && !this._node.isObserved) {
          // Use mutation observers to invalidate cache. It's magic!
          this._observer = new WindowManager.MutationObserver(this.refresh.bind(this)); // do not observe the window

          if (!WindowManager.isWindow(this._node)) {
            this._observer.observe(this._node, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });

            this._node.isObserved = true;
          }
        }
      }

      setReleaseCallback(cb, scope) {
        const scopeObj = scope || this;
        this._releaseCb = cb.bind(scopeObj);
      }

      checkNodeIsInDom() {
        // if underlying DOM node is gone,
        // this proxy should be released
        if (!isInDom(this._node)) {
          return false;
        }

        return true;
      }

      refresh() {
        const w = WindowManager.window;

        if (!this.isDirty()) {
          if (!this.checkNodeIsInDom()) {
            return this.release();
          }

          let box, x, scrollTop, scrollLeft;

          if (typeof w.pageYOffset !== 'undefined') {
            scrollTop = w.pageYOffset;
            scrollLeft = w.pageXOffset;
          } else {
            scrollTop = w.scrollY;
            scrollLeft = w.scrollX;
          }

          if (!WindowManager.isWindow(this._node)) {
            // force paint
            // eslint-disable-next-line no-unused-vars
            const offsetHeight = this._node.offsetHeight;
            box = this._node.getBoundingClientRect(); // not using integers causes weird rounding errors
            // eslint-disable-next-line guard-for-in

            for (x in box) {
              this[x] = Math.floor(box[x]);
            }

            this.top = Math.floor(this.top + scrollTop);
            this.bottom = Math.floor(this.top + box.height);
            this.left = Math.floor(this.left + scrollLeft);
            this.right = Math.floor(this.left + box.width);
          } else {
            box = {};
            this.width = WindowManager.documentElement.clientWidth;
            this.height = WindowManager.documentElement.clientHeight;
            this.left = scrollLeft;
            this.top = scrollTop;
            this.right = WindowManager.documentElement.clientWidth + scrollLeft;
            this.bottom = WindowManager.documentElement.clientHeight;
          }

          this._dirty = false;
        }

        return this._dirty;
      }

      getNode() {
        return this._node;
      }

      isDirty() {
        return this._dirty;
      }

      bake() {
        const w = WindowManager.window;

        const absPos = this._node.getBoundingClientRect();

        const style = w.getComputedStyle(this._node) || this._node.style;

        const hasPageOffset = typeof w.pageYOffset !== 'undefined';
        const scrollTop = hasPageOffset ? w.pageYOffset : w.scrollY;
        const scrollLeft = hasPageOffset ? w.pageXOffset : w.scrollX;
        const originalLeft = style.left.match(/auto|fixed/) ? '0' : parseInt(style.left.replace('px', ''), 10);
        const originalTop = style.top.match(/auto|fixed/) ? '0' : parseInt(style.top.replace('px', ''), 10);
        const leftDif = Math.round(this.left - (absPos.left + scrollLeft));
        const topDif = this.top - (absPos.top + scrollTop);
        this._node.style.left = `${originalLeft + leftDif}px`;
        this._node.style.top = `${originalTop + topDif}px`;

        if (this._restoreSize) {
          // Only store the first height/width which is the original height/width.
          if (this.originalHeight === undefined) {
            this.originalHeight = this._node.style.height;
          }

          if (this.originalWidth === undefined) {
            this.originalWidth = this._node.style.width;
          }

          this._node.style.width = `${this.width}px`;
          this._node.style.height = `${this.height}px`;
        }

        this._dirty = false;
      }

      setDirection(direction, val) {
        this[direction] = val;
        this._dirty = true; // if size is changed, should restore the original size.

        if (direction === 'height' || direction === 'width') {
          this._restoreSize = true;
        }
      }

      release() {
        if (this._restoreSize) {
          this._node.style.width = this.originalWidth;
          this._node.style.height = this.originalHeight;

          if (this._removeMinHeight) {
            this._node.style.minHeight = '';
          }
        }

        if (this._releaseCb) {
          this._releaseCb(this);
        } // Due to https://github.com/salesforce/lwc/pull/1423
        // require to call disconnect explicitly.


        if (this._observer) {
          this._observer.disconnect();

          this._observer = null;
        }
      }

      querySelectorAll(selector) {
        return this._node.querySelectorAll(selector);
      }

    }

    class ProxyCache {
      constructor() {
        this.proxyCache = {};
      }

      get count() {
        return Object.keys(this.proxyCache).length;
      }

      releaseOrphanProxies() {
        for (const proxy in this.proxyCache) {
          if (!this.proxyCache[proxy].el.checkNodeIsInDom()) {
            this.proxyCache[proxy].el.release();
          }
        }
      }

      bakeOff() {
        for (const proxy in this.proxyCache) {
          if (this.proxyCache[proxy].el.isDirty()) {
            this.proxyCache[proxy].el.bake();
          }
        }
      }

      getReferenceCount(proxy) {
        const id = proxy.id;

        if (!id || !this.proxyCache[id]) {
          return 0;
        }

        return this.proxyCache[id].refCount;
      }

      release(proxy) {
        const proxyInstance = this.proxyCache[proxy.id];

        if (proxyInstance) {
          --proxyInstance.refCount;
        }

        if (proxyInstance && proxyInstance.refCount <= 0) {
          delete this.proxyCache[proxy.id];
        }
      }

      reset() {
        this.proxyCache = {};
      }

      create(element) {
        let key = 'window';

        if (!WindowManager.isWindow(element)) {
          key = element ? element.getAttribute(POSITION_ATTR_NAME) : null; // 1 - Node.ELEMENT_NODE, 11 - Node.DOCUMENT_FRAGMENT_NODE

          assert(key && element.nodeType && (element.nodeType !== 1 || element.nodeType !== 11), `Element Proxy requires an element and has property ${POSITION_ATTR_NAME}`);
        }

        if (this.proxyCache[key]) {
          this.proxyCache[key].refCount++;
          return this.proxyCache[key].el;
        }

        const newProxy = new ElementProxy(element, key);
        newProxy.setReleaseCallback(release, newProxy);
        this.proxyCache[key] = {
          el: newProxy,
          refCount: 1
        }; // run GC

        timeout$1(0).then(() => {
          this.releaseOrphanProxies();
        });
        return this.proxyCache[key].el;
      }

    }

    lwc.registerDecorators(ProxyCache, {
      fields: ["proxyCache"]
    });

    const elementProxyCache = new ProxyCache();
    function bakeOff() {
      elementProxyCache.bakeOff();
    }
    function release(proxy) {
      return elementProxyCache.release(proxy);
    }
    function createProxy(element) {
      return elementProxyCache.create(element);
    }

    class RepositionQueue {
      constructor() {
        this.callbacks = [];
        this.repositionScheduled = false;
        this._constraints = [];
        this.timeoutId = 0;
        this.lastIndex = getZIndexBaseline();
        this.eventsBound = false;
      }

      get nextIndex() {
        return this.lastIndex++;
      }

      get constraints() {
        return this._constraints;
      }

      set constraints(value) {
        this._constraints = this._constraints.concat(value);
      }

      dispatchRepositionCallbacks() {
        while (this.callbacks.length > 0) {
          this.callbacks.shift()();
        }
      }

      add(callback) {
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
          return true;
        }

        return false;
      }

      scheduleReposition(callback) {
        if (this.timeoutId === 0) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          this.timeoutId = setTimeout(() => {
            this.reposition(callback);
          }, 10);
        }
      }

      reposition(callback) {
        // all the callbacks will be called
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
        } // this is for throttling


        clearTimeout(this.timeoutId);
        this.timeoutId = 0; // this semaphore is to make sure
        // if reposition is called twice within one frame
        // we only run this once

        if (!this.repositionScheduled) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            this.repositionScheduled = false; // this must be executed in order or constraints
            // will behave oddly

            this._constraints = this._constraints.filter(constraint => {
              if (!constraint.destroyed) {
                constraint.computeDisplacement().computePosition();
                return true;
              }

              return false;
            });
            bakeOff();
            this.dispatchRepositionCallbacks();
          });
          this.repositionScheduled = true;
        }
      }

      get repositioning() {
        if (!this._reposition) {
          this._reposition = this.scheduleReposition.bind(this);
        }

        return this._reposition;
      }

      bindEvents() {
        if (!this.eventsBound) {
          window.addEventListener('resize', this.repositioning);
          window.addEventListener('scroll', this.repositioning);
          this.eventsBound = true;
        }
      }

      detachEvents() {
        window.removeEventListener('resize', this.repositioning);
        window.removeEventListener('scroll', this.repositioning);
        this.eventsBound = false;
      }

      rebase(index) {
        if (this.lastIndex <= index) {
          this.lastIndex = index + 1;
        }
      }

    }

    lwc.registerDecorators(RepositionQueue, {
      fields: ["callbacks", "repositionScheduled", "_constraints", "timeoutId", "lastIndex", "eventsBound"]
    });

    const positionQueue = new RepositionQueue();
    function scheduleReposition(callback) {
      positionQueue.scheduleReposition(callback);
    }
    function bindEvents() {
      positionQueue.bindEvents();
    }
    function addConstraints(list) {
      positionQueue.constraints = list;
    }
    function reposition(callback) {
      positionQueue.reposition(callback);
    }
    function nextIndex() {
      return positionQueue.nextIndex;
    }
    function rebaseIndex(index) {
      return positionQueue.rebase(index);
    }

    class Relationship {
      constructor(config, constraintList, scrollableParent, observer) {
        this.config = config;
        this.constraintList = constraintList;
        this.scrollableParent = scrollableParent;
        this.observer = observer;
      }

      disable() {
        this.constraintList.forEach(constraintToDisable => {
          constraintToDisable.detach();
        });
      }

      enable() {
        this.constraintList.forEach(constraintToEnable => {
          constraintToEnable.attach();
        });
      }

      destroy() {
        if (this.config.removeListeners) {
          this.config.removeListeners();
          this.config.removeListeners = undefined;
        }

        while (this.constraintList.length > 0) {
          this.constraintList.pop().destroy();
        } // Clean up node appended to body of dom


        if (this.config.appendToBody && this.config.element) {
          // eslint-disable-next-line @lwc/lwc/no-document-query
          const nodeToRemove = document.querySelector(`[${POSITION_ATTR_NAME}="${this.config.element.getAttribute(POSITION_ATTR_NAME)}"]`);

          if (nodeToRemove) {
            nodeToRemove.parentNode.removeChild(nodeToRemove);
          }
        } // Due to https://github.com/salesforce/lwc/pull/1423
        // require to call disconnect explicitly.


        if (this.observer) {
          this.observer.disconnect();
          this.observer = null;
        }
      }

      reposition() {
        return new Promise(resolve => {
          reposition(() => {
            resolve();
          });
        });
      }

    }

    const DEFAULT_MIN_HEIGHT = '1.875rem';

    function setupObserver(config, scrollableParent) {
      const observedElement = config.element;
      let observer = null;

      if (WindowManager.MutationObserver && !observedElement.isObserved) {
        observer = new WindowManager.MutationObserver(() => {});
        observer.observe(observedElement, {
          attributes: true,
          subtree: true,
          childList: true
        });
        observedElement.isObserved = true;
      }

      if (scrollableParent) {
        scrollableParent.addEventListener('scroll', scheduleReposition);

        config.removeListeners = () => {
          scrollableParent.removeEventListener('scroll', scheduleReposition);
        };
      }

      return observer;
    }

    function validateConfig$5(config) {
      assert(config.element && isDomNode(config.element), 'Element is undefined or missing, or not a Dom Node');
      assert(config.target && (WindowManager.isWindow(config.target) || isDomNode(config.target)), 'Target is undefined or missing');
    }

    function createRelationship(config) {
      bindEvents();

      if (config.alignWidth && config.element.style.position === 'fixed') {
        config.element.style.width = config.target.getBoundingClientRect().width + 'px';
      }

      const constraintList = [];
      const scrollableParent = getScrollableParent(getPositionTarget(config.target), WindowManager.window); // This observer and the test for scrolling children
      // is so that if a panel contains a scroll we do not
      // proxy the events to the "parent"  (actually the target's parent)

      const observer = setupObserver(config, scrollableParent);

      if (config.appendToBody) {
        document.body.appendChild(config.element);
      }

      config.element = createProxy(config.element);
      config.target = createProxy(config.target); // Add horizontal constraint.

      const horizontalConfig = Object.assign({}, config);

      if (horizontalConfig.padLeft !== undefined) {
        horizontalConfig.pad = horizontalConfig.padLeft;
      } // Add vertical constraint.


      const verticalConfig = Object.assign({}, config);

      if (verticalConfig.padTop !== undefined) {
        verticalConfig.pad = verticalConfig.padTop;
      }

      constraintList.push(new Constraint(mapToHorizontal(config.align.horizontal), horizontalConfig));
      constraintList.push(new Constraint(mapToVertical(config.align.vertical), verticalConfig));
      const autoShrink = config.autoShrink.height || config.autoShrink.width;

      if (config.scrollableParentBound && scrollableParent) {
        const parent = normalizeElement(scrollableParent);
        const boxConfig = {
          element: config.element,
          enabled: config.enabled,
          target: createProxy(parent),
          align: {},
          targetAlign: {},
          pad: 3,
          boxDirections: {
            top: true,
            bottom: true,
            left: true,
            right: true
          }
        };

        if (autoShrink) {
          const style = boxConfig.element.getNode().style;

          if (!style.minHeight) {
            style.minHeight = config.minHeight;
            boxConfig.element._removeMinHeight = true;
          }

          boxConfig.boxDirections = {
            top: !!config.autoShrink.height,
            bottom: !!config.autoShrink.height,
            left: !!config.autoShrink.width,
            right: !!config.autoShrink.width
          };
          constraintList.push(new Constraint('shrinking box', boxConfig));
        } else {
          constraintList.push(new Constraint('bounding box', boxConfig));
        }
      }

      if (config.keepInViewport) {
        constraintList.push(new Constraint('bounding box', {
          element: config.element,
          enabled: config.enabled,
          target: createProxy(window),
          align: {},
          targetAlign: {},
          pad: 3,
          boxDirections: {
            top: true,
            bottom: true,
            left: true,
            right: true
          }
        }));
      }

      addConstraints(constraintList);
      reposition();
      return new Relationship(config, constraintList, scrollableParent, observer);
    }

    function isAutoFlipHorizontal(config) {
      return config.autoFlip || config.autoFlipHorizontal;
    }

    function isAutoFlipVertical(config) {
      return config.autoFlip || config.autoFlipVertical;
    }

    function normalizeAlignments(config, flipConfig) {
      const align = {
        horizontal: config.align.horizontal,
        vertical: config.align.vertical
      };
      const targetAlign = {
        horizontal: config.targetAlign.horizontal,
        vertical: config.targetAlign.vertical
      }; // Horizontal alignments flip for RTL languages.

      if (document.dir === 'rtl') {
        align.horizontal = flipDirection(align.horizontal);
        targetAlign.horizontal = flipDirection(targetAlign.horizontal);
      } // When using the autoFlip flags with center alignment, we change the element alignment to fit
      // within the viewport when it's detected that it overflows the edge of the viewport.


      let vFlip = false;

      if (isAutoFlipVertical(config)) {
        if (align.vertical === Direction.Bottom) {
          vFlip = !flipConfig.hasSpaceAbove && flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Top) {
          vFlip = flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Center) {
          if (flipConfig.centerOverflow.top && !flipConfig.centerOverflow.bottom) {
            align.vertical = targetAlign.vertical = Direction.Top;
          } else if (flipConfig.centerOverflow.bottom && !flipConfig.centerOverflow.top) {
            align.vertical = targetAlign.vertical = Direction.Bottom;
          }
        }
      }

      let hFlip = false;

      if (isAutoFlipHorizontal(config)) {
        if (align.horizontal === Direction.Left) {
          hFlip = flipConfig.shouldAlignToRight;
        } else if (align.horizontal === Direction.Right) {
          hFlip = flipConfig.shouldAlignToLeft;
        } else if (align.horizontal === Direction.Center) {
          if (flipConfig.centerOverflow.left && !flipConfig.centerOverflow.right) {
            align.horizontal = targetAlign.horizontal = Direction.Left;
          } else if (flipConfig.centerOverflow.right && !flipConfig.centerOverflow.left) {
            align.horizontal = targetAlign.horizontal = Direction.Right;
          }
        }
      }

      return {
        align: {
          horizontal: hFlip ? flipDirection(align.horizontal) : normalizeDirection(align.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(align.vertical) : normalizeDirection(align.vertical, Direction.Top)
        },
        targetAlign: {
          horizontal: hFlip ? flipDirection(targetAlign.horizontal) : normalizeDirection(targetAlign.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(targetAlign.vertical) : normalizeDirection(targetAlign.vertical, Direction.Bottom)
        }
      };
    }

    function normalizeConfig(config) {
      config.align = config.align || {};
      config.targetAlign = config.targetAlign || {};
      const flipConfig = checkFlipPossibility(config.element, config.target, config.leftAsBoundary);
      const {
        align,
        targetAlign
      } = normalizeAlignments(config, flipConfig); // When inside modal, element may expand out of the viewport and be cut off.
      // So if inside modal, and don't have enough space above or below, will add bounding box rule.

      if (config.isInsideModal && !flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow) {
        config.scrollableParentBound = true;
      }

      return {
        target: config.target,
        element: config.element,
        align,
        targetAlign,
        alignWidth: config.alignWidth,
        scrollableParentBound: config.scrollableParentBound,
        keepInViewport: config.keepInViewport,
        pad: config.pad,
        padTop: config.padTop,
        padLeft: config.padLeft,
        autoShrink: {
          height: config.autoShrink || config.autoShrinkHeight,
          width: config.autoShrink || config.autoShrinkWidth
        },
        minHeight: config.minHeight || DEFAULT_MIN_HEIGHT
      };
    }

    function toElement(root, target) {
      if (target && typeof target === 'string') {
        return root.querySelector(target);
      } else if (target && typeof target === 'function') {
        return target();
      }

      return target;
    }

    function startPositioning(root, config) {
      assert(root, 'Root is undefined or missing');
      assert(config, 'Config is undefined or missing');
      const node = normalizeElement(root);
      const target = toElement(node, config.target);
      const element = toElement(node, config.element); // when target/element is selector, there is chance, dom isn't present anymore.

      if (!target || !element) {
        return null;
      }

      config.target = normalizeElement(target);
      config.element = normalizeElement(element);
      const result = isInsideModal(config.element);
      config.isInsideModal = result.isInside; // stackManager will increase the zIndex too.
      // if detect inside modal, read modal zindex and rebase to it.

      if (config.isInsideModal && result.overlay) {
        const index = parseInt(result.overlay.style.zIndex, 10);
        rebaseIndex(index);
      } // Also should check if target inside modal too.


      const targetResult = isInsideModal(config.target);
      config.isInsideModal = targetResult.isInside; // if detect inside modal, read modal zindex and rebase to it.

      if (config.isInsideModal && targetResult.overlay) {
        const index = parseInt(targetResult.overlay.style.zIndex, 10);
        rebaseIndex(index);
      } // Element absolute / fixed must be set prior to getBoundingClientRect call or
      // the scrollable parent (usually due to uiModal/uiPanel) will push the page down.


      config.element = normalizePosition(config.element, nextIndex(), config.target, config.alignWidth);
      validateConfig$5(config);
      return createRelationship(normalizeConfig(config));
    }
    function stopPositioning(relationship) {
      if (relationship) {
        relationship.destroy();
      }
    }
    class AutoPosition {
      constructor(root) {
        this._autoPositionUpdater = null;
        this._root = root;
      }

      start(config) {
        return requestAnimationFrameAsPromise().then(() => {
          let promise = Promise.resolve();

          if (!this._autoPositionUpdater) {
            this._autoPositionUpdater = startPositioning(this._root, config);
          } else {
            promise = promise.then(() => {
              return this._autoPositionUpdater.reposition();
            });
          }

          return promise.then(() => {
            return this._autoPositionUpdater;
          });
        });
      }

      stop() {
        if (this._autoPositionUpdater) {
          stopPositioning(this._autoPositionUpdater);
          this._autoPositionUpdater = null;
        }

        return Promise.resolve();
      }

    }

    lwc.registerDecorators(AutoPosition, {
      fields: ["_autoPositionUpdater"]
    });

    function tmpl$4($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 0,
        on: {
          "mouseleave": _m0 || ($ctx._m0 = api_bind($cmp.handleMouseLeave))
        }
      }, [])];
    }

    var _tmpl$5 = lwc.registerTemplate(tmpl$4);
    tmpl$4.stylesheets = [];
    tmpl$4.stylesheetTokens = {
      hostAttribute: "lightning-primitiveBubble_primitiveBubble-host",
      shadowAttribute: "lightning-primitiveBubble_primitiveBubble"
    };

    const DEFAULT_ALIGN = {
      horizontal: 'left',
      vertical: 'bottom'
    };

    class LightningPrimitiveBubble extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          visible: false,
          contentId: ''
        };
        this.divElement = void 0;
      }

      get contentId() {
        return this.state.contentId;
      }

      set contentId(value) {
        this.state.contentId = value;

        if (this.state.inDOM) {
          this.divEl.setAttribute('id', this.state.contentId);
        }
      }

      connectedCallback() {
        this.updateClassList();
        this.state.inDOM = true;
      }

      disconnectedCallback() {
        this.state.inDOM = false;
      }

      renderedCallback() {
        // set content manually once rendered
        // - this is required to avoid the content update being in the wrong 'tick'
        this.setContentManually();
        this.setIdManually();
      }

      set content(value) {
        this.state.content = value;

        if (this.state.inDOM) {
          this.setContentManually();
        }
      }

      get content() {
        return this.state.content || '';
      }

      get align() {
        return this.state.align || DEFAULT_ALIGN;
      }

      set align(value) {
        this.state.align = value;
        this.updateClassList();
      }

      get visible() {
        return this.state.visible;
      }

      set visible(value) {
        this.state.visible = value;
        this.updateClassList();
      }

      setIdManually() {
        this.divElement = this.divElement ? this.divElement : this.template.querySelector('div');
        this.divElement.setAttribute('id', this.state.contentId);
      } // manually set the content value


      setContentManually() {
        /* manipulate DOM directly */
        this.template.querySelector('.slds-popover__body').textContent = this.state.content;
      } // compute class value for this bubble


      updateClassList() {
        const classes = classSet('slds-popover').add('slds-popover_tooltip'); // show or hide bubble

        classes.add({
          'slds-rise-from-ground': this.visible,
          'slds-fall-into-ground': !this.visible
        }); // apply the proper nubbin CSS class

        const {
          horizontal,
          vertical
        } = this.align;
        classes.add({
          'slds-nubbin_top-left': horizontal === 'left' && vertical === 'top',
          'slds-nubbin_top-right': horizontal === 'right' && vertical === 'top',
          'slds-nubbin_bottom-left': horizontal === 'left' && vertical === 'bottom',
          'slds-nubbin_bottom-right': horizontal === 'right' && vertical === 'bottom',
          'slds-nubbin_bottom': horizontal === 'center' && vertical === 'bottom',
          'slds-nubbin_top': horizontal === 'center' && vertical === 'top',
          'slds-nubbin_left': horizontal === 'left' && vertical === 'center',
          'slds-nubbin_right': horizontal === 'right' && vertical === 'center'
        });
        classListMutation(this.classList, classes);
      }

      handleMouseLeave() {
        this.visible = false;
      }

    }

    lwc.registerDecorators(LightningPrimitiveBubble, {
      publicProps: {
        contentId: {
          config: 3
        },
        content: {
          config: 3
        },
        align: {
          config: 3
        },
        visible: {
          config: 3
        }
      },
      track: {
        state: 1
      },
      fields: ["divElement"]
    });

    var LightningPrimitiveBubble$1 = lwc.registerComponent(LightningPrimitiveBubble, {
      tmpl: _tmpl$5
    });

    function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$4(target, key, source[key]); }); } return target; }

    function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const BUBBLE_ID = `salesforce-lightning-tooltip-bubble_${guid()}`;

    function isResizeObserverSupported() {
      return window.ResizeObserver != null;
    }

    function buildResizeObserver(callback) {
      if (isResizeObserverSupported()) {
        return new ResizeObserver(callback);
      }

      return {
        observe() {},

        unobserve() {}

      };
    }
    /**
     * Shared instance of a primitive bubble used as a tooltip by most components. This was originally
     * defined in the helptext component which is where the minWidth style came from.
     * TODO: We may want to revisit the minWidth style with the PO and/or UX.
     */


    let CACHED_BUBBLE_ELEMENT;

    function getCachedBubbleElement() {
      if (!CACHED_BUBBLE_ELEMENT) {
        CACHED_BUBBLE_ELEMENT = lwc.createElement('lightning-primitive-bubble', {
          is: LightningPrimitiveBubble$1
        });
        CACHED_BUBBLE_ELEMENT.contentId = BUBBLE_ID;
        CACHED_BUBBLE_ELEMENT.style.position = 'absolute';
        CACHED_BUBBLE_ELEMENT.style.minWidth = '75px'; // hide bubble element on create

        CACHED_BUBBLE_ELEMENT.classList.add('slds-hide');
        CACHED_BUBBLE_ELEMENT.addEventListener('transitionend', () => {
          // W-7201022 https://gus.lightning.force.com/lightning/r/ADM_Work__c/a07B00000079kNjIAI/view
          // The tooltip uses absolute positioning and visibility gets set to hidden to
          // hide it from view which means it's still part of the document layout.
          // If we don't hide the bubble it could stay on the page and accidentally scroll pages
          // in the console app after a tab switch, especially when the tab content lengths differ.
          if (!CACHED_BUBBLE_ELEMENT.visible) {
            CACHED_BUBBLE_ELEMENT.classList.add('slds-hide');
          }
        });
      }

      return CACHED_BUBBLE_ELEMENT;
    }

    const ARIA_DESCRIBEDBY = 'aria-describedby';
    /**
     * Used as a position offset to compensate for the nubbin. The dimensions of the nubbin are not
     * included in the position library bounding box calculations. This is the size in pixels of the
     * nubbin.
     * TODO: We may want to measure this instead in cases it changes.
     */

    const NUBBIN_SIZE = 16;
    /**
     * Used in the calculation that moves the tooltip to a location that places the nubbin at the
     * center of the target element. This is the nubbin offset from the edge of the bubble in pixels
     * when using slds-nubbin_bottom-left or slds-nubbin_bottom-right.
     * TODO: We may want to measure this instead in case it changes.
     */

    const NUBBIN_OFFSET = 24;
    /**
     * Known tooltip types:
     * - info: used in cases where target already has click handlers such as button-icon
     * - toggle: used in cases where target only shows a tooltip such as helptext
     */

    const TooltipType = {
      Info: 'info',
      Toggle: 'toggle'
    };
    /**
     * Allows us to attach a tooltip to components. Typical usage is as follows:
     * - Create an instance of Tooltip
     * - Call Tooltip.initialize() to add the appropriate listeners to the element that needs a tooltip
     * See buttonIcon and buttonMenu for example usage.
     */

    class Tooltip {
      /**
       * A shared instance of primitiveBubble is used when an element is not specified in the config
       * object.
       * @param {string} value the content of the tooltip
       * @param {object} config specifies the root component, target element of the tooltip
       */
      constructor(value, config) {
        this._autoPosition = null;
        this._disabled = true;
        this._initialized = false;
        this._visible = false;
        this._config = {};
        assert(config.target, 'target for tooltip is undefined or missing');
        this.value = value;
        this._root = config.root;
        this._target = config.target;
        this._config = _objectSpread$4({}, config);
        this._config.align = config.align || {};
        this._config.targetAlign = config.targetAlign || {};
        this._type = normalizeString(config.type, {
          fallbackValue: TooltipType.Info,
          validValues: Object.values(TooltipType)
        }); // If a tooltip element is not given, fall back on the globally shared instance.

        this._element = config.element;

        if (!this._element) {
          this._element = getCachedBubbleElement;
          const bubbleElement = getCachedBubbleElement();

          if (bubbleElement.parentNode === null) {
            document.body.appendChild(bubbleElement);
          }
        }

        this.handleDocumentTouch = this.handleDocumentTouch.bind(this);
      }
      /**
       * Disables the tooltip.
       */


      detach() {
        this._disabled = true;
      }
      /**
       * Enables the tooltip.
       */


      attach() {
        this._disabled = false;
      }
      /**
       * Adds the appropriate event listeners to the target element to make the tooltip appear. Also
       * links the tooltip and target element via the aria-describedby attribute for screen readers.
       */


      initialize() {
        const target = this._target();

        if (!this._initialized && target) {
          switch (this._type) {
            case TooltipType.Toggle:
              this.addToggleListeners();
              break;

            case TooltipType.Info:
            default:
              this.addInfoListeners();
              break;
          }

          const ariaDescribedBy = normalizeAriaAttribute([target.getAttribute(ARIA_DESCRIBEDBY), this._element().contentId]);
          target.setAttribute(ARIA_DESCRIBEDBY, ariaDescribedBy);
          this._initialized = true;
        }
      }

      addInfoListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          ['mouseenter', 'focus'].forEach(name => target.addEventListener(name, () => this.show())); // Unlike the tooltip in Aura, we want clicks and keys to dismiss the tooltip.

          ['mouseleave', 'blur', 'click', 'keydown'].forEach(name => target.addEventListener(name, event => this.hideIfNotSelfCover(event)));
        }
      }

      hideIfNotSelfCover(event) {
        if (event.type === 'mouseleave' && event.clientX && event.clientY) {
          // In any chance, if mouseleave is caused by tooltip itself, it would means
          // tooltip cover the target which mostly caused by dynamic resize of tooltip by CSS or JS.
          try {
            const elementMouseIsOver = document.elementFromPoint ? document.elementFromPoint(event.clientX, event.clientY) : null;

            if (elementMouseIsOver === this._element()) {
              if (!isResizeObserverSupported()) {
                this.startPositioning();
              }

              return;
            }
          } catch (ex) {// Jest Throw Exception
          }
        }

        this.hide();
      }

      handleDocumentTouch() {
        if (this._visible) {
          this.hide();
        }
      }

      addToggleListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          target.addEventListener('touchstart', e => {
            e.stopPropagation();
            this.toggle();
          });
          ['mouseenter', 'focus'].forEach(name => target.addEventListener(name, () => this.show()));
          ['mouseleave', 'blur'].forEach(name => target.addEventListener(name, event => this.hideIfNotSelfCover(event)));
        }
      }

      get resizeObserver() {
        if (!this._resizeObserver) {
          this._resizeObserver = buildResizeObserver(() => {
            if (this._visible && this._autoPosition) {
              this.startPositioning();
            }
          });
        }

        return this._resizeObserver;
      }

      show() {
        if (this._disabled) {
          return;
        }

        this._visible = true;

        const tooltip = this._element();
        /* We only change the visibility of the cached bubble element here,
           for custom bubble elements, we expect them to react to `visible`
           property change */


        if (CACHED_BUBBLE_ELEMENT) {
          // Show cached bubble element
          CACHED_BUBBLE_ELEMENT.classList.remove('slds-hide');
        }

        tooltip.content = this._value;
        this.startPositioning();
        document.addEventListener('touchstart', this.handleDocumentTouch);
        this.resizeObserver.observe(tooltip);
      }

      hide() {
        this._visible = false;

        const tooltip = this._element();

        tooltip.visible = this._visible;
        this.stopPositioning();
        document.removeEventListener('touchstart', this.handleDocumentTouch);
        this.resizeObserver.unobserve(tooltip);
      }

      toggle() {
        if (this._visible) {
          this.hide();
        } else {
          this.show();
        }
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
        this._disabled = !value;
      }

      get initialized() {
        return this._initialized;
      }

      get visible() {
        return this._visible;
      }

      startPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this._root);
        } // The lightning-helptext component was originally left aligned.


        const align = {
          horizontal: this._config.align.horizontal || Direction.Left,
          vertical: this._config.align.vertical || Direction.Bottom
        };
        const targetAlign = {
          horizontal: this._config.targetAlign.horizontal || Direction.Left,
          vertical: this._config.targetAlign.vertical || Direction.Top
        }; // Pads the tooltip so its nubbin is at the center of the target element.

        const targetBox = this._target().getBoundingClientRect();

        const padLeft = targetBox.width * 0.5 - NUBBIN_OFFSET;

        this._autoPosition.start({
          target: this._target,
          element: this._element,
          align,
          targetAlign,
          autoFlip: true,
          padTop: NUBBIN_SIZE,
          padLeft
        }).then(autoPositionUpdater => {
          // The calculation above may have flipped the alignment of the tooltip. When the
          // tooltip changes alignment we need to update the nubbin class to have it draw in
          // the appropriate place.
          if (autoPositionUpdater) {
            const tooltip = this._element();

            tooltip.align = autoPositionUpdater.config.align;
            tooltip.visible = this._visible;
          }
        });
      }

      stopPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

    }

    lwc.registerDecorators(Tooltip, {
      fields: ["_autoPosition", "_disabled", "_initialized", "_visible", "_config"]
    });

    const i18n = {
      buttonAlternativeText: labelButtonAlternativeText
    };
    const DEFAULT_ICON_NAME = 'utility:info';
    const DEFAULT_ICON_VARIANT = 'bare';
    /**
     * An icon with a text popover used for tooltips.
     */

    class LightningHelptext extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          iconName: DEFAULT_ICON_NAME,
          iconVariant: DEFAULT_ICON_VARIANT
        };
        this._tooltip = null;
      }

      /**
       * Text to be shown in the popover.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      set content(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button'),
            type: TooltipType.Toggle
          });

          this._tooltip.initialize();
        }
      }

      get content() {
        return this._tooltip ? this._tooltip.value : undefined;
      }
      /**
       * The Lightning Design System name of the icon used as the visible element.
       * Names are written in the format 'utility:info' where 'utility' is the category,
       * and 'info' is the specific icon to be displayed.
       * The default is 'utility:info'.
       * @type {string}
       * @param {string} value the icon name to use
       * @default utility:info
       */


      set iconName(value) {
        this.state.iconName = value;
      }

      get iconName() {
        if (isValidName(this.state.iconName)) {
          return this.state.iconName;
        }

        return DEFAULT_ICON_NAME;
      }
      /**
       * Changes the appearance of the icon.
       * Accepted variants include inverse, warning, error.
       * @type {string}
       * @param {string} value the icon variant to use
       * @default bare
       */


      set iconVariant(value) {
        this.state.iconVariant = value;
      }

      get iconVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.state.iconVariant, {
          fallbackValue: DEFAULT_ICON_VARIANT,
          validValues: ['bare', 'error', 'inverse', 'warning']
        });
      }

      disconnectedCallback() {
        // W-6441609 helptext maybe destroyed first, and tooltip won't receive events to hide.
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.hide();
        }

        this._tooltip = null;
      }

      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      get i18n() {
        return i18n;
      } // compute SVG CSS classes to apply to the icon


      get computedSvgClass() {
        const classes = classSet('slds-button__icon');

        switch (this.iconVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            classes.add('slds-icon-text-default');
        }

        return classes.toString();
      }

    }

    lwc.registerDecorators(LightningHelptext, {
      publicProps: {
        content: {
          config: 3
        },
        iconName: {
          config: 3
        },
        iconVariant: {
          config: 3
        }
      },
      track: {
        state: 1
      },
      fields: ["_tooltip"]
    });

    var _lightningHelptext = lwc.registerComponent(LightningHelptext, {
      tmpl: _tmpl$4
    });

    function stylesheet$2(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n[dir=\"rtl\"] input[type=\"tel\"]" + shadowSelector + " {direction: ltr;text-align: right;unicode-bidi: embed;}\n";
    }
    var _implicitStylesheets$2 = [stylesheet$2];

    function stylesheet$3(hostSelector, shadowSelector, nativeShadow) {
      return "slot" + shadowSelector + " {display: inline-block;}\n";
    }
    var _implicitStylesheets$3 = [stylesheet$3];

    function tmpl$5($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot
      } = $api;
      return [api_slot("", {
        key: 0
      }, [], $slotset)];
    }

    var _tmpl$6 = lwc.registerTemplate(tmpl$5);
    tmpl$5.slots = [""];
    tmpl$5.stylesheets = [];

    if (_implicitStylesheets$3) {
      tmpl$5.stylesheets.push.apply(tmpl$5.stylesheets, _implicitStylesheets$3);
    }
    tmpl$5.stylesheetTokens = {
      hostAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone-host",
      shadowAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone"
    };

    class LightningPrimitiveFileDroppableZone extends lwc.LightningElement {
      get disabled() {
        return this._disabled || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple || false;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      constructor() {
        super();
        this._disabled = void 0;
        this._multiple = void 0;
        this.template.addEventListener('dragover', this.allowDrop.bind(this));
        this.template.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.template.addEventListener('drop', this.handleOnDrop.bind(this));
      }

      connectedCallback() {
        this.classList.add('slds-file-selector__dropzone');
      }

      setDragOver(dragOver) {
        this.classList.toggle('slds-has-drag-over', dragOver);
      }

      handleDragLeave() {
        this.setDragOver(false);
      }

      handleOnDrop(event) {
        event.preventDefault();
        this.setDragOver(false);

        if (this.disabled) {
          event.stopPropagation();
          return;
        }

        if (!this.meetsMultipleCriteria(event)) {
          event.stopPropagation();
        }
      }

      allowDrop(event) {
        event.preventDefault();

        if (!this.disabled) {
          this.setDragOver(true);
        }
      }

      meetsMultipleCriteria(dragEvent) {
        const files = dragEvent.dataTransfer.files;
        return !(files.length > 1 && !this.multiple);
      }

    }

    lwc.registerDecorators(LightningPrimitiveFileDroppableZone, {
      publicProps: {
        disabled: {
          config: 3
        },
        multiple: {
          config: 3
        }
      },
      track: {
        _disabled: 1,
        _multiple: 1
      }
    });

    var _lightningPrimitiveFileDroppableZone = lwc.registerComponent(LightningPrimitiveFileDroppableZone, {
      tmpl: _tmpl$6
    });

    function tmpl$6($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-color-picker__custom": true
        },
        key: 31
      }, [api_element("p", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("color-picker-instructions")
        },
        key: 0
      }, [api_dynamic($cmp.i18n.colorPickerInstructions)]), api_element("div", {
        classMap: {
          "slds-m-bottom_small": true
        },
        style: $cmp.gradientStyle,
        attrs: {
          "data-id": "color-gradient"
        },
        key: 4,
        on: {
          "mousedown": _m3 || ($ctx._m3 = api_bind($cmp.handleMouseDown))
        }
      }, [api_element("canvas", {
        attrs: {
          "width": $cmp.canvasRect.x,
          "height": $cmp.canvasRect.y
        },
        key: 1
      }, []), api_element("a", {
        classMap: {
          "slds-color-picker__range-indicator": true
        },
        styleMap: {
          "position": "absolute",
          "display": "inline"
        },
        attrs: {
          "data-id": "color-anchor",
          "href": "javascript:void(0)",
          "aria-live": "assertive",
          "aria-atomic": "true",
          "aria-describedby": `${api_scoped_id("color-picker-instructions")}`
        },
        key: 3,
        on: {
          "mousedrag": _m0 || ($ctx._m0 = api_bind($cmp.handlePreventDefault)),
          "mousedown": _m1 || ($ctx._m1 = api_bind($cmp.handlePreventDefault)),
          "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 2
      }, [api_dynamic($cmp.computedSaturationAndBrightness)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__hue-and-preview": true
        },
        key: 9
      }, [api_element("label", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "for": `${api_scoped_id("rainbow")}`
        },
        key: 5
      }, [api_dynamic($cmp.i18n.hueInput)]), api_element("input", {
        classMap: {
          "slds-color-picker__hue-slider": true
        },
        attrs: {
          "data-id": "hue-slider",
          "type": "range",
          "min": "0",
          "max": "360",
          "id": api_scoped_id("rainbow")
        },
        props: {
          "value": $cmp._hueValue
        },
        key: 6,
        on: {
          "mousedown": _m4 || ($ctx._m4 = api_bind($cmp.handleDrag)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.onChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.thumbnailStyle,
        attrs: {
          "data-id": "color-preview"
        },
        key: 8
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 7
      }, [api_dynamic($cmp._hex)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__custom-inputs": true
        },
        key: 29
      }, [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__input-custom-hex": true
        },
        key: 13
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 10
      }, [api_dynamic($cmp.i18n.hexLabel)]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 12
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "data-primary-input": true,
          "type": "text",
          "id": api_scoped_id("input"),
          "minlength": "4",
          "maxlength": "7",
          "pattern": "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$",
          "placeholder": "#FFFFFF"
        },
        props: {
          "value": $cmp._hex
        },
        key: 11,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleHexChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 18
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("red")}`
        },
        key: 15
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.redAbbr
        },
        key: 14
      }, [api_dynamic($cmp.i18n.rInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 17
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("red"),
          "data-color-name": "red",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.red
        },
        key: 16,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("green")}`
        },
        key: 20
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.greenAbbr
        },
        key: 19
      }, [api_dynamic($cmp.i18n.gInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 22
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("green"),
          "data-color-name": "green",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.green
        },
        key: 21,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 28
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("blue")}`
        },
        key: 25
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.blueAbbr
        },
        key: 24
      }, [api_dynamic($cmp.i18n.bInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 27
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("blue"),
          "data-color-name": "blue",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.blue
        },
        key: 26,
        on: {
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleRgbChange))
        }
      }, [])])])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "aria-live": "assertive"
        },
        key: 30
      }, [api_dynamic($cmp._errorMessage)]) : null])];
    }

    var _tmpl$7 = lwc.registerTemplate(tmpl$6);
    tmpl$6.stylesheets = [];
    tmpl$6.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerCustom_colorPickerCustom-host",
      shadowAttribute: "lightning-colorPickerCustom_colorPickerCustom"
    };

    var labelBInput = 'B';

    var labelBlueAbbr = 'Blue';

    var labelColorPickerInstructions = 'Use arrow keys to select a saturation and brightness, on an x and y axis.';

    var labelErrorMessage = 'Enter a valid hexadecimal value.';

    var labelGInput = 'G';

    var labelGreenAbbr = 'Green';

    var labelHexLabel = 'Hex';

    var labelHueInput = 'Select Hue';

    var labelRInput = 'R';

    var labelRedAbbr = 'Red';

    function fullHexValue(hex) {
      if (Array.isArray(hex) && hex.length > 0) {
        hex = hex[0];
      }

      if (hex && hex.length <= 6 && hex.charAt(0) !== '#') {
        hex = '#' + hex;
      }

      const isInputValid = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);

      if (!isInputValid) {
        hex = '#000000';
      } // Converting 3 digit hex color to 6 digit hex color


      if (hex.length === 4) {
        hex = '#' + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2) + hex.charAt(3) + hex.charAt(3);
      }

      return hex;
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHexValue(hex));

      if (!result) {
        return null;
      }

      return {
        red: parseInt(result[1], 16),
        green: parseInt(result[2], 16),
        blue: parseInt(result[3], 16)
      };
    }
    function rgbToHex(rgb) {
      const r = rgb.red;
      const g = rgb.green;
      const b = rgb.blue;
      const bin = r << 16 | g << 8 | b;
      return function (hex) {
        return new Array(7 - hex.length).join('0') + hex;
      }(bin.toString(16).toUpperCase());
    }
    function rgbToHsl(rgb) {
      const r1 = rgb.red / 255;
      const g1 = rgb.green / 255;
      const b1 = rgb.blue / 255;
      const maxColor = Math.max(r1, g1, b1);
      const minColor = Math.min(r1, g1, b1); // Calculate L:

      let L = (maxColor + minColor) / 2;
      let S = 0;
      let H = 0;

      if (maxColor !== minColor) {
        // Calculate S:
        if (L < 0.5) {
          S = (maxColor - minColor) / (maxColor + minColor);
        } else {
          S = (maxColor - minColor) / (2.0 - maxColor - minColor);
        } // Calculate H:


        if (r1 === maxColor) {
          const x = g1 - b1,
                y = maxColor - minColor;
          H = x / y;
        } else if (g1 === maxColor) {
          const x = b1 - r1,
                y = maxColor - minColor,
                z = x / y;
          H = 2.0 + z;
        } else {
          const x = r1 - g1,
                y = maxColor - minColor,
                z = x / y;
          H = 4.0 + z;
        }
      }

      L *= 100;
      S *= 100;
      H *= 60;

      if (H < 0) {
        H += 360;
      }

      const result = {
        hue: H,
        saturation: S,
        lightness: L
      };
      return result;
    }
    function rgbToPosition(rgb, canvas) {
      const hsv = rgbToHsv(rgb);
      const saturation = hsv.saturation / 100,
            brightness = hsv.brightness / 100;
      const x = canvas.x * saturation;
      const y = canvas.y * (1 - brightness);
      return {
        x,
        y
      };
    }
    function rgbToHsv(rgb) {
      const r = rgb.red / 255;
      const g = rgb.green / 255;
      const b = rgb.blue / 255;
      const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
      const d = max - min,
            s = max === 0 ? 0 : d / max,
            v = max;
      let h, x, y;

      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            x = g - b;
            y = x / d;
            h = y + (g < b ? 6 : 0);
            break;

          case g:
            x = b - r;
            y = x / d;
            h = y + 2;
            break;

          case b:
            x = r - g;
            y = x / d;
            h = y + 4;
            break;
        }

        h /= 6;
      }

      const result = {
        hue: h * 360,
        saturation: s * 100,
        brightness: v * 100
      };
      return result;
    }

    const i18n$1 = {
      bInput: labelBInput,
      blueAbbr: labelBlueAbbr,
      colorPickerInstructions: labelColorPickerInstructions,
      errorMessage: labelErrorMessage,
      gInput: labelGInput,
      greenAbbr: labelGreenAbbr,
      hexLabel: labelHexLabel,
      hueInput: labelHueInput,
      rInput: labelRInput,
      redAbbr: labelRedAbbr
    };
    const CANVAS = {
      x: 198,
      y: 80
    };

    class LightningColorPickerCustom extends lwc.LightningElement {
      constructor() {
        super();
        this._hueValue = null;
        this._rgb = {
          red: '86',
          green: '121',
          blue: '192'
        };
        this._hex = '#5679C0';
        this._errorMessage = null;
        this._currentColor = null;
        this._initialized = false;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        if (!this._initialized) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            this.focus();
          });
          this.gradient();
          this.handleUpdateAnchor();
          this._initialized = true;
        }
      }

      get currentColor() {
        return this._currentColor;
      }

      set currentColor(value) {
        const fullHex = fullHexValue(value);
        this._currentColor = value;
        this._hex = fullHex;
        this._rgb = hexToRgb(fullHex);
      }

      focus() {
        this.anchorElement.focus();
      }

      get i18n() {
        return i18n$1;
      }

      get thumbnailStyle() {
        return `background: ${this._hex || 'hsl(220, 46%, 55%)'};`;
      }

      get gradientStyle() {
        return `background: ${this._hex || 'rgb(0, 85, 255)'}; position: relative;`;
      }

      get canvasRect() {
        return CANVAS;
      }

      get anchorElement() {
        return this.template.querySelector('*[data-id="color-anchor"]');
      }

      get thumbnailElement() {
        return this.template.querySelector('*[data-id="color-preview"]');
      }

      get gradientElement() {
        return this.template.querySelector('*[data-id="color-gradient"]');
      }

      get computedSaturationAndBrightness() {
        const rgb = this._rgb;
        const saturation = rgbToHsv(rgb).saturation || 0;
        const brightness = rgbToHsv(rgb).brightness || 0;
        return `Saturation: ${saturation.toFixed()}%. Brightness: ${brightness.toFixed()}%.`;
      }

      handlePreventDefault(event) {
        event.preventDefault();
      }

      selectColor(event) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: event.target.innerText
          }
        }));
      }

      handleMouseDown(event) {
        event.preventDefault();
        this.onMouseDrag(event, true);
      }

      handleDrag(event) {
        this.onMouseDrag(event, false);
      }

      onChange() {
        this.rainbowCursor();
      }

      parseAndLimit(value) {
        let out = value;

        if (!value || parseInt(value, 10) < 0 || isNaN(value)) {
          out = 0;
        } else if (parseInt(value, 10) > 255) {
          out = 255;
        }

        return out;
      }

      handleRgbChange(event) {
        const target = event.currentTarget;
        const value = this.parseAndLimit(target.value); // Fix for no rerender on second bad value attempt

        target.value = value;
        const color = target.getAttribute('data-color-name');

        if (color === 'red') {
          this._rgb.red = value;
        } else if (color === 'green') {
          this._rgb.green = value;
        } else if (color === 'blue') {
          this._rgb.blue = value;
        }

        const rgb = this._rgb;
        const hue = rgbToHsl(rgb).hue;
        const position = this.rgbToPosition(rgb);
        const selectedColor = `#${rgbToHex(rgb)}`;
        this.updateRainbow(hue);
        this.setCanvasColor(hue);
        this.setCanvasCursor(position.x, position.y);
        this.updateSelectedColor(selectedColor);
      }

      handleHexChange(event) {
        const isInputValid = event.srcElement.validity.valid;

        if (isInputValid) {
          const selectedColor = fullHexValue(event.target.value);
          this.classList.remove('slds-has-error');
          this._errorMessage = null;
          const rgb = hexToRgb(selectedColor);
          this._rgb = rgb;
          const hue = rgbToHsl(rgb).hue;
          const position = this.rgbToPosition(rgb);
          this.updateRainbow(hue);
          this.setCanvasColor(hue);
          this.setCanvasCursor(position.x, position.y);
          this.updateSelectedColor(selectedColor);
        } else {
          event.srcElement.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(event.srcElement.validity, {
            patternMismatch: this.i18n.errorMessage
          });
        }
      }

      updateSelectedColor(selectedColor) {
        this.template.querySelector(`[data-primary-input]`).classList.remove('slds-has-error');
        this._errorMessage = null;
        this._hex = selectedColor;
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updateselectedcolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: selectedColor
          }
        }));
      }

      onMouseDrag(event, isGradientCursor) {
        const that = this;
        let drag = false;

        if (isGradientCursor) {
          this.getColorFromGradient(event);
        } else {
          this.rainbowCursor();
        }

        if (this._mousedown && this._mousemove && this._mouseup) {
          return;
        }

        that._mousedown = function () {
          drag = true;
          this._cursorActive = true;
        };

        that._mouseup = function () {
          drag = false;
          this._cursorActive = false;
          window.removeEventListener('mousedown', that._mousedown);
          window.removeEventListener('mouseup', that._mouseup);
          window.removeEventListener('mousemove', that._mousemove);
          that._mousedown = null;
          that._mouseup = null;
          that._mousemove = null;
        };

        that._mousemove = function (evt) {
          if (drag && isGradientCursor) {
            that.getColorFromGradient(evt);
          } else if (drag) {
            that.rainbowCursor();
          }
        };

        window.addEventListener('mousedown', that._mousedown);
        window.addEventListener('mouseup', that._mouseup);
        window.addEventListener('mousemove', that._mousemove);
      }

      gradient() {
        const hue = rgbToHsl(this._rgb).hue;
        this.canvasContext();
        this.setCanvasColor(hue);
        this.updateRainbow(hue);
      }

      getColorFromGradient(event) {
        let cursorPosition;

        if (event.type === 'keydown' && event.key !== 'Tab') {
          cursorPosition = this.gradientCursorPositionFromKeydown(event);
        } else if (event.type === 'mousedown' || event.type === 'mousemove') {
          cursorPosition = this.gradientCursorPosition(event);
        } else {
          return;
        }

        const x = cursorPosition.x;
        const y = cursorPosition.y; // Get the current HUE value and update the canvas & cursor

        this.setCanvasColor(this._hueValue); // set color from gradient

        this.setRGBValues(x, y);
      }

      rainbowCursor() {
        const rainbow = this.template.querySelector('*[data-id="hue-slider"]');
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        this.setCanvasColor(rainbow.value);
        this.setRGBValues(position.x, position.y);
        this.updateRainbow(rainbow.value);
      }

      updateRainbow(hue) {
        this._hueValue = hue;
      }

      handleUpdateAnchor() {
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        const x = position.x - offset + 5;
        const y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      gradientCursorPosition(event) {
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        let x = event.clientX - gradientCanvas.left;
        let y = event.clientY - gradientCanvas.top;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      gradientCursorPositionFromKeydown(event) {
        event.preventDefault();
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        const keyCode = event.keyCode;
        let x, y;

        if (!this._cachePosition) {
          this._cachePosition = this.rgbToPosition(this._rgb);
        }

        const positionMap = {};
        positionMap[keyCodes.left] = {
          x: -1,
          y: 0
        };
        positionMap[keyCodes.up] = {
          x: 0,
          y: -1
        };
        positionMap[keyCodes.right] = {
          x: +1,
          y: 0
        };
        positionMap[keyCodes.down] = {
          x: 0,
          y: +1
        };
        const transform = positionMap[keyCode] ? positionMap[keyCode] : {
          x: 0,
          y: 0
        };
        x = this._cachePosition.x + transform.x;
        y = this._cachePosition.y + transform.y;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      setRGBValues(x, y) {
        const ctx = this._canvasCtx;
        const imageData = ctx.getImageData(x, y, 1, 1).data;
        const rgb = {
          red: imageData[0],
          green: imageData[1],
          blue: imageData[2]
        };
        const color = `#${rgbToHex(rgb)}`;
        this._rgb = rgb;
        this.updateSelectedColor(color);
        this.handleUpdateAnchor();
      }

      setCanvasColor(hue) {
        const ctx = this._canvasCtx; // don't map the gradient onto extreme left and right to make extremes have their max values

        const white = ctx.createLinearGradient(1, 0, this.canvasRect.x - 1, 0);
        white.addColorStop(0, 'rgb(255,255,255)');
        white.addColorStop(1, 'hsl(' + hue + ', 100%, 50%)');
        ctx.fillStyle = white;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y); // starting y is the first line to avoid blending the black into the hue, thus
        // making extreme values unselectable

        const black = ctx.createLinearGradient(0, 1, 0, this.canvasRect.y);
        black.addColorStop(0, 'rgba(0,0,0,0)');
        black.addColorStop(1, 'rgb(0,0,0)');
        ctx.fillStyle = black;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y);
      }

      setCanvasCursor(x, y) {
        const position = {
          x,
          y
        };
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        x = position.x - offset + 5;
        y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      canvasContext() {
        this._canvas = this.template.querySelector('canvas');
        this._canvasCtx = this._canvas.getContext('2d');
        this._cursorActive = false;
      }

      handleKeydown(event) {
        this.getColorFromGradient(event);
      }

      rgbToPosition(rgb) {
        return rgbToPosition(rgb, this.canvasRect);
      }

    }

    lwc.registerDecorators(LightningColorPickerCustom, {
      publicProps: {
        currentColor: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _hueValue: 1,
        _rgb: 1,
        _hex: 1,
        _errorMessage: 1,
        _currentColor: 1
      },
      fields: ["_initialized"]
    });

    var _lightningColorPickerCustom = lwc.registerComponent(LightningColorPickerCustom, {
      tmpl: _tmpl$7
    });

    function tmpl$7($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        h: api_element,
        d: api_dynamic,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("section", {
        classMap: {
          "slds-popover": true,
          "slds-color-picker__selector": true,
          "slds-show": true,
          "slds-is-absolute": true
        },
        attrs: {
          "role": "dialog",
          "aria-label": "Choose a color",
          "aria-describedby": `${api_scoped_id("dialog-body-id")}`
        },
        key: 6,
        on: {
          "updateselectedcolor": _m2 || ($ctx._m2 = api_bind($cmp.handleUpdateSelectedColor)),
          "keydown": _m3 || ($ctx._m3 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        attrs: {
          "id": api_scoped_id("dialog-body-id")
        },
        key: 1
      }, [api_custom_element("lightning-color-picker-custom", _lightningColorPickerCustom, {
        props: {
          "currentColor": $cmp.currentColor
        },
        key: 0
      }, [])]), api_element("footer", {
        classMap: {
          "slds-popover__footer": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-color-picker__selector-footer": true
        },
        key: 4
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_neutral": true
        },
        attrs: {
          "name": "cancel"
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCancelClick))
        }
      }, [api_dynamic($cmp.i18n.cancelButton)]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true
        },
        attrs: {
          "name": "done"
        },
        key: 3,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleDoneClick))
        }
      }, [api_dynamic($cmp.i18n.doneButton)])])])])];
    }

    var _tmpl$8 = lwc.registerTemplate(tmpl$7);
    tmpl$7.stylesheets = [];
    tmpl$7.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerPanel_colorPickerPanel-host",
      shadowAttribute: "lightning-colorPickerPanel_colorPickerPanel"
    };

    var labelCancelButton = 'Cancel';

    var labelCustomTab = 'Custom';

    var labelDefaultTab = 'Default';

    var labelDoneButton = 'Done';

    const i18n$2 = {
      cancelButton: labelCancelButton,
      customTab: labelCustomTab,
      defaultTab: labelDefaultTab,
      doneButton: labelDoneButton
    };
    const DEFAULT_COLOR = '#000000';

    class LightningColorPickerPanel extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.currentColor = void 0;
        this._isCustomTabActive = false;
        this._selectedColor = null;
      }

      connectedCallback() {
        this._selectedColor = this.currentColor || DEFAULT_COLOR;
      }

      get i18n() {
        return i18n$2;
      }

      get computedClassDefault() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': !this._isCustomTabActive
        }).toString();
      }

      get computedClassCustom() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': this._isCustomTabActive
        }).toString();
      }

      get ariaSelectedDefault() {
        return !this._isCustomTabActive.toString();
      }

      get ariaSelectedCustom() {
        return this._isCustomTabActive.toString();
      }

      handleTabChange(event) {
        event.preventDefault();
        const tabElement = event.currentTarget;

        if (tabElement.classList.contains('slds-is-active')) {
          return;
        }

        this._isCustomTabActive = tabElement.title !== i18n$2.defaultTab;
      }

      handleUpdateSelectedColor(event) {
        this._selectedColor = event.detail.color;
      }

      dispatchUpdateColorEventWithColor(color) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          composed: true,
          bubbles: true,
          detail: {
            color
          }
        }));
      }

      handleDoneClick() {
        this.dispatchUpdateColorEventWithColor(this._selectedColor);
      }

      handleCancelClick() {
        this.dispatchUpdateColorEventWithColor(this.currentColor);
      }

      handleKeydown(event) {
        if (event.keyCode === keyCodes.escape) {
          event.preventDefault();
          this.dispatchUpdateColorEventWithColor(this.currentColor);
        } else if (event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.dataset.id === 'color-anchor') {
          event.preventDefault();
          this.template.querySelector('button[name="done"]').focus();
        } else if (!event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.name === 'done') {
          event.preventDefault();
          this.template.querySelector('lightning-color-picker-custom').focus();
        }
      }

    }

    lwc.registerDecorators(LightningColorPickerPanel, {
      publicProps: {
        currentColor: {
          config: 0
        }
      },
      track: {
        _isCustomTabActive: 1,
        _selectedColor: 1
      }
    });

    var _lightningColorPickerPanel = lwc.registerComponent(LightningColorPickerPanel, {
      tmpl: _tmpl$8
    });

    function tmpl$8($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-color-picker__summary-button": true,
          "slds-button_icon": true,
          "slds-button_icon-more": true
        },
        attrs: {
          "type": "button"
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 4,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleColorPickerToggleClick))
        }
      }, [api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.colorInputStyle,
        attrs: {
          "data-id": "thumbnail"
        },
        key: 1
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 0
      }, [api_dynamic($cmp.i18n.a11yTriggerText)])]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:down",
          "svgClass": "slds-button__icon slds-button__icon_small",
          "variant": "bare"
        },
        key: 2
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true,
          "a11y-color-value": true
        },
        key: 3
      }, [api_dynamic($cmp.value)])]), $cmp._isColorPickerPanelOpen ? api_custom_element("lightning-color-picker-panel", _lightningColorPickerPanel, {
        classMap: {
          "color-picker-panel": true
        },
        props: {
          "currentColor": $cmp.value
        },
        key: 5,
        on: {
          "updatecolor": _m1 || ($ctx._m1 = api_bind($cmp.handleUpdateColorEvent))
        }
      }, []) : null];
    }

    var _tmpl$9 = lwc.registerTemplate(tmpl$8);
    tmpl$8.stylesheets = [];
    tmpl$8.stylesheetTokens = {
      hostAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton-host",
      shadowAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton"
    };

    var labelA11yTriggerText = 'Choose a color. Current color: ';

    const i18n$3 = {
      a11yTriggerText: labelA11yTriggerText
    };

    class PrimitiveColorpickerButton extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._isColorPickerPanelOpen = false;
        this._value = '';
        this._disabled = false;
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      focus() {
        const button = this.template.querySelector('button');
        return button && button.focus();
      }

      blur() {
        const button = this.template.querySelector('button');
        return button && button.blur();
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      handleColorPickerToggleClick(event) {
        event.preventDefault();
        this._isColorPickerPanelOpen = !this._isColorPickerPanelOpen;

        if (this._isColorPickerPanelOpen) {
          this.startColorPickerPositioning();
        } else {
          this.stopColorPickerPositioning();
        }
      }

      startColorPickerPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('button.slds-color-picker__summary-button'),
          element: () => this.template.querySelector('lightning-color-picker-panel').shadowRoot.querySelector('section'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true
        });
      }

      stopColorPickerPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      handleUpdateColorEvent(event) {
        event.stopPropagation();
        const detail = event.detail;
        this._isColorPickerPanelOpen = false;
        this.stopColorPickerPositioning();
        this.dispatchEvent(new CustomEvent('change', {
          detail
        }));
      }

      get i18n() {
        return i18n$3;
      }

    }

    PrimitiveColorpickerButton.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveColorpickerButton, {
      publicProps: {
        value: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur"],
      track: {
        _isColorPickerPanelOpen: 1,
        _value: 1,
        _disabled: 1
      }
    });

    var _lightningPrimitiveColorpickerButton = lwc.registerComponent(PrimitiveColorpickerButton, {
      tmpl: _tmpl$9
    });

    function tmpl$9($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "title": $cmp.computedTitle,
          "accesskey": $cmp.computedAccessKey,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-label": $cmp.computedAriaLabel,
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 0
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.alternativeText)]) : null])];
    }

    var _tmpl$a = lwc.registerTemplate(tmpl$9);
    tmpl$9.stylesheets = [];
    tmpl$9.stylesheetTokens = {
      hostAttribute: "lightning-buttonIcon_buttonIcon-host",
      shadowAttribute: "lightning-buttonIcon_buttonIcon"
    };

    function tmpl$a($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$b = lwc.registerTemplate(tmpl$a);
    tmpl$a.stylesheets = [];
    tmpl$a.stylesheetTokens = {
      hostAttribute: "lightning-primitiveButton_primitiveButton-host",
      shadowAttribute: "lightning-primitiveButton_primitiveButton"
    };

    const ARIA_DESCRIBEDBY$1 = 'aria-describedby';
    const ARIA_CONTROLS = 'aria-controls';
    /**
     * Primitive for button, buttonIcon and buttonIconStateful
     */

    class LightningPrimitiveButton extends lwc.LightningElement {
      /**
       * Specifies whether this button should be displayed in a disabled state.
       * Disabled buttons can't be clicked. This value defaults to false.
       *
       * @type {boolean}
       * @default false
       */
      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        this.state.disabled = normalizeBoolean(value);
      }

      set accessKey(value) {
        this.state.accesskey = value;
      }
      /**
       * Specifies a shortcut key to activate or focus an element.
       *
       * @type {string}
       */


      get accessKey() {
        return this.state.accesskey;
      }

      get computedAccessKey() {
        return this.state.accesskey;
      }
      /**
       * Displays tooltip text when the mouse cursor moves over the element.
       *
       * @type {string}
       */


      get title() {
        return this.state.title;
      }

      set title(value) {
        this.state.title = value;
      }
      /**
       * Label describing the button to assistive technologies.
       *
       * @type {string}
       */


      get ariaLabel() {
        return this.state.ariaLabel;
      }

      set ariaLabel(value) {
        this.state.ariaLabel = value;
      }

      get computedAriaLabel() {
        return this.state.ariaLabel;
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the button.
       *
       * @type {string}
       */


      get ariaDescribedBy() {
        return this.state.ariaDescribedBy;
      }

      set ariaDescribedBy(value) {
        this.state.ariaDescribedBy = value;
        const button = this.template.querySelector('button');
        synchronizeAttrs(button, {
          [ARIA_DESCRIBEDBY$1]: value
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by this button.
       *
       * @type {string}
       */


      get ariaControls() {
        return this.state.ariaControls;
      }

      set ariaControls(value) {
        this.state.ariaControls = value;
        const button = this.template.querySelector('button');
        synchronizeAttrs(button, {
          [ARIA_CONTROLS]: value
        });
      }
      /**
       * Indicates whether an element that the button controls is expanded or collapsed.
       * Valid values are 'true' or 'false'. The default value is undefined.
       *
       * @type {string}
       * @default undefined
       */


      get ariaExpanded() {
        return this.state.ariaExpanded;
      }

      set ariaExpanded(value) {
        this.state.ariaExpanded = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaExpanded() {
        return this.state.ariaExpanded || null;
      }

      set ariaLive(value) {
        this.state.ariaLive = value;
      }
      /**
       * Indicates that the button can be updated when it doesn't have focus.
       * Valid values are 'polite', 'assertive', or 'off'. The polite value causes assistive
       * technologies to notify users of updates at a low priority, generally without interrupting.
       * The assertive value causes assistive technologies to notify users immediately,
       * potentially clearing queued speech updates.
       *
       * @type {string}
       */


      get ariaLive() {
        return this.state.ariaLive;
      }

      get computedAriaLive() {
        return this.state.ariaLive;
      }
      /**
       * Indicates whether assistive technologies present all, or only parts of,
       * the changed region. Valid values are 'true' or 'false'.
       *
       * @type {string}
       */


      get ariaAtomic() {
        return this.state.ariaAtomic || null;
      }

      set ariaAtomic(value) {
        this.state.ariaAtomic = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaAtomic() {
        return this.state.ariaAtomic || null;
      }
      /**
       * Sets focus on the element.
       */


      focus() {}

      constructor() {
        super(); // Workaround for an IE11 bug where click handlers on button ancestors
        // receive the click event even if the button element has the `disabled`
        // attribute set.

        this._initialized = false;
        this.state = {
          accesskey: null,
          ariaAtomic: null,
          ariaControls: null,
          ariaDescribedBy: null,
          ariaExpanded: null,
          ariaLabel: null,
          ariaLive: null,
          disabled: false
        };

        if (isIE11) {
          this.template.addEventListener('click', event => {
            if (this.disabled) {
              event.stopImmediatePropagation();
            }
          });
        }
      }

      renderedCallback() {
        if (!this._initialized) {
          const button = this.template.querySelector('button');
          synchronizeAttrs(button, {
            [ARIA_CONTROLS]: this.state.ariaControls,
            [ARIA_DESCRIBEDBY$1]: this.state.ariaDescribedBy
          });
          this._initialized = true;
        }
      }

    }

    lwc.registerDecorators(LightningPrimitiveButton, {
      publicProps: {
        disabled: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        title: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaExpanded: {
          config: 3
        },
        ariaLive: {
          config: 3
        },
        ariaAtomic: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      },
      fields: ["_initialized"]
    });

    var LightningPrimitiveButton$1 = lwc.registerComponent(LightningPrimitiveButton, {
      tmpl: _tmpl$b
    });

    const DEFAULT_SIZE = 'medium';
    const DEFAULT_VARIANT = 'border';
    const DEFAULT_TYPE = 'button';
    /**
     * An icon-only HTML button.
     */

    class LightningButtonIcon extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.variant = DEFAULT_VARIANT;
        this.iconName = void 0;
        this.iconClass = void 0;
        this.size = DEFAULT_SIZE;
        this.type = DEFAULT_TYPE;
        this.alternativeText = void 0;
        this._order = null;
        this._tooltip = null;
      }

      // remove-next-line-for-c-namespace

      /**
       * Text to display when the user mouses over or focuses on the button.
       * The tooltip is auto-positioned relative to the button and screen space.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      set tooltip(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button')
          });

          this._tooltip.initialize();
        }
      } // remove-next-line-for-c-namespace


      get tooltip() {
        return this._tooltip ? this._tooltip.value : undefined;
      }

      // this is there because raptor currently doesnt support inheritance
      render() {
        return _tmpl$a;
      }

      get computedTitle() {
        return this.state.title || this.alternativeText || '';
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: DEFAULT_VARIANT,
          validValues: ['bare', 'brand', 'container', 'border', 'border-filled', 'bare-inverse', 'border-inverse']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: DEFAULT_TYPE,
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: DEFAULT_SIZE,
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      getVariantBase() {
        return this.normalizedVariant.split('-')[0];
      }

      getVariantModifier() {
        return this.normalizedVariant.split('-')[1] || '';
      }

      get computedButtonClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedSize) === 'bare';
        const classes = classSet('slds-button');
        classes.add('slds-button_icon');

        if (!isBare) {
          // If the variant is not bare, then size the button instead of the icon
          switch (normalizedSize) {
            case 'small':
              classes.add('slds-button_icon-small');
              break;

            case 'x-small':
              classes.add('slds-button_icon-x-small');
              break;

            case 'xx-small':
              classes.add('slds-button_icon-xx-small');
              break;

            case 'large':
              // There is no `large` modifier for buttons so we should drop down one size to `medium`
              console.warn(`<lightning-button-icon> The non-bare variants of buttonIcon do not support a size value of "large". Supported values include "xx-small", "x-small", "small", and "medium". Falling back to size value "medium".`);
          }
        }

        return classes.add({
          'slds-button_icon-bare': isBare,
          'slds-button_icon-container': normalizedVariant === 'container',
          'slds-button_icon-border': normalizedVariant === 'border',
          'slds-button_icon-border-filled': normalizedVariant === 'border-filled',
          'slds-button_icon-border-inverse': normalizedVariant === 'border-inverse',
          'slds-button_icon-inverse': normalizedVariant === 'bare-inverse',
          'slds-button_icon-brand': normalizedVariant === 'brand',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedIconClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedVariant) === 'bare';
        const iconClass = this.iconClass || '';
        const classes = classSet('slds-button__icon');
        classes.add(iconClass);

        if (isBare) {
          // If the variant is bare, then size the icon instead of the button
          switch (normalizedSize) {
            case 'large':
              classes.add('slds-button__icon_large');
              break;

            case 'small':
              classes.add('slds-button__icon_small');
              break;

            case 'xx-small':
              // There is no `xx-small` modifier for bare so we should drop down one size to `x-small`
              console.warn(`<lightning-button-icon> The bare variant of buttonIcon does not support a size value of "xx-small". Supported values include "x-small", "small", "medium", and "large". The default is "medium".`);

            /* falls through */

            case 'x-small':
              classes.add('slds-button__icon_x-small');
              break;
          }
        }

        if (this.getVariantModifier(normalizedVariant) === 'inverse') {
          classes.add('slds-button_icon-inverse');
        }

        return classes.toString();
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        if (this._connected) {
          this.template.querySelector('button').focus();
        }
      }
      /**
       * Clicks the button.
       */


      click() {
        if (this._connected) {
          this.template.querySelector('button').click();
        }
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        this._connected = true;
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      } // remove-next-line-for-c-namespace


      renderedCallback() {
        // initialize aria attributes in primitiveButton
        super.renderedCallback();

        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButtonIcon.delegatesFocus = true;

    lwc.registerDecorators(LightningButtonIcon, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconClass: {
          config: 0
        },
        size: {
          config: 0
        },
        type: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        tooltip: {
          config: 3
        }
      },
      publicMethods: ["focus", "click"],
      track: {
        _order: 1
      },
      fields: ["_tooltip"]
    });

    var _lightningButtonIcon = lwc.registerComponent(LightningButtonIcon, {
      tmpl: _tmpl$a
    });

    function stylesheet$4(hostSelector, shadowSelector, nativeShadow) {
      return "[dir=\"rtl\"] .slds-dropdown_left" + shadowSelector + " {left: 0;right: auto;}\n";
    }
    var _implicitStylesheets$4 = [stylesheet$4];

    function tmpl$b($api, $cmp, $slotset, $ctx) {
      const {
        ti: api_tab_index,
        b: api_bind,
        h: api_element,
        s: api_slot
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("div", {
        attrs: {
          "tabindex": api_tab_index($cmp._bookendTabIndex),
          "data-start": true
        },
        key: 0,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp._focusLastElement))
        }
      }, []), api_slot("", {
        key: 1,
        on: {
          "focusin": _m1 || ($ctx._m1 = api_bind($cmp._handleFocusIn)),
          "focusout": _m2 || ($ctx._m2 = api_bind($cmp._handleFocusOut))
        }
      }, [], $slotset), api_element("div", {
        attrs: {
          "tabindex": api_tab_index($cmp._bookendTabIndex),
          "data-end": true
        },
        key: 2,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp._focusFirstElement))
        }
      }, [])];
    }

    var _tmpl$c = lwc.registerTemplate(tmpl$b);
    tmpl$b.slots = [""];
    tmpl$b.stylesheets = [];
    tmpl$b.stylesheetTokens = {
      hostAttribute: "lightning-focusTrap_focusTrap-host",
      shadowAttribute: "lightning-focusTrap_focusTrap"
    };

    /**
     *
     * Returns all tabbable elements within a containing element. Tabbable elements are:
     * a visible/non-disabled element that has a tabIndex of 0 and is not within a custom
     * element with tabindex attribute of “-1" on it.
     *
     * @param {Element} container The element to search for tabbable element.
     * @returns {Array} Tabbable elements.
     */
    function findAllTabbableElements(container) {
      const result = [];
      traverseActiveTreeRecursively(container, element => {
        // Remove the try/catch once https://github.com/salesforce/lwc/issues/1421 is fixed
        try {
          if (isTabbable({
            element,
            rootContainer: container
          })) {
            result.push(element);
          }
        } catch (e) {
          console.warn(e);
        }
      });
      return result;
    }
    /**
     * Recursively traverse an active tree and run callback on each non-inert node element.
     *
     * @param {Node} node The starting node to recursively traverse.
     * @param {Function} callback Function to call on each node element.
     */

    function traverseActiveTreeRecursively(node, callback) {
      if (!node) {
        return;
      }

      if (node.nodeType === Node.ELEMENT_NODE) {
        // inert is only supported by Chrome for now (behind a flag)
        if (node.hasAttribute('inert')) {
          return;
        }

        if (isIframe(node)) {
          if (isIframeOfSameOrigin(node)) {
            // for a same-origin iframe, we don't want to include the
            // iframe itself in the list, since we can see any of the
            // frames focusable children. So, skip calling callback on
            // the iframe node, and proceed to traverse it's children.
            traverseActiveTreeRecursively(node.contentDocument, callback);
          } else {
            // a non same-origin iframe is totally opaque, so include the
            // iframe in the results, but do no try to traverse into the
            // iframes children
            if (callback) {
              callback(node);
            }
          }

          return;
        }

        if (callback) {
          callback(node);
        } // If the element has a shadow root, traverse that


        if (node.shadowRoot) {
          traverseActiveTreeRecursively(node.shadowRoot, callback);
          return;
        } // if it's a slot element, get all assigned nodes and traverse them


        if (node.localName === 'slot') {
          const slottedNodes = node.assignedNodes({
            flatten: true
          });

          for (let i = 0; i < slottedNodes.length; i++) {
            traverseActiveTreeRecursively(slottedNodes[i], callback);
          }

          return;
        }
      }

      let child = node.firstChild;

      while (child !== null) {
        traverseActiveTreeRecursively(child, callback);
        child = child.nextSibling;
      }
    } // returns true if iframe is same origin, and therefore, can focus its internal elements


    function isIframe(node) {
      return node.tagName === 'IFRAME' || node instanceof HTMLIFrameElement;
    }

    function isIframeOfSameOrigin(iframe) {
      // if we can access contentDocument (is not null) on the iframe, then it is of same origin
      return !!iframe.contentDocument;
    }

    const ELEMENTS_WITH_DISABLED_ATTRIBUTE = ['button', 'select', 'textarea', 'input']; // https://html.spec.whatwg.org/multipage/interaction.html#dom-tabindex

    const ELEMENTS_WITH_TABINDEX_ZERO_BY_DEFAULT = ['a', 'select', 'textarea', 'input', 'button', 'iframe', 'object', 'area', 'frame'];

    function isTabbable({
      element,
      rootContainer
    }) {
      const elementLocalName = element.localName;

      if (elementLocalName === 'input' && elementLocalName.type === 'hidden') {
        return false;
      }

      const tabIndexAttribute = element.getAttribute('tabindex');

      if (tabIndexAttribute === '-1') {
        return false;
      }

      if (element.disabled && ELEMENTS_WITH_DISABLED_ATTRIBUTE.includes(element.localName)) {
        return false;
      } // Either the attribute was set directly to '0' or it's an element that has tabIndex zero by default


      const hasTabIndexZero = tabIndexAttribute === '0' || element.tabIndex === 0 && ELEMENTS_WITH_TABINDEX_ZERO_BY_DEFAULT.includes(element.localName);
      return hasTabIndexZero && isElementVisible(element) && isParentCustomElementTabbable({
        element,
        rootContainer
      });
    }

    function isElementVisible(element) {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      const nonZeroSize = width > 0 || height > 0;
      return nonZeroSize && getComputedStyle(element).visibility !== 'hidden';
    }

    function isParentCustomElementTabbable({
      element,
      rootContainer
    }) {
      const parentRoot = rootContainer.getRootNode();
      const ownerDocument = element.ownerDocument;
      let root = element.getRootNode();

      while (root !== parentRoot && root !== ownerDocument) {
        const host = root.host;

        if (host.getAttribute('tabindex') === '-1') {
          return false;
        }

        root = host && host.getRootNode();
      }

      return true;
    }

    class FocusTrap extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._startNode = void 0;
        this._endNode = void 0;
        this._focused = false;
        this._initialized = false;
        this._pendingFocusOut = false;
      }

      renderedCallback() {
        if (!this._initialized) {
          this._initialized = true;
          this._startNode = this.template.querySelector('[data-start]');
          this._endNode = this.template.querySelector('[data-end]');
        }
      }
      /**
       * Focuses the first focusable element in the focus trap.
       */


      focus() {
        if (!this._focused) {
          // We could potentially add support for focusing the element that has 'autofocus' attribute on it,
          // and if none, then focus on the first element
          this._focusFirstElement();
        }
      }

      get _bookendTabIndex() {
        return this._focused ? '0' : '-1';
      }

      _handleFocusIn() {
        if (this._pendingFocusOut) {
          this._pendingFocusOut = false;
        }

        this._focused = true;
      }

      _handleFocusOut() {
        // This assumes that a focusin will be dispatched after a focusout
        this._pendingFocusOut = true; // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          if (this._pendingFocusOut) {
            this._focused = false;
          }
        });
      }
      /**
       * Focuses on the specified element location.
       * @param {String} elementLocation Could be 'first or 'last'.
       */


      _moveFocusTo(elementLocation) {
        const focusableElements = this._getFocusableElements();

        if (focusableElements.length > 0) {
          let node;

          if (elementLocation === 'last') {
            node = focusableElements[focusableElements.length - 1];
          } else if (elementLocation === 'first') {
            node = focusableElements[0];
          }

          node.focus();
        }
      }
      /**
       * Focuses the last focusable element in the focus trap.
       */


      _focusFirstElement() {
        this._moveFocusTo('first');
      }
      /**
       * Focuses the last focusable element in the focus trap.
       */


      _focusLastElement() {
        this._moveFocusTo('last');
      }
      /**
       * Returns a list of the focusable children found within the element.
       */


      _getFocusableElements() {
        return findAllTabbableElements(this.template.querySelector('slot'));
      }

    }

    lwc.registerDecorators(FocusTrap, {
      publicMethods: ["focus"],
      fields: ["_startNode", "_endNode", "_focused", "_initialized", "_pendingFocusOut"]
    });

    var _lightningFocusTrap = lwc.registerComponent(FocusTrap, {
      tmpl: _tmpl$c
    });

    function tmpl$c($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("select")}`
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-select_container": true
        },
        key: 5
      }, [api_element("select", {
        classMap: {
          "slds-select": true
        },
        attrs: {
          "id": api_scoped_id("select"),
          "name": $cmp.name,
          "size": $cmp.size,
          "accesskey": $cmp.accessKey,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        props: {
          "disabled": $cmp.disabled,
          "multiple": $cmp.multiple
        },
        key: 4,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, api_iterator($cmp.options, function (option) {
        return api_element("option", {
          attrs: {
            "value": option.value
          },
          key: api_key(3, option.value)
        }, [api_dynamic(option.label)]);
      }))])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "aria-live": "assertive"
        },
        key: 7
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$d = lwc.registerTemplate(tmpl$c);
    tmpl$c.stylesheets = [];
    tmpl$c.stylesheetTokens = {
      hostAttribute: "lightning-primitiveSelect_primitiveSelect-host",
      shadowAttribute: "lightning-primitiveSelect_primitiveSelect"
    };

    var labelRequired = 'required';

    const i18n$4 = {
      required: labelRequired
    };
    const {
      reduce: ArrayReduce
    } = Array.prototype;

    class LightningPrimitiveSelect extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._errorMessage = '';
        this._options = [];
        this._selectedValue = void 0;
        this._variant = void 0;
        this._required = false;
        this._disabled = false;
        this._multiple = false;
        this._fieldLevelHelp = void 0;
        this._size = void 0;
        this._ariaDescribedBy = void 0;
        this._tabIndex = void 0;
        this.label = void 0;
        this.name = void 0;
        this.messageWhenValueMissing = void 0;
        this.accessKey = void 0;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple;
      }

      set size(newValue) {
        this._size = newValue;
      }

      get size() {
        if (!this.multiple) {
          return null;
        }

        if (this._size === undefined) {
          return '4';
        }

        return this._size;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get disabled() {
        return this._disabled;
      }

      set value(newValue) {
        this._selectedValue = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(newValue);
        }
      }

      get value() {
        return this._selectedValue;
      }

      set options(newValue) {
        this._options = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      get options() {
        return this._options;
      }

      get tabIndex() {
        return this._tabIndex;
      }

      set tabIndex(newValue) {
        this._tabIndex = newValue;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid());
        this.connected = true;
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      renderedCallback() {
        if (this.options && this._selectedValue !== undefined) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      disconnectedCallback() {
        this.connected = false;
      }

      focus() {
        if (this.connected) {
          this.getElement.focus();
        }
      }

      blur() {
        if (this.connected) {
          this.getElement.blur();
        }
      }

      get validity() {
        const missing = !this.disabled && this.required && (this._selectedValue == null || this._selectedValue === '' || this._selectedValue.length === 0);
        return buildSyntheticValidity({
          valueMissing: missing,
          customError: this.customErrorMessage != null && this.customErrorMessage !== ''
        });
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          this.dispatchEvent(new CustomEvent('invalid', {
            cancellable: true
          }));
        }

        return isValid;
      }

      reportValidity() {
        this.showHelpMessageIfInvalid();
        return this.checkValidity();
      }

      setCustomValidity(message) {
        this.customErrorMessage = message;
      }

      showHelpMessageIfInvalid() {
        const validity = this.validity;

        if (validity.valid) {
          this._errorMessage = '';
          this.classList.remove('slds-has-error');
          this.removeAriaDescribedBy();
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(validity, {
            valueMissing: this.messageWhenValueMissing,
            customError: this.customErrorMessage
          });
          this.setAriaDescribedBy(this.computedUniqueErrorMessageElementId);
        }
      }

      get i18n() {
        return i18n$4;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get getElement() {
        return this.template.querySelector('select');
      }

      get computedUniqueErrorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        return this._ariaDescribedBy;
      }

      handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this._selectedValue = this.getSelectedOptionValues();
        this.dispatchChangeEvent();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._selectedValue
          }
        }));
      }

      selectOptionsByValue(optionValue) {
        if (this.multiple) {
          if (Array.isArray(optionValue)) {
            const options = this.template.querySelectorAll('option');
            options.forEach(option => {
              option.selected = optionValue.includes(option.value);
            });
          }
        } else {
          this.getElement.value = optionValue;
        }
      }

      getSelectedOptionValues() {
        if (this.multiple) {
          const options = this.template.querySelectorAll('option');
          return ArrayReduce.call(options, (selectedValues, option) => {
            if (option.selected) {
              selectedValues.push(option.value);
            }

            return selectedValues;
          }, []);
        }

        return this.getElement.value;
      }

      setAriaDescribedBy(val) {
        this.getElement.setAttribute('aria-describedby', val);
      }

      removeAriaDescribedBy() {
        this.getElement.removeAttribute('aria-describedby');
      }

    }

    lwc.registerDecorators(LightningPrimitiveSelect, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        multiple: {
          config: 3
        },
        size: {
          config: 3
        },
        required: {
          config: 3
        },
        disabled: {
          config: 3
        },
        value: {
          config: 3
        },
        options: {
          config: 3
        },
        tabIndex: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _errorMessage: 1,
        _options: 1,
        _selectedValue: 1,
        _variant: 1,
        _required: 1,
        _disabled: 1,
        _multiple: 1,
        _fieldLevelHelp: 1,
        _size: 1,
        _ariaDescribedBy: 1,
        _tabIndex: 1
      }
    });

    var _lightningPrimitiveSelect = lwc.registerComponent(LightningPrimitiveSelect, {
      tmpl: _tmpl$d
    });

    function tmpl$d($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-datepicker": true,
          "slds-dropdown": true,
          "slds-dropdown_left": true
        },
        attrs: {
          "aria-hidden": "false",
          "aria-label": $cmp.computedAriaLabel,
          "role": "dialog",
          "tabindex": "-1"
        },
        key: 20
      }, [api_custom_element("lightning-focus-trap", _lightningFocusTrap, {
        key: 19
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter": true,
          "slds-grid": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter_month": true,
          "slds-grid": true,
          "slds-grid_align-spread": true,
          "slds-grow": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 1
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:left",
          "variant": "container",
          "alternativeText": $cmp.i18n.previousMonth
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.goToPreviousMonth))
        }
      }, [])]), api_element("h2", {
        classMap: {
          "slds-align-middle": true
        },
        attrs: {
          "aria-atomic": "true",
          "aria-live": "assertive",
          "id": api_scoped_id("month-title"),
          "data-index": $cmp.monthIndex
        },
        key: 2
      }, [api_dynamic($cmp.computedMonthTitle)]), api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 4
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:right",
          "variant": "container",
          "alternativeText": $cmp.i18n.nextMonth
        },
        key: 3,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.goToNextMonth))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-shrink-none": true
        },
        key: 7
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.calendarYear,
          "label": $cmp.i18n.yearSelector,
          "variant": "label-hidden",
          "options": $cmp.computedYearList
        },
        key: 6,
        on: {
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleYearChange)),
          "click": _m3 || ($ctx._m3 = api_bind($cmp.handleYearSelectClick))
        }
      }, [])])]), api_element("table", {
        classMap: {
          "slds-datepicker__month": true
        },
        attrs: {
          "aria-labelledby": `${api_scoped_id("month-title")}`,
          "role": "grid"
        },
        key: 17
      }, [api_element("thead", {
        key: 12
      }, [api_element("tr", {
        attrs: {
          "id": api_scoped_id("weekdays-element")
        },
        key: 11
      }, api_iterator($cmp.computedWeekdayLabels, function (weekday) {
        return api_element("th", {
          attrs: {
            "id": api_scoped_id(weekday.fullName),
            "scope": "col"
          },
          key: api_key(10, weekday.fullName)
        }, [api_element("abbr", {
          attrs: {
            "title": weekday.fullName
          },
          key: 9
        }, [api_dynamic(weekday.shortName)])]);
      }))]), api_element("tbody", {
        key: 16,
        on: {
          "keydown": _m5 || ($ctx._m5 = api_bind($cmp.handleCalendarKeyDown))
        }
      }, api_iterator($cmp.computedMonth, function (week, index) {
        return api_element("tr", {
          key: api_key(15, week.id)
        }, api_iterator(week.days, function (day) {
          return api_element("td", {
            className: day.className,
            attrs: {
              "role": "gridcell",
              "aria-selected": day.isSelected,
              "aria-current": day.ariaCurrent,
              "tabindex": api_tab_index(day.tabIndex),
              "data-value": day.dateValue
            },
            key: api_key(14, day.dateValue)
          }, [api_element("span", {
            classMap: {
              "slds-day": true
            },
            key: 13,
            on: {
              "click": _m4 || ($ctx._m4 = api_bind($cmp.handleDateClick))
            }
          }, [api_dynamic(day.dayInMonth)])]);
        }));
      }))]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-align_absolute-center": true,
          "slds-text-link": true
        },
        attrs: {
          "name": "today",
          "type": "button"
        },
        key: 18,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleTodayClick))
        }
      }, [api_dynamic($cmp.i18n.today)])])])];
    }

    var _tmpl$e = lwc.registerTemplate(tmpl$d);
    tmpl$d.stylesheets = [];

    if (_implicitStylesheets$4) {
      tmpl$d.stylesheets.push.apply(tmpl$d.stylesheets, _implicitStylesheets$4);
    }
    tmpl$d.stylesheetTokens = {
      hostAttribute: "lightning-calendar_calendar-host",
      shadowAttribute: "lightning-calendar_calendar"
    };

    var labelAriaLabelMonth = 'Date picker: ';

    var labelNextMonth = 'Next Month';

    var labelPreviousMonth = 'Previous Month';

    var labelToday = 'Today';

    var labelYearSelector = 'Pick a Year';

    var firstDayOfWeek = '1';

    function handleKeyDownOnCalendar(event, date, calendarInterface) {
      const tdElement = event.target;
      const keyValue = normalizeKeyValue(event.key);

      switch (keyValue) {
        case 'ArrowUp':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 7);
          calendarInterface.focusDate(date);
          break;

        case 'ArrowDown':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 7);
          calendarInterface.focusDate(date);
          break;

        case 'ArrowRight':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 1);
          calendarInterface.focusDate(date);
          break;

        case 'ArrowLeft':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 1);
          calendarInterface.focusDate(date);
          break;

        case 'Enter':
        case ' ':
          preventDefaultAndStopPropagation(event);
          calendarInterface.selectDate(tdElement);
          break;

        case 'PageUp':
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() - 1);
          } else {
            date.setMonth(date.getMonth() - 1);
          }

          calendarInterface.focusDate(date);
          break;

        case 'PageDown':
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() + 1);
          } else {
            date.setMonth(date.getMonth() + 1);
          }

          calendarInterface.focusDate(date);
          break;

        case 'Home':
          {
            preventDefaultAndStopPropagation(event);
            const startOfWeek = calendarInterface.getStartOfWeek(date);
            calendarInterface.focusDate(startOfWeek);
            break;
          }

        case 'End':
          {
            preventDefaultAndStopPropagation(event);
            const endOfWeek = calendarInterface.getStartOfWeek(date);
            endOfWeek.setDate(endOfWeek.getDate() + 6);
            calendarInterface.focusDate(endOfWeek);
            break;
          }
      }
    }

    function preventDefaultAndStopPropagation(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/address.js
    // For new versions, copy AddressFormat.js from node_modules/address.js/dist/AddressFormat.js
    // And add "export { address };" at the end.

    /* eslint-disable */
    var data = {
      AE: {
        fmt: '%A%n%S%n%K',
        require: 'AS',
        input: 'ASK'
      },
      AL: {
        fmt: '%A%n%Z%n%C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      EC: {
        _ref: 'AL'
      },
      MU: {
        _ref: 'AL'
      },
      OM: {
        _ref: 'AL'
      },
      AM: {
        fmt: '%A%n%Z%n%C%n%S%n%K',
        require: 'AZCS',
        input: 'AZK'
      },
      AR: {
        fmt: '%A%n%Z %C%n%S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      CL: {
        _ref: 'AR'
      },
      CV: {
        _ref: 'AR'
      },
      MY: {
        _ref: 'AR'
      },
      UZ: {
        _ref: 'AR'
      },
      AT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      BA: {
        _ref: 'AT'
      },
      BG: {
        _ref: 'AT'
      },
      CH: {
        _ref: 'AT'
      },
      DE: {
        _ref: 'AT'
      },
      DK: {
        _ref: 'AT'
      },
      DO: {
        _ref: 'AT'
      },
      DZ: {
        _ref: 'AT'
      },
      EE: {
        _ref: 'AT'
      },
      ET: {
        _ref: 'AT'
      },
      FR: {
        _ref: 'AT'
      },
      GE: {
        _ref: 'AT'
      },
      GR: {
        _ref: 'AT'
      },
      IL: {
        _ref: 'AT'
      },
      KW: {
        _ref: 'AT'
      },
      LA: {
        _ref: 'AT'
      },
      LR: {
        _ref: 'AT'
      },
      IS: {
        _ref: 'AT'
      },
      MA: {
        _ref: 'AT'
      },
      MG: {
        _ref: 'AT'
      },
      MK: {
        _ref: 'AT'
      },
      MZ: {
        _ref: 'AT'
      },
      NL: {
        _ref: 'AT'
      },
      NO: {
        _ref: 'AT'
      },
      PL: {
        _ref: 'AT'
      },
      PT: {
        _ref: 'AT'
      },
      PY: {
        _ref: 'AT'
      },
      RO: {
        _ref: 'AT'
      },
      RS: {
        _ref: 'AT'
      },
      SK: {
        _ref: 'AT'
      },
      TJ: {
        _ref: 'AT'
      },
      TN: {
        _ref: 'AT'
      },
      TZ: {
        _ref: 'AT'
      },
      WF: {
        _ref: 'AT'
      },
      AU: {
        fmt: '%A%n%C %S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CA: {
        _ref: 'AU'
      },
      AZ: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      AF: {
        fmt: '%A%n%C%n%Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      FK: {
        _ref: 'AF'
      },
      GB: {
        fmt: '%A%n%C%n%S%n%Z%n%K',
        require: 'ACZ',
        input: 'ACSZK'
      },
      KE: {
        _ref: 'AF'
      },
      LK: {
        _ref: 'AF'
      },
      ZA: {
        _ref: 'AF'
      },
      SH: {
        _ref: 'AF'
      },
      SZ: {
        _ref: 'AF'
      },
      US: {
        fmt: '%A%n%C, %S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      BB: {
        _ref: 'US'
      },
      BS: {
        _ref: 'US'
      },
      SO: {
        _ref: 'US'
      },
      ES: {
        fmt: '%A%n%Z %C %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      IT: {
        _ref: 'ES'
      },
      UY: {
        _ref: 'ES'
      },
      ID: {
        fmt: '%A%n%C%n%S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      IE: {
        _ref: 'ID'
      },
      TH: {
        _ref: 'ID'
      },
      VN: {
        _ref: 'ID'
      },
      HU: {
        fmt: '%C%n%A%n%Z%n%K',
        require: 'CAZ',
        input: 'CAZK'
      },
      BH: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      BM: {
        _ref: 'BH'
      },
      BN: {
        _ref: 'BH'
      },
      BT: {
        _ref: 'BH'
      },
      KH: {
        _ref: 'BH'
      },
      LB: {
        _ref: 'BH'
      },
      JO: {
        _ref: 'BH'
      },
      MT: {
        _ref: 'BH'
      },
      NP: {
        _ref: 'BH'
      },
      NZ: {
        _ref: 'BH'
      },
      SA: {
        _ref: 'BH'
      },
      BD: {
        fmt: '%A%n%C - %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      BR: {
        fmt: '%A%n%C-%S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CN: {
        fmt: '%K%n%S %C%n%A%n%Z',
        require: 'CAZ',
        input: 'KSCAZ'
      },
      HK: {
        fmt: '%K%S%C%n%A%n%Z',
        require: 'CA',
        input: 'KSCAZ'
      },
      CO: {
        fmt: '%A%n%C, %S, %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CR: {
        fmt: '%A%n%S, %C%n%Z%n%K',
        require: 'ACSZ',
        input: 'ASCZK'
      },
      EG: {
        fmt: '%A%n%C%n%S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      RU: {
        _ref: 'EG'
      },
      UA: {
        _ref: 'EG'
      },
      FI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      GT: {
        fmt: '%A%n%Z-%C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      HN: {
        fmt: '%A%n%C, %S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      IQ: {
        _ref: 'HN'
      },
      HR: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      HT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      IN: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      NG: {
        _ref: 'IN'
      },
      PE: {
        _ref: 'IN'
      },
      IR: {
        fmt: '%S%n%C%n%A%n%Z%n%K',
        require: 'SCAZ',
        input: 'SCAZK'
      },
      JM: {
        fmt: '%A%n%C%n%S%n%K',
        require: 'ACS',
        input: 'ACSK'
      },
      PA: {
        _ref: 'JM'
      },
      SC: {
        _ref: 'JM'
      },
      SR: {
        _ref: 'JM'
      },
      JP: {
        // Escape non-ASCII character. Aura component test cannot parse non-ASCII string properly.
        fmt: '%K%n' + String.fromCharCode(12306) + '%Z%n%S %C%n%A',
        require: 'ZCA',
        input: 'KZSCA'
      },
      EN_JP: {
        fmt: '%A%n%C %S%n%Z %K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      KG: {
        fmt: '%Z %C%n%A%n%S%n%K',
        require: 'ZCA',
        input: 'ZCAK'
      },
      KR: {
        fmt: '%S %C%n%A%n%Z%n%K',
        require: 'SCAZ',
        input: 'SCAZK'
      },
      KY: {
        fmt: '%A%n%S %Z%n%K',
        require: 'ASZ',
        input: 'ASZK'
      },
      KZ: {
        fmt: '%Z%n%S%n%C%n%A%n%K',
        require: 'ZSCA',
        input: 'ZSCAK'
      },
      LT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      LV: {
        fmt: '%A%n%C, %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      MM: {
        _ref: 'LV'
      },
      MC: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      MD: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      MW: {
        fmt: '%A%n%C%n%K',
        require: 'AC',
        input: 'ACK'
      },
      MX: {
        fmt: '%A%n%Z %C, %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      NI: {
        fmt: '%A%n%Z%n%C, %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      PG: {
        fmt: '%A%n%C %Z %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      PH: {
        fmt: '%A, %C%n%Z %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      PK: {
        fmt: '%A%n%C-%Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      PR: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      SE: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      SG: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'AZ',
        input: 'AZK'
      },
      SI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      SV: {
        fmt: '%A%n%Z-%C%n%S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      TR: {
        fmt: '%A%n%Z %C/%S%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      TW: {
        fmt: '%K%n%Z%n%S %C%n%A',
        require: 'ZSCA',
        input: 'KZSCA'
      },
      VE: {
        fmt: '%A%n%C %Z, %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      }
    };
    var languageCodeToCountry = {
      languageCode: {
        ar: 'AE',
        af: 'ZA',
        bg: 'BG',
        bn: 'BN',
        bs: 'BA',
        ca: 'ES',
        cs: 'CZ',
        cy: 'GB',
        da: 'DK',
        de: 'DE',
        el: 'GR',
        es: 'ES',
        et: 'ET',
        eu: 'ES',
        fi: 'FI',
        fr: 'FR',
        ga: 'IE',
        gu: 'IN',
        hi: 'IN',
        hr: 'HR',
        hu: 'HU',
        hy: 'HY',
        in: 'ID',
        is: 'IS',
        it: 'IT',
        iw: 'IL',
        ja: 'JP',
        ka: 'GE',
        kn: 'IN',
        ko: 'KR',
        lb: 'LU',
        lt: 'IT',
        lv: 'LV',
        mk: 'MK',
        ml: 'IN',
        mr: 'IN',
        ms: 'MY',
        mt: 'MT',
        nl: 'NL',
        no: 'NO',
        pl: 'PL',
        pt: 'PT',
        rm: 'DE',
        ro: 'RO',
        ru: 'RU',
        sh: 'BA',
        sk: 'SK',
        sl: 'SL',
        sq: 'SQ',
        sr: 'RS',
        sv: 'SE',
        sw: 'ZA',
        ta: 'IN',
        te: 'IN',
        th: 'TH',
        tl: 'PH',
        tr: 'TR',
        uk: 'UK',
        ur: 'IN',
        vi: 'VN',
        xh: 'ZA',
        zh: 'CN',
        zu: 'ZA'
      }
    };
    /**
     * Define address format patterns.
     */

    var AddressFormatPattern = Object.freeze({
      /**
       *
       * N: Name (The formatting of names for this field is outside of the scope of the address elements.)
       * O: Organization
       * A: Address Lines (2 or 3 lines address)
       * D: District (Sub-locality): smaller than a city, and could be a neighborhood, suburb or dependent locality.
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * X: Sorting code, for example, CEDEX as used in France
       * n: newline
       */
      A: Symbol('Address Lines'),
      C: Symbol('City'),
      S: Symbol('State'),
      K: Symbol('Country'),
      Z: Symbol('Zip Code'),
      n: Symbol('New Line'),
      fromPlaceHolder: function fromPlaceHolder(placeHolder) {
        switch (placeHolder) {
          case 'A':
            return AddressFormatPattern.A;

          case 'C':
            return AddressFormatPattern.C;

          case 'S':
            return AddressFormatPattern.S;

          case 'K':
            return AddressFormatPattern.K;

          case 'Z':
            return AddressFormatPattern.Z;

          case 'n':
            return AddressFormatPattern.n;
        }

        return null;
      },
      getPlaceHolder: function getPlaceHolder(pattern) {
        switch (pattern) {
          case AddressFormatPattern.A:
            return 'A';

          case AddressFormatPattern.C:
            return 'C';

          case AddressFormatPattern.S:
            return 'S';

          case AddressFormatPattern.K:
            return 'K';

          case AddressFormatPattern.Z:
            return 'Z';

          case AddressFormatPattern.n:
            return 'n';
        }

        return null;
      },
      getData: function getData(pattern, data) {
        if (data) {
          switch (pattern) {
            case AddressFormatPattern.A:
              return data.address;

            case AddressFormatPattern.C:
              return data.city;

            case AddressFormatPattern.S:
              return data.state;

            case AddressFormatPattern.K:
              return data.country;

            case AddressFormatPattern.Z:
              return data.zipCode;

            case AddressFormatPattern.n:
              return data.newLine;
          }
        }

        return null;
      }
    });

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    /**
     * Address token types enum
     *
     * @private
     */


    var AddressTokenTypes = Object.freeze({
      DATA: Symbol('data'),
      STRING: Symbol('string'),
      NEWLINE: Symbol('newline'),
      GROUP: Symbol('group')
    });
    /**
     * AddressToken class
     *
     * @private
     */

    var AddressToken = function () {
      /**
       *
       * @param {AddressTokenTypes} type
       * @param {string} string
       * @param {*} pattern
       */
      function AddressToken(type, string, pattern) {
        classCallCheck(this, AddressToken);
        this.type = type;
        this.string = string;
        this.pattern = pattern;
      }
      /**
       * Construct a string type token
       *
       * @param {string} string String
       * @return {AddressToken} Address Token
       */


      createClass(AddressToken, null, [{
        key: 'string',
        value: function string(_string) {
          return new AddressToken(AddressTokenTypes.STRING, _string);
        }
        /**
         * Construct a data type token
         *
         * @param {pattern} pattern Address Format Pattern
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'data',
        value: function data(pattern) {
          return new AddressToken(AddressTokenTypes.DATA, undefined, pattern);
        }
        /**
         * Construct a new line type token
         *
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'newLine',
        value: function newLine() {
          return new AddressToken(AddressTokenTypes.NEWLINE);
        }
      }]);
      return AddressToken;
    }();
    /**
     * TokenizerState class
     *
     * @private
     */


    var TokenizerState =
    /**
     * Constructor
     *
     * @param {string} pattern
     * @param {int} start
     */
    function TokenizerState(pattern, start) {
      classCallCheck(this, TokenizerState);
      this.pattern = pattern;
      this.start = start;
    };
    /**
     * Tokenize string pattern to AddressToken array
     *
     * @param {TokenizerState} state
     * @param {AddressToken[]} tokens
     * @return {TokenizerState} Tokenizer state
     *
     * @private
     */


    function tokenize(state, tokens) {
      var nextIndex = state.start;

      if (state.pattern) {
        var len = state.pattern.length;

        while (state.start < len) {
          nextIndex = state.pattern.indexOf('%', nextIndex);

          if (nextIndex >= 0 && nextIndex + 1 < len) {
            var placeHolder = state.pattern.substring(nextIndex + 1, nextIndex + 2);

            switch (placeHolder) {
              case 'n':
                {
                  if (nextIndex - state.start > 0) {
                    tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                  }

                  tokens.push(AddressToken.newLine());
                  state.start = nextIndex + 2;
                  nextIndex = state.start;
                  break;
                }

              default:
                {
                  var p = AddressFormatPattern.fromPlaceHolder(placeHolder);

                  if (p) {
                    if (nextIndex - state.start > 0) {
                      tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                    }

                    tokens.push(AddressToken.data(p));
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  } else {
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  }

                  break;
                }
            }
          } else {
            if (state.start < len) {
              tokens.push(AddressToken.string(state.pattern.substring(state.start)));
            }

            state.start = len;
          }
        }
      }

      return state;
    }
    /**
     * Format line from tokens
     *
     * @param {*} tokens
     * @param {*} data
     * @param {*} ignoreEmptyLines
     * @param {*} firstIndex
     * @param {*} lastIndex
     * @return {string} Formatted line
     *
     * @private
     */


    function formatLineTokens(tokens, data, ignoreEmptyLines, firstIndex, lastIndex) {
      var parts = [];

      for (var index = firstIndex; index <= lastIndex; index++) {
        var token = tokens[index];

        if (!token) {
          continue;
        } else if (token.type == AddressTokenTypes.DATA) {
          // Consume all subsequent data if available
          var dataBuffer = '';
          var lastDataIndex = index;

          for (var dataIndex = index; dataIndex <= lastIndex; dataIndex++) {
            var dataToken = tokens[dataIndex];

            if (!dataToken || dataToken.type != AddressTokenTypes.DATA) {
              break;
            }

            var fieldData = AddressFormatPattern.getData(dataToken.pattern, data);

            if (fieldData) {
              dataBuffer += fieldData;
              lastDataIndex = dataIndex;
            }
          }

          var hasData = dataBuffer && dataBuffer.length > 0; // Output previous string only if there is data before it,
          // or if it is the first on the line

          var hasPreviousData = false;

          if (index - 1 >= firstIndex) {
            var stringToken = tokens[index - 1];

            if (stringToken && stringToken.type == AddressTokenTypes.STRING && stringToken.string) {
              for (var prevIndex = index - 2; prevIndex >= firstIndex; prevIndex--) {
                var prevToken = tokens[prevIndex];

                if (prevToken && prevToken.type == AddressTokenTypes.DATA) {
                  var _fieldData = AddressFormatPattern.getData(prevToken.pattern, data);

                  if (_fieldData) {
                    hasPreviousData = true;
                    break;
                  }
                } else if (prevToken && prevToken.type == AddressTokenTypes.STRING) {
                  // ie. for "%C, %S %Z" without S -> "City, 95100"
                  // Comment this if we want "City 95100" instead
                  // (use the separator between S Z instead of C S)
                  stringToken = prevToken;
                }
              }

              if (!ignoreEmptyLines || hasPreviousData && hasData || index - 1 == firstIndex && hasData) {
                parts.push(stringToken.string);
              }
            }
          }

          if (hasData) {
            parts.push(dataBuffer);
          }

          index = lastDataIndex; // Output next string only if it is the last
          // and there is previous data before it

          if (index + 1 == lastIndex) {
            var _stringToken = tokens[index + 1];

            if (_stringToken && _stringToken.type == AddressTokenTypes.STRING && _stringToken.string) {
              if (!ignoreEmptyLines || hasData || hasPreviousData) {
                parts.push(_stringToken.string);
              }
            } // Consume the last string token


            index = index + 1;
          }
        }
      }

      return parts.join('').trim();
    }
    /**
     * Tokenize address format pattern.
     *
     * @param {AddressToken[]} tokens
     * @param {*} data
     * @param {string} lineBreak
     * @param {boolean} ignoreEmptyLines
     * @return {string} Formatted Address
     *
     * @private
     */


    function formatTokens(tokens, data, lineBreak, ignoreEmptyLines) {
      var lines = [];
      var lineIndex = -1;

      for (var index = 0; index < tokens.length; index++) {
        var doFormat = false;
        var endWithNewLine = false;
        var token = tokens[index];

        switch (token.type) {
          case AddressTokenTypes.NEWLINE:
            {
              if (lineIndex >= 0) {
                doFormat = true;
                endWithNewLine = true;
              } else if (!ignoreEmptyLines) {
                lines.push(''); // Empty line
                // If the pattern ends with a newline

                if (index + 1 == tokens.length) {
                  lines.push(''); // Empty line
                }
              }

              break;
            }

          default:
            {
              lineIndex = lineIndex < 0 ? index : lineIndex;
              doFormat = index + 1 == tokens.length ? true : doFormat;
              break;
            }
        }

        if (doFormat) {
          var line = formatLineTokens(tokens, data, ignoreEmptyLines, lineIndex, endWithNewLine ? index - 1 : index);

          if (!ignoreEmptyLines || line) {
            lines.push(line);
          } // If line ends with a newline, and it is the last line on pattern


          if (!ignoreEmptyLines && endWithNewLine && index + 1 == tokens.length) {
            lines.push('');
          }

          lineIndex = -1;
        }
      }

      return lines.join(lineBreak);
    }
    /**
     * Format address data.
     *
     * @param {*} data Address data being processed.
     * @param {string} pattern Address format pattern.
     * @param {string} lineBreak Line break string to use
     * @param {boolean} ignoreEmptyLines Ignore lines that has no or empty data to replace.
     * @return {string} Formatted address.
     */


    function format(data, pattern, lineBreak, ignoreEmptyLines) {
      // TODO: support escapeHtml to match Java class feature parity
      ignoreEmptyLines = ignoreEmptyLines === false ? false : true; // Defaults to false

      lineBreak = lineBreak || '\n'; // Defaults to <br/> or lf

      var tokens = [];
      tokenize(new TokenizerState(pattern, 0), tokens);
      return formatTokens(tokens, data, lineBreak, ignoreEmptyLines);
    }

    var addressFormatter = {
      format: format
    };
    var CJK_COUNTRIES = ['CN', 'HK', 'TW', 'JP', 'KR', 'KP'];
    var CJK_LANGUAGES = ['zh', 'ja', 'ko'];
    var address = {
      /**
       * Gets the globalization for the specified country code.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {{fmt: string, input: string, require: string}} Format Data
       */
      getAddressInfoForCountry: function getAddressInfoForCountry(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          var cloneAddressRep = Object.freeze(Object.assign({}, data[code]));
          return Object.freeze({
            address: cloneAddressRep
          });
        }

        return {};
      },

      /**
       * Get the format pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Address Format Pattern
       */
      getAddressFormat: function getAddressFormat(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].fmt;
        }

        return '';
      },

      /**
       * Get the input order pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrder: function getAddressInputOrder(langCode, countryCode) {
        // A special case to deal with en_HK locale. We want to use US like
        // format for en_HK.
        // See W-4718344
        if (langCode && langCode.toLowerCase() == 'en' && countryCode && countryCode.toUpperCase() == 'HK') {
          langCode = 'en';
          countryCode = 'US';
        }

        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].input;
        }

        return '';
      },

      /**
       * Get the input order pattern for all fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrderAllField: function getAddressInputOrderAllField(langCode, countryCode) {
        // A special case to deal with en_HK locale. We want to use US like
        // format for en_HK.
        // See W-4718344
        if (langCode && langCode.toLowerCase() == 'en' && countryCode && countryCode.toUpperCase() == 'HK') {
          langCode = 'en';
          countryCode = 'US';
        }

        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          var input = data[code].input; // Add missing patterns.

          if (input.indexOf('S') === -1) {
            input = input.replace('K', 'SK');
          }

          if (input.indexOf('C') === -1) {
            input = input.replace('S', 'CS');
          }

          if (input.indexOf('Z') === -1) {
            input = input.replace('C', 'ZC');
          }

          return input;
        }

        return '';
      },

      /**
       * Get required fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Required Fields
       */
      getAddressRequireFields: function getAddressRequireFields(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].require;
        }

        return '';
      },

      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddressAllFields: function formatAddressAllFields(langCode, countryCode, values, lineBreak) {
        var code = this.getCountryFromLocale(langCode, countryCode, values);

        if (data[code]) {
          // Double check.
          var pattern = data[code].fmt; // Some countries don't have City, State or ZIP code. We don't want to
          // lose those data from formatted string.

          if (values.zipCode && pattern.indexOf('%Z') === -1) {
            pattern = pattern.replace('%K', '%Z %K');
          }

          if (values.city && pattern.indexOf('%C') === -1) {
            pattern = pattern.replace('%K', '%C %K');
          }

          if (values.state && pattern.indexOf('%S') === -1) {
            pattern = pattern.replace('%K', '%S %K');
          }

          return this.buildAddressLines(pattern, values, lineBreak, true);
        }

        return '';
      },

      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddress: function formatAddress(langCode, countryCode, values, lineBreak) {
        var code = this.getCountryFromLocale(langCode, countryCode, values);

        if (data[code]) {
          // Double check.
          return this.buildAddressLines(data[code].fmt, values, lineBreak, true);
        }

        return '';
      },

      /**
       * Creates an array of address lines given the format and the values to use.
       *
       * @param {string} pattern
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values
       * @param {string} lineBreak
       * @param {string} ignoreEmptyLines
       * @return {string} the text for use in the address
       */
      buildAddressLines: function buildAddressLines(pattern, values, lineBreak, ignoreEmptyLines) {
        return addressFormatter.format(values, pattern, lineBreak, ignoreEmptyLines);
      },

      /**
       * Resolve the reference by tracing down the _ref value.
       * @param {*} data Address Format Data
       * @param {string} countryCode Country Code
       * @return {*} Referenced Address Format Data
       */
      followReferences: function followReferences(data$$1, countryCode) {
        if (data$$1[countryCode] && data$$1[countryCode]._ref) {
          return this.followReferences(data$$1, data$$1[countryCode]._ref);
        }

        return countryCode;
      },

      /**
       * Check strings for Han characters
       *
       * @param {...string} values String values to check against
       * @return {boolean} true if any of string values contain Han script character
       */
      containsHanScript: function containsHanScript() {
        for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        if (!values || !Array.isArray(values)) return false;
        return values.some(function (value) {
          if (!value) return false; // Javascript regex do not work with surrogate pairs so String#match is unusable with supplemental ranges.
          // Iterating a string returns a char that contains one codepoint.
          // Surrogate pairs will be returned as a pair.
          // Unicode block ranges: @see http://www.unicode.org/Public/UCD/latest/ucd/Blocks.txt

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var singleChar = _step.value;
              var codePoint = singleChar.codePointAt(0); // Thank you ES2015

              if (0x2e80 <= codePoint && codePoint <= 0x2eff || // CJK Radicals Supplement
              0x3300 <= codePoint && codePoint <= 0x33ff || // CJK Compatibility
              0xfe30 <= codePoint && codePoint <= 0xfe4f || // CJK Compatibility Forms
              0xf900 <= codePoint && codePoint <= 0xfaff || // CJK Compatibility Ideographs
              0x2f800 <= codePoint && codePoint <= 0x2fa1f || // CJK Compatibility Ideographs Supplement
              0x3000 <= codePoint && codePoint <= 0x303f || // CJK Symbols and Punctuation
              0x4e00 <= codePoint && codePoint <= 0x9fff || // CJK Unified Ideographs
              0x3400 <= codePoint && codePoint <= 0x4dbf || // CJK Unified Ideographs Extension A
              0x20000 <= codePoint && codePoint <= 0x2a6df || // CJK Unified Ideographs Extension B
              0x2a700 <= codePoint && codePoint <= 0x2b73f || // CJK Unified Ideographs Extension C
              0x2b740 <= codePoint && codePoint <= 0x2b81f || // CJK Unified Ideographs Extension D
              0x2b820 <= codePoint && codePoint <= 0x2ceaf || // CJK Unified Ideographs Extension E // Not on core
              0x2ceb0 <= codePoint && codePoint <= 0x2ebef || // CJK Unified Ideographs Extension F // Not on core
              0x3200 <= codePoint && codePoint <= 0x32ff || // Enclosed CJK Letters and Months
              0x31c0 <= codePoint && codePoint <= 0x31ef || // CJK Strokes
              // Chinese
              0x3100 <= codePoint && codePoint <= 0x312f || // Bopomofo
              0x31a0 <= codePoint && codePoint <= 0x31bf || // Bopomofo Extended
              0x2f00 <= codePoint && codePoint <= 0x2fdf || // Kangxi Radicals
              0x2ff0 <= codePoint && codePoint <= 0x2fff || // Ideographic Description Characters
              // Japanese
              0xff00 <= codePoint && codePoint <= 0xffef || // Halfwidth and Fullwidth Forms
              0x3040 <= codePoint && codePoint <= 0x309f || // Hiragana
              0x30a0 <= codePoint && codePoint <= 0x30ff || // Katakana
              0x31f0 <= codePoint && codePoint <= 0x31ff || // Katakana Phonetic Extensions
              0x1b000 <= codePoint && codePoint <= 0x1b0ff || // Kana Supplement
              0x1b100 <= codePoint && codePoint <= 0x1b12f || // Kana Extended-A // Not on core
              // Korean
              0x1100 <= codePoint && codePoint <= 0x11ff || // Hangul Jamo
              0xac00 <= codePoint && codePoint <= 0xd7af || // Hangul Syllables
              0x3130 <= codePoint && codePoint <= 0x318f || // Hangul Compatibility Jamo
              0xa960 <= codePoint && codePoint <= 0xa97f || // Hangul Jamo Extended-A
              0xd7b0 <= codePoint && codePoint <= 0xd7ff // Hangul Jamo Extended-B
              ) {
                  return true;
                }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return false;
        });
      },

      /**
       * Returns the address code (country code) for given locale and data.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} values Address Data
       * @return {string} Address Code
       */
      getCountryFromLocale: function getCountryFromLocale(langCode, countryCode, values) {
        if (values) {
          var isCJK = !countryCode && CJK_LANGUAGES.indexOf(langCode.toLowerCase()) >= 0 || countryCode && CJK_COUNTRIES.indexOf(countryCode.toUpperCase()) >= 0;
          var isJA = !countryCode && 'ja' == langCode.toLowerCase() || countryCode && 'JP' == countryCode.toUpperCase(); // English format (ja_en_JP) is only used when all fields do not contain CJK characters

          if (!(isJA && this.containsHanScript(values.address, values.city, values.state, values.country)) && isCJK && !this.containsHanScript(values.address)) {
            return this.getCountryFromLocale(langCode, 'EN_' + countryCode);
          }
        }

        var country = countryCode; // Address format should be always associated to a COUNTRY.
        // If country part is empty, we need to map language to a
        // certain country. For example, "de" -> "DE".

        if (!countryCode && languageCodeToCountry.languageCode[langCode]) {
          country = languageCodeToCountry.languageCode[langCode];
        } // Trace the real data from country reference.


        country = this.followReferences(data, country);

        if (!country || !data[country]) {
          return 'US'; // Always fall back to US format.
        }

        return country;
      },

      /**
       * Get fall back country code.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} address Address Data
       * @return {string} Address Code
       *
       * @deprecated Use getCountryFromLocale instead
       */
      getFallback: function getFallback(langCode, countryCode, address) {
        return this.getCountryFromLocale(langCode, countryCode);
      }
    };

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/name.js
    // This will be added/updated through a build process in the future

    /* eslint-disable */
    var data$1 = {
      DEFAULT: {
        short_f: '%F %L',
        medium_f: '%F %M %L',
        long_f: '%S %F %M %L %X %I',
        input: 'SFMLXI'
      },
      vi: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLFMXI'
      },
      vi_VN: {
        _ref: 'vi'
      },
      hu: {
        short_f: '%L %F',
        medium_f: '%L %F',
        long_f: '%L %F %M %X %I',
        input: 'SLFMXI'
      },
      hu_HU: {
        _ref: 'hu'
      },
      ja: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLMFXI'
      },
      ja_JP: {
        _ref: 'ja'
      },
      ko: {
        _ref: 'ja'
      },
      ko_KR: {
        _ref: 'ja'
      },
      zh: {
        _ref: 'ja'
      },
      zh_CN: {
        _ref: 'ja'
      },
      zh_CN_PINYIN: {
        _ref: 'ja'
      },
      zh_CN_STROKE: {
        _ref: 'ja'
      },
      zh_HK: {
        _ref: 'ja'
      },
      zh_HK_STROKE: {
        _ref: 'ja'
      },
      zh_MO: {
        _ref: 'ja'
      },
      zh_SG: {
        _ref: 'ja'
      },
      zh_TW: {
        _ref: 'ja'
      },
      zh_TW_STROKE: {
        _ref: 'ja'
      }
    }; // Define all available fields.

    /**
     S: Salutation
     F: First Name(givenName)
     M: Middle Name
     L: Last Name(familyName)
     X: Suffix
     I: Informal Name
     */

    var fieldConstants = {
      SALUTATION: Symbol('Salutation'),
      FIRST: Symbol('First Name'),
      MIDDLE: Symbol('Middle Name'),
      LAST: Symbol('Last Name'),
      SUFFIX: Symbol('Suffix'),
      INFORMAL: Symbol('Informal Name')
    };

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var Format = function Format(parts) {
      _classCallCheck(this, Format);

      this.parts = Object.freeze(parts);
      Object.freeze(this);
    };
    /**
     * Represents a field within the format
     */


    var FieldFormatPart = function FieldFormatPart(field) {
      _classCallCheck(this, FieldFormatPart);

      this.field = field;
      this.type = 'field';
      Object.freeze(this);
    };
    /**
     * Represents text to be output directly
     */


    var TextFormatPart = function TextFormatPart(text) {
      _classCallCheck(this, TextFormatPart);

      this.type = 'text';
      this.text = text;
      Object.freeze(this);
    };

    var fieldFormatParts = Object.freeze({
      SALUTATION: new FieldFormatPart(fieldConstants.SALUTATION),
      FIRST: new FieldFormatPart(fieldConstants.FIRST),
      MIDDLE: new FieldFormatPart(fieldConstants.MIDDLE),
      LAST: new FieldFormatPart(fieldConstants.LAST),
      SUFFIX: new FieldFormatPart(fieldConstants.SUFFIX),
      INFORMAL: new FieldFormatPart(fieldConstants.INFORMAL)
    });

    var FormatParser = function () {
      function FormatParser() {
        _classCallCheck(this, FormatParser);
      }

      _createClass(FormatParser, [{
        key: 'parse',

        /**
         * Parses the format
         * @param {string} fmt the format to be parsed
         * @returns {Format}
         */
        value: function parse(fmt) {
          var nodes = [];
          var textBuffer = ''; // parse the format string

          for (var i = 0; i < fmt.length; i = i + 1) {
            if (fmt[i] === '%') {
              i = i + 1; // move to the next character after %
              // end the last text buffer

              if (textBuffer.length > 0) {
                nodes.push(Object.freeze(new TextFormatPart(textBuffer)));
                textBuffer = '';
              }

              if (i >= fmt.length) {
                throw new Error('Unexpected end of format. Symbol at ' + (i - 1) + ' should be followed by a valid field code');
              }

              var code = fmt[i];

              switch (code) {
                case 'S':
                  nodes.push(fieldFormatParts.SALUTATION);
                  break;

                case 'F':
                  nodes.push(fieldFormatParts.FIRST);
                  break;

                case 'M':
                  nodes.push(fieldFormatParts.MIDDLE);
                  break;

                case 'L':
                  nodes.push(fieldFormatParts.LAST);
                  break;

                case 'X':
                  nodes.push(fieldFormatParts.SUFFIX);
                  break;

                case 'I':
                  nodes.push(fieldFormatParts.INFORMAL);
                  break;
              }
            } else {
              // if it wasn't a symbol, then just output the value directly
              textBuffer += fmt[i];
            }
          }

          if (textBuffer.length > 0) {
            nodes.push(new TextFormatPart(textBuffer));
          }

          return new Format(nodes);
        }
      }]);

      return FormatParser;
    }();

    var formatParser = new FormatParser();
    var name = {
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {{short: string, medium: string, long: string, input: string}} format data
       */
      getNameInfoForLocale: function getNameInfoForLocale(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          var cloneNameInfo = Object.freeze(Object.assign({}, data$1[key]));
          return Object.freeze({
            name: cloneNameInfo
          });
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternMedium: function getNameFormatPatternMedium(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].medium_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternShort: function getNameFormatPatternShort(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].short_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternLong: function getNameFormatPatternLong(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].long_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} input order
       */
      getNameInputOrder: function getNameInputOrder(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].input;
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameShort: function formatNameShort(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].short_f, values);
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameMedium: function formatNameMedium(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].medium_f, values);
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameLong: function formatNameLong(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].long_f, values);
        }
      },

      /**
       * Creates an array of address lines given the format and the values to use.
       * @param {string} pattern
       * @param @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the text for use in the address
       */
      buildName: function buildName(pattern, values) {
        var format = formatParser.parse(pattern);
        var sb = [];

        for (var i = 0; i < format.parts.length; i++) {
          var part = format.parts[i];

          if (part.type === 'text') {
            sb.push(part.text);
          } else if (part.type === 'field') {
            if (part.field === fieldConstants.SALUTATION) {
              sb.push(values.salutation || '');
            } else if (part.field === fieldConstants.FIRST) {
              sb.push(values.first || '');
            } else if (part.field === fieldConstants.MIDDLE) {
              sb.push(values.middle || '');
            } else if (part.field === fieldConstants.LAST) {
              sb.push(values.last || '');
            } else if (part.field === fieldConstants.SUFFIX) {
              sb.push(values.suffix || '');
            } else if (part.field === fieldConstants.INFORMAL) {
              sb.push(values.informal || '');
            }
          }
        }

        return sb.join('').trim().replace(/  /g, ' ');
      },
      // Resolve the reference by tracing down the _ref value.
      followReferences: function followReferences(key) {
        if (data$1[key] && data$1[key]._ref) {
          return this.followReferences(data$1[key]._ref);
        }

        return key;
      },
      // Get fall back key.
      getFallback: function getFallback(localeStr) {
        // Resolve the reference.
        var key = this.followReferences(localeStr);

        if (!data$1[key]) {
          return 'DEFAULT'; // Always fall back to 'US'.
        }

        return key;
      }
    };

    var numberFormat = '#,##0.###';

    var percentFormat = '#,##0%';

    var currencyFormat = '¤#,##0.00;(¤#,##0.00)';

    var currency = 'USD';

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat#Parameters

    const POSSIBLE_OPTS = {
      style: true,
      currency: true,
      currencyDisplay: true,
      useGrouping: true,
      minimumIntegerDigits: true,
      minimumFractionDigits: true,
      maximumFractionDigits: true,
      minimumSignificantDigits: true,
      maximumSignificantDigits: true
    };
    const STYLE = {
      DECIMAL: 'decimal',
      CURRENCY: 'currency',
      PERCENT: 'percent'
    };
    const CURRENCY_DISPLAY = {
      CODE: 'code',
      // USD
      SYMBOL: 'symbol',
      // $
      NAME: 'name' // US Dollars

    };
    const SAFE_NUM_LENGTH = 15;
    const numberFormatInstancesCache = {};

    function getStringOfChar(char, amount) {
      return new Array(amount + 1).join(char);
    }

    function getGroupingCount(skeleton) {
      const match = skeleton.match(/,[#0]*\./);
      return match ? match[0].length - 2 : 0;
    }

    function getOptionsUniqueKey$1(options) {
      return Object.keys(options).sort().reduce((prev, optionName) => {
        if (POSSIBLE_OPTS[optionName]) {
          return prev + optionName + options[optionName] + '';
        }

        return prev;
      }, '');
    }

    function toNumber(value, defaultValue) {
      const number = parseInt(value, 10);

      if (isNaN(number)) {
        return defaultValue;
      }

      return number;
    }

    function getFractionPart(options) {
      const minimumDigits = toNumber(options.minimumFractionDigits, 0);
      const maximumDigits = Math.max(toNumber(options.maximumFractionDigits, 0), minimumDigits);
      return '.' + new Array(minimumDigits + 1).join('0') + new Array(maximumDigits - minimumDigits + 1).join('#');
    }

    function updateFractionPart(skeleton, options) {
      const fractionPart = getFractionPart(options);
      return addFractionsToPattern(skeleton, fractionPart);
    }

    function addFractionsToPattern(pattern, fractionPart) {
      if (!fractionPart) {
        return pattern;
      } // if pattern has two formats (one for positive and one for negative numbers), add fractions to both patterns


      if (pattern.indexOf(';') > 0) {
        const [positivePattern, negativePattern] = pattern.split(';');
        return `${addFractionsToPattern(positivePattern, fractionPart)};${addFractionsToPattern(negativePattern, fractionPart)}`;
      } // If the pattern already has a fraction part, replace it with the fractions calculated from the options


      if (pattern.indexOf('.') > 0) {
        return pattern.replace(/\.(0|#)*/, fractionPart);
      } // If the pattern doesn't have a fraction part, we need to add it to the pattern
      // We need to add the fraction part after the last digit (represented by '0' or '#')


      const position = Math.max(pattern.lastIndexOf('0'), pattern.lastIndexOf('#')) + 1;
      return [pattern.slice(0, position), fractionPart, pattern.slice(position)].join('');
    }

    function updateCurrencySymbol(skeleton, currencyCode, options) {
      const symbol = String.fromCharCode(164);

      if (options.currencyDisplay === CURRENCY_DISPLAY.NAME) {
        // append the currency code at the end.
        return skeleton.replace(symbol, '') + currencyCode;
      }

      return skeleton.replace(symbol, currencyCode);
    }

    function updateIntegerPart(skeleton, options) {
      const minimumIntegerDigits = options.minimumIntegerDigits;
      const groupingCount = getGroupingCount(skeleton);

      if (!minimumIntegerDigits) {
        return skeleton;
      }

      if (minimumIntegerDigits <= groupingCount) {
        return skeleton.replace(/,[#0]*\./, ',' + getStringOfChar('#', groupingCount - minimumIntegerDigits) + getStringOfChar('0', minimumIntegerDigits) + '.');
      }

      return skeleton.replace(/[#0]*\./, getStringOfChar('0', minimumIntegerDigits - groupingCount) + ',' + getStringOfChar('0', groupingCount) + '.');
    }

    function getBestMatchCurrencySymbol(code, currencyDisplay) {
      if (!('Intl' in window)) {
        return code; // fail gracefully.
      }

      const opts = {
        style: 'currency',
        currency: code,
        minimumFractionDigits: 0
      };

      if (currencyDisplay) {
        opts.currencyDisplay = currencyDisplay;
      }

      const nf = getFromCache(opts);
      return nf.format(2).replace(/2/g, '');
    }

    function getCurrency(options) {
      const currencyDisplay = options.currencyDisplay || CURRENCY_DISPLAY.SYMBOL;

      if (currencyDisplay === CURRENCY_DISPLAY.SYMBOL || currencyDisplay === CURRENCY_DISPLAY.NAME) {
        return getBestMatchCurrencySymbol(options.currency, currencyDisplay);
      }

      return options.currency;
    }

    function getFromCache(options) {
      const optionsUniqueKey = getOptionsUniqueKey$1(options);
      let numberFormatInstance = numberFormatInstancesCache[optionsUniqueKey];

      if (numberFormatInstance) {
        return numberFormatInstance;
      }

      numberFormatInstance = new Intl.NumberFormat(locale, options);
      numberFormatInstancesCache[optionsUniqueKey] = numberFormatInstance;
      return numberFormatInstance;
    }

    function exceedsSafeLength(value) {
      const numberAsString = value.toString().replace('.', '');
      return numberAsString.length >= SAFE_NUM_LENGTH;
    }

    function normalizedMinimumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0]/g, '');
      return fractionDigits.length;
    }

    function normalizedMaximumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0#]/g, '');
      return Math.max(options.minimumFractionDigits, fractionDigits.length);
    }

    function getFallbackFractionSkeleton(style) {
      let styleFormat = numberFormat;

      if (style === STYLE.CURRENCY) {
        styleFormat = currencyFormat;
      } else if (style === STYLE.PERCENT) {
        styleFormat = percentFormat;
      }

      const format = styleFormat.split(';')[0];
      return format.split('.')[1] || '';
    }

    function normalizeOptions(options) {
      const normalizedOpts = Object.assign({}, options);
      normalizedOpts.currency = normalizedOpts.currency || currency;

      if (normalizedOpts.minimumFractionDigits === undefined) {
        normalizedOpts.minimumFractionDigits = normalizedMinimumFractionDigits(normalizedOpts);
      }

      if (normalizedOpts.maximumFractionDigits === undefined || normalizedOpts.maximumFractionDigits < normalizedOpts.minimumFractionDigits) {
        normalizedOpts.maximumFractionDigits = normalizedMaximumFractionDigits(normalizedOpts);
      }

      return normalizedOpts;
    }

    function NumberOptions(options) {
      this.options = options || {};
    }

    NumberOptions.prototype.isCurrency = function () {
      return this.options.style === 'currency';
    };

    NumberOptions.prototype.isPercent = function () {
      return this.options.style === 'percent';
    };

    NumberOptions.prototype.isDefaultCurrency = function () {
      return !this.options.currency || currency === this.options.currency;
    };

    NumberOptions.prototype.getDefaultSkeleton = function () {
      return this.isCurrency() ? currencyFormat : this.isPercent() ? percentFormat : numberFormat;
    };

    NumberOptions.prototype.getSkeleton = function () {
      const options = this.options;
      const defaultSkeleton = this.getDefaultSkeleton();
      let skeleton = updateFractionPart(defaultSkeleton, options);
      skeleton = updateIntegerPart(skeleton, options);

      if (!this.isDefaultCurrency()) {
        skeleton = updateCurrencySymbol(skeleton, getCurrency(options), options);
      }

      return skeleton;
    };

    /*
     * Regex to test a string for an ISO8601 Date. The following formats are matched.
     * Note that if a time element is present (e.g. 'T'), the string should have a time zone designator (Z or +hh:mm or -hh:mm).
     *
     *  YYYY
     *  YYYY-MM
     *  YYYY-MM-DD
     *  YYYY-MM-DDThh:mmTZD
     *  YYYY-MM-DDThh:mm:ssTZD
     *  YYYY-MM-DDThh:mm:ss.STZD
     *
     *
     * @see: https://www.w3.org/TR/NOTE-datetime
     */
    const ISO8601_STRICT_PATTERN = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z){1})?)?)?$/i;
    /* Regex to test a string for an ISO8601 partial time or full time:
     * hh:mm
     * hh:mm:ss
     * hh:mm:ss.S
     * full time = partial time + TZD
     */

    const ISO8601_TIME_PATTERN = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;
    const STANDARD_DATE_FORMAT = 'YYYY-MM-DD';
    const TIME_SEPARATOR = 'T';
    const TIMEZONE_INDICATOR = /(Z|([+-])(\d{2}):(\d{2}))$/;
    function isValidISODateTimeString(dateTimeString) {
      return isValidISO8601String(dateTimeString) && isValidDate(dateTimeString);
    }
    function isValidISOTimeString(timeString) {
      if (!isValidISO8601TimeString(timeString)) {
        return false;
      }

      const timeOnly = removeTimeZoneSuffix(timeString);
      return isValidDate(`2018-09-09T${timeOnly}Z`);
    }
    function removeTimeZoneSuffix(dateTimeString) {
      if (typeof dateTimeString === 'string') {
        return dateTimeString.split(TIMEZONE_INDICATOR)[0];
      }

      return dateTimeString;
    }

    function isValidISO8601String(dateTimeString) {
      if (typeof dateTimeString !== 'string') {
        return false;
      }

      return ISO8601_STRICT_PATTERN.test(dateTimeString);
    }

    function isValidISO8601TimeString(timeString) {
      if (typeof timeString !== 'string') {
        return false;
      }

      return ISO8601_TIME_PATTERN.test(timeString);
    }

    function isValidDate(value) {
      // Date.parse returns NaN if the argument doesn't represent a valid date
      const timeStamp = Date.parse(value);
      return isFinite(timeStamp);
    }

    // This is a library for all calls to the aura localizationService.
    function isBefore(date1, date2, unit) {
      return configProvider.getLocalizationService().isBefore(date1, date2, unit);
    }
    function isAfter(date1, date2, unit) {
      return configProvider.getLocalizationService().isAfter(date1, date2, unit);
    }
    function formatDateTimeUTC(date) {
      return configProvider.getLocalizationService().formatDateTimeUTC(date);
    }
    function formatDate(dateString, format, locale) {
      return configProvider.getLocalizationService().formatDate(dateString, format, locale);
    }
    function formatTime(timeString, format) {
      return configProvider.getLocalizationService().formatTime(timeString, format);
    }
    function parseDateTimeUTC(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeUTC(dateTimeString);
    }
    function parseDateTimeISO8601(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeISO8601(dateTimeString);
    }
    function parseDateTime(dateTimeString, format, strictMode) {
      return configProvider.getLocalizationService().parseDateTime(dateTimeString, format, strictMode);
    }
    function syncUTCToWallTime(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider.getLocalizationService().UTCToWallTime(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function syncWallTimeToUTC(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider.getLocalizationService().WallTimeToUTC(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function toOtherCalendar(date) {
      return configProvider.getLocalizationService().translateToOtherCalendar(date);
    }
    function fromOtherCalendar(date) {
      return configProvider.getLocalizationService().translateFromOtherCalendar(date);
    }
    function toLocalizedDigits(input) {
      return configProvider.getLocalizationService().translateToLocalizedDigits(input);
    }
    function fromLocalizedDigits(input) {
      return configProvider.getLocalizationService().translateFromLocalizedDigits(input);
    } // This belongs to localization service; i.e. getLocalizationService().parseTime()
    // Should be removed after it's been added to the localization service

    function parseTime(timeString, format, strictParsing) {
      if (!timeString) {
        return null;
      }

      if (!format) {
        if (!isValidISOTimeString(timeString)) {
          return null;
        }

        return parseDateTimeISO8601(timeString);
      }

      const parseString = timeString.replace(/(\d)([AaPp][Mm])/g, '$1 $2'); // Modifying the time string so that strict parsing doesn't break on minor deviations

      const parseFormat = format.replace(/(\b|[^h])h{2}(?!h)/g, '$1h').replace(/(\b|[^H])H{2}(?!H)/g, '$1H').replace(/(\b|[^m])m{2}(?!m)/g, '$1m').replace(/\s*A/g, ' A').trim();
      const acceptableFormats = [parseFormat]; // We want to be lenient and accept input values with seconds or milliseconds precision.
      // So even though we may display the time as 10:23 AM, we would accept input values like 10:23:30.555 AM.

      acceptableFormats.push(parseFormat.replace('m', 'm:s'), parseFormat.replace('m', 'm:s.S'), parseFormat.replace('m', 'm:s.SS'), parseFormat.replace('m', 'm:s.SSS')); // Start parsing from the most strict format (i.e. time with milliseconds).
      // The strict mode parsing of time strings using parseDateTime seems to be lenient for certain formats

      acceptableFormats.reverse();

      for (let i = 0; i < acceptableFormats.length; i++) {
        const time = parseDateTime(parseString, acceptableFormats[i], strictParsing);

        if (time) {
          return time;
        }
      }

      return null;
    } // This is called from the numberFormat library when the value exceeds the safe length.

    function getNumberFormat(format) {
      return configProvider.getLocalizationService().getNumberFormat(format);
    }

    function numberFormatFallback(options) {
      const skeleton = new NumberOptions(options).getSkeleton();
      return {
        format: value => {
          return getNumberFormat(skeleton).format(value);
        }
      };
    }

    function numberFormat$1(options) {
      const normalizedOpts = Object.assign({}, normalizeOptions(options));

      if (!('Intl' in window)) {
        return numberFormatFallback(normalizedOpts);
      }

      return {
        format: value => {
          if (value && exceedsSafeLength(value)) {
            return numberFormatFallback(normalizedOpts).format(value);
          }

          const numberFormatInstance = getFromCache(normalizedOpts);
          return numberFormatInstance.format(value);
        }
      };
    }

    const isTimeZonesSupported = function () {
      try {
        // IE11 only supports the UTC time zone and throws when given anything else
        // eslint-disable-next-line new-cap
        Intl.DateTimeFormat('en-US', {
          timeZone: 'America/Los_Angeles'
        });
      } catch (err) {
        return false;
      }

      return true;
    }();

    var lang = 'en';

    // Falling back to the user's locale or the default 'en-us' in case the tag isn't supported by the browser's Intl implementation

    const FALLBACK_LOCALES = [locale, 'en-us'];
    const symbolsCache = {}; // languageOverride is only used in the tests

    function getNameOfWeekdays(languageOverride) {
      const language = languageOverride || lang;
      const languageDataCache = symbolsCache[language];

      if (languageDataCache && languageDataCache.weekdays) {
        return languageDataCache.weekdays;
      }

      const intlLocales = [language, ...FALLBACK_LOCALES];
      const fullNameFormatter = new Intl.DateTimeFormat(intlLocales, {
        weekday: 'long',
        timeZone: 'UTC'
      });
      const shortNameFormatter = new Intl.DateTimeFormat(intlLocales, {
        weekday: 'short',
        timeZone: 'UTC'
      });
      const weekdays = [];

      for (let i = 0; i <= 6; i++) {
        // (1970, 0, 4) corresponds to a sunday.
        const date = new Date(Date.UTC(1970, 0, 4 + i));
        weekdays.push({
          fullName: format$1(fullNameFormatter, date),
          shortName: format$1(shortNameFormatter, date)
        });
      }

      if (!symbolsCache[language]) {
        symbolsCache[language] = {};
      }

      symbolsCache[language].weekdays = weekdays;
      return weekdays;
    } // languageOverride is only used in the tests

    function getMonthNames(languageOverride) {
      const language = languageOverride || lang;
      const languageDataCache = symbolsCache[language];

      if (languageDataCache && languageDataCache.months) {
        return languageDataCache.months;
      }

      const intlLocales = [language, ...FALLBACK_LOCALES];
      const monthNameFormatter = new Intl.DateTimeFormat(intlLocales, {
        month: 'long'
      });
      const months = [];

      for (let i = 0; i <= 11; i++) {
        const date = new Date(1970, i, 4);
        months.push({
          // we currently only need the fullName
          fullName: format$1(monthNameFormatter, date)
        });
      }

      if (!symbolsCache[language]) {
        symbolsCache[language] = {};
      }

      symbolsCache[language].months = months;
      return months;
    }

    function format$1(dateTimeFormat, date) {
      const formattedDate = dateTimeFormat.format(date);
      return removeIE11Markers(formattedDate);
    }

    function removeIE11Markers(formattedString) {
      // IE11 adds LTR / RTL mark in the formatted date time string
      return formattedString.replace(/[\u200E\u200F]/g, '');
    }

    var mediumDateFormat = 'MMM d, yyyy';

    var mediumTimeFormat = 'h:mm:ss a';

    function normalizeISODate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // if value is an ISO string, only fetch the date part


      const dateOnlyString = typeof dateValue === 'string' && dateValue.split(TIME_SEPARATOR)[0] || dateValue;
      assert(isValidISODateTimeString(dateOnlyString), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTime(dateOnlyString, STANDARD_DATE_FORMAT);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // convert from Gregorian to Buddhist Calendar if necessary


      const civilDate = toOtherCalendar(parsedDate);
      return {
        isoValue: dateOnlyString,
        displayValue: formatDate(civilDate, format)
      };
    }
    function normalizeISOTime(value, format) {
      // We are not converting the time to the user's timezone. All values are displayed and saved as UTC time values
      const normalizedValue = removeTimeZoneSuffix(value);
      const timeValue = typeof normalizedValue === 'string' ? normalizedValue.trim() : normalizedValue;

      if (!timeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISOTimeString(timeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string. ` + `but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedTime = parseTime(timeValue);

      if (!parsedTime) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      return {
        isoValue: getISOTimeString(parsedTime),
        displayValue: formatTime(parsedTime, format)
      };
    }
    function normalizeISODateTime(value, timezone, format) {
      const dateTimeValue = typeof value === 'string' ? value.trim() : value;

      if (!dateTimeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISODateTimeString(dateTimeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTimeISO8601(dateTimeValue);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      const convertedDate = syncUTCToWallTime(parsedDate, timezone);
      return {
        // We are passing the ISO value without a timezone designator.
        // the native input type='datetime-local' who calls this does not accept timezone offset
        isoValue: removeTimeZoneSuffix(convertedDate.toISOString()),
        displayValue: formatDateTimeUTC(convertedDate)
      };
    }
    function normalizeFormattedDate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return null;
      }

      const parsedDate = parseDateTime(dateValue, format || mediumDateFormat, true);

      if (!parsedDate) {
        return null;
      }

      const gregorianDate = fromOtherCalendar(parsedDate);
      return getISODateString(gregorianDate);
    }
    function normalizeFormattedTime(value, format) {
      const timeValue = typeof value === 'string' ? value.trim() : value;

      if (!timeValue) {
        return null;
      }

      const parsedDate = parseTime(timeValue, format || mediumTimeFormat, true);

      if (!parsedDate) {
        return null;
      }

      return getISOTimeString(parsedDate);
    } // The value here isn't really formatted, it's always an ISO string in the form isoDate + T + isoTime (without Z).

    function normalizeFormattedDateTime(value, timezone, format) {
      const datetimeValue = typeof value === 'string' ? value.trim() : value;

      if (!datetimeValue) {
        return null;
      } // given that value is an ISO string without Z, the method below is equivalent to parseDateTimeISO8601(value + 'Z')
      // However, parseDateTimeUTC is more concise and doesn't need any manipulation of the input (adding Z).


      const parsedDate = parseDateTimeUTC(datetimeValue);

      if (!parsedDate) {
        return null;
      }

      const convertedDate = syncWallTimeToUTC(parsedDate, timezone);
      return convertedDate.toISOString();
    }
    function getToday() {
      const today = getTodayBasedOnTimezone();
      return getISODateString(today);
    }
    function getISODateString(date) {
      return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
    }
    function getISOTimeString(date) {
      return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${doublePad(date.getMilliseconds())}`;
    }
    function getCurrentTime(timezone) {
      const today = getTodayBasedOnTimezone(timezone);
      return pad(today.getHours()) + ':' + pad(today.getMinutes());
    }

    function getTodayBasedOnTimezone(timezone) {
      const today = new Date();
      today.setTime(today.getTime() + today.getTimezoneOffset() * 60 * 1000); // time in UTC
      // localization service will use $Locale.timezone when no timezone provided

      return syncUTCToWallTime(today, timezone);
    }

    function pad(n) {
      return Number(n) < 10 ? '0' + n : n;
    }

    function doublePad(n) {
      const number = Number(n);

      if (number < 10) {
        return '00' + n;
      } else if (number < 100) {
        return '0' + n;
      }

      return n;
    }

    const i18n$5 = {
      ariaLabelMonth: labelAriaLabelMonth,
      nextMonth: labelNextMonth,
      previousMonth: labelPreviousMonth,
      today: labelToday,
      yearSelector: labelYearSelector
    };
    const WEEKS_PER_MONTH = 6;
    const DAYS_PER_WEEK = 7;
    const calendarCache = {}; // cache of calendar cells for a given year/month

    class LightningCalendar extends lwc.LightningElement {
      get value() {
        return this.selectedDate;
      }

      set value(newValue) {
        // if value is an ISO string, only fetch the time part
        const dateOnlyString = typeof newValue === 'string' ? newValue.split(TIME_SEPARATOR)[0] : newValue;

        if (dateOnlyString !== this.selectedDate) {
          this.selectedDate = dateOnlyString;

          if (!this._connected) {
            return;
          }

          const newDate = this.parseDate(dateOnlyString); // if the date is invalid, render today's date

          if (!newDate) {
            this.selectedDate = null;
            this.renderToday();
          } else {
            this.selectDate(newDate);
          }
        }
      }

      constructor() {
        super();
        this.calendarYear = null;
        this.calendarMonth = null;
        this.min = void 0;
        this.max = void 0;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready'));
      }

      connectedCallback() {
        this._connected = true;
        this.todayDate = getToday();
        const renderDate = this.getSelectedDate() || this.getTodaysDate();
        this.renderCalendar(renderDate);
        this.keyboardInterface = this.calendarKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the focusable date cell in the calendar.
       */


      focus() {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const dateElement = this.getFocusableDateCell();

          if (dateElement) {
            dateElement.focus();
          }
        });
      }

      get i18n() {
        return i18n$5;
      }

      get computedAriaLabel() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return i18n$5.ariaLabelMonth + getMonthNames()[renderedMonth].fullName;
      }

      get computedMonthTitle() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return getMonthNames()[renderedMonth].fullName;
      }

      get computedWeekdayLabels() {
        const nameOfWeekdays = getNameOfWeekdays();
        const firstDay = this.getFirstDayOfWeek();
        const computedWeekdayLabels = []; // We need to adjust the weekday labels to start from the locale's first day of week

        for (let i = firstDay; i < nameOfWeekdays.length; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        for (let i = 0; i < firstDay; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        return computedWeekdayLabels;
      }

      get computedSelectElementId() {
        return this.uniqueId + '-select';
      }

      get computedWeekdaysElementId() {
        return this.uniqueId + '-weekdays';
      }

      get computedMonthTitleId() {
        return this.uniqueId + '-month';
      }

      get computedYearList() {
        const sampleDate = new Date();
        const currentYear = sampleDate.getFullYear();
        const minDate = this.parseDate(this.min);
        const maxDate = this.parseDate(this.max);
        const minYear = minDate ? minDate.getFullYear() : currentYear - 100;
        const maxYear = maxDate ? maxDate.getFullYear() : currentYear + 100;
        const yearList = [];

        for (let year = minYear; year <= maxYear; year++) {
          yearList.push({
            label: this.getYearDisplayValue(sampleDate, year),
            value: year
          });
        }

        return yearList;
      }

      get monthIndex() {
        return this.getCalendarDate().getMonth();
      }

      getYearDisplayValue(date, yearValue) {
        date.setFullYear(yearValue);
        return toLocalizedDigits(String(toOtherCalendar(date).getFullYear()));
      }

      get computedMonth() {
        if (!this._connected) {
          return [];
        }

        this.removeCurrentlySelectedDateAttributes();
        const selectedDate = this.getSelectedDate();
        const renderDate = this.getCalendarDate();
        const cacheKey = this.getCalendarCacheKey(renderDate, selectedDate);

        if (cacheKey in calendarCache) {
          return calendarCache[cacheKey];
        }

        const todayDate = this.getTodaysDate();
        const focusableDate = this.getInitialFocusDate(todayDate, selectedDate, renderDate);
        const calendarDates = {
          selectedDate,
          renderDate,
          focusableDate,
          todayDate,
          minDate: this.parseDate(this.min),
          maxDate: this.parseDate(this.max)
        };
        const monthCells = [];
        const date = this.getCalendarStartDate(renderDate);

        for (let week = 0; week < WEEKS_PER_MONTH; week++) {
          const weekCells = {
            id: week,
            days: []
          };

          for (let weekday = 0; weekday < DAYS_PER_WEEK; weekday++) {
            const dayCell = this.getDateCellAttributes(date, calendarDates);
            weekCells.days.push(dayCell);
            date.setDate(date.getDate() + 1);
          }

          monthCells.push(weekCells);
        }

        calendarCache[cacheKey] = monthCells;
        return monthCells;
      }

      getDateCellAttributes(date, calendarDates) {
        const isInAdjacentMonth = !this.dateInCalendar(date, calendarDates.renderDate) || !this.isBetween(date, calendarDates.minDate, calendarDates.maxDate);
        const isSelected = this.isSame(date, calendarDates.selectedDate);
        const isToday = this.isSame(date, calendarDates.todayDate);
        const ariaCurrent = isToday ? 'date' : false;
        const tabIndex = this.isSame(date, calendarDates.focusableDate) ? '0' : false;
        const className = classSet().add({
          'slds-is-today': isToday,
          'slds-is-selected': isSelected,
          'slds-day_adjacent-month': isInAdjacentMonth
        }).toString();
        return {
          dayInMonth: toLocalizedDigits(String(date.getDate())),
          dateValue: this.formatDate(date),
          isSelected: isSelected ? 'true' : 'false',
          className,
          tabIndex,
          ariaCurrent
        };
      }

      dispatchSelectEvent() {
        this.dispatchEvent(new CustomEvent('select', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this.selectedDate
          }
        }));
      } // Determines if the date is in the rendered month/year calendar.


      dateInCalendar(date, calendarDate) {
        const renderedCalendar = calendarDate || this.getCalendarDate();
        return date.getMonth() === renderedCalendar.getMonth() && date.getFullYear() === renderedCalendar.getFullYear();
      }

      getInitialFocusDate(todayDate, selectedDate, renderedDate) {
        if (selectedDate && this.dateInCalendar(selectedDate, renderedDate)) {
          return selectedDate;
        }

        if (this.dateInCalendar(todayDate, renderedDate)) {
          return todayDate;
        }

        return new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
      }

      getTodaysDate() {
        if (this.todayDate) {
          return this.parseDate(this.todayDate);
        } // Today's date will be fetched in connectedCallback. In the meantime, use the date based on the device timezone.


        return new Date();
      }

      getSelectedDate() {
        return this.parseDate(this.selectedDate);
      } // returns the month and year in the calendar


      getCalendarDate() {
        if (this.calendarYear) {
          return new Date(this.calendarYear, this.calendarMonth, 1);
        }

        return this.getTodaysDate();
      }

      getCalendarStartDate(renderedDate) {
        const firstDayOfMonth = new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
        return this.getStartOfWeek(firstDayOfMonth);
      }

      getStartOfWeek(dayInWeek) {
        const firstDay = this.getFirstDayOfWeek(); // Negative dates in JS will subtract days from the 1st of the given month

        let startDay = dayInWeek.getDay();

        while (startDay !== firstDay) {
          dayInWeek.setDate(dayInWeek.getDate() - 1);
          startDay = dayInWeek.getDay();
        }

        return dayInWeek;
      }

      getFirstDayOfWeek() {
        return firstDayOfWeek - 1; // In Java, week days are 1 - 7
      } // This method is called when a new value is set, or when you click the today button.
      // In both cases, we need to check if newValue is in the currently rendered calendar


      selectDate(newDate) {
        if (this.dateInCalendar(newDate)) {
          const dateElement = this.getElementByDate(this.formatDate(newDate));
          this.selectDateInCalendar(dateElement);
        } else {
          this.renderCalendar(newDate);
        }
      } // Select a date in current calendar without the need to re-render the calendar


      selectDateInCalendar(dateElement) {
        this.selectedDate = dateElement.getAttribute('data-value');
        this.removeCurrentlySelectedDateAttributes();
        this.addSelectedDateAttributes(dateElement);
      }

      selectDateInCalendarAndDispatchSelect(dateElement) {
        this.selectDateInCalendar(dateElement);
        this.dispatchSelectEvent();
      } // we should be able to control the select value with an attribute once we have a select component


      selectYear(year) {
        const optionElement = this.template.querySelector(`option[value='${year}']`);

        if (optionElement) {
          optionElement.selected = true;
        }
      }

      getElementByDate(dateString) {
        return this.template.querySelector(`td[data-value='${dateString}']`);
      }

      getFocusableDateCell() {
        return this.template.querySelector(`td[tabIndex='0']`);
      }

      unfocusDateCell(element) {
        if (element) {
          element.removeAttribute('tabIndex');
        }
      }

      focusDateCell(element) {
        if (element) {
          element.setAttribute('tabIndex', 0);
          element.focus();
        }
      }

      focusElementByDate(date) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const element = this.getElementByDate(this.formatDate(date));

          if (element) {
            this.unfocusDateCell(this.getFocusableDateCell());
            this.focusDateCell(element);
          }
        });
      }

      renderCalendar(newDate) {
        this.calendarMonth = newDate.getMonth();
        this.calendarYear = newDate.getFullYear();
        this.selectYear(newDate.getFullYear());
      }

      renderToday() {
        const todaysDate = this.getTodaysDate();

        if (this.dateInCalendar(todaysDate)) {
          this.removeCurrentlySelectedDateAttributes();
          this.unfocusDateCell(this.getFocusableDateCell());
          const todayElement = this.getElementByDate(this.todayDate);
          todayElement.setAttribute('tabIndex', 0);
        } else {
          this.renderCalendar(todaysDate);
        }
      }

      removeCurrentlySelectedDateAttributes() {
        const currentlySelectedElement = this.template.querySelector(`td[class*='slds-is-selected']`);

        if (currentlySelectedElement) {
          currentlySelectedElement.classList.remove('slds-is-selected');
          currentlySelectedElement.setAttribute('aria-selected', 'false');
        }

        this.unfocusDateCell(this.getFocusableDateCell());
      }

      addSelectedDateAttributes(dateElement) {
        this.focusDateCell(dateElement);
        dateElement.classList.add('slds-is-selected');
        dateElement.setAttribute('aria-selected', 'true');
      }

      handleCalendarKeyDown(event) {
        const dateString = event.target.getAttribute('data-value');
        handleKeyDownOnCalendar(event, this.parseDate(dateString), this.keyboardInterface);
      }

      handleDateClick(event) {
        event.stopPropagation();
        const tdElement = event.target.parentElement;
        this.selectDateInCalendarAndDispatchSelect(tdElement);
      }

      handleTodayClick(event) {
        event.stopPropagation();
        this.selectedDate = this.todayDate;
        this.selectDate(this.getTodaysDate());
        this.dispatchSelectEvent();
      }

      handleYearSelectClick(event) {
        event.stopPropagation();
      }

      handleYearChange(event) {
        event.stopPropagation();
        const newYearValue = event.target.value;

        if (this.calendarYear !== newYearValue) {
          this.calendarYear = newYearValue;
        }
      }

      goToNextMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() + 1);
        this.renderCalendar(calendarDate);
      }

      goToPreviousMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() - 1);
        this.renderCalendar(calendarDate);
      }

      calendarKeyboardInterface() {
        const that = this;
        return {
          focusDate(newDate) {
            if (!that.dateInCalendar(newDate)) {
              that.renderCalendar(newDate);
            }

            that.focusElementByDate(newDate);
          },

          getStartOfWeek(dayInWeek) {
            return that.getStartOfWeek(dayInWeek);
          },

          selectDate(dateElement) {
            that.selectDateInCalendarAndDispatchSelect(dateElement);
          }

        };
      }

      formatDate(date) {
        return getISODateString(date);
      }

      parseDate(dateString) {
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      isSame(date1, date2) {
        if (!date1 || !date2) {
          return false;
        }

        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate() // getDate returns the day in month whereas getDay returns the weekday number
        ;
      }

      isBetween(date, date1, date2) {
        let isBeforeEndDate = true;
        let isAfterStartDate = true;

        if (date2) {
          isBeforeEndDate = isBefore(date, date2, 'day') || this.isSame(date, date2);
        }

        if (date1) {
          isAfterStartDate = isAfter(date, date1, 'day') || this.isSame(date, date1);
        }

        return isBeforeEndDate && isAfterStartDate;
      }

      getCalendarCacheKey(renderDate, selectedDate) {
        let key = renderDate.getFullYear() + '-' + renderDate.getMonth(); // Having the key include min/max seems enough for now.
        // We're not going to complicate things by checking if renderDate falls before/after the min/max.

        key += this.min ? 'min' + this.min : '';
        key += this.max ? 'max' + this.max : '';

        if (selectedDate && this.dateInCalendar(selectedDate, renderDate)) {
          key += '_' + selectedDate.getDate();
        }

        return key;
      }

    }

    lwc.registerDecorators(LightningCalendar, {
      publicProps: {
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        value: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        calendarYear: 1,
        calendarMonth: 1
      }
    });

    var _lightningCalendar = lwc.registerComponent(LightningCalendar, {
      tmpl: _tmpl$e
    });

    function tmpl$e($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-dropdown-trigger": true,
          "slds-dropdown-trigger_click": true,
          "slds-size_1-of-1": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 7
      }, [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-input-has-icon": true,
          "slds-input-has-icon_right": true
        },
        key: 6
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("input"),
          "name": $cmp.name,
          "placeholder": $cmp.placeholder,
          "aria-label": $cmp.ariaLabel,
          "autocomplete": $cmp.autocomplete
        },
        props: {
          "value": $cmp.displayValue,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 3,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "focusin": _m2 || ($ctx._m2 = api_bind($cmp.onFocusIn)),
          "focusout": _m3 || ($ctx._m3 = api_bind($cmp.handleInputBlur)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeydown)),
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleInputClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "iconName": "utility:event",
          "variant": "bare",
          "disabled": $cmp.computedIconDisabledState,
          "title": $cmp.i18n.selectDate,
          "alternativeText": $cmp.i18n.selectDate
        },
        key: 4,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleDatePickerIconClick)),
          "keydown": _m7 || ($ctx._m7 = api_bind($cmp.handleDatePickerIconKeyDown)),
          "focusin": _m8 || ($ctx._m8 = api_bind($cmp.onFocusIn)),
          "focusout": _m9 || ($ctx._m9 = api_bind($cmp.onFocusOut))
        }
      }, []), $cmp.isCalendarVisible ? api_custom_element("lightning-calendar", _lightningCalendar, {
        props: {
          "value": $cmp.value,
          "min": $cmp.min,
          "max": $cmp.max
        },
        key: 5,
        on: {
          "select": _m10 || ($ctx._m10 = api_bind($cmp.handleDateSelect)),
          "ready": _m11 || ($ctx._m11 = api_bind($cmp.startPositioning)),
          "keydown": _m12 || ($ctx._m12 = api_bind($cmp.handleCalendarKeyDown)),
          "focusin": _m13 || ($ctx._m13 = api_bind($cmp.onFocusIn)),
          "focusout": _m14 || ($ctx._m14 = api_bind($cmp.onFocusOut))
        }
      }, []) : null])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 8
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$f = lwc.registerTemplate(tmpl$e);
    tmpl$e.stylesheets = [];
    tmpl$e.stylesheetTokens = {
      hostAttribute: "lightning-datepicker_datepicker-host",
      shadowAttribute: "lightning-datepicker_datepicker"
    };

    var labelInvalidDate = 'Your entry does not match the allowed format {0}.';

    var labelRangeOverflow$1 = 'Value must be {0} or earlier.';

    var labelRangeUnderflow$1 = 'Value must be {0} or later.';

    var labelSelectDate = 'Select a date';

    var shortDateFormat = 'M/d/yyyy';

    var longDateFormat = 'MMMM d, yyyy';

    function handleKeyDownOnDatePickerIcon(event, datepickerInterface) {
      switch (normalizeKeyValue(event.key)) {
        case 'Enter':
        case ' ':
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.showCalendar();
          break;

        case 'Escape':
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.hideCalendar();
          break;
      }
    }
    function handleBasicKeyDownBehaviour(event, datepickerInterface) {
      if (!datepickerInterface.isCalendarVisible()) {
        return;
      }

      if (normalizeKeyValue(event.key) === 'Escape') {
        preventDefaultAndStopPropagation$1(event);
        datepickerInterface.hideCalendar();
      }
    }

    function preventDefaultAndStopPropagation$1(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    const i18n$6 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      selectDate: labelSelectDate
    };
    const ARIA_CONTROLS$1 = 'aria-controls';
    const ARIA_LABEL = 'aria-label';
    const ARIA_LABELLEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$2 = 'aria-describedby';
    const DATE_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningDatePicker extends lwc.LightningElement {
      get messageWhenBadInput() {
        return this._messageWhenBadInput || formatLabel(this.i18n.invalidDate, this.dateFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || formatLabel(this.i18n.rangeOverflow, this.max);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || formatLabel(this.i18n.rangeUnderflow, this.min);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      } // setter is required to properly trigger update


      get ariaLabel() {
        return this._ariaLabel;
      }

      set ariaLabel(val) {
        this._ariaLabel = val;
        this.synchronizeA11y();
      }

      set ariaLabelledByElement(el) {
        this._ariaLabelledBy = el;
        this.synchronizeA11y();
      }

      get ariaLabelledByElement() {
        return this._ariaLabelledBy;
      }

      set ariaControlsElement(el) {
        this._ariaControls = el;
        this.synchronizeA11y();
      }

      get ariaControlsElement() {
        return this._ariaControls;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedBy = el;
        } else {
          this._ariaDescribedBy = [el];
        }

        this.synchronizeA11y();
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedBy;
      }

      get ariaLabelledbyId() {
        return getRealDOMId(this._ariaLabelledBy);
      }

      get ariaControlsId() {
        return getRealDOMId(this.ariaControlsElement);
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY]: this.ariaLabelledbyId,
          [ARIA_DESCRIBEDBY$2]: this.computedAriaDescribedby,
          [ARIA_CONTROLS$1]: this.ariaControlsId,
          [ARIA_LABEL]: this._ariaLabel
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedDate = normalizeISODate(newValue, this.dateFormat);
        this._value = normalizedDate.isoValue;
        this._displayValue = normalizedDate.displayValue;
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      focus() {
        if (this.connected) {
          this.inputElement.focus();
        }
      }

      blur() {
        if (this.connected) {
          this.inputElement.blur();
        }
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      get dateStyle() {
        return this._dateStyle;
      }

      set dateStyle(value) {
        this._dateStyle = normalizeString(value, {
          fallbackValue: DATE_STYLE.MEDIUM,
          validValues: [DATE_STYLE.SHORT, DATE_STYLE.MEDIUM, DATE_STYLE.LONG]
        });
        this.dateFormat = this.getDateFormatFromStyle(this._dateStyle);
        const normalizedDate = normalizeISODate(this._value, this.dateFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._value = null;
        this._calendarVisible = false;
        this._displayValue = null;
        this._errorMessage = '';
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this.label = void 0;
        this.name = void 0;
        this.max = void 0;
        this.min = void 0;
        this.placeholder = void 0;
        this.autocomplete = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaLabelledBy = void 0;
        this._ariaControls = void 0;
        this._ariaDescribedBy = [];
        this.uniqueId = generateUniqueId();
      }

      connectedCallback() {
        this.connected = true;
        this.keyboardInterface = this.datepickerKeyboardInterface();
      }

      disconnectedCallback() {
        this.connected = false;
      }

      get i18n() {
        return i18n$6;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedUniqueErrorMessageElementId() {
        const el = this.template.querySelector('[data-error-message]');
        return getRealDOMId(el);
      }

      get isCalendarVisible() {
        return this._calendarVisible;
      }

      get displayValue() {
        return this._displayValue;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get computedIconDisabledState() {
        return this.disabled || this.readOnly;
      }

      get computedAriaDescribedby() {
        const ariaValues = [];

        if (this.errorMessage) {
          ariaValues.push(this.computedUniqueErrorMessageElementId);
        }

        this._ariaDescribedBy.forEach(item => {
          const id = getRealDOMId(item);

          if (id) {
            ariaValues.push(id);
          }
        });

        return normalizeAriaAttribute(ariaValues);
      }

      handleInputChange(event) {
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.currentTarget.value;
        this._value = this.parseFormattedDate(this._displayValue);
        this.dispatchChangeEvent();
      }

      handleInput() {
        // keeping the display value in sync with the element's value
        this._displayValue = this.inputElement.value; // IE11 fires an input event along with the click event when the element has a placeholder.
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/
        // remove this block when we stop support for IE11

        if (isIE11 && this.placeholder !== undefined) {
          return;
        } // Making sure that the focus remains on the input and we're not triggering leave


        this.hideCalendarAndFocusTrigger();
      }

      handleInputBlur() {
        if (this._value !== null) {
          const normalizedDate = normalizeISODate(this._value, this.dateFormat);
          this._displayValue = normalizedDate.displayValue;
        }

        this.onFocusOut();
      }

      handleInputClick(event) {
        if (this.readOnly) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showCalendar();
      }
      /**
       * When the element gains focus this function is called.
       */


      onFocusIn() {
        if (this._pendingFocusOut) {
          this._pendingFocusOut = false;
        }

        if (!this._focused) {
          this.dispatchEvent(new CustomEvent('focus'));
        }

        this._focused = true;
      }
      /**
       * When the element looses its focus this function is called.
       */


      onFocusOut() {
        // This assumes that a focusin will be dispatched after a focusout
        this._pendingFocusOut = true; // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          if (this._pendingFocusOut) {
            this._focused = false;
            this.hideCalendar();
            this.dispatchEvent(new CustomEvent('blur'));
          }
        });
      }

      handleDatePickerIconClick(event) {
        if (this.readOnly || this.disabled) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showAndFocusCalendar();
      }

      handleInputKeydown(event) {
        this.calendarTrigger = event.target;
        handleBasicKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDatePickerIconKeyDown(event) {
        this.calendarTrigger = event.target;
        handleKeyDownOnDatePickerIcon(event, this.keyboardInterface);
      }

      handleCalendarKeyDown(event) {
        handleBasicKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDateSelect(event) {
        event.stopPropagation();
        this._value = event.detail.value;
        this._displayValue = normalizeISODate(this._value, this.dateFormat).displayValue;
        this.hideCalendarAndFocusTrigger();
        this.dispatchChangeEvent();
      }

      showAndFocusCalendar() {
        this.showCalendar(); // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          this.focusCalendar();
        });
      }

      hideCalendarAndFocusTrigger() {
        this.hideCalendar();

        if (this.calendarTrigger) {
          this.calendarTrigger.focus();
        }
      }

      focusCalendar() {
        const calendar = this.template.querySelector('lightning-calendar');

        if (calendar) {
          calendar.focus();
        }
      }

      startPositioning() {
        if (!this._relationship) {
          this._relationship = startPositioning(this, {
            target: () => this.template.querySelector('input'),
            element: () => this.template.querySelector('lightning-calendar').shadowRoot.querySelector('div'),
            align: {
              horizontal: Direction.Right,
              vertical: Direction.Top
            },
            targetAlign: {
              horizontal: Direction.Right,
              vertical: Direction.Bottom
            },
            autoFlip: true,
            // Auto flip direction if not have enough space
            leftAsBoundary: true // horizontal flip uses target left as boundary

          });
        } else {
          this._relationship.reposition();
        }
      }

      stopPositioning() {
        if (this._relationship) {
          stopPositioning(this._relationship);
          this._relationship = null;
        }
      }

      showCalendar() {
        if (!this.isCalendarVisible) {
          this.rootElement.classList.add('slds-is-open');
          this._calendarVisible = true;
        }
      }

      hideCalendar() {
        if (this.isCalendarVisible) {
          this.rootElement.classList.remove('slds-is-open');
          this.stopPositioning();
          this._calendarVisible = false;
        }
      }

      get rootElement() {
        return this.template.querySelector('div');
      }

      get inputElement() {
        return this.template.querySelector('input');
      }

      get dateFormat() {
        if (!this._dateFormat) {
          this._dateFormat = this.getDateFormatFromStyle();
        }

        return this._dateFormat;
      }

      set dateFormat(value) {
        this._dateFormat = value;
      }

      getDateFormatFromStyle(dateStyle) {
        let dateFormat;

        switch (dateStyle) {
          case DATE_STYLE.SHORT:
            dateFormat = shortDateFormat;
            break;

          case DATE_STYLE.LONG:
            dateFormat = longDateFormat;
            break;

          default:
            dateFormat = mediumDateFormat;
            break;
        }

        return dateFormat;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      datepickerKeyboardInterface() {
        const that = this;
        return {
          showCalendar() {
            that.showAndFocusCalendar();
          },

          hideCalendar() {
            that.hideCalendarAndFocusTrigger();
          },

          isCalendarVisible() {
            return that.isCalendarVisible;
          }

        };
      }

      parse(dateString) {
        // We cannot use parseDateTimeISO8601 here because that method does not have a strict flag. If the value is not an ISO string, that method will parse using the native Date()
        // Alternatively we could call isValidISODateTimeString and then parseDateTimeISO8601.
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      get allowedDateFormats() {
        // We should prioritize the long, because a long date matched with the medium format. An issue in aura?
        // Ex: September 8, 2017 when be parsed with the medium format, returns a valid iso date.
        return [longDateFormat, mediumDateFormat, shortDateFormat];
      }
      /**
       * Parses the input date and sets the dateFormat used to parse the displayValue
       * if it is a valid Date.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted date if displayValue is valid. null otherwise.
       */


      parseFormattedDate(displayValue) {
        const allowedFormats = this.allowedDateFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedDate(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        return value;
      }

    }

    LightningDatePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDatePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        max: {
          config: 0
        },
        min: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaLabelledByElement: {
          config: 3
        },
        ariaControlsElement: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        dateStyle: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "showHelpMessage", "hasBadInput"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _value: 1,
        _calendarVisible: 1,
        _displayValue: 1,
        _errorMessage: 1,
        _fieldLevelHelp: 1,
        _variant: 1
      },
      fields: ["_ariaLabelledBy", "_ariaControls", "_ariaDescribedBy"]
    });

    var _lightningDatepicker = lwc.registerComponent(LightningDatePicker, {
      tmpl: _tmpl$f
    });

    function stylesheet$5(hostSelector, shadowSelector, nativeShadow) {
      return ".slds-inline-logo" + shadowSelector + " {height: 1rem;margin-top: 1rem;margin-bottom: 1rem;}\n";
    }
    var _implicitStylesheets$5 = [stylesheet$5];

    function tmpl$f($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.state.iconName,
          "size": $cmp.size,
          "variant": $cmp.variant,
          "src": $cmp.state.src
        },
        key: 0
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.alternativeText)]) : null];
    }

    var _tmpl$g = lwc.registerTemplate(tmpl$f);
    tmpl$f.stylesheets = [];
    tmpl$f.stylesheetTokens = {
      hostAttribute: "lightning-icon_icon-host",
      shadowAttribute: "lightning-icon_icon"
    };

    /**
     * Represents a visual element that provides context and enhances usability.
     */

    class LightningIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {};
        this.alternativeText = void 0;
      }

      /**
       * A uri path to a custom svg sprite, including the name of the resouce,
       * for example: /assets/icons/standard-sprite/svg/test.svg#icon-heart
       * @type {string}
       */
      get src() {
        return this.privateSrc;
      }

      set src(value) {
        this.privateSrc = value; // if value is not present, then we set the state back
        // to the original iconName that was passed
        // this might happen if the user sets a custom icon, then
        // decides to revert back to SLDS by removing the src attribute

        if (!value) {
          this.state.iconName = this.iconName;
          this.classList.remove('slds-icon-standard-default');
        } // if isIE11 and the src is set
        // we'd like to show the 'standard:default' icon instead
        // for performance reasons.


        if (value && isIE11) {
          this.setDefault();
          return;
        }

        this.state.src = value;
      }
      /**
       * The Lightning Design System name of the icon.
       * Names are written in the format 'utility:down' where 'utility' is the category,
       * and 'down' is the specific icon to be displayed.
       * @type {string}
       * @required
       */


      get iconName() {
        return this.privateIconName;
      }

      set iconName(value) {
        this.privateIconName = value; // if src is set, we don't need to validate
        // iconName

        if (this.src) {
          return;
        }

        if (isValidName(value)) {
          const isAction = getCategory(value) === 'action'; // update classlist only if new iconName is different than state.iconName
          // otherwise classListMutation receives class:true and class: false and removes slds class

          if (value !== this.state.iconName) {
            classListMutation(this.classList, {
              'slds-icon_container_circle': isAction,
              [computeSldsClass(value)]: true,
              [computeSldsClass(this.state.iconName)]: false
            });
          }

          this.state.iconName = value;
        } else {
          console.warn(`<lightning-icon> Invalid icon name ${value}`); // eslint-disable-line no-console
          // Invalid icon names should render a blank icon. Remove any
          // classes that might have been previously added.

          classListMutation(this.classList, {
            'slds-icon_container_circle': false,
            [computeSldsClass(this.state.iconName)]: false
          });
          this.state.iconName = undefined;
        }
      }
      /**
       * The size of the icon. Options include xx-small, x-small, small, medium, or large.
       * The default is medium.
       * @type {string}
       * @default medium
       */


      get size() {
        return normalizeString(this.state.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      set size(value) {
        this.state.size = value;
      }
      /**
       * The variant changes the appearance of a utility icon.
       * Accepted variants include inverse, success, warning, and error.
       * Use the inverse variant to implement a white fill in utility icons on dark backgrounds.
       * @type {string}
       */


      get variant() {
        return normalizeVariant$1(this.state.variant, this.state.iconName);
      }

      set variant(value) {
        this.state.variant = value;
      }

      connectedCallback() {
        this.classList.add('slds-icon_container');
      }

      setDefault() {
        this.state.src = undefined;
        this.state.iconName = 'standard:default';
        this.classList.add('slds-icon-standard-default');
      }

    }

    lwc.registerDecorators(LightningIcon, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        src: {
          config: 3
        },
        iconName: {
          config: 3
        },
        size: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var _lightningIcon = lwc.registerComponent(LightningIcon, {
      tmpl: _tmpl$g
    });

    function normalizeVariant$1(variant, iconName) {
      // Unfortunately, the `bare` variant was implemented to do what the
      // `inverse` variant should have done. Keep this logic for as long as
      // we support the `bare` variant.
      if (variant === 'bare') {
        // TODO: Deprecation warning using strippable assertion
        variant = 'inverse';
      }

      if (getCategory(iconName) === 'utility') {
        return normalizeString(variant, {
          fallbackValue: '',
          validValues: ['error', 'inverse', 'warning', 'success']
        });
      }

      return 'inverse';
    }

    function tmpl$g($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator,
        f: api_flatten
      } = $api;
      return api_flatten([$cmp.hasParts ? api_iterator($cmp.text, function (item) {
        return [item.part.highlight ? api_element("strong", {
          key: api_key(0, item.key)
        }, [api_dynamic(item.part.text)]) : null, !item.part.highlight ? api_dynamic(item.part.text) : null];
      }) : [], !$cmp.hasParts ? api_dynamic($cmp.text) : null]);
    }

    var _tmpl$h = lwc.registerTemplate(tmpl$g);
    tmpl$g.stylesheets = [];
    tmpl$g.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText-host",
      shadowAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText"
    };

    class LightningBaseComboboxFormattedText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._text = '';
        this.hasParts = void 0;
      }

      get text() {
        return this._text;
      }

      set text(value) {
        this.hasParts = Array.isArray(value) && value.length > 0;

        if (this.hasParts) {
          // Generate keys for LWC DOM
          this._text = value.map((part, i) => ({
            part,
            key: i
          }));
        } else {
          this._text = value;
        }
      }

    }

    lwc.registerDecorators(LightningBaseComboboxFormattedText, {
      publicProps: {
        text: {
          config: 3
        }
      },
      track: {
        _text: 1,
        hasParts: 1
      }
    });

    var _lightningBaseComboboxFormattedText = lwc.registerComponent(LightningBaseComboboxFormattedText, {
      tmpl: _tmpl$h
    });

    function tmpl$h($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true
        },
        key: 1
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.iconSize,
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName
        },
        key: 0
      }, [])]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 8
      }, [api_element("span", {
        classMap: {
          "slds-listbox__option-text": true,
          "slds-listbox__option-text_entity": true
        },
        key: 4
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 2
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.text,
          "text": $cmp.item.text
        },
        key: 3
      }, []) : null]), $cmp.hasSubText ? api_element("span", {
        classMap: {
          "slds-listbox__option-meta": true,
          "slds-listbox__option-meta_entity": true
        },
        key: 7
      }, [!$cmp.subTextHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.subText
        },
        key: 5
      }, [api_dynamic($cmp.item.subText)]) : null, $cmp.subTextHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.subText,
          "text": $cmp.item.subText
        },
        key: 6
      }, []) : null]) : null]), $cmp.item.rightIconName ? api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-media__figure_reverse": true
        },
        key: 10
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.rightIconSize,
          "alternativeText": $cmp.item.rightIconAlternativeText,
          "iconName": $cmp.item.rightIconName
        },
        key: 9
      }, [])]) : null];
    }

    var card = lwc.registerTemplate(tmpl$h);
    tmpl$h.stylesheets = [];
    tmpl$h.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_card-host",
      shadowAttribute: "lightning-baseComboboxItem_card"
    };

    function tmpl$i($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-listbox__option-icon": true
        },
        key: 1
      }, [$cmp.item.iconName ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName,
          "size": "x-small"
        },
        key: 0
      }, []) : null]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 4
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 2
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "text": $cmp.item.text,
          "title": $cmp.text
        },
        key: 3
      }, []) : null])];
    }

    var inline = lwc.registerTemplate(tmpl$i);
    tmpl$i.stylesheets = [];
    tmpl$i.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_inline-host",
      shadowAttribute: "lightning-baseComboboxItem_inline"
    };

    class LightningBaseComboboxItem extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.item = {};
      }

      connectedCallback() {
        // We want to make sure that the item has 'aria-selected' if it's selectable
        if (this.item.selectable) {
          this.setAttribute('aria-selected', 'false');
        }

        if (this.item.type === 'option-inline') {
          this.classList.add('slds-media_small', 'slds-listbox__option_plain');
        } else {
          this.classList.add('slds-listbox__option_entity');
        }
      }

      get textHasParts() {
        const text = this.item.text;
        return text && Array.isArray(text) && text.length > 0;
      }

      get subTextHasParts() {
        const subText = this.item.subText;
        return subText && Array.isArray(subText) && subText.length > 0;
      } // Return html based on the specified item type


      render() {
        if (this.item.type === 'option-card') {
          return card;
        }

        return inline;
      }

      highlight() {
        this.toggleHighlight(true);
      }

      removeHighlight() {
        this.toggleHighlight(false);
      }

      toggleHighlight(highlighted) {
        if (this.item.selectable) {
          this.setAttribute('aria-selected', highlighted ? 'true' : 'false');
          this.classList.toggle('slds-has-focus', highlighted);
        }
      } // Parts are needed for highlighting


      partsToText(parts) {
        if (parts && Array.isArray(parts) && parts.length > 0) {
          return parts.map(part => part.text).join('');
        }

        return parts;
      }

      get rightIconSize() {
        return this.item.rightIconSize || 'small';
      }

      get iconSize() {
        return this.item.iconSize || 'small';
      }

      get text() {
        return this.partsToText(this.item.text);
      }

      get subText() {
        return this.partsToText(this.item.subText);
      }

      get hasSubText() {
        const subText = this.item.subText;
        return subText && subText.length > 0;
      }

    }

    lwc.registerDecorators(LightningBaseComboboxItem, {
      publicProps: {
        item: {
          config: 0
        }
      },
      publicMethods: ["highlight", "removeHighlight"]
    });

    var _lightningBaseComboboxItem = lwc.registerComponent(LightningBaseComboboxItem, {
      tmpl: _tmpl$3
    });

    function tmpl$j($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        b: api_bind,
        h: api_element,
        d: api_dynamic,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [api_element("div", {
        className: $cmp.computedDropdownTriggerClass,
        attrs: {
          "role": "combobox",
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-haspopup": "listbox"
        },
        key: 29,
        on: {
          "click": _m14 || ($ctx._m14 = api_bind($cmp.handleTriggerClick))
        }
      }, [api_element("div", {
        className: $cmp.computedFormElementClass,
        attrs: {
          "role": "none"
        },
        key: 12
      }, [$cmp.hasInputPill ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-combobox__input-entity-icon": true
        },
        props: {
          "iconName": $cmp.inputPill.iconName,
          "alternativeText": $cmp.inputPill.iconAlternativeText,
          "size": "x-small"
        },
        key: 0
      }, []) : null, api_element("input", {
        className: $cmp.computedInputClass,
        attrs: {
          "id": api_scoped_id("input"),
          "type": "text",
          "role": "textbox",
          "autocomplete": "off",
          "name": $cmp.name,
          "placeholder": $cmp.computedPlaceholder,
          "maxlength": $cmp.inputMaxlength,
          "aria-autocomplete": $cmp.computedAriaAutocomplete,
          "aria-label": $cmp.inputLabel
        },
        props: {
          "required": $cmp.required,
          "value": $cmp.computedInputValue,
          "disabled": $cmp.disabled,
          "readOnly": $cmp._inputReadOnly
        },
        key: 1,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleInputSelect)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleTextChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeyDown)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur))
        }
      }, []), $cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 5
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true,
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        attrs: {
          "type": "button",
          "title": $cmp.i18n.pillCloseButtonAlternativeText
        },
        key: 4,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handlePillRemove))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:close",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 2
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.i18n.pillCloseButtonAlternativeText)])])]) : null, !$cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 11
      }, [$cmp.showInputActivityIndicator ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 9
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 7
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 8
      }, [])]) : null, $cmp.inputIconName ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "alternativeText": $cmp.inputIconAlternativeText,
          "iconName": $cmp.inputIconName,
          "size": $cmp.inputIconSize
        },
        key: 10
      }, []) : null]) : null]), api_element("div", {
        className: $cmp.computedDropdownClass,
        attrs: {
          "id": api_scoped_id("dropdown-element"),
          "data-dropdown-element": true,
          "role": "listbox"
        },
        key: 28,
        on: {
          "scroll": _m9 || ($ctx._m9 = api_bind($cmp.handleListboxScroll)),
          "mousedown": _m10 || ($ctx._m10 = api_bind($cmp.handleDropdownMouseDown)),
          "mouseup": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownMouseUp)),
          "mouseleave": _m12 || ($ctx._m12 = api_bind($cmp.handleDropdownMouseLeave)),
          "click": _m13 || ($ctx._m13 = api_bind($cmp.handleOptionClick))
        }
      }, $cmp._hasDropdownOpened ? api_flatten([api_iterator($cmp._items, function (item) {
        return [!item.items ? api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-media_center": true
          },
          attrs: {
            "data-item-id": item.id,
            "data-value": item.value
          },
          props: {
            "role": "option",
            "item": item,
            "id": api_scoped_id(item.id)
          },
          key: api_key(13, item.value),
          on: {
            "mouseenter": _m7 || ($ctx._m7 = api_bind($cmp.handleOptionMouseEnter))
          }
        }, []) : null, item.items ? api_element("ul", {
          attrs: {
            "role": "group",
            "aria-label": item.label
          },
          key: api_key(19, item.label)
        }, api_flatten([item.label ? api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 16
        }, [api_element("div", {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-listbox__option_plain": true,
            "slds-media_small": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 15
        }, [api_element("h3", {
          attrs: {
            "role": "presentation",
            "title": item.label
          },
          key: 14
        }, [api_dynamic(item.label)])])]) : null, api_iterator(item.items, function (groupItem) {
          return api_element("li", {
            classMap: {
              "slds-listbox__item": true
            },
            attrs: {
              "role": "presentation"
            },
            key: api_key(18, groupItem.value)
          }, [api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
            classMap: {
              "slds-media": true,
              "slds-listbox__option": true,
              "slds-media_center": true
            },
            attrs: {
              "data-item-id": groupItem.id,
              "data-value": groupItem.value
            },
            props: {
              "role": "option",
              "item": groupItem,
              "id": api_scoped_id(groupItem.id)
            },
            key: 17,
            on: {
              "mouseenter": _m8 || ($ctx._m8 = api_bind($cmp.handleOptionMouseEnter))
            }
          }, [])]);
        })])) : null];
      }), $cmp.showDropdownActivityIndicator ? api_element("div", {
        classMap: {
          "slds-listbox__item": true
        },
        attrs: {
          "role": "presentation"
        },
        key: 25
      }, [api_element("div", {
        classMap: {
          "slds-align_absolute-center": true,
          "slds-p-top_medium": true
        },
        key: 24
      }, [api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_x-small": true,
          "slds-spinner_inline": true
        },
        attrs: {
          "role": "status"
        },
        key: 23
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 20
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 21
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 22
      }, [])])])]) : null, $cmp.showAttribution ? api_element("div", {
        classMap: {
          "slds-align_absolute-center": true
        },
        key: 27
      }, [api_element("img", {
        classMap: {
          "slds-inline-logo": true
        },
        attrs: {
          "src": $cmp.attributionLogoUrl,
          "alt": $cmp.attributionLogoAssistiveText,
          "title": $cmp.attributionLogoAssistiveText
        },
        key: 26
      }, [])]) : null]) : [])])];
    }

    var _tmpl$i = lwc.registerTemplate(tmpl$j);
    tmpl$j.stylesheets = [];

    if (_implicitStylesheets$5) {
      tmpl$j.stylesheets.push.apply(tmpl$j.stylesheets, _implicitStylesheets$5);
    }
    tmpl$j.stylesheetTokens = {
      hostAttribute: "lightning-baseCombobox_baseCombobox-host",
      shadowAttribute: "lightning-baseCombobox_baseCombobox"
    };

    var labelAriaSelectedOptions = 'Selected Options:';

    var labelDeselectOptionKeyboard = 'Press delete or backspace to remove';

    var labelLoadingText = 'Loading';

    var labelPillCloseButtonAlternativeText = 'Clear Selection';

    function preventDefaultAndStopPropagation$2(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function handleEnterKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (dropdownInterface.isDropdownVisible() && currentIndex >= 0) {
        dropdownInterface.selectByIndex(currentIndex);
      } else {
        dropdownInterface.openDropdownIfNotEmpty();
      }
    }

    function handlePageUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const pageUpDownOptionSkipCount = 10;

      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          let highlightIndex = 0;

          if (event.key === 'PageUp') {
            highlightIndex = Math.max(currentIndex - pageUpDownOptionSkipCount, 0);
          } else {
            // Jump 10 options down
            highlightIndex = Math.min(currentIndex + pageUpDownOptionSkipCount, dropdownInterface.getTotalOptions() - 1);
          }

          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleHomeOrEndKey({
      event,
      dropdownInterface
    }) {
      // If not a read-only input we want the default browser behaviour
      if (!dropdownInterface.isInputReadOnly()) {
        return;
      }

      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const highlightIndex = event.key === 'Home' ? 0 : dropdownInterface.getTotalOptions() - 1;
          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const isUpKey = event.key === 'Up' || event.key === 'ArrowUp';
      let nextIndex;

      if (currentIndex >= 0) {
        nextIndex = isUpKey ? currentIndex - 1 : currentIndex + 1;

        if (nextIndex >= dropdownInterface.getTotalOptions()) {
          nextIndex = 0;
        } else if (nextIndex < 0) {
          nextIndex = dropdownInterface.getTotalOptions() - 1;
        }
      } else {
        nextIndex = isUpKey ? dropdownInterface.getTotalOptions() - 1 : 0;
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          dropdownInterface.highlightOptionWithIndex(nextIndex);
        });
      }
    }

    function handleEscapeOrTabKey({
      event,
      dropdownInterface
    }) {
      if (dropdownInterface.isDropdownVisible()) {
        event.stopPropagation();
        dropdownInterface.closeDropdown();
      }
    }

    function handleTypedCharacters({
      event,
      currentIndex,
      dropdownInterface
    }) {
      if (event.key && event.key.length > 1) {
        // not a printable character
        return;
      }

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.isInputReadOnly()) {
        // The element should be read only, it's a work-around for IE11 as it will still make editable an input
        // that has focus and was dynamically changed to be readonly on focus change. Remove once we no longer
        // support IE11
        event.preventDefault(); // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => runActionOnBufferedTypedCharacters(event, dropdownInterface.highlightOptionWithText.bind(this, currentIndex || 0)));
      }
    }

    const eventKeyToHandlerMap = {
      Enter: handleEnterKey,
      PageUp: handlePageUpOrDownKey,
      PageDown: handlePageUpOrDownKey,
      Home: handleHomeOrEndKey,
      End: handleHomeOrEndKey,
      Down: handleUpOrDownKey,
      // IE11/Edge specific
      Up: handleUpOrDownKey,
      // IE11/Edge specific
      ArrowUp: handleUpOrDownKey,
      ArrowDown: handleUpOrDownKey,
      Esc: handleEscapeOrTabKey,
      // IE11/Edge specific
      Escape: handleEscapeOrTabKey,
      Tab: handleEscapeOrTabKey
    };
    function handleKeyDownOnInput({
      event,
      currentIndex,
      dropdownInterface
    }) {
      const parameters = {
        event,
        currentIndex,
        dropdownInterface
      };

      if (eventKeyToHandlerMap[event.key]) {
        eventKeyToHandlerMap[event.key](parameters);
      } else {
        handleTypedCharacters(parameters);
      }
    }

    class BaseComboboxEvents {
      constructor(baseCombobox) {
        this.dispatchEvent = baseCombobox.dispatchEvent.bind(baseCombobox);
      }

      dispatchPillRemove(pill) {
        this.dispatchEvent(new CustomEvent('pillremove', {
          detail: {
            item: pill
          }
        }));
      }

      dispatchEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }

      dispatchFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      dispatchBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchTextInput(text) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text
          }
        }));
      }

      dispatchTextChange(text) {
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text
          }
        }));
      }

      dispatchSelect(value) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value
          }
        }));
      }

      dispatchDropdownOpen() {
        this.dispatchEvent(new CustomEvent('dropdownopen'));
      }

      dispatchDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }

    }

    const i18n$7 = {
      ariaSelectedOptions: labelAriaSelectedOptions,
      deselectOptionKeyboard: labelDeselectOptionKeyboard,
      pillCloseButtonAlternativeText: labelPillCloseButtonAlternativeText,
      loadingText: labelLoadingText
    };
    const SMALL_MIN_HEIGHT = '2.25rem';
    const MEDIUM_MIN_HEIGHT = '6.75rem';
    const ARIA_CONTROLS$2 = 'aria-controls';
    const ARIA_LABELLEDBY$1 = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$3 = 'aria-describedby';
    const ARIA_LABEL$1 = 'aria-label';
    const ARIA_ACTIVEDESCENDANT = 'aria-activedescendant';

    class LightningBaseCombobox extends lwc.LightningElement {
      constructor() {
        super();
        this.inputText = '';
        this.inputIconName = 'utility:down';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showInputActivityIndicator = false;
        this.required = false;
        this.dropdownAlignment = 'left';
        this.placeholder = 'Select an Item';
        this.inputLabel = void 0;
        this.name = void 0;
        this.inputPill = void 0;
        this.attributionLogoUrl = void 0;
        this.attributionLogoAssistiveText = void 0;
        this._showDropdownActivityIndicator = false;
        this._items = [];
        this._disabled = false;
        this._dropdownVisible = false;
        this._hasDropdownOpened = false;
        this._highlightedOptionElementId = null;
        this._variant = void 0;
        this._dropdownHeight = 'standard';
        this._readonly = false;
        this._logoLoaded = false;
        this._inputDescribedBy = [];
        this._inputAriaControls = void 0;
        this._activeElementDomId = void 0;
        this._events = new BaseComboboxEvents(this);
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready', {
          detail: {
            id: this.inputId,
            name: this.name
          }
        }));
        this.synchronizeA11y();
      }

      connectedCallback() {
        this.classList.add('slds-combobox_container');
        this._connected = true;
        this._keyboardInterface = this.dropdownKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
        this._listBoxElementCache = undefined;
      }

      get inputControlsElement() {
        return this._inputAriaControls;
      }

      set inputControlsElement(el) {
        this._inputAriaControls = el;
        this.synchronizeA11y();
      }

      get inputDescribedByElements() {
        return this._inputDescribedBy;
      }

      set inputDescribedByElements(elements) {
        if (Array.isArray(elements)) {
          this._inputDescribedBy = elements;
        } else {
          this._inputDescribedBy = [elements];
        }

        this.synchronizeA11y();
      }

      get inputLabelledByElement() {
        return this._inputLabelledBy;
      }

      set inputLabelledByElement(el) {
        this._inputLabelledBy = el;
        this.synchronizeA11y();
      }

      get inputLabelledById() {
        return getRealDOMId(this._inputLabelledBy);
      }

      get inputAriaControlsId() {
        return getRealDOMId(this._inputAriaControls);
      }

      get inputId() {
        return getRealDOMId(this.template.querySelector('input'));
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        this._inputDescribedBy.forEach(el => {
          ariaValues.push(getRealDOMId(el));
        });

        return normalizeAriaAttribute(ariaValues);
      }

      get dropdownHeight() {
        return this._dropdownHeight;
      }

      set dropdownHeight(height) {
        this._dropdownHeight = normalizeString(height, {
          fallbackValue: 'standard',
          validValues: ['standard', 'small']
        });
      }

      get showDropdownActivityIndicator() {
        return this._showDropdownActivityIndicator;
      }

      set showDropdownActivityIndicator(value) {
        this._showDropdownActivityIndicator = normalizeBoolean(value);

        if (this._connected) {
          if (this._showDropdownActivityIndicator) {
            if (this._shouldOpenDropDown) {
              this.openDropdownIfNotEmpty();
            }
          } else if (this._dropdownVisible && this.isDropdownEmpty) {
            this.closeDropdown();
          }
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: VARIANT.STANDARD,
          validValues: [VARIANT.STANDARD, 'lookup']
        });
      }

      get items() {
        return this._unprocessedItems;
      }

      set items(items = []) {
        this._unprocessedItems = items;

        if (this._connected) {
          if (this._hasDropdownOpened) {
            // The dropdown has already been opened at least once, so process the items immediately
            this.updateItems(items);

            if (this._dropdownVisible) {
              // The dropdown is visible but there are no items to show, close it
              if (this.isDropdownEmpty) {
                this.closeDropdown();
              } else {
                // We have new items, update highlight
                this.highlightDefaultItem(); // Since the items have changed, the positioning should be recomputed
                // remove-next-line-for-c-namespace

                this.startDropdownAutoPositioning();
              }
            }
          }

          if (this._shouldOpenDropDown) {
            this.openDropdownIfNotEmpty();
          }
        }
      }

      highlightInputText() {
        if (this._connected) {
          // Safari has issues with invoking set selection range immediately in the 'focus' handler, instead
          // we'd be doing it in an animation frame. Remove the requestAnimationFrame once/if this is fixed
          // in Safari
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            const {
              inputElement
            } = this;
            inputElement.setSelectionRange(0, inputElement.value.length);
          });
        }
      }

      get showAttribution() {
        return this.attributionLogoUrl;
      }

      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }

      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          if (!this._inputHasFocus) {
            this.focus();
          }

          this.openDropdownIfNotEmpty();
        }
      }

      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY$1]: this.inputLabelledById,
          [ARIA_DESCRIBEDBY$3]: this.computedAriaDescribedBy,
          [ARIA_ACTIVEDESCENDANT]: this._activeElementDomId,
          [ARIA_CONTROLS$2]: this.computedInputControls,
          [ARIA_LABEL$1]: this.inputLabel
        });
      }

      itemId(index) {
        return this.inputId + '-' + index;
      }

      itemIndexFromId(id) {
        // Extracts the index from an item id.
        return parseInt(id.substring(id.lastIndexOf('-') + 1), 10);
      }

      processItem(item) {
        const itemCopy = {}; // Supported item properties:
        // 'type' (string): option-inline, option-card
        // 'highlight' (boolean): Whether to highlight the item when dropdown opens
        // 'iconName': left icon name
        // 'iconSize': left icon size
        // 'iconAlternativeText': assistive text for the left icon
        // 'rightIconName': right icon name
        // 'rightIconSize': right icon size
        // 'rightIconAlternativeText': assistive text for the right icon
        // 'text': text to display
        // 'subText': sub-text to display (only option-card supports it)
        // 'value': value associated with the option

        itemCopy.type = item.type;
        itemCopy.iconName = item.iconName;
        itemCopy.iconSize = item.iconSize;
        itemCopy.iconAlternativeText = item.iconAlternativeText;
        itemCopy.rightIconName = item.rightIconName;
        itemCopy.rightIconSize = item.rightIconSize;
        itemCopy.rightIconAlternativeText = item.rightIconAlternativeText;
        itemCopy.text = item.text;
        itemCopy.subText = item.subText;
        itemCopy.value = item.value; // extra metadata needed

        itemCopy.selectable = ['option-card', 'option-inline'].indexOf(item.type) >= 0;

        if (itemCopy.selectable) {
          itemCopy.index = this._selectableItems;
          itemCopy.id = this.itemId(itemCopy.index);
          this._selectableItems += 1;

          if (item.highlight) {
            this._highlightedItemIndex = itemCopy.index;
          }
        }

        return itemCopy;
      }

      get _inputReadOnly() {
        return this._readonly || this.variant === VARIANT.STANDARD || this.hasInputPill;
      }

      get computedAriaAutocomplete() {
        if (this.hasInputPill) {
          // no aria-autocomplete when pill is showing
          return null;
        }

        return this._inputReadOnly ? 'none' : 'list';
      }

      get computedPlaceholder() {
        return this.hasInputPill ? this.inputPill.label : this.placeholder;
      }

      get computedInputValue() {
        return this.hasInputPill ? this.inputPill.label : this.inputText;
      }

      handleListboxScroll(event) {
        // We don't want this to bubble up to the modal which due to event retargeting wouldn't be able
        // to know what is actually being scrolled and thus may lead to the scrolling of the modal
        event.stopPropagation();
        const listbox = event.target;
        const height = listbox.getBoundingClientRect().height;
        const maxScroll = listbox.scrollHeight - height; // Account for variation between browsers when it comes to calculation of margins/padding

        const buffer = 20;
        const bottomReached = listbox.scrollTop + buffer >= maxScroll;

        if (bottomReached) {
          this._events.dispatchEndReached();
        }
      }

      get listboxElement() {
        if (!this._listBoxElementCache) {
          this._listBoxElementCache = this.template.querySelector('[role="listbox"]');
        }

        return this._listBoxElementCache;
      }

      get computedUniqueElementId() {
        return this.inputId;
      }

      get computedUniqueDropdownElementId() {
        return getRealDOMId(this.template.querySelector('[data-dropdown-element]'));
      }

      get computedInputControls() {
        const ariaValues = [this.computedUniqueDropdownElementId];

        if (this.inputControlsElement) {
          ariaValues.push(this.inputAriaControlsId);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get i18n() {
        return i18n$7;
      }

      get computedDropdownTriggerClass() {
        return classSet('slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click').add({
          'slds-is-open': this._dropdownVisible
        }).toString();
      }

      get computedDropdownClass() {
        const alignment = this.dropdownAlignment;
        return classSet('slds-listbox slds-listbox_vertical slds-dropdown slds-dropdown_fluid').add({
          'slds-dropdown_length-with-icon-10': this._dropdownHeight === 'standard',
          'slds-dropdown_length-with-icon-5': this._dropdownHeight === 'small',
          'slds-dropdown_left': alignment === 'left' || alignment === 'auto',
          'slds-dropdown_center': alignment === 'center',
          'slds-dropdown_right': alignment === 'right',
          'slds-dropdown_bottom': alignment === 'bottom-center',
          'slds-dropdown_bottom slds-dropdown_right slds-dropdown_bottom-right': alignment === 'bottom-right',
          'slds-dropdown_bottom slds-dropdown_left slds-dropdown_bottom-left': alignment === 'bottom-left'
        }).toString();
      }

      get computedInputClass() {
        const classes = classSet('slds-input slds-combobox__input');

        if (this.hasInputPill) {
          classes.add('slds-combobox__input-value');
        } else {
          classes.add({
            'slds-input-has-icon_group-right': this.showInputActivityIndicator
          });
        }

        return classes.toString();
      }

      get _shouldOpenDropDown() {
        // If items were empty and through a user interaction the dropdown should have opened, and if the
        // component still has the focus we'll open it on items update instead.
        return !this.dropdownDisabled && this._inputHasFocus && this._requestedDropdownOpen;
      }

      get dropdownDisabled() {
        return this.readOnly || this.disabled;
      }

      handleOptionClick(event) {
        if (event.target.hasAttribute('aria-selected')) {
          event.stopPropagation();
          event.preventDefault();
          this.selectOptionAndCloseDropdown(event.target);
        }
      }

      handleOptionMouseEnter(event) {
        if (event.target.hasAttribute('aria-selected')) {
          this.highlightOption(event.target);
        }
      }

      handleDropdownMouseLeave() {
        this.removeHighlight(); // This is to account for when a user makes a mousedown press on the dropdown and then leaves the dropdown
        // area, it would leave the dropdown open even though the focus would no longer be on the input

        if (!this._inputHasFocus) {
          this.closeDropdown();
        }
      }

      handleTriggerClick(event) {
        event.stopPropagation();
        this.allowBlur();

        if (this.dropdownDisabled) {
          return;
        }

        if (!this.hasInputPill) {
          // toggle dropdown only for readonly combobox, only open the dropdown otherwise
          // if it's not already opened.
          if (this._inputReadOnly) {
            if (this._dropdownVisible) {
              this.closeDropdown();
            } else {
              this.openDropdownIfNotEmpty();
            }
          } else {
            this.openDropdownIfNotEmpty();
          }

          this.inputElement.focus();
        }
      }

      handlePillKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        } // 'Del' is IE11 specific, remove once IE11 is no longer supported


        if (event.key === 'Delete' || event.key === 'Del') {
          this.handlePillRemove();
        }
      }

      handleInputKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        }

        if (this.hasInputPill) {
          this.handlePillKeyDown(event);
        } else {
          handleKeyDownOnInput({
            event,
            currentIndex: this.getCurrentHighlightedOptionIndex(),
            dropdownInterface: this._keyboardInterface
          });
        }
      }

      handleTextChange() {
        this._events.dispatchTextChange(this.inputElement.value);
      }

      handleFocus() {
        this._inputHasFocus = true;

        this._events.dispatchFocus();
      }

      handleInput() {
        // Do not dispatch any events if the pill is showing, this is specifically an IE11 problem,
        // which fires an 'input' event when the placeholder on an input is changed (which is what happens when
        // the pill is shown). The check can be removed when IE11 is no longer supported.
        if (!this.hasInputPill) {
          this._events.dispatchTextInput(this.inputElement.value);
        }
      }

      handleBlur() {
        this._inputHasFocus = false;

        if (this._cancelBlur) {
          return;
        }

        this.closeDropdown();

        this._events.dispatchBlur();
      }

      handleDropdownMouseDown(event) {
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseUp() {
        // We need this to make sure that if a scrollbar is being dragged with the mouse, upon release
        // of the drag we allow blur, otherwise the dropdown would not close on blur since we'd have cancel blur
        // set
        this.allowBlur();
      }

      highlightOption(option) {
        this.removeHighlight();

        if (option) {
          option.highlight();
          this._highlightedOptionElement = option;
          this._highlightedOptionElementId = option.getAttribute('data-item-id'); // active element is a component id getter works properly

          this._activeElementDomId = option.id;
        }

        this.synchronizeA11y();
      }

      highlightOptionAndScrollIntoView(optionElement) {
        if (this._selectableItems.length === 0 || !optionElement) {
          return;
        }

        this.highlightOption(optionElement);
        scrollIntoViewIfNeeded(optionElement, this.listboxElement);
      }

      removeHighlight() {
        const option = this._highlightedOptionElement;

        if (option) {
          option.removeHighlight();
          this._highlightedOptionElement = null;
          this._highlightedOptionElementId = null;
          this._activeElementDomId = null;
        }
      }

      selectOptionAndCloseDropdown(optionElement) {
        this.closeDropdown();
        this.inputElement.focus();
        const value = optionElement.getAttribute('data-value');

        this._events.dispatchSelect(value);
      }

      handleInputSelect(event) {
        event.stopPropagation();
      }

      openDropdownIfNotEmpty() {
        if (this._dropdownVisible) {
          // Already visible
          return;
        }

        const noOptions = !Array.isArray(this.items) || this.items.length === 0; // Do not dispatch the open request event if there already was a request to open

        if (noOptions && !this._requestedDropdownOpen) {
          // Dispatch dropdown open request
          this._events.dispatchDropdownOpenRequest();
        } // Do not open if there's nothing to show in the dropdown (eg. no options and no dropdown activity indicator)


        if (this.isDropdownEmpty) {
          // We use this attribute to flag whether an attempt has been made via user-interaction
          // to open the dropdown
          this._requestedDropdownOpen = true;
          return;
        }

        if (!this._hasDropdownOpened) {
          if (this._unprocessedItems) {
            this.updateItems(this._unprocessedItems);
          }

          this._hasDropdownOpened = true;
        }

        this._requestedDropdownOpen = false;
        this._dropdownVisible = true; // remove-next-line-for-c-namespace

        this.startDropdownAutoPositioning();
        this.highlightDefaultItem();

        this._events.dispatchDropdownOpen();
      }

      closeDropdown() {
        if (!this._dropdownVisible) {
          // Already closed
          return;
        } // remove-next-line-for-c-namespace


        this.stopDropdownPositioning();
        this.removeHighlight();
        this._dropdownVisible = false;
      }

      findOptionElementByIndex(index) {
        return this.template.querySelector(`[data-item-id="${this.itemId(index)}"]`);
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      getCurrentHighlightedOptionIndex() {
        if (this._highlightedOptionElementId && this._highlightedOptionElementId.length > 0) {
          return this.itemIndexFromId(this._highlightedOptionElementId);
        }

        return -1;
      }

      get inputElement() {
        return this.template.querySelector('input');
      } // remove-next-line-for-c-namespace


      startDropdownAutoPositioning() {
        if (this.dropdownAlignment !== 'auto') {
          return;
        }

        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('input'),
          element: () => this.template.querySelector('div.slds-dropdown'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true,
          alignWidth: true,
          autoShrinkHeight: true,
          minHeight: this._selectableItems < 3 ? SMALL_MIN_HEIGHT : MEDIUM_MIN_HEIGHT
        });
      } // remove-next-line-for-c-namespace


      stopDropdownPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      get hasInputPill() {
        return this.inputPill && Object.keys(this.inputPill).length > 0;
      }

      handlePillRemove() {
        this.inputElement.focus();

        this._events.dispatchPillRemove(this.inputPill);
      }

      get computedFormElementClass() {
        const hasIcon = this.hasInputPill && this.inputPill.iconName;
        return classSet('slds-combobox__form-element slds-input-has-icon').add({
          'slds-input-has-icon_right': !hasIcon,
          'slds-input-has-icon_left-right': hasIcon
        }).toString();
      }

      get computedAriaExpanded() {
        return this._dropdownVisible ? 'true' : 'false';
      }

      updateItems(items) {
        if (!items) {
          return;
        }

        assert(Array.isArray(items), '"items" must be an array');
        this._selectableItems = 0;
        this._highlightedItemIndex = 0;
        this._items = items.map(item => {
          if (item.items) {
            // This is a group
            const groupCopy = {
              label: item.label
            };
            groupCopy.items = item.items.map(groupItem => {
              return this.processItem(groupItem);
            });
            return groupCopy;
          }

          return this.processItem(item);
        });
      }

      highlightDefaultItem() {
        this.removeHighlight(); // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          this.highlightOptionAndScrollIntoView(this.findOptionElementByIndex(this._highlightedItemIndex));
        });
      }

      get isDropdownEmpty() {
        // If the activity indicator is showing then it's not empty
        return !this.showDropdownActivityIndicator && (!Array.isArray(this.items) || this.items.length === 0);
      }

      dropdownKeyboardInterface() {
        const that = this;
        return {
          getTotalOptions() {
            return that._selectableItems;
          },

          selectByIndex(index) {
            that.selectOptionAndCloseDropdown(that.findOptionElementByIndex(index));
          },

          highlightOptionWithIndex(index) {
            that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
          },

          isInputReadOnly() {
            return that._inputReadOnly;
          },

          highlightOptionWithText(currentIndex, text) {
            // This only supports a flat structure, groups are not supported
            for (let index = currentIndex + 1; index < that._items.length; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }

            for (let index = 0; index < currentIndex; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }
          },

          isDropdownVisible() {
            return that._dropdownVisible;
          },

          openDropdownIfNotEmpty() {
            that.openDropdownIfNotEmpty();
          },

          closeDropdown() {
            that.closeDropdown();
          }

        };
      }

    }

    LightningBaseCombobox.delegatesFocus = true;

    lwc.registerDecorators(LightningBaseCombobox, {
      publicProps: {
        inputText: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showInputActivityIndicator: {
          config: 0
        },
        required: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        inputLabel: {
          config: 0
        },
        name: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        attributionLogoUrl: {
          config: 0
        },
        attributionLogoAssistiveText: {
          config: 0
        },
        inputControlsElement: {
          config: 3
        },
        inputDescribedByElements: {
          config: 3
        },
        inputLabelledByElement: {
          config: 3
        },
        dropdownHeight: {
          config: 3
        },
        showDropdownActivityIndicator: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur"],
      track: {
        _showDropdownActivityIndicator: 1,
        _items: 1,
        _disabled: 1,
        _dropdownVisible: 1,
        _hasDropdownOpened: 1,
        _highlightedOptionElementId: 1,
        _variant: 1,
        _dropdownHeight: 1,
        _readonly: 1,
        _logoLoaded: 1
      },
      fields: ["_inputDescribedBy", "_inputAriaControls", "_activeElementDomId"]
    });

    var _lightningBaseCombobox = lwc.registerComponent(LightningBaseCombobox, {
      tmpl: _tmpl$i
    });

    function scrollIntoViewIfNeeded(element, scrollingParent) {
      const parentRect = scrollingParent.getBoundingClientRect();
      const findMeRect = element.getBoundingClientRect();

      if (findMeRect.top < parentRect.top) {
        if (element.offsetTop + findMeRect.height < parentRect.height) {
          // If element fits by scrolling to the top, then do that
          scrollingParent.scrollTop = 0;
        } else {
          // Otherwise, top align the element
          scrollingParent.scrollTop = element.offsetTop;
        }
      } else if (findMeRect.bottom > parentRect.bottom) {
        // bottom align the element
        scrollingParent.scrollTop += findMeRect.bottom - parentRect.bottom;
      }
    }

    function tmpl$k($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 4
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        props: {
          "dropdownHeight": "small",
          "name": $cmp.name,
          "variant": "lookup",
          "placeholder": $cmp.placeholder,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "items": $cmp.items,
          "inputText": $cmp.displayValue,
          "inputIconName": "utility:clock",
          "inputLabel": $cmp.ariaLabel,
          "inputControlsElement": $cmp.ariaControlsElement,
          "inputLabelledByElement": $cmp.ariaLabelledByElement,
          "dropdownAlignment": "auto"
        },
        key: 3,
        on: {
          "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleReady)),
          "textchange": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "textinput": _m2 || ($ctx._m2 = api_bind($cmp.handleTextInput)),
          "dropdownopenrequest": _m3 || ($ctx._m3 = api_bind($cmp.handleDropdownOpenRequest)),
          "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
          "select": _m6 || ($ctx._m6 = api_bind($cmp.handleTimeSelect))
        }
      }, [])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 5
      }, [api_dynamic($cmp._errorMessage)]) : null];
    }

    var _tmpl$j = lwc.registerTemplate(tmpl$k);
    tmpl$k.stylesheets = [];
    tmpl$k.stylesheetTokens = {
      hostAttribute: "lightning-timepicker_timepicker-host",
      shadowAttribute: "lightning-timepicker_timepicker"
    };

    var shortTimeFormat = 'h:mm a';

    /* returns the closes time in the list that should be highlighted in case the value is not in the list. E.g.
    - if value is 16:18 and the list has 15 minute intervals, returns 16:30
    */

    function getTimeToHighlight(value, step) {
      const selectedTime = parseTime(value);

      if (!selectedTime) {
        return null;
      }

      selectedTime.setSeconds(0, 0);
      let closestHour = selectedTime.getHours();
      let closestMinute = selectedTime.getMinutes();
      const mod = closestMinute % step;
      const quotient = Math.floor(closestMinute / step);

      if (mod !== 0) {
        const multiplier = mod < step / 2 ? quotient : quotient + 1;
        closestMinute = multiplier * step;

        if (closestMinute >= 60) {
          if (closestHour === 23) {
            closestMinute -= step;
          } else {
            closestMinute = 0;
            closestHour++;
          }
        }

        selectedTime.setHours(closestHour);
        selectedTime.setMinutes(closestMinute);
      }

      return getISOTimeString(selectedTime);
    }

    const i18n$8 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired
    };
    const STEP = 15; // in minutes

    const TIME_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningTimePicker extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._disabled = false;
        this._required = false;
        this._displayValue = null;
        this._value = null;
        this._min = void 0;
        this._max = void 0;
        this._items = [];
        this._fieldLevelHelp = void 0;
        this._variant = 'lookup';
        this._mainInputId = void 0;
        this._errorMessage = void 0;
        this._readonly = true;
        this._describedByElements = [];
        this.label = void 0;
        this.name = void 0;
        this.placeholder = '';
        this.ariaLabelledByElement = void 0;
        this.ariaControlsElement = void 0;
        this.ariaLabel = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaDescribedByElements = void 0;
      }

      get messageWhenBadInput() {
        return this._messageWhenBadInput || formatLabel(i18n$8.invalidDate, this.timeFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        // using isoValue since the manually entered time could have seconds/milliseconds and the locale format generally doesn't have this precision
        return this._messageWhenRangeOverflow || formatLabel(i18n$8.rangeOverflow, normalizeISOTime(this.max, this.timeFormat).isoValue);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || formatLabel(i18n$8.rangeUnderflow, normalizeISOTime(this.min, this.timeFormat).isoValue);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedByElements = el;
        } else {
          this.ariaDescribedByElements = [el];
        }
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedByElements;
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = removeTimeZoneSuffix(newValue);
        const normalizedTime = normalizeISOTime(normalizedValue, this.timeFormat);
        this._value = normalizedTime.isoValue;
        this._displayValue = normalizedTime.displayValue;
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly) {
          this._variant = VARIANT.STANDARD;
        }
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      get max() {
        return this._max;
      }

      set max(newValue) {
        this._max = newValue;

        if (this.connected) {
          this.rebuildAndUpdateTimeList();
        }
      }

      get min() {
        return this._min;
      }

      set min(newValue) {
        this._min = newValue;

        if (this.connected) {
          this.rebuildAndUpdateTimeList();
        }
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this.connected) {
          this.getCombobox().focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this.connected) {
          this.getCombobox().blur();
        }
      }

      get timeStyle() {
        return this._timeStyle;
      }

      set timeStyle(value) {
        this._timeStyle = normalizeString(value, {
          fallbackValue: TIME_STYLE.SHORT,
          validValues: [TIME_STYLE.SHORT, TIME_STYLE.MEDIUM, TIME_STYLE.LONG]
        });
        this.timeFormat = this.getTimeFormatFromStyle(this._timeStyle);
        const normalizedDate = normalizeISOTime(this._value, this.timeFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      connectedCallback() {
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      synchronizeA11y() {
        const label = this.template.querySelector('label');
        const comboBox = this.template.querySelector('lightning-base-combobox');
        let describedByElements = [];

        if (this._ariaDescribedByElements) {
          describedByElements = describedByElements.concat(this._ariaDescribedByElements);
        }

        const errorMessage = this.template.querySelector('[data-error-message]');

        if (errorMessage) {
          describedByElements.push(errorMessage);
        }

        comboBox.inputDescribedByElements = describedByElements;
        synchronizeAttrs(label, {
          for: this._mainInputId
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get displayValue() {
        return this._displayValue;
      }

      get items() {
        return this._items;
      }

      get i18n() {
        return i18n$8;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleReady(e) {
        this._mainInputId = e.detail.id;
      }

      buildTimeList() {
        // We should always display the options in the short style since m/l will add an extra :00 to the options.
        const optionsTimeFormat = shortTimeFormat;
        const timeList = [];
        const minTime = parseTime(removeTimeZoneSuffix(this.min));
        const minHour = minTime ? minTime.getHours() : 0;
        const maxTime = parseTime(removeTimeZoneSuffix(this.max));
        const maxHour = maxTime ? maxTime.getHours() + 1 : 24;
        const date = new Date();

        for (let hour = minHour; hour < maxHour; hour++) {
          for (let minutes = 0; minutes < 60; minutes += STEP) {
            date.setHours(hour, minutes);
            date.setSeconds(0, 0);

            if (this.isBeforeMinTime(date, minTime)) {
              continue; // eslint-disable-line no-continue
            }

            if (this.isAfterMaxTime(date, maxTime)) {
              break;
            } // @todo: should we always display it short in the combobox given that it makes no sense?


            timeList.push({
              type: 'option-inline',
              text: this.format(date, optionsTimeFormat),
              value: this.format(date)
            });
          }
        }

        return timeList;
      }

      get timeList() {
        if (!this._timeList) {
          this._timeList = this.buildTimeList();
        }

        if (!this._value) {
          return this._timeList;
        }

        const timeToHighlight = getTimeToHighlight(this._value, STEP);

        const timeList = this._timeList.map(item => {
          const itemCopy = Object.assign({}, item);

          if (item.value === this._value) {
            itemCopy.iconName = 'utility:check';
          }

          if (item.value === timeToHighlight) {
            itemCopy.highlight = true;
          }

          return itemCopy;
        });

        return timeList;
      }

      rebuildAndUpdateTimeList() {
        // forcing the time list to be rebuilt
        this._timeList = null;
        this._items = this.timeList;
      }

      get timeFormat() {
        if (!this._timeFormat) {
          this._timeFormat = this.getTimeFormatFromStyle();
        }

        return this._timeFormat;
      }

      set timeFormat(value) {
        this._timeFormat = value;
      }

      getCombobox() {
        return this.template.querySelector('lightning-base-combobox');
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleInputChange(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
        this._value = this.parseFormattedTime(this._displayValue);
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleTextInput(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
      }

      handleTimeSelect(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from grouped-combobox

        if (!event.detail) {
          return;
        }

        this._value = event.detail.value;
        this._displayValue = normalizeISOTime(this._value, this.timeFormat).displayValue;
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleDropdownOpenRequest() {
        this._items = this.timeList;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      format(date, formatString) {
        if (formatString) {
          return formatTime(date, formatString);
        }

        return getISOTimeString(date);
      }

      isBeforeMinTime(date, minTime) {
        const minDate = minTime || parseTime(removeTimeZoneSuffix(this.min));
        return minDate ? isBefore(date, minDate, 'minute') : false;
      }

      isAfterMaxTime(date, maxTime) {
        const maxDate = maxTime || parseTime(removeTimeZoneSuffix(this.max));
        return maxDate ? isAfter(date, maxDate, 'minute') : false;
      }

      getTimeFormatFromStyle(timeStyle) {
        let timeFormat;

        switch (timeStyle) {
          case TIME_STYLE.MEDIUM:
          case TIME_STYLE.LONG:
            timeFormat = mediumTimeFormat;
            break;

          default:
            timeFormat = shortTimeFormat;
            break;
        }

        return timeFormat;
      }

      get allowedTimeFormats() {
        // the locale.timeFormat is the medium format. Locale dont supports a large
        // time format at the moment.
        return [mediumTimeFormat, shortTimeFormat];
      }
      /**
       * Parses the input time and sets the timeFormat used to parse the displayValue
       * if it is a valid time.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted time if displayValue is valid. null otherwise.
       */


      parseFormattedTime(displayValue) {
        const allowedFormats = this.allowedTimeFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedTime(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        if (value !== null) {
          this.timeFormat = allowedFormats[i - 1];
        }

        return value;
      }

    }

    LightningTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        ariaLabelledByElement: {
          config: 0
        },
        ariaControlsElement: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        timeStyle: {
          config: 3
        }
      },
      publicMethods: ["hasBadInput", "showHelpMessage", "focus", "blur"],
      track: {
        _disabled: 1,
        _required: 1,
        _displayValue: 1,
        _value: 1,
        _min: 1,
        _max: 1,
        _items: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _mainInputId: 1,
        _errorMessage: 1,
        _readonly: 1,
        _describedByElements: 1
      },
      fields: ["_ariaDescribedByElements"]
    });

    var _lightningTimepicker = lwc.registerComponent(LightningTimePicker, {
      tmpl: _tmpl$j
    });

    function tmpl$l($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form": true,
          "slds-form_compound": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 10
      }, [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 9
      }, [api_element("legend", {
        className: $cmp.computedLabelClass,
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-form-element__row": true
        },
        key: 5
      }, [api_custom_element("lightning-datepicker", _lightningDatepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "min": $cmp.dateMin,
          "max": $cmp.dateMax,
          "label": $cmp.i18n.date,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled,
          "autocomplete": $cmp.autocomplete,
          "dateStyle": $cmp.dateStyle
        },
        key: 3,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleDatepickerFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleDatepickerBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleDateChange))
        }
      }, []), api_custom_element("lightning-timepicker", _lightningTimepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "label": $cmp.i18n.time,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 4,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleTimepickerFocus)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleTimepickerBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleTimeChange))
        }
      }, [])])])]), $cmp.customErrorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "data-error-message": true,
          "id": api_scoped_id("errormessage"),
          "aria-live": "assertive"
        },
        key: 8
      }, [api_dynamic($cmp.customErrorMessage)]) : null])])];
    }

    var _tmpl$k = lwc.registerTemplate(tmpl$l);
    tmpl$l.stylesheets = [];
    tmpl$l.stylesheetTokens = {
      hostAttribute: "lightning-datetimepicker_datetimepicker-host",
      shadowAttribute: "lightning-datetimepicker_datetimepicker"
    };

    var labelDate = 'Date';

    var labelTime = 'Time';

    const i18n$9 = {
      date: labelDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      time: labelTime
    };

    class LightningDateTimePicker extends lwc.LightningElement {
      // getters and setters necessary to trigger sync
      set timeAriaControls(val) {
        this._timeAriaControls = val;
        this.synchronizeA11y();
      }

      get timeAriaControls() {
        return this._timeAriaControls;
      }

      set timeAriaLabelledBy(val) {
        this._timeAriaLabelledBy = val;
        this.synchronizeA11y();
      }

      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaDescribedBy(val) {
        this._timeAriaDescribedBy = val;
        this.synchronizeA11y();
      }

      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      get messageWhenBadInput() {
        if (this._messageWhenBadInput) {
          return this._messageWhenBadInput;
        } else if (this.hasBadDateInput) {
          return this.getDatepicker().messageWhenBadInput;
        } else if (this.hasBadTimeInput) {
          return this.getTimepicker().messageWhenBadInput;
        }

        return null;
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || formatLabel(i18n$9.rangeOverflow, this.formattedMax);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || formatLabel(i18n$9.rangeUnderflow, this.formattedMin);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      get max() {
        return this.maxValue;
      }

      set max(newValue) {
        this.maxValue = newValue;
        this.calculateFormattedMaxValue();
      }

      get min() {
        return this.minValue;
      }

      set min(newValue) {
        this.minValue = newValue;
        this.calculateFormattedMinValue();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        if (this.connected) {
          this.setDateAndTimeValues(newValue);
        } else {
          // we set the values in connectedCallback to make sure timezone is available.
          this._initialValue = newValue;
        }
      }

      get timezone() {
        return this._timezone;
      }

      set timezone(newValue) {
        this._timezone = newValue;

        if (this.connected) {
          this.updateValuesForTimezone();
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }
      /**
       * Sets focus on the date input element.
       */


      focus() {
        if (this.connected) {
          this.getDatepicker().focus();
        }
      }
      /**
       * Removes keyboard focus from the input elements.
       */


      blur() {
        if (this.connected) {
          this.getDatepicker().blur();
          this.getTimepicker().blur();
        }
      }

      hasBadInput() {
        return this.connected && (this.hasBadDateInput || this.hasBadTimeInput);
      }

      get hasBadDateInput() {
        return this.getDatepicker().hasBadInput();
      }

      get hasBadTimeInput() {
        const timeBadInput = this.getTimepicker().hasBadInput();
        const timeMissing = this.required && this._dateValue && !this._timeValue;
        return timeMissing || timeBadInput;
      }

      showHelpMessage(message) {
        if (!this.connected) {
          return;
        }

        if (!message) {
          this.clearHelpMessage();
          return;
        }

        if (this.hasBadDateInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getDatepicker().showHelpMessage(message);
          return;
        }

        if (this.hasBadTimeInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getTimepicker().showHelpMessage(message);
          return;
        }

        this.classList.add('slds-has-error');
        this._customErrorMessage = message;
      }

      clearHelpMessage() {
        this.classList.remove('slds-has-error');
        this._customErrorMessage = '';
        this.getDatepicker().showHelpMessage('');
        this.getTimepicker().showHelpMessage('');
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__legend slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get i18n() {
        return i18n$9;
      }

      get customErrorMessage() {
        return this._customErrorMessage;
      }

      get dateMin() {
        return this._dateMin;
      }

      get dateMax() {
        return this._dateMax;
      }

      get errorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-error-message]'));
      }

      get computedDateAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.dateAriaDescribedBy) {
          ariaValues.push(this.dateAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedTimeAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.timeAriaDescribedBy) {
          ariaValues.push(this.timeAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this._value = null;
        this._timezone = null;
        this._customErrorMessage = '';
        this._dateMin = void 0;
        this._dateMax = void 0;
        this.label = void 0;
        this.name = void 0;
        this.placeholder = '';
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.timeAriaLabel = void 0;
        this.autocomplete = void 0;
        this.dateAriaControls = void 0;
        this.dateAriaLabel = void 0;
        this.dateAriaLabelledBy = void 0;
        this.dateAriaDescribedBy = void 0;
        this.messageWhenValueMissing = void 0;
        this.uniqueId = generateUniqueId();
      }

      synchronizeA11y() {
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.dateAriaLabelledBy,
            ariaDescribedByElements: this.computedDateAriaDescribedBy,
            ariaControlsElement: this.dateAriaControls,
            'aria-label': this.dateAriaLabel
          });
        }

        if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.timeAriaLabelledBy,
            ariaDescribedByElements: this.computedTimeAriaDescribedBy,
            ariaControlsElement: this.timeAriaControls,
            'aria-label': this.timeAriaLabel
          });
        }
      }

      connectedCallback() {
        this.classList.add('slds-form_compound');
        this.connected = true; // we set the initial values here in order to make sure timezone is available.

        this.updateValuesForTimezone(this._initialValue);
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this.connected = false;
      }

      getTimepicker() {
        return this.template.querySelector('lightning-timepicker');
      }

      getDatepicker() {
        return this.template.querySelector('lightning-datepicker');
      }

      handleDatepickerFocus() {
        this._dateFocus = true;
        this.interactingState.enter();
      }

      handleTimepickerFocus() {
        this._timeFocus = true;
        this.interactingState.enter();
      }

      handleDatepickerBlur() {
        this._dateFocus = false; // timepicker fires focus before datepicker fires blur

        if (!this._timeFocus) {
          this.interactingState.leave();
        }
      }

      handleTimepickerBlur() {
        this._timeFocus = false; // datepicker fires focus before timepicker fires blur

        if (!this._dateFocus) {
          this.interactingState.leave();
        }
      }

      handleDateChange(event) {
        event.stopPropagation();

        if (!event.detail) {
          return;
        }

        this._dateValue = event.detail.value;

        if (this._dateValue) {
          this._timeValue = this._timeValue || getCurrentTime(this.timezone);
          this.setTimepickerValue(this._timeValue);
        }

        this.updateValue();
      }

      handleTimeChange(event) {
        event.stopPropagation();

        if (!event.detail) {
          return;
        }

        this._timeValue = event.detail.value;
        this.updateValue();
      }

      updateValue() {
        const dateValue = this._dateValue;
        const timeValue = this._timeValue;

        if (dateValue && timeValue) {
          const dateTimeString = dateValue + TIME_SEPARATOR + timeValue;
          this._value = normalizeFormattedDateTime(dateTimeString, this.timezone);
          this.dispatchChangeEvent();
        } else if (!dateValue) {
          this._value = null;
          this.dispatchChangeEvent();
        }
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      updateValuesForTimezone(datetimeValue) {
        this.setDateAndTimeValues(datetimeValue || this._value);
        this.calculateFormattedMinValue();
        this.calculateFormattedMaxValue();
      }

      setDateAndTimeValues(value) {
        const normalizedValue = normalizeISODateTime(value, this.timezone).isoValue;
        const isDateOnly = normalizedValue && value.indexOf(TIME_SEPARATOR) < 0;

        if (isDateOnly) {
          this._dateValue = value;
          this._value = this._dateValue;
          this.setDatepickerValue(value);
          return;
        }

        const dateAndTime = this.separateDateTime(normalizedValue);
        this._dateValue = dateAndTime && dateAndTime[0];
        this._timeValue = dateAndTime && dateAndTime[1];
        this._value = value;
        this.setDatepickerValue(this._dateValue);
        this.setTimepickerValue(this._timeValue);
      }

      setDatepickerValue(value) {
        const datepicker = this.getDatepicker();

        if (datepicker) {
          datepicker.value = value;
        }
      }

      setTimepickerValue(value) {
        const timepicker = this.getTimepicker();

        if (timepicker) {
          timepicker.value = value;
        }
      }

      calculateFormattedMinValue() {
        if (!this.min) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.min, this.timezone);
        this._dateMin = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMin = normalizedDate.displayValue;
      }

      calculateFormattedMaxValue() {
        if (!this.max) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.max, this.timezone);
        this._dateMax = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMax = normalizedDate.displayValue;
      }

      separateDateTime(isoString) {
        return typeof isoString === 'string' ? isoString.split(TIME_SEPARATOR) : null;
      }

    }

    LightningDateTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDateTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        timeAriaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        timeAriaControls: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        dateAriaLabelledBy: {
          config: 0
        },
        dateAriaDescribedBy: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        value: {
          config: 3
        },
        timezone: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "hasBadInput", "showHelpMessage"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _value: 1,
        _timezone: 1,
        _customErrorMessage: 1,
        _dateMin: 1,
        _dateMax: 1
      }
    });

    var _lightningDatetimepicker = lwc.registerComponent(LightningDateTimePicker, {
      tmpl: _tmpl$k
    });

    function tmpl$m($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        t: api_text,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16,
        _m17,
        _m18,
        _m19,
        _m20,
        _m21,
        _m22,
        _m23,
        _m24,
        _m25,
        _m26,
        _m27,
        _m28,
        _m29,
        _m30,
        _m31,
        _m32,
        _m33,
        _m34,
        _m35,
        _m36,
        _m37,
        _m38,
        _m39
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "data-aria": true
        },
        key: 0
      }, []), $cmp.isTypeSimple ? api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 1
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeSimple ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 3
      }, []) : null : null, $cmp.isTypeSimple ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 14
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": $cmp._internalType,
          "id": api_scoped_id("input"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "autocomplete": $cmp.autocomplete,
          "max": $cmp.normalizedMax,
          "min": $cmp.normalizedMin,
          "inputmode": $cmp._inputMode,
          "step": $cmp.step,
          "maxlength": $cmp.maxLength,
          "minlength": $cmp.minLength,
          "pattern": $cmp.pattern,
          "placeholder": $cmp.placeholder,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 4,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleKeyDown))
        }
      }, []), $cmp.isTypeSearch ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:search",
          "variant": "bare",
          "svgClass": "slds-input__icon slds-input__icon_left slds-icon-text-default"
        },
        key: 5
      }, []) : null, $cmp.isTypeSearch ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 13
      }, [$cmp.isLoading ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 9
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.i18n.loading)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 7
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 8
      }, [])]) : null, $cmp._showClearButton ? api_element("button", {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true,
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "data-element-id": "searchClear"
        },
        key: 12,
        on: {
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
          "click": _m6 || ($ctx._m6 = api_bind($cmp._clearAndSetFocusOnInput))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:clear",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 10
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 11
      }, [api_dynamic($cmp.i18n.clear)])]) : null]) : null]) : null, $cmp.isTypeToggle ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-checkbox_toggle": true,
          "slds-grid": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-toggle")}`
        },
        key: 22
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 15
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 16
      }, [api_dynamic($cmp.label)]), api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-toggle"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 17,
        on: {
          "blur": _m7 || ($ctx._m7 = api_bind($cmp.handleBlur)),
          "focus": _m8 || ($ctx._m8 = api_bind($cmp.handleFocus)),
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_faux_container": true
        },
        attrs: {
          "id": api_scoped_id("toggle-description"),
          "data-toggle-description": true,
          "aria-live": "assertive"
        },
        key: 21
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 18
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_on": true
        },
        key: 19
      }, [api_dynamic($cmp.messageToggleActive)]), api_element("span", {
        classMap: {
          "slds-checkbox_off": true
        },
        key: 20
      }, [api_dynamic($cmp.messageToggleInactive)])])])]) : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 26
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 24
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 25
      }, [api_dynamic($cmp.label)])]) : null : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 27
      }, []) : null : null : null, $cmp.isTypeCheckbox ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 36
      }, [api_element("span", {
        className: $cmp.computedCheckboxClass,
        key: 35
      }, [$cmp.isStandardVariant ? $cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 28
      }, [api_text("*")]) : null : null, api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 29,
        on: {
          "blur": _m10 || ($ctx._m10 = api_bind($cmp.handleBlur)),
          "focus": _m11 || ($ctx._m11 = api_bind($cmp.handleFocus)),
          "change": _m12 || ($ctx._m12 = api_bind($cmp.handleChange))
        }
      }, []), !$cmp.isStandardVariant ? api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 30
      }, []) : null, $cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 33
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 31
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 32
      }, [api_dynamic($cmp.label)])]) : null, $cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 34
      }, []) : null : null])]) : null, $cmp.isTypeCheckboxButton ? api_element("div", {
        classMap: {
          "slds-checkbox_add-button": true
        },
        key: 40
      }, [api_element("input", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-button"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 37,
        on: {
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handleBlur)),
          "focus": _m14 || ($ctx._m14 = api_bind($cmp.handleFocus)),
          "change": _m15 || ($ctx._m15 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox_faux": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-button")}`
        },
        key: 39
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 38
      }, [api_dynamic($cmp.label)])])]) : null, $cmp.isTypeRadio ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 46
      }, [api_element("span", {
        classMap: {
          "slds-radio": true
        },
        key: 45
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "id": api_scoped_id("radio"),
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 41,
        on: {
          "blur": _m16 || ($ctx._m16 = api_bind($cmp.handleBlur)),
          "focus": _m17 || ($ctx._m17 = api_bind($cmp.handleFocus)),
          "change": _m18 || ($ctx._m18 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-radio__label": true
        },
        attrs: {
          "for": `${api_scoped_id("radio")}`
        },
        key: 44
      }, [api_element("span", {
        classMap: {
          "slds-radio_faux": true
        },
        key: 42
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 43
      }, [api_dynamic($cmp.label)])])])]) : null, $cmp.isTypeFile ? api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("form-label"),
          "data-form-label": true
        },
        key: 48
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 47
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeFile ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 56
      }, [api_element("div", {
        classMap: {
          "slds-file-selector": true,
          "slds-file-selector_files": true
        },
        key: 55,
        on: {
          "drop": _m23 || ($ctx._m23 = api_bind($cmp.handleDropFiles))
        }
      }, [api_custom_element("lightning-primitive-file-droppable-zone", _lightningPrimitiveFileDroppableZone, {
        props: {
          "multiple": $cmp.multiple,
          "disabled": $cmp.disabled
        },
        key: 54
      }, [api_element("input", {
        classMap: {
          "slds-file-selector__input": true,
          "slds-assistive-text": true
        },
        attrs: {
          "type": "file",
          "id": api_scoped_id("input-file"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "accept": $cmp.accept,
          "name": $cmp.name
        },
        props: {
          "multiple": $cmp.multiple,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 49,
        on: {
          "blur": _m19 || ($ctx._m19 = api_bind($cmp.handleBlur)),
          "click": _m20 || ($ctx._m20 = api_bind($cmp.handleFileClick)),
          "focus": _m21 || ($ctx._m21 = api_bind($cmp.handleFocus)),
          "change": _m22 || ($ctx._m22 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-file-selector__body": true
        },
        attrs: {
          "id": api_scoped_id("file-selector-label"),
          "data-file-selector-label": true,
          "for": `${api_scoped_id("input-file")}`
        },
        key: 53
      }, [api_element("span", {
        classMap: {
          "slds-file-selector__button": true,
          "slds-button": true,
          "slds-button_neutral": true
        },
        key: 51
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:upload",
          "variant": "bare",
          "svgClass": "slds-button__icon slds-button__icon_left"
        },
        key: 50
      }, []), api_dynamic($cmp.i18n.inputFileButtonLabel)]), api_element("span", {
        classMap: {
          "slds-file-selector__text": true,
          "slds-medium-show": true
        },
        key: 52
      }, [api_dynamic($cmp.i18n.inputFileBodyText)])])])])]) : null, $cmp.isTypeColor ? api_element("div", {
        classMap: {
          "slds-color-picker": true
        },
        key: 65
      }, [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__summary": true
        },
        key: 64
      }, [api_element("label", {
        className: $cmp.computedColorLabelClass,
        attrs: {
          "for": `${api_scoped_id("color")}`
        },
        key: 58
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 57
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 62
      }, [api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton, {
        props: {
          "value": $cmp.value,
          "disabled": $cmp.disabled
        },
        key: 59,
        on: {
          "blur": _m24 || ($ctx._m24 = api_bind($cmp.handleBlur)),
          "focus": _m25 || ($ctx._m25 = api_bind($cmp.handleFocus)),
          "change": _m26 || ($ctx._m26 = api_bind($cmp.handleColorChange))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-color-picker__summary-input": true
        },
        key: 61
      }, [api_element("input", {
        classMap: {
          "slds-input": true,
          "slds-m-right_x-small": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("color"),
          "name": $cmp.name,
          "autocomplete": $cmp.autocomplete,
          "accesskey": $cmp.accesskey,
          "aria-label": $cmp.computedAriaLabel,
          "minlength": "4",
          "maxlength": "7",
          "placeholder": $cmp.placeholder,
          "pattern": $cmp.pattern
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 60,
        on: {
          "blur": _m27 || ($ctx._m27 = api_bind($cmp.handleBlur)),
          "focus": _m28 || ($ctx._m28 = api_bind($cmp.handleFocus)),
          "change": _m29 || ($ctx._m29 = api_bind($cmp.handleChange)),
          "input": _m30 || ($ctx._m30 = api_bind($cmp.handleInput))
        }
      }, [])])]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 63
      }, []) : null])]) : null, $cmp.isTypeDesktopDate ? api_custom_element("lightning-datepicker", _lightningDatepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "ariaLabel": $cmp.ariaLabel,
          "dateStyle": $cmp.dateStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 66,
        on: {
          "change": _m31 || ($ctx._m31 = api_bind($cmp.handleChange)),
          "blur": _m32 || ($ctx._m32 = api_bind($cmp.handleBlur)),
          "focus": _m33 || ($ctx._m33 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopTime ? api_custom_element("lightning-timepicker", _lightningTimepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "ariaLabel": $cmp.ariaLabel,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 67,
        on: {
          "change": _m34 || ($ctx._m34 = api_bind($cmp.handleChange)),
          "blur": _m35 || ($ctx._m35 = api_bind($cmp.handleBlur)),
          "focus": _m36 || ($ctx._m36 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopDateTime ? api_custom_element("lightning-datetimepicker", _lightningDatetimepicker, {
        props: {
          "dateAriaControls": $cmp.dateAriaControls,
          "dateAriaLabel": $cmp.dateAriaLabel,
          "dateAriaLabelledBy": $cmp.dateAriaLabelledBy,
          "dateAriaDescribedBy": $cmp.dateAriaDescribedBy,
          "dateStyle": $cmp.dateStyle,
          "timeStyle": $cmp.timeStyle,
          "timeAriaControls": $cmp.timeAriaControls,
          "timeAriaLabel": $cmp.timeAriaLabel,
          "timeAriaLabelledBy": $cmp.timeAriaLabelledBy,
          "timeAriaDescribedBy": $cmp.timeAriaDescribedBy,
          "max": $cmp.max,
          "min": $cmp.min,
          "timezone": $cmp.timezone,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 68,
        on: {
          "change": _m37 || ($ctx._m37 = api_bind($cmp.handleChange)),
          "blur": _m38 || ($ctx._m38 = api_bind($cmp.handleBlur)),
          "focus": _m39 || ($ctx._m39 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 69
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$l = lwc.registerTemplate(tmpl$m);
    tmpl$m.stylesheets = [];

    if (_implicitStylesheets$2) {
      tmpl$m.stylesheets.push.apply(tmpl$m.stylesheets, _implicitStylesheets$2);
    }
    tmpl$m.stylesheetTokens = {
      hostAttribute: "lightning-input_input-host",
      shadowAttribute: "lightning-input_input"
    };

    var labelInputFileBodyText = 'Or drop files';

    var labelInputFileButtonLabel = 'Upload Files';

    var labelMessageToggleActive = 'Active';

    var labelMessageToggleInactive = 'Inactive';

    var labelClear = 'Clear';

    var labelLoading = 'Loading';

    var labelNumberIncrementCounter = 'Increase number';

    var labelNumberDecrementCounter = 'Decrease number';

    var userTimeZone = 'America/Los_Angeles';

    var formFactor = 'Large';

    function normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return String(value);
      }

      return '';
    }

    function normalizeDate(value) {
      return normalizeISODate(value).isoValue || '';
    } // Converts value to the user's timezone and formats it in a way that will be accepted by the input

    function normalizeUTCDateTime(value, timezone) {
      return normalizeISODateTime(value, timezone).isoValue || '';
    }
    function normalizeTime(value) {
      return normalizeISOTime(value).isoValue || '';
    } // parses the input value and converts it back to UTC from the user's timezone

    function normalizeDateTimeToUTC(value, timezone) {
      return normalizeFormattedDateTime(value, timezone) || '';
    }

    var groupingSeparator = ',';

    var decimalSeparator = '.';

    const VALID_NUMBER_CHARACTERS_EXPRESSION = new RegExp( // eslint-disable-next-line no-useless-escape
    '^[-+0-9kKmMeE.,\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9' + '\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF' + '\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF' + '\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9' + '\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9' + '\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89' + '\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49' + '\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909' + '\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9' + ']$');
    const SHORTCUT_FACTORS = {
      k: 3,
      m: 6
    };
    function toIsoDecimal(numberAsString) {
      const result = transformLocalizedNumberToIsoDecimal(numberAsString);

      if (isNaN(result)) {
        return '';
      }

      return result;
    }
    function isValidNumber(numberAsString) {
      return !isNaN(transformLocalizedNumberToIsoDecimal(numberAsString));
    }
    function fromIsoDecimal(numberAsString) {
      return toLocalizedDigits(numberAsString.replace('.', decimalSeparator));
    } // TODO: Too many options, simplify

    function increaseNumberByStep({
      value,
      increment,
      step,
      fractionDigits
    }) {
      const startingValue = value === '' || value == null ? '0' : value;
      const stepAsFloat = parseFloat(step);
      let result;

      if (isNaN(stepAsFloat)) {
        result = parseFloat(startingValue) + increment;
      } else {
        // ideally we'd round the value to the closest correct step, so that if say the step is '2', and the
        // current value is '1' it would increment to '2' instead of '3', since the former would be the valid
        // number given the step constraint, however this would significantly complicate the code, keeping
        // it simple for now.
        const increaseBy = increment * stepAsFloat;
        result = parseFloat(startingValue) + increaseBy;
      }

      return result.toFixed(fractionDigits);
    }
    function calculateFractionDigitsFromStep(step) {
      let calculatedFractionDigits;

      if (step) {
        const stepAsString = String(step).toLowerCase();

        if (stepAsString !== 'any') {
          // lowering the case because we're checking for exponent format as well
          let fractionDigits = 0;

          if (stepAsString.indexOf('.') >= 0 && stepAsString.indexOf('e') < 0) {
            const fractionalPart = stepAsString.split('.')[1]; // we're parsing to account for cases where the step is
            // '1.0', or '1.000', etc.

            if (parseInt(fractionalPart, 10) > 0) {
              fractionDigits = fractionalPart.length;
            }
          } else if (stepAsString.indexOf('e-') > 0) {
            // exponent form eg. 1.5e-5
            const splitOnExponent = stepAsString.split('e-');
            const fractionalPart = splitOnExponent[0].split('.')[1];
            const exponentPart = splitOnExponent[1];
            const fractionalPartLength = fractionalPart ? fractionalPart.length : 0;
            fractionDigits = parseInt(exponentPart, 10) + fractionalPartLength;
          }

          calculatedFractionDigits = fractionDigits;
        }
      }

      return calculatedFractionDigits;
    }
    function formatNumber(numberAsString, options) {
      if (isEmptyString(numberAsString)) {
        return '';
      }

      let formattedValue = numberAsString;
      let inputValue = numberAsString; // set formatter style & default options

      const formatStyle = options.style;
      const formatOptions = {
        style: formatStyle
      };
      formatOptions.minimumFractionDigits = options.minimumFractionDigits;
      formatOptions.maximumFractionDigits = options.maximumFractionDigits;

      if (formatStyle === 'percent-fixed') {
        // percent-fixed just uses percent format and divides the value by 100
        // before passing to the library, this is to deal with the
        // fact that percentages in salesforce are 0-100, not 0-1
        formatOptions.style = 'percent';
        const inputValueAsString = inputValue.toString();
        const normalisedNumberInPercent = parseFloat(inputValue) / 100; // If the number contains fraction digits and is not in an exponent format

        if (inputValueAsString.indexOf('.') > 0 && inputValueAsString.indexOf('e') < 0) {
          // Depending on the input number, division by 100 may lead to rounding errors
          // (e.g 0.785 / 100 is 0.007850000000000001), so we need to round back
          // to the correct precision, that is - existing number of fractional digits
          // plus extra 2 for division by 100.
          inputValue = normalisedNumberInPercent.toFixed(inputValueAsString.split('.')[1].length + 2);
        } else {
          inputValue = normalisedNumberInPercent;
        }
      }

      try {
        formattedValue = numberFormat$1(formatOptions).format(inputValue) || '';
      } catch (ignore) {// ignore any errors
      }

      return formattedValue;
    } // Exporting only to test, separators are only overridden in the tests

    function transformLocalizedNumberToIsoDecimal(numberAsString, separators) {
      if (numberAsString == null || numberAsString.length === 0) {
        return '';
      }

      const decimalSymbol = separators ? separators.decimalSeparator : decimalSeparator;
      const groupingSymbol = separators ? separators.groupSeparator : groupingSeparator; // remove the grouping separator

      let result = numberAsString.split(groupingSymbol).join('');

      if (decimalSymbol !== '.') {
        // replace the local decimal separator with a
        result = result.replace(decimalSymbol, '.');
      }

      return expandShortcuts(addLeadingZeroIfNeeded(fromLocalizedDigits(result)));
    }
    function isValidNumberCharacter(character) {
      return VALID_NUMBER_CHARACTERS_EXPRESSION.test(character);
    }
    function normalizeNumber(value) {
      if (value === undefined || value === null || isNaN(value)) {
        return '';
      }

      return String(value);
    }
    function hasValidNumberShortcut(value) {
      const result = value.toLowerCase().trim();
      const hasMoreThanOneK = result.indexOf('k') !== result.lastIndexOf('k');
      const hasMoreThanOneM = result.indexOf('m') !== result.lastIndexOf('m');
      const hasBothKAndM = result.indexOf('k') > 0 && result.indexOf('m') > 0;

      if (hasMoreThanOneK && hasMoreThanOneM || hasBothKAndM) {
        return false;
      }

      const endsWithK = result.endsWith('k');
      const endsWithM = result.endsWith('m'); // has 'm' or 'k' and more than just them (ie. result of 'm' or 'k' are not valid.

      return (endsWithK || endsWithM) && result.length > 1;
    } // Exported for testing only

    function expandShortcuts(isoValue) {
      if (!hasValidNumberShortcut(isoValue)) {
        return isoValue;
      }

      let result = isoValue.toLowerCase().trim();
      const shortcut = result.charAt(result.length - 1); // remove the suffix

      result = result.substring(0, result.length - 1);

      if (isNaN(result)) {
        return isoValue;
      }

      const parts = result.split('.');
      let fractionDigits = 0;
      const hasDecimalPart = parts.length > 1;

      if (hasDecimalPart) {
        fractionDigits = parts[1].length;
      }

      const exponent = SHORTCUT_FACTORS[shortcut]; // since multiplication may result in loss of precision on javascript's part,
      // we're calculating here the number of fraction digits needed and formatting
      // the number at that

      const newFractionDigits = Math.max(0, fractionDigits - exponent);
      return parseFloat(result * Math.pow(10, exponent)).toFixed(newFractionDigits);
    }

    function addLeadingZeroIfNeeded(result) {
      // If the number starts with +. OR  -. OR . ; insert a 0 before the decimal separator.
      // eg. -.2 -> -0.2
      const decimalSeparatorLocation = result.indexOf('.');

      if (decimalSeparatorLocation === 0 || decimalSeparatorLocation === 1) {
        const firstCharacter = result.charAt(0);

        if (firstCharacter === '+' || firstCharacter === '-' || firstCharacter === '.') {
          result = result.substring(0, decimalSeparatorLocation) + '0' + result.substring(decimalSeparatorLocation);
        }
      }

      return result;
    }

    const i18n$a = {
      a11yTriggerText: labelA11yTriggerText,
      inputFileBodyText: labelInputFileBodyText,
      inputFileButtonLabel: labelInputFileButtonLabel,
      messageToggleActive: labelMessageToggleActive,
      messageToggleInactive: labelMessageToggleInactive,
      numberIncrementCounter: labelNumberIncrementCounter,
      numberDecrementCounter: labelNumberDecrementCounter,
      required: labelRequired,
      clear: labelClear,
      loading: labelLoading
    };
    const ARIA_CONTROLS$3 = 'aria-controls';
    const ARIA_LABEL$2 = 'aria-label';
    const ARIA_LABELEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$4 = 'aria-describedby';
    /*
    * This component supports the regular native input types, with the addition of toggle, checkbox-button and color.
    * Furthermore the file type supports a droppable zone, search has a clear button, number has formatting.
    * Input changes (native oninput event) triggers an onchange event,
    *     the native even is stopped, the dispatched custom event has a value that points to the state of the component
    *     in case of files it's the files uploaded (via droppable zone or through the upload button),
    *     checked for radio and checkbox, checkbox-button, and just straight input's value for everything else
    *
    *
    * _Toggle_ (always has an aria-describedby, on error has an additional one, default label text for active and inactive
    * states)
    * _File_ (as it has a droppable zone, the validity returned would have to be valid - unless a custom error message was
    *    passed)
    * _Search_ (it has the clear button and the icon)
    * _Number_ (formatting when not in focus, when in focus shows raw value)
    *
    * */

    const VALID_NUMBER_FORMATTERS = ['decimal', 'percent', 'percent-fixed', 'currency'];
    const DEFAULT_COLOR$1 = '#000000';
    const DEFAULT_FORMATTER = VALID_NUMBER_FORMATTERS[0];
    /**
     * Returns an aria string with all the non-autolinked values removed
     * @param {String} values space sperated list of ids
     * @returns {String} The aria values with the non-auto linked ones removed
     */

    function filterNonAutoLink(values) {
      const ariaValues = values && values.split(/\s+/);
      return ariaValues && ariaValues.filter(value => {
        return !!value.match(/^auto-link/);
      }).join(' ');
    }
    /**
     * Represents interactive controls that accept user input depending on the type attribute.
     */


    class LightningInput extends lwc.LightningElement {
      /**
       * Text that is displayed when the field is empty, to prompt the user for a valid entry. Use this attribute with date, email, number, password, search, tel, text, time, and url input types only.
       * @type {string}
       *
       */

      /**
       * Specifies the name of an input element.
       * @type {string}
       *
       */

      /**
       * Text label for the input.
       * @type {string}
       * @required
       *
       */

      /**
       * Error message to be displayed when a bad input is detected. The badInput error can be returned for invalid input for any input type.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a pattern mismatch is detected. The patternMismatch error can be returned when you specify a pattern for email, password, search, tel, text, or url input types.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range overflow is detected. The rangeOverflow error can be returned when you specify a max value for number or range input types.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range underflow is detected. The rangeUnderflow error can be returned when you specify a min value for number or range input types.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a step mismatch is detected. The stepMismatch error can be returned when you specify a step value for number and range input types.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too short. The tooShort error can be returned when you specify a min-length value for email, password, search, tel, text, and url input types.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too long. The tooLong error can be returned when you specify a max-length value for email, password, search, tel, text, and url input types.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a type mismatch is detected. The typeMismatch error can be returned for the email and url input types.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is missing. The valueMissing error can be returned when you specify the required attribute for any input type.
       * @type {string}
       *
       */

      /**
       * Text shown for the active state of a toggle. The default is "Active".
       * @type {string}
       */

      /**
       * Text shown for the inactive state of a toggle. The default is "Inactive".
       * @type {string}
       */

      /**
       * Describes the input to assistive technologies.
       * @type {string}
       */

      /**
       * Controls auto-filling of the field. Use this attribute with
       * email, search, tel, text, and url input types only. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * @type {string}
       */

      /**
       * The display style of the date when type='date' or type='datetime'. Valid values are
       * short, medium (default), and long. The format of each style is specific to the locale.
       * On mobile devices this attribute has no effect.
       * @type {string}
       * @default medium
       */

      /**
       * The display style of the time when type='time' or type='datetime'. Valid values are
       * short (default), medium, and long. Currently, medium and long styles look the same.
       * On mobile devices this attribute has no effect.
       * @type {string}
       * @default short
       *
       */

      /**
       * Describes the date input to assistive technologies when type='datetime'. On mobile devices,
       * this label is merged with aria-label and time-aria-label to describe the native date time input.
       * @type {string}
       *
       */
      constructor() {
        super();
        this.placeholder = void 0;
        this.name = void 0;
        this.label = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenPatternMismatch = void 0;
        this.messageWhenRangeOverflow = void 0;
        this.messageWhenRangeUnderflow = void 0;
        this.messageWhenStepMismatch = void 0;
        this.messageWhenTooShort = void 0;
        this.messageWhenTooLong = void 0;
        this.messageWhenTypeMismatch = void 0;
        this.messageWhenValueMissing = void 0;
        this.messageToggleActive = i18n$a.messageToggleActive;
        this.messageToggleInactive = i18n$a.messageToggleInactive;
        this.ariaLabel = void 0;
        this.autocomplete = void 0;
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.dateAriaLabel = void 0;
        this._timeAriaDescribedBy = void 0;
        this._timeAriaLabelledBy = void 0;
        this._timeAriaControls = void 0;
        this._dateAriaControls = void 0;
        this._dateAriaDescribedBy = void 0;
        this._dateAriaLabelledBy = void 0;
        this._value = '';
        this._type = 'text';
        this._pattern = void 0;
        this._max = void 0;
        this._min = void 0;
        this._step = void 0;
        this._disabled = false;
        this._readOnly = false;
        this._required = false;
        this._checked = false;
        this._isLoading = false;
        this._multiple = false;
        this._timezone = false;
        this._helpMessage = null;
        this._isColorPickerPanelOpen = false;
        this._fieldLevelHelp = void 0;
        this._accesskey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._accept = void 0;
        this._variant = void 0;
        this._numberRawValue = '';
        this._formatter = DEFAULT_FORMATTER;
        this._showRawNumber = false;
        this._initialValueSet = false;
        this._files = null;
        this._rendered = void 0;
        this.ariaObserver = new ContentMutation(this); // Native Shadow Root will return [native code].
        // Our synthetic method will return the function source.

        this.isNative = this.template.querySelector.toString().match(/\[native code\]/);
      }

      connectedCallback() {
        this.classList.add('slds-form-element');

        this._updateClassList();

        this._validateRequiredAttributes();

        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.reportValidity());

        if (this.isTypeNumber) {
          this._updateNumberValue(this._value);
        }
      }

      disconnectedCallback() {
        this._rendered = false;
        this._initialValueSet = false;
        this._cachedInputElement = undefined;
      }

      renderedCallback() {
        if (!this._initialValueSet && this._inputElement) {
          this._rendered = true;

          if (this.isTypeNumber) {
            this._numberRawValue = fromIsoDecimal(this._value);
          }

          this._setInputValue(this._displayedValue);

          if (this.isTypeCheckable) {
            this._inputElement.checked = this._checked;
          }

          this._initialValueSet = true;
        }

        this.ariaObserver.sync();

        this._synchronizeA11y();
      }
      /**
       * Reserved for internal use.
       * @type {number}
       *
       */


      get formatFractionDigits() {
        return this._formatFractionDigits;
      }

      set formatFractionDigits(value) {
        this._formatFractionDigits = value;

        if (this._rendered && this.isTypeNumber) {
          this._setInputValue(this._displayedValue);
        }
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * time input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and date-aria-controls to describe the native date time input.
       * @type {string}
       */


      get timeAriaControls() {
        return this._timeAriaControls;
      }

      set timeAriaControls(references) {
        this._timeAriaControls = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._timeAriaControls = reference;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the date input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and time-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       */


      get dateAriaLabelledBy() {
        return this._dateAriaLabelledBy;
      }

      set dateAriaLabelledBy(references) {
        this._dateAriaLabelledBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._dateAriaLabelledBy = reference;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the time input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and date-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       *
       */


      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaLabelledBy(references) {
        this._timeAriaLabelledBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._timeAriaLabelledBy = reference;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the time input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and date-aria-described-by
       * to describe the native date time input.
       *  @type {string}
       *
       */


      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      set timeAriaDescribedBy(references) {
        this._timeAriaDescribedBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._timeAriaDescribedBy = reference;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * date input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and time-aria-controls to describe the native date time input.
       * @type {string}
       *
       */


      get dateAriaControls() {
        return this._dateAriaControls;
      }

      set dateAriaControls(references) {
        this._dateAriaControls = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._dateAriaControls = reference;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the date input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and time-aria-described-by
       * to describe the native date time input.
       * @type {string}
       */


      get dateAriaDescribedBy() {
        return this._dateAriaDescribedBy;
      }

      set dateAriaDescribedBy(references) {
        this._dateAriaDescribedBy = references;
        this.ariaObserver.connectLiveIdRef(references, reference => {
          this._dateAriaDescribedBy = reference;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the input.
       * @type {string}
       */


      get ariaControls() {
        return this._ariaControls;
      }

      set ariaControls(references) {
        this._ariaControls = references;
        this.ariaObserver.link('input', 'aria-controls', references, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide labels for the input.
       * @type {string}
       */


      get ariaLabelledBy() {
        // native version returns the auto linked value
        if (this.isNative) {
          const ariaValues = this.template.querySelector('input').getAttribute('aria-labelledby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaLabelledBy;
      }

      set ariaLabelledBy(references) {
        this._ariaLabelledBy = references;
        this.ariaObserver.link('input', 'aria-labelledby', references, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the input.
       * @type {string}
       */


      get ariaDescribedBy() {
        if (this.isNative) {
          // in native case return the linked value
          const ariaValues = this.template.querySelector('input').getAttribute('aria-describedby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaDescribedBy;
      }

      set ariaDescribedBy(references) {
        this._ariaDescribedBy = references;
        this.ariaObserver.link('input', 'aria-describedby', references, '[data-aria]');
      }
      /**
       * String value with the formatter to be used for number input. Valid values include
       * decimal, percent, percent-fixed, and currency.
       * @type {string}
       */


      get formatter() {
        return this._formatter;
      }

      set formatter(value) {
        this._formatter = normalizeString(value, {
          fallbackValue: DEFAULT_FORMATTER,
          validValues: VALID_NUMBER_FORMATTERS
        });

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * The type of the input. This value defaults to text.
       * @type {string}
       * @default text
       */


      get type() {
        return this._type;
      }

      set type(value) {
        const normalizedValue = normalizeString(value);
        this._type = normalizedValue === 'datetime' ? 'datetime-local' : normalizedValue;

        this._validateType(normalizedValue);

        this._inputElementRefreshNeeded = true;

        if (this._rendered) {
          // The type is being changed after render, which means the input element may be different (eg. changing
          // from text to 'checkbox', so we need to set the initial value again
          this._initialValueSet = false;

          if (this.isTypeNumber) {
            // If the type has changed, we need to re-parse the value as a number
            this._updateNumberValue(this._value);
          }
        }

        this._updateProxyInputAttributes(['type', 'value', 'max', 'min', 'required', 'pattern']);
      }
      /**
       * For the search type only. If present, a spinner is displayed to indicate that data is loading.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return this._isLoading;
      }

      set isLoading(value) {
        this._isLoading = normalizeBoolean(value);
      }
      /**
       * Specifies the regular expression that the input's value is checked against.
       * This attribute is supported for email, password, search, tel, text, and url types.
       * @type {string}
       *
       */


      get pattern() {
        if (this.isTypeColor) {
          return '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$';
        }

        return this._pattern;
      }

      set pattern(value) {
        this._pattern = value;

        this._updateProxyInputAttributes('pattern');
      }
      /**
       * The maximum number of characters allowed in the field.
       * Use this attribute with email, password, search, tel, text, and url input types only.
       * @type {number}
       */


      get maxLength() {
        return this._maxLength;
      }

      set maxLength(value) {
        this._maxLength = value;

        this._updateProxyInputAttributes('maxlength');
      }
      /**
       * Specifies the types of files that the server accepts. Use this attribute with file input type only.
       * @type {string}
       */


      get accept() {
        return this._accept;
      }

      set accept(value) {
        this._accept = value;

        this._updateProxyInputAttributes('accept');
      }
      /**
       * The minimum number of characters allowed in the field.
       * Use this attribute with email, password, search, tel, text, and url input types only.
       * @type {number}
       */


      get minLength() {
        return this._minLength;
      }

      set minLength(value) {
        this._minLength = value;

        this._updateProxyInputAttributes('minlength');
      } // number and date/time

      /**
       * The maximum acceptable value for the input.  Use this attribute with number,
       * range, date, time, and datetime input types only. For number and range type, the max value is a
       * decimal number. For the date, time, and datetime types, the max value must use a valid string for the type.
       * @type {decimal|string}
       */


      get max() {
        return this._max;
      }

      set max(value) {
        this._max = value;

        this._updateProxyInputAttributes('max');
      }
      /**
       * The minimum acceptable value for the input. Use this attribute with number,
       * range, date, time, and datetime input types only. For number and range types, the min value
       * is a decimal number. For the date, time, and datetime types, the min value must use a valid string for the type.
       * @type {decimal|string}
       */


      get min() {
        return this._min;
      }

      set min(value) {
        this._min = value;

        this._updateProxyInputAttributes('min');
      }
      /**
       * Granularity of the value, specified as a positive floating point number.
       * Use this attribute with number and range input types only.
       * Use 'any' when granularity is not a concern. This value defaults to 1.
       * @type {decimal|string}
       * @default 1
       */


      get step() {
        // This should be reconsidered as it in effect disabled any step support for datetime/time types on mobile
        if (this.isTypeDateTime || this.isTypeTime) {
          return 'any';
        } // It should probably default to '1' instead, but this means that we'd be explicitly passing step='1' to the
        // native input


        return this._step;
      }

      set step(value) {
        if (typeof value === 'string' && value.toLowerCase() === 'any') {
          this._step = 'any';
        } else {
          this._step = isUndefinedOrNull(value) || isNaN(value) ? undefined : String(value);
        }

        this._updateProxyInputAttributes('step');

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * If present, the checkbox is selected.
       * @type {boolean}
       * @default false
       */


      get checked() {
        // checkable inputs can be part of a named group, in that case there won't be a change event thrown and so
        // the internal tracking _checked would be out of sync with the actual input value.
        if (this.isTypeCheckable && this._initialValueSet) {
          return this._inputElement.checked;
        }

        return this._checked;
      }

      set checked(value) {
        this._checked = normalizeBoolean(value);

        this._updateProxyInputAttributes('checked');

        if (this._rendered) {
          this._inputElement.checked = this._checked;
        }
      }
      /**
       * Specifies that a user can enter more than one value. Use this attribute with file and email input types only.
       * @type {boolean}
       * @default false
       */


      get multiple() {
        return this._multiple;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);

        this._updateProxyInputAttributes('multiple');
      }
      /**
       * Specifies the value of an input element.
       * @type {object}
       */


      get value() {
        return this._value;
      }

      set value(value) {
        const previousValue = this._value;
        this._value = normalizeInput(value);

        if (this._rendered && this.isTypeNumber) {
          this._value = normalizeNumber(value); // the extra check for whether the value has changed is done for cases
          // when the same value is set back in a change handler, this is to avoid
          // the raw number from changing formatting under the user
          // (eg. if the user typed 1,000 we want to preserve that formatting as the user
          // types the value)

          if (this.validity.badInput || this._value !== previousValue) {
            this._updateNumberValue(value);
          }
        }

        this._updateProxyInputAttributes('value'); // Setting value of a type='file' isn't allowed


        if (!this.isTypeFile) {
          // Again, due to the interop layer we need to check whether the value being set
          // is different, otherwise we're duplicating the sets on the input, which result
          // in different bugs like Japanese IME duplication of characters in Safari (likely a browser bug) or
          // character position re-set in IE11.
          if (this._rendered && this._inputElement.value !== this._displayedValue) {
            this._setInputValue(this._displayedValue);
          }
        }
      }
      /**
       * The variant changes the appearance of an input field.
       * Accepted variants include standard, label-inline, label-hidden, and label-stacked.
       * This value defaults to standard, which displays the label above the field.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input field.
       * Use label-stacked to place the label above the input field.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);

        this._updateClassList();
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        this._updateProxyInputAttributes('disabled');
      }
      /**
       * If present, the input field is read-only and cannot be edited by users.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readOnly;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);

        this._updateProxyInputAttributes('readonly');
      }
      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);

        this._updateProxyInputAttributes('required');
      }
      /**
       * Specifies the time zone used when type='datetime' only. This value defaults to the user's Salesforce time zone setting.
       * @type {string}
       *
       */


      get timezone() {
        return this._timezone || userTimeZone;
      }

      set timezone(value) {
        this._timezone = value; // mobile date/time normalization of value/max/min depends on timezone, so we need to update here as well

        this._updateProxyInputAttributes(['value', 'max', 'min']);
      }
      /**
       * Help text detailing the purpose and function of the input.
       * This attribute isn't supported for file, toggle, and checkbox-button types.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Specifies a shortcut key to activate or focus an element.
       * @type {string}
       *
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
      }
      /**
       * A FileList that contains selected files. Use this attribute with the file input type only.
       * @type {object}
       *
       */


      get files() {
        if (this.isTypeFile) {
          return this._files;
        }

        return null;
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Sets a custom error message to be displayed when a form is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          if (this._rendered && !this.isNativeInput) {
            this._inputElement.showHelpMessage(message);
          } else {
            this._helpMessage = message;
          }
        });
      }
      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this._rendered) {
          this._inputElement.focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this._rendered) {
          this._inputElement.blur();
        }
      }

      get isNativeInput() {
        return !(this.isTypeDesktopDate || this.isTypeDesktopDateTime || this.isTypeDesktopTime);
      }

      get computedAriaControls() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaControls);
          ariaValues.push(this.timeAriaControls);
        }

        if (this.ariaControls) {
          ariaValues.push(this.ariaControls);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabel() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabel);
          ariaValues.push(this.timeAriaLabel);
        }

        if (this.ariaLabel) {
          ariaValues.push(this.ariaLabel);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabelledBy() {
        const ariaValues = [];

        if (this.isTypeFile) {
          ariaValues.push(this.computedUniqueFileElementLabelledById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabelledBy);
          ariaValues.push(this.timeAriaLabelledBy);
        }

        if (this.ariaLabelledBy) {
          ariaValues.push(this.ariaLabelledBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        if (this._helpMessage) {
          ariaValues.push(this.computedUniqueHelpElementId);
        } // The toggle type is described by a secondary element


        if (this.isTypeToggle) {
          ariaValues.push(this.computedUniqueToggleElementDescribedById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaDescribedBy);
          ariaValues.push(this.timeAriaDescribedBy);
        }

        if (this.ariaDescribedBy) {
          ariaValues.push(this.ariaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get isLabelStacked() {
        return this.variant === VARIANT.LABEL_STACKED;
      }

      get accesskey() {
        return this._accesskey;
      }

      get colorInputElementValue() {
        return this.validity.valid && this.value ? this.value : DEFAULT_COLOR$1;
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      get computedUniqueHelpElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get computedUniqueToggleElementDescribedById() {
        if (this.isTypeToggle) {
          const toggle = this.template.querySelector('[data-toggle-description]');
          return getRealDOMId(toggle);
        }

        return null;
      }

      get computedUniqueFormLabelId() {
        if (this.isTypeFile) {
          const formLabel = this.template.querySelector('[data-form-label]');
          return getRealDOMId(formLabel);
        }

        return null;
      }

      get computedUniqueFileSelectorLabelId() {
        if (this.isTypeFile) {
          const fileBodyLabel = this.template.querySelector('[data-file-selector-label]');
          return getRealDOMId(fileBodyLabel);
        }

        return null;
      }

      get computedUniqueFileElementLabelledById() {
        if (this.isTypeFile) {
          const labelIds = [this.computedUniqueFormLabelId, this.computedUniqueFileSelectorLabelId];
          return labelIds.join(' ');
        }

        return null;
      }

      get computedFormElementClass() {
        const classes = classSet('slds-form-element__control slds-grow');

        if (this.isTypeSearch) {
          classes.add('slds-input-has-icon slds-input-has-icon_left-right');
        }

        return classes.toString();
      }

      get i18n() {
        return i18n$a;
      }

      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');

        if (this.isTypeCheckable || this.isTypeFile) ; else if (this.isTypeToggle) {
          classnames.add('slds-m-bottom_none');
        } else {
          classnames.add('slds-no-flex');
        }

        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedNumberClass() {
        return classSet('slds-input').add({
          'slds-is-disabled': this.disabled
        }).toString();
      }

      get computedColorLabelClass() {
        return classSet('slds-form-element__label slds-color-picker__summary-label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedCheckboxClass() {
        return classSet('slds-checkbox').add({
          'slds-checkbox_standalone': !this.isStandardVariant
        }).toString();
      }

      get normalizedMax() {
        return this._normalizeDateTimeString(this.max);
      }

      get normalizedMin() {
        return this._normalizeDateTimeString(this.min);
      }

      get isTypeNumber() {
        return this.type === 'number';
      }

      get isTypeCheckable() {
        return this.isTypeCheckbox || this.isTypeCheckboxButton || this.isTypeRadio || this.isTypeToggle;
      }

      get isTypeSearch() {
        return this.type === 'search';
      }

      get isTypeToggle() {
        return this.type === 'toggle';
      }

      get isTypeText() {
        return this.type === 'text';
      }

      get isTypeCheckbox() {
        return this.type === 'checkbox';
      }

      get isTypeRadio() {
        return this.type === 'radio';
      }

      get isTypeCheckboxButton() {
        return this.type === 'checkbox-button';
      }

      get isTypeFile() {
        return this.type === 'file';
      }

      get isTypeColor() {
        return this.type === 'color';
      }

      get isTypeDate() {
        return this.type === 'date';
      }

      get isTypeDateTime() {
        return this.type === 'datetime' || this.type === 'datetime-local';
      }

      get isTypeTime() {
        return this.type === 'time';
      }

      get isTypeMobileDate() {
        return this.isTypeDate && !this._isDesktopBrowser();
      }

      get isTypeDesktopDate() {
        return this.isTypeDate && this._isDesktopBrowser();
      }

      get isTypeMobileDateTime() {
        return this.isTypeDateTime && !this._isDesktopBrowser();
      }

      get isTypeDesktopDateTime() {
        return this.isTypeDateTime && this._isDesktopBrowser();
      }

      get isTypeMobileTime() {
        return this.isTypeTime && !this._isDesktopBrowser();
      }

      get isTypeDesktopTime() {
        return this.isTypeTime && this._isDesktopBrowser();
      }

      get isTypeSimple() {
        return !this.isTypeCheckbox && !this.isTypeCheckboxButton && !this.isTypeToggle && !this.isTypeRadio && !this.isTypeFile && !this.isTypeColor && !this.isTypeDesktopDate && !this.isTypeDesktopDateTime && !this.isTypeDesktopTime;
      }

      get _inputElement() {
        if (!this._cachedInputElement || this._inputElementRefreshNeeded) {
          this._inputDragonDecorated = false;
          let inputElement;

          if (this.isTypeDesktopDate) {
            inputElement = this.template.querySelector('lightning-datepicker');
          } else if (this.isTypeDesktopDateTime) {
            inputElement = this.template.querySelector('lightning-datetimepicker');
          } else if (this.isTypeDesktopTime) {
            inputElement = this.template.querySelector('lightning-timepicker');
          } else {
            inputElement = this.template.querySelector('input');
            this._inputDragonDecorated = true;
            decorateInputForDragon(inputElement);
          }

          this._inputElementRefreshNeeded = false;
          this._cachedInputElement = inputElement;
        }

        return this._cachedInputElement;
      }

      get _inputTypeForValidity() {
        let inputType = 'text';

        if (this.isTypeSimple) {
          if (this.isTypeNumber) {
            inputType = 'number';
          } else {
            inputType = this.type;
          }
        } else if (this.isTypeCheckable) {
          inputType = this.isTypeRadio ? 'radio' : 'checkbox';
        } else if (this.isTypeFile) {
          inputType = 'file';
        } else if (this.isTypeDateTime) {
          inputType = 'datetime-local';
        } else if (this.isTypeTime) {
          inputType = 'time';
        } else if (this.isTypeDate) {
          inputType = 'date';
        }

        return inputType;
      }

      get _displayedValue() {
        if (this.isTypeNumber) {
          // If the number is not valid (bad input, step mismatch, etc.) show the raw number as
          // well, otherwise the formatted value ends up being 'NaN' which makes it hard to
          // see mistakes
          if (this._showRawNumber || !this.validity.valid) {
            if (hasValidNumberShortcut(this._numberRawValue) && isValidNumber(this._numberRawValue)) {
              this._numberRawValue = fromIsoDecimal(this._value);
            }

            return this._numberRawValue;
          }

          return formatNumber(this._value, this._buildFormatNumberOptions(this.formatter));
        }

        if (this.isTypeMobileDate || this.isTypeMobileDateTime || this.isTypeMobileTime) {
          return this._normalizeDateTimeString(this._value);
        }

        return this._value;
      }

      get _internalType() {
        if (this.isTypeNumber) {
          return 'text';
        }

        return this._type;
      }

      get isStandardVariant() {
        return this.variant === VARIANT.STANDARD || this.variant === VARIANT.LABEL_HIDDEN;
      }

      get _showClearButton() {
        return this.isTypeSearch && isNotUndefinedOrNull(this._value) && this._value !== '';
      }

      get _ignoreRequired() {
        // If uploading via the drop zone or via the input directly, we should
        // ignore the required flag as a file has been uploaded
        return this.isTypeFile && this._required && (this.fileUploadedViaDroppableZone || this._files && this._files.length > 0);
      }

      get _inputMode() {
        if (this.isTypeNumber) {
          return 'decimal';
        }

        return null;
      }

      get _constraint() {
        if (!this._constraintApi) {
          const overrides = {
            badInput: () => {
              if (!this._rendered) {
                return false;
              }

              if (this.isTypeNumber) {
                return !isValidNumber(this._numberRawValue);
              }

              if (!this.isNativeInput) {
                return this._inputElement.hasBadInput();
              }

              return this._inputElement.validity.badInput;
            },
            tooLong: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as maxlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._rendered && this._inputElement.validity.tooLong,
            tooShort: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as minlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._rendered && this._inputElement.validity.tooShort,
            patternMismatch: () => this.isNativeInput && this._rendered && this._inputElement.validity.patternMismatch
          }; // FF, IE and Safari don't support type datetime-local,
          // IE and Safari don't support type date or time
          // we need to defer to the base component to check rangeOverflow/rangeUnderflow.
          // Due to the custom override, changing the type to or from datetime/time would affect the validation

          if (this.isTypeDesktopDateTime || this.isTypeDesktopTime || this.isTypeDesktopDate) {
            overrides.rangeOverflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const max = this.isTypeDesktopTime ? normalizeTime(this.max) : this.max;
              return isAfter(this.value, max);
            };

            overrides.rangeUnderflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const min = this.isTypeDesktopTime ? normalizeTime(this.min) : this.min;
              return isBefore(this.value, min);
            };

            overrides.stepMismatch = () => false;
          }

          if (this.isIE11) {
            overrides.stepMismatch = () => false;
          }

          this._constraintApi = new FieldConstraintApiWithProxyInput(() => {
            // The date/time components display their own errors and have custom messages for badInput and rangeOverflow/Underflow.
            if (!this.isNativeInput) {
              return this._inputElement;
            }

            return this;
          }, overrides);
          this._constraintApiProxyInputUpdater = this._constraint.setInputAttributes({
            type: () => this._inputTypeForValidity,
            // We need to normalize value so that it's consumable by the proxy input (otherwise the value
            // will be invalid for the native input)
            value: () => this._normalizeDateTimeString(this.value),
            checked: () => this.checked,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            // 'pattern' depends on type
            pattern: () => this.pattern,
            // 'max' and 'min' depend on type and timezone
            max: () => this.normalizedMax,
            min: () => this.normalizedMin,
            step: () => this.step,
            accept: () => this.accept,
            multiple: () => this.multiple,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            // depends on type and whether an upload has been made
            required: () => this.required && !this._ignoreRequired
          });
        }

        return this._constraintApi;
      }

      handleFileClick() {
        this._setInputValue(null);

        this._updateValueAndValidityAttribute(null);
      }

      handleDropFiles(event) {
        // drop doesn't trigger focus nor blur, so set state to interacting
        // and auto leave when there's no more action
        this.interactingState.interacting();
        this.fileUploadedViaDroppableZone = true;
        this._files = event.dataTransfer && event.dataTransfer.files;

        this._updateProxyInputAttributes('required');

        this._dispatchChangeEventWithDetail({
          files: this._files
        });
      }

      handleFocus() {
        this.interactingState.enter();

        if (this.isTypeColor) {
          this._isColorPickerPanelOpen = false;
        }

        if (this._rendered && this.isTypeNumber) {
          this._showRawNumber = true;
          this._inputElement.value = this._displayedValue; // W-6176985: IE11 input when set value, will move cursor to beginning.
          // This fix is only for input type=number on IE11, and force the cursor to the end.

          if (isIE11) {
            const length = this._inputElement.value.length;
            this._inputElement.selectionStart = length;
            this._inputElement.selectionEnd = length;
          }
        }

        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur(event) {
        this.interactingState.leave();

        if (this._rendered && this.isTypeNumber) {
          this._showRawNumber = false;

          this._setInputValue(this._displayedValue);
        }

        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }

      handleChange(event) {
        event.stopPropagation();

        this._dispatchCommitEvent();

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this._dispatchChangeEvent();
      }

      handleInput(event) {
        event.stopPropagation();

        if (this.isTypeNumber) {
          // for invalid numbers the value might stay the same as the user
          // changed the invalid input, so we need to update the raw value
          this._numberRawValue = this._inputElement.value;
        }

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this._dispatchChangeEvent();
      }

      handleKeyDown(event) {
        if (this.isTypeNumber) {
          // we're letting "Shift" through to prevent capital letters, other special symbols for type="number"
          const hasMetaOrCtrlModifier = event.metaKey || event.ctrlKey; // need to check that event.key is valid for "autofill" cases

          if (!hasMetaOrCtrlModifier && !this.readOnly && event.key) {
            const key = normalizeKeyValue(event.key);

            if (key.length === 1 && !isValidNumberCharacter(key)) {
              event.preventDefault();
            }

            if (key === 'ArrowUp') {
              event.preventDefault();

              this._numberStepUpAndDispatchEvents(1);
            } else if (key === 'ArrowDown') {
              event.preventDefault();

              this._numberStepUpAndDispatchEvents(-1);
            }
          }
        }
      }

      handleColorChange(event) {
        const selectedColor = event.detail.color;

        if (selectedColor !== this._inputElement.value) {
          this._setInputValue(selectedColor);

          this._updateValueAndValidityAttribute(selectedColor);

          this.focus();

          this._dispatchChangeEventWithDetail({
            value: selectedColor
          });

          this._dispatchCommitEvent();
        }

        this.template.querySelector('lightning-primitive-colorpicker-button').focus();
      }

      _clearAndSetFocusOnInput(event) {
        // TODO: Discuss this, it seems the wrong thing to do.
        // button is removed from template, but
        // event still is propagated, For example, captured by panel,
        // then cause panel think is clicked outside.
        event.stopPropagation();
        this.interactingState.enter();

        this._setInputValue('');

        this._updateValueAndValidityAttribute('');

        this._inputElement.focus();

        this._dispatchChangeEventWithDetail({
          value: this._value
        });

        this._dispatchCommitEvent();
      }

      _dispatchCommitEvent() {
        this.dispatchEvent(new CustomEvent('commit'));
      }

      _dispatchChangeEventWithDetail(detail) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail
        }));
      }

      _validateType(type) {
        assert(type !== 'hidden', `<lightning-input> The type attribute value "hidden" is invalid. Use a regular <input type="hidden"> instead.`);
        assert(type !== 'submit' && type !== 'reset' && type !== 'image' && type !== 'button', `<lightning-input> The type attribute value "${type}" is invalid. Use <lightning:button> instead.`);

        if (this.isTypeRadio) {
          assert(!this.required, `<lightning-input> The required attribute is not supported on radio inputs directly. It should be implemented at the radio group level.`);
        }
      }

      _validateRequiredAttributes() {
        const {
          label
        } = this;
        assert(typeof label === 'string' && label.length, `<lightning-input> The required label attribute value "${label}" is invalid.`);
      }

      _setInputValue(value) {
        if (this._inputDragonDecorated) {
          // The underlying input has been modified to dispatch an 'input' event when a direct value set
          // is used to allow for Dragon Natural Speaking (which sets the value directly on the inputs instead
          // dispatching an input event against the input). Since we're in a programatic set here (ie. set
          // not resulting from a direct user interaction) we want a default setter behaviour that doesn't
          // dispatch any events.
          setDecoratedDragonInputValueWithoutEvent(this._inputElement, value);
        } else {
          this._inputElement.value = value;
        }
      }

      _dispatchChangeEvent() {
        this.interactingState.enter();
        const detail = {};

        if (this.isTypeCheckable) {
          this._updateCheckedAndValidityAttribute(this._inputElement.checked);

          detail.checked = this._checked;
        } else if (this.isTypeFile) {
          this._files = this._inputElement.files; // LWC does not proxy dom elements any more. So there is no need to call lwc.unwrap here anymore

          detail.files = this._files;

          this._updateProxyInputAttributes('required');
        }

        if (!this.isTypeCheckable) {
          if (this.isTypeNumber) {
            this._numberRawValue = this._inputElement.value;
            detail.value = toIsoDecimal(this._inputElement.value);
          } else {
            detail.value = this._inputElement.value;
          }

          if (this.isTypeMobileDateTime) {
            detail.value = normalizeDateTimeToUTC(detail.value, this.timezone);
          } else if (this.isTypeMobileTime) {
            detail.value = normalizeTime(detail.value);
          }

          this._updateValueAndValidityAttribute(detail.value);
        }

        this._dispatchChangeEventWithDetail(detail);
      }

      _isDesktopBrowser() {
        return formFactor === 'Large';
      }

      _updateValueAndValidityAttribute(value) {
        this._value = value;

        this._updateProxyInputAttributes('value');
      }

      _updateCheckedAndValidityAttribute(value) {
        this._checked = value;

        this._updateProxyInputAttributes('checked');
      }

      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      _updateInputDisplayValueIfTypeNumber() {
        // Displayed value depends on the format number, so if we're not showing the raw
        // number we should update the value
        if (this._rendered && this.isTypeNumber && !this._showRawNumber && this._inputElement) {
          this._setInputValue(this._displayedValue);
        }
      }
      /**
       * Increases (if increment is positive, decreases otherwise) the number value of the input by the increment
       * multiple of the given 'step'. Additionally dispatches the 'change' and 'commit' events.
       *
       * @param {Number} increment A multiple of the step to increase, when step is 'any',
       * the step is assumed to be 1.
       * @private
       */


      _numberStepUpAndDispatchEvents(increment) {
        if (this._readOnly || this._disabled) {
          return;
        }

        this._value = increaseNumberByStep({
          value: this._value,
          step: this.step,
          increment,
          fractionDigits: this._buildFormatNumberOptions(this.formatter).minimumFractionDigits
        }); // Raw value is the value the user entered (we preserve a user's input),
        // since we're generating a new value we're overriding it

        this._numberRawValue = fromIsoDecimal(this._value);

        this._setInputValue(this._displayedValue);

        this._dispatchChangeEvent();

        this._dispatchCommitEvent();
      }

      _updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      _updateNumberValue(value) {
        const newValue = normalizeNumber(value);
        this._value = newValue;
        this._numberRawValue = fromIsoDecimal(newValue);
      }

      _buildFormatNumberOptions(formatter) {
        const options = {
          style: formatter
        }; // Use the min/max fraction digits from the formatFractionDigits provided by the user if available.
        // Otherwise, use the number of digits calculated from step

        if (this._formatFractionDigits !== undefined) {
          options.minimumFractionDigits = this._formatFractionDigits;
          options.maximumFractionDigits = this._formatFractionDigits;
        } else {
          let digitsFromStep = calculateFractionDigitsFromStep(this._step); // if formatting percentages, when calculating digits from step, take into
          // consideration that the formatted number is effectively multiplied by 10^2, ie. 0.1 is 10%
          // so we need to subtract 2 digits;

          if (formatter === 'percent' && typeof digitsFromStep === 'number') {
            digitsFromStep -= 2;

            if (digitsFromStep < 0) {
              digitsFromStep = 0;
            }
          }

          options.minimumFractionDigits = digitsFromStep;
          options.maximumFractionDigits = digitsFromStep;
        }

        return options;
      }

      _normalizeDateTimeString(value) {
        let result = value;

        if (this.isTypeDate) {
          result = normalizeDate(value);
        } else if (this.isTypeTime) {
          result = normalizeTime(value);
        } else if (this.isTypeDateTime) {
          result = normalizeUTCDateTime(value, this.timezone);
        }

        return result;
      }

      _synchronizeA11y() {
        const input = this.template.querySelector('input');
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (input) {
          synchronizeAttrs(input, {
            [ARIA_LABELEDBY]: this.computedAriaLabelledBy,
            [ARIA_DESCRIBEDBY$4]: this.computedAriaDescribedBy,
            [ARIA_CONTROLS$3]: this.computedAriaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
        } else if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
        } else if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
        }
      }

    }

    LightningInput.delegatesFocus = true;

    lwc.registerDecorators(LightningInput, {
      publicProps: {
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        label: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenPatternMismatch: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 0
        },
        messageWhenRangeUnderflow: {
          config: 0
        },
        messageWhenStepMismatch: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenTypeMismatch: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageToggleActive: {
          config: 0
        },
        messageToggleInactive: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        formatFractionDigits: {
          config: 3
        },
        timeAriaControls: {
          config: 3
        },
        dateAriaLabelledBy: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 3
        },
        dateAriaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        formatter: {
          config: 3
        },
        type: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        pattern: {
          config: 3
        },
        maxLength: {
          config: 3
        },
        accept: {
          config: 3
        },
        minLength: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        step: {
          config: 3
        },
        checked: {
          config: 3
        },
        multiple: {
          config: 3
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        timezone: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        files: {
          config: 1
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["checkValidity", "setCustomValidity", "reportValidity", "showHelpMessageIfInvalid", "focus", "blur"],
      track: {
        _timeAriaDescribedBy: 1,
        _timeAriaLabelledBy: 1,
        _timeAriaControls: 1,
        _dateAriaControls: 1,
        _dateAriaDescribedBy: 1,
        _dateAriaLabelledBy: 1,
        _value: 1,
        _type: 1,
        _pattern: 1,
        _max: 1,
        _min: 1,
        _step: 1,
        _disabled: 1,
        _readOnly: 1,
        _required: 1,
        _checked: 1,
        _isLoading: 1,
        _multiple: 1,
        _timezone: 1,
        _helpMessage: 1,
        _isColorPickerPanelOpen: 1,
        _fieldLevelHelp: 1,
        _accesskey: 1,
        _maxLength: 1,
        _minLength: 1,
        _accept: 1,
        _variant: 1,
        _numberRawValue: 1
      },
      fields: ["_formatter", "_showRawNumber", "_initialValueSet", "_files", "_rendered"]
    });

    var _lightningInput = lwc.registerComponent(LightningInput, {
      tmpl: _tmpl$l
    });
    LightningInput.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    function stylesheet$6(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$6 = [stylesheet$6];

    function stylesheet$7(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$7 = [stylesheet$7];

    function tmpl$n($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        className: $cmp.computedClass,
        attrs: {
          "role": "status"
        },
        key: 3
      }, [$cmp.validAlternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 0
      }, [api_dynamic($cmp.alternativeText)]) : null, api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 1
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 2
      }, [])])];
    }

    var _tmpl$m = lwc.registerTemplate(tmpl$n);
    tmpl$n.stylesheets = [];
    tmpl$n.stylesheetTokens = {
      hostAttribute: "lightning-spinner_spinner-host",
      shadowAttribute: "lightning-spinner_spinner"
    };

    /**
     * Displays an animated spinner.
     */

    class LightningSpinner extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = void 0;
        this.size = 'medium';
        this.variant = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-spinner_container');
        this.template.addEventListener('mousewheel', this.stopScrolling);
        this.template.addEventListener('touchmove', this.stopScrolling);
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'base',
          validValues: ['base', 'brand', 'inverse']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['small', 'medium', 'large']
        });
      }

      get computedClass() {
        const {
          normalizedVariant,
          normalizedSize
        } = this;
        const classes = classSet('slds-spinner'); // add variant-specific class

        if (normalizedVariant !== 'base') {
          classes.add(`slds-spinner_${normalizedVariant}`);
        } // add size-specific class


        classes.add(`slds-spinner_${normalizedSize}`);
        return classes.toString();
      } // alternativeText validation


      get validAlternativeText() {
        const hasAlternativeText = !!this.alternativeText; // if we have an empty value output a console warning

        if (!hasAlternativeText) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-spinner> The alternativeText attribute should not be empty. Please add a description of what is causing the wait.`);
        }

        return hasAlternativeText;
      } // prevent scrolling


      stopScrolling(event) {
        event.preventDefault();
      }

    }

    lwc.registerDecorators(LightningSpinner, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      }
    });

    var _lightningSpinner = lwc.registerComponent(LightningSpinner, {
      tmpl: _tmpl$m
    });

    function tmpl$o($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        ti: api_tab_index,
        b: api_bind,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("div", {
        attrs: {
          "role": "group",
          "aria-labelledby": `${api_scoped_id("group-label")}`
        },
        key: 34
      }, [api_element("div", {
        className: $cmp.computedGroupLabelClass,
        attrs: {
          "id": api_scoped_id("group-label")
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 32
      }, [api_element("div", {
        classMap: {
          "slds-dueling-list": true
        },
        key: 31,
        on: {
          "focusin": _m8 || ($ctx._m8 = api_bind($cmp.handleFocus)),
          "focusout": _m9 || ($ctx._m9 = api_bind($cmp.handleBlur))
        }
      }, [api_element("div", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("assertive-thing"),
          "aria-live": "assertive"
        },
        key: 3
      }, []), api_element("div", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("keyboard-interacton")
        },
        key: 4
      }, [api_dynamic($cmp.i18n.componentAssistiveText)]), api_element("div", {
        className: $cmp.computedLeftColumnClass,
        key: 14
      }, [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "id": api_scoped_id("source-list-label")
        },
        key: 5
      }, [api_dynamic($cmp.sourceLabel)]), api_element("div", {
        className: $cmp.computedListboxContainerClass,
        style: $cmp.computedColumnStyle,
        key: 11
      }, [api_element("ul", {
        classMap: {
          "slds-listbox": true,
          "slds-listbox_vertical": true
        },
        attrs: {
          "data-source-list": true,
          "id": api_scoped_id("source-list"),
          "aria-describedby": `${api_scoped_id("keyboard-interacton")}`,
          "aria-labelledby": `${api_scoped_id("source-list-label")}`,
          "aria-multiselectable": "true",
          "role": "listbox",
          "aria-disabled": $cmp.ariaDisabled
        },
        key: 10
      }, api_iterator($cmp.computedSourceList, function (option, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(9, option.value)
        }, [api_element("div", {
          className: option.classList,
          attrs: {
            "aria-selected": option.selected,
            "role": "option",
            "tabindex": api_tab_index(option.tabIndex),
            "data-index": index,
            "data-value": option.value,
            "data-type": $cmp.computedSourceListId
          },
          key: 8,
          on: {
            "click": _m0 || ($ctx._m0 = api_bind($cmp.handleOptionClick)),
            "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleOptionKeyDown))
          }
        }, [api_element("span", {
          classMap: {
            "slds-media__body": true
          },
          key: 7
        }, [api_element("span", {
          classMap: {
            "slds-truncate": true
          },
          attrs: {
            "title": option.label
          },
          key: 6
        }, [api_dynamic(option.label)])])])]);
      }))]), $cmp.showActivityIndicator ? api_element("div", {
        key: 13
      }, [api_custom_element("lightning-spinner", _lightningSpinner, {
        props: {
          "size": "small",
          "variant": "brand",
          "alternativeText": $cmp.i18n.loadingText
        },
        key: 12
      }, [])]) : null]), api_element("div", {
        classMap: {
          "slds-dueling-list__column": true
        },
        key: 17
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:right",
          "variant": "container",
          "disabled": $cmp.moveButtonsDisabled,
          "title": $cmp.addButtonLabel,
          "alternativeText": $cmp.addButtonLabel
        },
        key: 15,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.handleRightButtonClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:left",
          "variant": "container",
          "disabled": $cmp.moveButtonsDisabled,
          "title": $cmp.removeButtonLabel,
          "alternativeText": $cmp.removeButtonLabel
        },
        key: 16,
        on: {
          "click": _m3 || ($ctx._m3 = api_bind($cmp.handleLeftButtonClick))
        }
      }, [])]), api_element("div", {
        classMap: {
          "slds-dueling-list__column": true,
          "slds-dueling-list__column_responsive": true
        },
        key: 27
      }, [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "id": api_scoped_id("selected-list-label")
        },
        key: 18
      }, [api_dynamic($cmp.selectedLabel)]), api_element("div", {
        className: $cmp.computedListboxContainerClass,
        style: $cmp.computedColumnStyle,
        key: 26
      }, [api_element("ul", {
        classMap: {
          "slds-listbox": true,
          "slds-listbox_vertical": true
        },
        attrs: {
          "data-selected-list": true,
          "id": api_scoped_id("selected-list"),
          "aria-describedby": `${api_scoped_id("keyboard-interacton")}`,
          "aria-labelledby": `${api_scoped_id("selected-list-label")}`,
          "aria-multiselectable": "true",
          "role": "listbox",
          "aria-disabled": $cmp.ariaDisabled
        },
        key: 25
      }, api_iterator($cmp.computedSelectedList, function (option, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(24, option.value)
        }, [api_element("div", {
          className: option.classList,
          attrs: {
            "aria-selected": option.selected,
            "role": "option",
            "tabindex": api_tab_index(option.tabIndex),
            "data-index": index,
            "data-value": option.value,
            "data-type": $cmp.computedSelectedListId
          },
          key: 23,
          on: {
            "click": _m4 || ($ctx._m4 = api_bind($cmp.handleOptionClick)),
            "keydown": _m5 || ($ctx._m5 = api_bind($cmp.handleOptionKeyDown))
          }
        }, [api_element("span", {
          classMap: {
            "slds-media__body": true
          },
          key: 20
        }, [api_element("span", {
          classMap: {
            "slds-truncate": true
          },
          attrs: {
            "title": option.label
          },
          key: 19
        }, [api_dynamic(option.label)])]), option.isLocked ? api_element("span", {
          classMap: {
            "slds-media__figure": true,
            "slds-media__figure_reverse": true
          },
          key: 22
        }, [api_custom_element("lightning-icon", _lightningIcon, {
          props: {
            "iconName": "utility:lock",
            "size": "x-small",
            "alternativeText": $cmp.computedLockAssistiveText
          },
          key: 21
        }, [])]) : null])]);
      }))])]), !$cmp.disableReordering ? api_element("div", {
        classMap: {
          "slds-dueling-list__column": true
        },
        key: 30
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:up",
          "variant": "container",
          "disabled": $cmp.disabled,
          "title": $cmp.upButtonLabel,
          "alternativeText": $cmp.upButtonLabel
        },
        key: 28,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleUpButtonClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:down",
          "variant": "container",
          "disabled": $cmp.disabled,
          "title": $cmp.downButtonLabel,
          "alternativeText": $cmp.downButtonLabel
        },
        key: 29,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.handleDownButtonClick))
        }
      }, [])]) : null])]), $cmp.errorMessage ? api_element("span", {
        classMap: {
          "slds-has-error": true,
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "aria-live": "assertive"
        },
        key: 33
      }, [api_dynamic($cmp.errorMessage)]) : null])];
    }

    var _tmpl$n = lwc.registerTemplate(tmpl$o);
    tmpl$o.stylesheets = [];

    if (_implicitStylesheets$7) {
      tmpl$o.stylesheets.push.apply(tmpl$o.stylesheets, _implicitStylesheets$7);
    }
    tmpl$o.stylesheetTokens = {
      hostAttribute: "lightning-dualListbox_dualListbox-host",
      shadowAttribute: "lightning-dualListbox_dualListbox"
    };

    var labelComponentAssistiveText = 'Press Ctrl (Cmd on Mac) + Left Arrow or Ctrl (Cmd on Mac) + Right Arrow to move items between lists.';

    var labelDownButtonAssistiveText = 'Move selection down';

    var labelMaxError = 'Select at most {0} options';

    var labelMaxHelp = ' [and a maximum of {0}]';

    var labelMinErrorPlural = 'Select at least {0} options';

    var labelMinErrorSingular = 'Select at least 1 option';

    var labelMinHelp = ' [and a minimum of {0}]';

    var labelMinRequiredErrorPlural = 'At least {0} options must be selected';

    var labelMinRequiredErrorSingular = 'At least 1 option must be selected';

    var labelOptionLockAssistiveText = ': item cannot be removed from {0}';

    var labelRequiredError = 'An option must be selected';

    var labelRequiredOptionError = '{0} must be selected';

    var labelUpButtonAssistiveText = 'Move selection up';

    var labelMoveSelectionToAssistiveText = 'Move selection to {0}';

    function preventDefaultAndStopPropagation$3(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function setFocusOnNextOption(option, moveUp, intf) {
      const index = parseInt(option.getAttribute('data-index'), 10);
      const i = index + (moveUp ? -1 : 1);
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const next = options[i];

      if (next) {
        next.focus();
      }
    }

    function selectNextOption(option, moveUp, intf) {
      const selected = option.getAttribute('aria-selected') === 'true';
      const index = parseInt(option.getAttribute('data-index'), 10);
      const i = index + (selected ? moveUp ? -1 : 1 : 0);
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const next = options[i];

      if (next) {
        intf.updateSelectedOptions(next, true, false);
      }
    }

    function selectNextOptionFromShift(option, moveUp, isMultiple, intf) {
      const curr = parseInt(option.getAttribute('data-index'), 10);

      if (intf.getShiftIndex() < 0) {
        intf.setShiftIndex(curr);
        intf.setLastShift(moveUp);
      }

      const next = curr + (intf.getLastShift() !== moveUp ? 0 : moveUp ? -1 : 1);
      const pos = next < intf.getShiftIndex();
      const shiftAdd = pos === moveUp || intf.getShiftIndex() === next;
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const nextOption = options[next];

      if (nextOption) {
        intf.updateSelectedOptions(nextOption, shiftAdd, true);
        intf.setLastShift(moveUp);
      }
    }

    function handleKeyDownOnOption(event, keyboardInterface) {
      if (event.metaKey || event.ctrlKey) {
        keyboardInterface.setShiftIndex(-1);
        const keyCodesA = 'A'.charCodeAt(0);
        const selected = event.target.getAttribute('aria-selected') === 'true';

        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            setFocusOnNextOption(event.target, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            setFocusOnNextOption(event.target, false, keyboardInterface);
            break;

          case keyCodes.right:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.moveOptionsBetweenLists(true);
            break;

          case keyCodes.left:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.moveOptionsBetweenLists(false);
            break;

          case keyCodes.space:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.updateSelectedOptions(event.target, !selected, true);
            break;

          case keyCodesA:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.selectAllOptions(event.target);
            break;

        }
      } else if (event.shiftKey) {
        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            selectNextOptionFromShift(event.target, true, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            selectNextOptionFromShift(event.target, false, true, keyboardInterface);
            break;

        }
      } else {
        keyboardInterface.setShiftIndex(-1);

        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            selectNextOption(event.target, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            selectNextOption(event.target, false, keyboardInterface);
            break;

        }
      }
    }

    function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$5(target, key, source[key]); }); } return target; }

    function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const i18n$b = {
      componentAssistiveText: labelComponentAssistiveText,
      downButtonAssistiveText: labelDownButtonAssistiveText,
      maxError: labelMaxError,
      maxHelp: labelMaxHelp,
      minErrorPlural: labelMinErrorPlural,
      minErrorSingular: labelMinErrorSingular,
      minHelp: labelMinHelp,
      minRequiredErrorPlural: labelMinRequiredErrorPlural,
      minRequiredErrorSingular: labelMinRequiredErrorSingular,
      optionLockAssistiveText: labelOptionLockAssistiveText,
      required: labelRequired,
      requiredError: labelRequiredError,
      requiredOptionError: labelRequiredOptionError,
      upButtonAssistiveText: labelUpButtonAssistiveText,
      moveSelectionToAssistiveText: labelMoveSelectionToAssistiveText,
      loadingText: labelLoadingText
    };
    /**
     * A pair of listboxes that enables multiple options to be selected and reordered.
     */

    class LightningDualListbox extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.sourceLabel = void 0;
        this.selectedLabel = void 0;
        this.label = void 0;
        this.options = void 0;
        this.min = 0;
        this.max = void 0;
        this.name = void 0;
        this._showActivityIndicator = false;
        this._requiredOptions = [];
        this._selectedValues = [];
        this._variant = void 0;
        this._disabled = void 0;
        this._disableReordering = false;
        this._required = false;
        this._addButtonLabel = void 0;
        this._removeButtonLabel = void 0;
        this._upButtonLabel = void 0;
        this._downButtonLabel = void 0;
        this._size = void 0;
        this.errorMessage = '';
        this.highlightedOptions = [];
        this.focusableInSource = void 0;
        this.focusableInSelected = void 0;
        this.isFocusOnList = false;
        this.messageWhenValueMissing = i18n$b.requiredError;
        this.fieldLevelHelp = void 0;
      }

      /**
       * Error message to be displayed when a range overflow is detected.
       * @type {string}
       */
      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this._overflowMessage;
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }
      /**
       * Error message to be displayed when a range underflow is detected.
       * @type {string}
       */


      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this._underflowMessage;
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }
      /**
       * If present, the listbox is disabled and users cannot interact with it.
       * @type {string}
       */


      get disabled() {
        return this._disabled || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the user must add an item to the selected listbox before submitting the form.
       * @type {string}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * A list of default options that are included in the selected options listbox. This list is populated with values from the options attribute.
       * @type {list}
       */


      get value() {
        return this._selectedValues;
      }

      set value(newValue) {
        this._selectedValues = newValue || [];

        if (this._connected) {
          this.addRequiredOptionsToValue();
        }
      }
      /**
       * A list of required options that cannot be removed from selected options listbox. This list is populated with values from the options attribute.
       * @type {list}
       */


      get requiredOptions() {
        return this._requiredOptions;
      }

      set requiredOptions(newValue) {
        this._requiredOptions = newValue || [];

        if (this._connected) {
          this.addRequiredOptionsToValue();
        }
      }
      /**
       * The variant changes the appearance of the dual listbox.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and dual listbox.
       * Use label-stacked to place the label above the dual listbox.
       * @type {string}
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      set size(value) {
        this._size = value;
      }
      /**
       * Number of items that display in the listboxes before vertical scrollbars are displayed. Determines the vertical size of the listbox.
       * @type {number}
       * @default
       */


      get size() {
        return this._size;
      }
      /**
       * Help text detailing the purpose and function of the dual listbox.
       * @type {string}
       */


      set disableReordering(value) {
        this._disableReordering = normalizeBoolean(value);
      }
      /**
       * If present, the Up and Down buttons used for reordering the selected list items are hidden.
       * @type {boolean}
       * @default false
       */


      get disableReordering() {
        return this._disableReordering;
      }
      /**
       * If present, a spinner is displayed in the first listbox to indicate loading activity.
       * @type {boolean}
       * @default false
       */


      get showActivityIndicator() {
        return this._showActivityIndicator;
      }

      set showActivityIndicator(value) {
        this._showActivityIndicator = normalizeBoolean(value);
      }
      /**
       * Sets focus on the first option from either list.
       * If the source list doesn't contain any options, the first option on the selected list is focused on.
       */


      focus() {
        // focus on the first option from either list
        // if nothing on source, then it'll pick the one on selected
        const firstOption = this.template.querySelector(`div[data-index='0']`);

        if (firstOption) {
          firstOption.focus();
          this.updateSelectedOptions(firstOption, true, false);
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the dual listbox meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this.errorMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the dual listbox value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message
       *     is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays an error message if the dual listbox value is required.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.keyboardInterface = this.selectKeyboardInterface();
        this._connected = true;
        this.addRequiredOptionsToValue(); // debounceInteraction since DualListbox has multiple focusable elements

        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.showHelpMessageIfInvalid();
          this.dispatchEvent(new CustomEvent('blur')); // reset the optionToFocus otherwise dualListbox will steal the focus any time it's rerendered.

          this.optionToFocus = null;
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      renderedCallback() {
        this.assertRequiredAttributes();

        if (this.disabled) {
          return;
        }

        if (this.optionToFocus) {
          // value could have an apostrophe, which is why we need to escape it otherwise the queryselector will not work
          const option = this.template.querySelector(`div[data-value='${this.optionToFocus.replace(/'/g, "\\'")}']`);

          if (option) {
            this.isFocusOnList = true;
            option.focus();
          }
        }
      }

      get computedUniqueId() {
        return this.uniqueId;
      }

      get computedSourceListId() {
        return getRealDOMId(this.template.querySelector('[data-source-list]'));
      }

      get computedSelectedListId() {
        return getRealDOMId(this.template.querySelector('[data-selected-list]'));
      }

      get ariaDisabled() {
        // aria-disabled works only with String not Boolean value
        return String(this.disabled);
      }

      get computedSourceList() {
        let sourceListOptions = [];

        if (this.options) {
          const required = this.requiredOptions;
          const values = this.value;
          sourceListOptions = this.options.filter(option => values.indexOf(option.value) === -1 && required.indexOf(option.value) === -1);
        }

        return this.computeListOptions(sourceListOptions, this.focusableInSource);
      }

      get computedSelectedList() {
        const selectedListOptions = [];

        if (this.options) {
          const optionsMap = {};
          this.options.forEach(option => {
            optionsMap[option.value] = _objectSpread$5({}, option);
          });
          this.value.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              option.isSelected = true;
            }
          });
          this.requiredOptions.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              option.isLocked = true;
            }
          }); // add selected items in the given order

          this.value.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              selectedListOptions.push(option);
            }
          });
        }

        return this.computeListOptions(selectedListOptions, this.focusableInSelected);
      }

      computeListOptions(options, focusableOptionValue) {
        if (options.length > 0) {
          const focusableOption = options.find(option => {
            return option.value === focusableOptionValue;
          });
          const focusableValue = focusableOption ? focusableOption.value : options[0].value;
          return options.map(option => {
            return this.computeOptionProperties(option, focusableValue);
          });
        }

        return [];
      }

      computeOptionProperties(option, focusableValue) {
        const isSelected = this.highlightedOptions.indexOf(option.value) > -1;
        const classList = classSet('slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline').add({
          'slds-is-selected': isSelected
        }).toString();
        return _objectSpread$5({}, option, {
          tabIndex: option.value === focusableValue ? '0' : '-1',
          selected: isSelected ? 'true' : 'false',
          classList
        });
      }

      get computedLeftColumnClass() {
        return classSet('slds-dueling-list__column slds-dueling-list__column_responsive').add({
          'slds-is-relative': this.showActivityIndicator
        }).toString();
      }

      get computedColumnStyle() {
        if (this.isNumber(this.size)) {
          // From the SLDS page on how to adjust the height: lightningdesignsystem.com/components/dueling-picklist/#Responsive
          const newHeight = parseInt(this.size, 10) * 2.25 + 1;
          return `height:${newHeight}rem`;
        }

        return '';
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedGroupLabelClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedListboxContainerClass() {
        return classSet('slds-dueling-list__options').add({
          'slds-is-disabled': this.disabled
        }).toString();
      }

      get computedLockAssistiveText() {
        return formatLabel(this.i18n.optionLockAssistiveText, this.selectedLabel);
      }

      get i18n() {
        return i18n$b;
      }

      getRightButtonAssistiveText() {
        return formatLabel(i18n$b.moveSelectionToAssistiveText, this.selectedLabel);
      }
      /**
       * Label for add button.
       * @type {string}
       * @default Move selection to {selectedLabel}
       */


      get addButtonLabel() {
        if (this._addButtonLabel) {
          return this._addButtonLabel;
        }

        return this.getRightButtonAssistiveText();
      }

      set addButtonLabel(value) {
        this._addButtonLabel = value;
      }

      getLeftButtonAssistiveText() {
        return formatLabel(i18n$b.moveSelectionToAssistiveText, this.sourceLabel);
      }
      /**
       * Label for remove button.
       * @type {string}
       * @default "Move selection to {sourceLabel}"
       */


      get removeButtonLabel() {
        if (this._removeButtonLabel) {
          return this._removeButtonLabel;
        }

        return this.getLeftButtonAssistiveText();
      }

      set removeButtonLabel(value) {
        this._removeButtonLabel = value;
      }
      /**
       * Label for up button.
       * @type {string}
       * @default "Move selection up"
       */


      get upButtonLabel() {
        return this._upButtonLabel || this.i18n.upButtonAssistiveText;
      }

      set upButtonLabel(value) {
        this._upButtonLabel = value;
      }
      /**
       * Label for down button.
       * @type {string}
       * @default "Move selection down"
       */


      get downButtonLabel() {
        return this._downButtonLabel || this.i18n.downButtonAssistiveText;
      }

      set downButtonLabel(value) {
        this._downButtonLabel = value;
      }

      get moveButtonsDisabled() {
        return this.disabled || this.showActivityIndicator;
      }

      handleOptionClick(event) {
        this.interactingState.interacting();

        if (this.disabled) {
          return;
        }

        const selectMultiple = event.metaKey || event.ctrlKey || event.shiftKey;
        const option = event.currentTarget;

        if (event.shiftKey) {
          this.selectAllFromLastSelectedToOption(option, false);
          return;
        }

        const selected = selectMultiple && option.getAttribute('aria-selected') === 'true';
        this.updateSelectedOptions(option, !selected, selectMultiple);
        this.shiftIndex = -1;
      }

      handleFocus(event) {
        this.interactingState.enter(); // select the focused option if entering a listbox

        const element = event.target;

        if (element.role === 'option') {
          if (!this.isFocusOnList) {
            this.isFocusOnList = true;
            this.updateSelectedOptions(element, true, false);
          }
        }
      }

      handleBlur(event) {
        this.interactingState.leave();
        const element = event.target;

        if (element.role !== 'option') {
          this.isFocusOnList = false;
        }
      }

      handleRightButtonClick() {
        this.interactingState.interacting();
        this.moveOptionsBetweenLists(true);
      }

      handleLeftButtonClick() {
        this.interactingState.interacting();
        this.moveOptionsBetweenLists(false);
      }

      handleUpButtonClick() {
        this.interactingState.interacting();
        this.changeOrderOfOptionsInList(true);
      }

      handleDownButtonClick() {
        this.interactingState.interacting();
        this.changeOrderOfOptionsInList(false);
      }

      handleOptionKeyDown(event) {
        this.interactingState.interacting();

        if (this.disabled) {
          return;
        }

        handleKeyDownOnOption(event, this.keyboardInterface);
      }

      moveOptionsBetweenLists(addToSelect, retainFocus) {
        const isValidList = addToSelect ? this.selectedList === this.computedSourceListId : this.selectedList === this.computedSelectedListId;

        if (!isValidList) {
          return;
        }

        const toMove = this.highlightedOptions;
        const values = this.computedSelectedList.map(option => option.value);
        const required = this.requiredOptions;
        let newValues = [];

        if (addToSelect) {
          newValues = values.concat(toMove);
        } else {
          newValues = values.filter(value => toMove.indexOf(value) === -1 || required.indexOf(value) > -1);
        }

        const oldSelectedValues = this._selectedValues;
        this._selectedValues = newValues;
        const invalidMove = this.validity.valueMissing || this.validity.rangeOverflow && this.selectedList === this.computedSourceListId || this.validity.rangeUnderflow && this.selectedList === this.computedSelectedListId;

        if (invalidMove || toMove.length === 0) {
          this.showHelpMessageIfInvalid();
          this._selectedValues = oldSelectedValues;
          return;
        }

        if (retainFocus) {
          const listId = addToSelect ? this.computedSelectedListId : this.computedSourceListId;
          this.selectedList = listId;
          this.updateFocusableOption(listId, toMove[0]);
        } else {
          this.interactingState.leave();
          this.isFocusOnList = false;
          this.highlightedOptions = [];
          this.optionToFocus = null;
        }

        this.dispatchChangeEvent(newValues);
      }

      changeOrderOfOptionsInList(moveUp) {
        const elementList = this.getElementsOfList(this.selectedList);
        const values = this.computedSelectedList.map(option => option.value);
        const toMove = values.filter(option => this.highlightedOptions.indexOf(option) > -1);
        const validSelection = toMove.length === 0 || this.selectedList !== this.computedSelectedListId;

        if (validSelection) {
          return;
        }

        let start = moveUp ? 0 : toMove.length - 1;
        let index = values.indexOf(toMove[start]);
        const validMove = moveUp && index === 0 || !moveUp && index === values.length - 1;

        if (validMove) {
          return;
        }

        if (moveUp) {
          while (start < toMove.length) {
            index = values.indexOf(toMove[start]);
            this.swapOptions(index, index - 1, values, elementList);
            start++;
          }
        } else {
          while (start > -1) {
            index = values.indexOf(toMove[start]);
            this.swapOptions(index, index + 1, values, elementList);
            start--;
          }
        }

        this._selectedValues = values;
        this.updateFocusableOption(this.selectedList, toMove[0]);
        this.optionToFocus = null;
        this.dispatchChangeEvent(values);
      }

      selectAllFromLastSelectedToOption(option, all) {
        const listId = option.getAttribute('data-type');
        this.updateCurrentSelectedList(listId, true);
        const options = this.getElementsOfList(listId);
        const end = all ? 0 : this.getOptionIndex(option);
        this.lastSelected = this.lastSelected < 0 ? end : this.lastSelected;
        const start = all ? options.length : this.lastSelected;
        let val, select;
        this.highlightedOptions = [];

        for (let i = 0; i < options.length; i++) {
          select = (i - start) * (i - end) <= 0;

          if (select) {
            val = options[i].getAttribute('data-value');
            this.highlightedOptions.push(val);
          }
        }
      }

      updateSelectedOptions(option, select, isMultiple) {
        const value = option.getAttribute('data-value');
        const listId = this.getListId(option);
        const optionIndex = this.getOptionIndex(option);
        this.updateCurrentSelectedList(listId, isMultiple);

        if (select) {
          if (this.highlightedOptions.indexOf(value) === -1) {
            this.highlightedOptions.push(value);
          }
        } else {
          this.highlightedOptions.splice(this.highlightedOptions.indexOf(value), 1);
        }

        this.updateFocusableOption(listId, value);
        this.lastSelected = optionIndex;
      }

      addRequiredOptionsToValue() {
        if (!this.options || !this.options.length || !this._requiredOptions || !this._requiredOptions.length) {
          // no options/requiredOptions, just ignore
          return;
        }

        const numOfSelectedValues = this._selectedValues.length;
        const allValues = this.options.map(option => option.value);

        const requiredValues = this._requiredOptions.filter(option => allValues.includes(option)); // add required options to the selected values as they are already displayed in the selected list


        this._selectedValues = [...new Set([...requiredValues, ...this._selectedValues])];

        if (numOfSelectedValues !== this._selectedValues.length) {
          // value was changed
          this.dispatchChangeEvent(this._selectedValues);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && this.computedSelectedList.length < 1,
            rangeUnderflow: () => this.computedSelectedList.length < this.min,
            rangeOverflow: () => this.computedSelectedList.length > this.max
          });
        }

        return this._constraintApi;
      }

      get _overflowMessage() {
        const minHelpMsg = this.min > 0 ? formatLabel(this.i18n.minHelp, this.min) : '';
        return formatLabel(this.i18n.maxError, this.max) + minHelpMsg;
      }

      get _underflowMessage() {
        const maxHelpMsg = this.max ? formatLabel(this.i18n.maxHelp, this.max) : '';
        const minRequiredError = this.min > 1 ? formatLabel(this.i18n.minRequiredErrorPlural, this.min) : this.i18n.minRequiredErrorSingular;
        const minError = this.min > 1 ? formatLabel(this.i18n.minErrorPlural, this.min) : this.i18n.minErrorSingular;
        return this.required ? minRequiredError + maxHelpMsg : minError + maxHelpMsg;
      }

      updateCurrentSelectedList(currentList, isMultiple) {
        if (this.selectedList !== currentList || !isMultiple) {
          if (this.selectedList) {
            this.highlightedOptions = [];
            this.lastSelected = -1;
          }

          this.selectedList = currentList;
        }
      }

      dispatchChangeEvent(values) {
        // the change event needs to propagate to elements outside of the light-DOM, hence making it composed.
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: values
          }
        }));
      }

      assertRequiredAttributes() {
        assert(!!this.label, `<lightning-dual-listbox> Missing required "label" attribute.`);
        assert(!!this.sourceLabel, `<lightning-dual-listbox> Missing required "sourceLabel" attribute.`);
        assert(!!this.selectedLabel, `<lightning-dual-listbox> Missing required "selectedLabel" attribute.`);
        assert(!!this.options, `<lightning-dual-listbox> Missing required "options" attribute.`);
      }

      swapOptions(i, j, array) {
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }

      getElementsOfList(listId) {
        const elements = this.template.querySelectorAll(`div[data-type='${listId}']`);
        return elements ? elements : [];
      }

      selectKeyboardInterface() {
        const that = this;
        that.shiftIndex = -1;
        that.lastShift = null;
        return {
          getShiftIndex() {
            return that.shiftIndex;
          },

          setShiftIndex(value) {
            that.shiftIndex = value;
          },

          getLastShift() {
            return that.lastShift;
          },

          setLastShift(value) {
            that.lastShift = value;
          },

          getElementsOfList(listId) {
            return that.getElementsOfList(listId);
          },

          selectAllOptions(option) {
            that.selectAllFromLastSelectedToOption(option, true);
          },

          updateSelectedOptions(option, select, isMultiple) {
            that.updateSelectedOptions(option, select, isMultiple);
          },

          moveOptionsBetweenLists(addToSelect) {
            that.moveOptionsBetweenLists(addToSelect, true);
          }

        };
      }

      getOptionIndex(optionElement) {
        return parseInt(optionElement.getAttribute('data-index'), 10);
      }

      getListId(optionElement) {
        return getRealDOMId(optionElement.parentElement.parentElement);
      }

      updateFocusableOption(listId, value) {
        if (listId === this.computedSourceListId) {
          this.focusableInSource = value;
        } else if (listId === this.computedSelectedListId) {
          this.focusableInSelected = value;
        }

        this.optionToFocus = value;
      }

      isNumber(value) {
        return value !== '' && value !== null && isFinite(value);
      }

    }

    lwc.registerDecorators(LightningDualListbox, {
      publicProps: {
        sourceLabel: {
          config: 0
        },
        selectedLabel: {
          config: 0
        },
        label: {
          config: 0
        },
        options: {
          config: 0
        },
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        value: {
          config: 3
        },
        requiredOptions: {
          config: 3
        },
        variant: {
          config: 3
        },
        size: {
          config: 3
        },
        fieldLevelHelp: {
          config: 0
        },
        disableReordering: {
          config: 3
        },
        showActivityIndicator: {
          config: 3
        },
        validity: {
          config: 1
        },
        addButtonLabel: {
          config: 3
        },
        removeButtonLabel: {
          config: 3
        },
        upButtonLabel: {
          config: 3
        },
        downButtonLabel: {
          config: 3
        }
      },
      publicMethods: ["focus", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _showActivityIndicator: 1,
        _requiredOptions: 1,
        _selectedValues: 1,
        _variant: 1,
        _disabled: 1,
        _disableReordering: 1,
        _required: 1,
        _addButtonLabel: 1,
        _removeButtonLabel: 1,
        _upButtonLabel: 1,
        _downButtonLabel: 1,
        _size: 1,
        errorMessage: 1,
        highlightedOptions: 1,
        focusableInSource: 1,
        focusableInSelected: 1
      },
      fields: ["isFocusOnList"]
    });

    var _lightningDualListbox = lwc.registerComponent(LightningDualListbox, {
      tmpl: _tmpl$n
    });

    function stylesheet$8(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$8 = [stylesheet$8];

    function tmpl$p($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp._fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp._fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 4
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        props: {
          "name": $cmp.name,
          "required": $cmp.required,
          "disabled": $cmp.disabled,
          "placeholder": $cmp.placeholder,
          "items": $cmp._items,
          "inputText": $cmp._selectedLabel,
          "inputIconSize": "xx-small",
          "inputIconName": "utility:down",
          "showDropdownActivityIndicator": $cmp.spinnerActive,
          "dropdownAlignment": $cmp.dropdownAlignment
        },
        key: 3,
        on: {
          "dropdownopen": _m0 || ($ctx._m0 = api_bind($cmp.handleDropdownOpen)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "ready": _m3 || ($ctx._m3 = api_bind($cmp.handleComboboxReady)),
          "select": _m4 || ($ctx._m4 = api_bind($cmp.handleSelect))
        }
      }, [])]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-text"),
          "data-help-text": true,
          "aria-live": "assertive"
        },
        key: 5
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$o = lwc.registerTemplate(tmpl$p);
    tmpl$p.stylesheets = [];

    if (_implicitStylesheets$8) {
      tmpl$p.stylesheets.push.apply(tmpl$p.stylesheets, _implicitStylesheets$8);
    }
    tmpl$p.stylesheetTokens = {
      hostAttribute: "lightning-combobox_combobox-host",
      shadowAttribute: "lightning-combobox_combobox"
    };

    var labelPlaceholder = 'Select an Option';

    const i18n$c = {
      required: labelRequired,
      placeholder: labelPlaceholder
    };
    /**
     * A widget that provides an input field that is readonly,
     * accompanied by a dropdown list of selectable options.
     */

    class LightningCombobox extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._ariaLabelledBy = '';
        this._ariaDescribedBy = '';
        this._fieldLevelHelp = '';
        this._selectedLabel = '';
        this._disabled = false;
        this._readOnly = false;
        this._spinnerActive = false;
        this._required = false;
        this.label = void 0;
        this.dropdownAlignment = 'left';
        this.placeholder = i18n$c.placeholder;
        this.messageWhenValueMissing = void 0;
        this.name = void 0;
        this._items = [];
        this._variant = void 0;
        this._helpMessage = void 0;
        this._labelForId = void 0;
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid()); // The connected logic here is needed because at the point when @api setters
        // are called other values may not have been set yet, so it could happen that the 'value' was set, but 'options'
        // are not available, or that the 'options' and 'value' have been set but 'multiple' hasn't been set yet.
        // So here we make sure that we start processing the data only once the element is actually in DOM, which
        // should be beneficial for performance as well

        this.connected = true;
        this._items = this.generateItems(this.options);

        if (this.options && this.selectedValue !== undefined) {
          this.updateSelectedOptions();
        }
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this.connected = false;
      }
      /**
       * Reserved for internal use. Use the standard aria-labelledby instead. A space-separated list of element IDs that provide labels for the combobox.
       * @type {string}
       */


      get ariaLabelledBy() {
        return this._ariaLabelledBy;
      }

      set ariaLabelledBy(labelledBy) {
        this._ariaLabelledBy = labelledBy;
      }
      /**
       * Reserved for internal use. Use the standard aria-describedby instead. A space-separated list of element IDs that provide descriptive labels for the combobox.
       * @type {string}
       */


      get ariaDescribedBy() {
        return this._ariaDescribedBy;
      }

      set ariaDescribedBy(describedBy) {
        this._ariaDescribedBy = describedBy;
      }
      /**
       * Help text detailing the purpose and function of the combobox.
       * @type {string}
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * The variant changes the appearance of the combobox.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and combobox.
       * Use label-stacked to place the label above the combobox.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }
      /**
       * Specifies the value of an input element.
       * @type {object}
       */


      get value() {
        return this.selectedValue;
      }

      set value(newValue) {
        // There are some cases where this won't work correctly
        // See https://git.soma.salesforce.com/raptor/raptor/issues/457
        if (newValue !== this.selectedValue) {
          this.selectedValue = newValue;

          if (this.connected && this.options) {
            this.updateSelectedOptions();
          }
        }
      }
      /**
       * A list of options that are available for selection. Each option has the following attributes: label and value.
       * @type {object[]}
       * @required
       */


      get options() {
        return this._options || [];
      }

      set options(newValue) {
        this._options = normalizeArray(newValue);

        if (this.connected) {
          this._items = this.generateItems(this._options);
          this.updateSelectedOptions();
        }
      }
      /**
       * If present, the combobox is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled || this._readOnly || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the combobox is read-only.
       * A read-only combobox is also disabled.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this.disabled;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);
      }
      /**
       * If present, a value must be selected before the form can be submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * If present, a spinner is displayed below the menu items to indicate loading activity.
       * @type {boolean}
       * @default false
       */


      get spinnerActive() {
        return this._spinnerActive;
      }

      set spinnerActive(value) {
        this._spinnerActive = normalizeBoolean(value);
      }
      /**
       * Sets focus on the combobox.
       */


      focus() {
        if (this.connected) {
          this.getBaseComboboxElement().focus();
        }
      }
      /**
       * Removes focus from the combobox.
       */


      blur() {
        if (this.connected) {
          this.getBaseComboboxElement().blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       * @required
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the combobox has any validity errors.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the combobox.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the combobox value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message
       * is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Shows the help message if the combobox is in an invalid state.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleComboboxReady(e) {
        this._labelForId = e.detail.id;
      }

      synchronizeA11y() {
        synchronizeAttrs(this.template.querySelector('label'), {
          for: this._labelForId
        });
        const baseCombobox = this.template.querySelector('lightning-base-combobox');
        baseCombobox.inputLabelledByElement = this.ariaLabelledBy;
        baseCombobox.inputDescribedByElements = this.computedAriaDescribedBy;
      }

      get i18n() {
        return i18n$c;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        const describedByElements = [];

        if (this._helpMessage) {
          const helpText = this.template.querySelector('[data-help-text]');
          describedByElements.push(helpText);
        }

        if (typeof this.ariaDescribedBy === 'string') {
          describedByElements.push(this.ariaDescribedBy);
        }

        return describedByElements;
      }

      handleSelect(event) {
        if (event.detail.value === this.selectedValue) {
          return;
        }

        this.selectedValue = event.detail.value;
        this.updateSelectedOptions(); // the change event needs to propagate to elements outside of the light-DOM, hence making it composed.

        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this.selectedValue
          }
        }));
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleDropdownOpen() {
        this.dispatchEvent(new CustomEvent('open'));
      }

      updateSelectedOptions() {
        this.updateSelectedLabelFromValue(this.selectedValue);
        this.markOptionSelectedFromValue(this.selectedValue);
      }

      markOptionSelectedFromValue(value) {
        if (this._items) {
          const selectedItem = this._items.find(item => item.value === value); // de-select previously selected item


          if (this._selectedItem) {
            this._selectedItem.iconName = undefined;
            this._selectedItem.highlight = false;
          }

          this._selectedItem = selectedItem;

          if (selectedItem) {
            selectedItem.iconName = 'utility:check';
            this._selectedItem.highlight = true;
          } // Make a shallow copy to trigger an update on the combobox


          this._items = this._items.slice();
        }
      }

      updateSelectedLabelFromValue(newValue) {
        this._selectedLabel = this.getOptionLabelByValue(newValue);
      }

      getOptionLabelByValue(value) {
        const foundOption = this.options.find(option => option.value === value);

        if (foundOption) {
          return foundOption.label;
        }

        return '';
      }

      generateItems(options) {
        return options.map(option => {
          return {
            type: 'option-inline',
            text: option.label,
            highlight: this.value === option.value,
            value: option.value
          };
        });
      }

      getBaseComboboxElement() {
        return this.template.querySelector('lightning-base-combobox');
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.selectedValue)
          });
        }

        return this._constraintApi;
      }

    }

    LightningCombobox.delegatesFocus = true;

    lwc.registerDecorators(LightningCombobox, {
      publicProps: {
        label: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        name: {
          config: 0
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        value: {
          config: 3
        },
        options: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        spinnerActive: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _ariaLabelledBy: 1,
        _ariaDescribedBy: 1,
        _fieldLevelHelp: 1,
        _selectedLabel: 1,
        _disabled: 1,
        _readOnly: 1,
        _spinnerActive: 1,
        _required: 1,
        _items: 1,
        _variant: 1,
        _helpMessage: 1
      },
      fields: ["_labelForId"]
    });

    var _lightningCombobox = lwc.registerComponent(LightningCombobox, {
      tmpl: _tmpl$o
    });

    function tmpl$q($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [$cmp.isDesktop ? $cmp.multiple ? api_custom_element("lightning-dual-listbox", _lightningDualListbox, {
        props: {
          "label": $cmp.label,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "size": $cmp.size,
          "disabled": $cmp.disabled,
          "required": $cmp.required,
          "showActivityIndicator": $cmp.showActivityIndicator,
          "disableReordering": $cmp.disableReordering,
          "sourceLabel": $cmp.i18n.available,
          "selectedLabel": $cmp.i18n.chosen
        },
        key: 0,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.isDesktop ? !$cmp.multiple ? api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "label": $cmp.label,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "placeholder": $cmp.placeholder,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "disabled": $cmp.disabled,
          "required": $cmp.required,
          "spinnerActive": $cmp.showActivityIndicator,
          "dropdownAlignment": "auto"
        },
        key: 1,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange)),
          "open": _m6 || ($ctx._m6 = api_bind($cmp.handleOpen))
        }
      }, []) : null : null, !$cmp.isDesktop ? api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "label": $cmp.label,
          "multiple": $cmp.multiple,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "size": $cmp.size,
          "disabled": $cmp.disabled,
          "required": $cmp.required
        },
        key: 2,
        on: {
          "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []) : null];
    }

    var _tmpl$p = lwc.registerTemplate(tmpl$q);
    tmpl$q.stylesheets = [];

    if (_implicitStylesheets$6) {
      tmpl$q.stylesheets.push.apply(tmpl$q.stylesheets, _implicitStylesheets$6);
    }
    tmpl$q.stylesheetTokens = {
      hostAttribute: "lightning-picklist_picklist-host",
      shadowAttribute: "lightning-picklist_picklist"
    };

    var labelNoneLabel = '--None--';

    var labelAvailable = 'Available';

    var labelChosen = 'Chosen';

    const i18n$d = {
      noneLabel: labelNoneLabel,
      available: labelAvailable,
      chosen: labelChosen
    };

    class LightningPicklist extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._internalValue = void 0;
        this._picklistValue = void 0;
        this._options = void 0;
        this._required = false;
        this._disabled = false;
        this._size = 4;
        this._showActivityIndicator = false;
        this._fieldLevelHelp = void 0;
        this.label = void 0;
        this.name = void 0;
        this.placeholder = void 0;
        this.variant = void 0;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set value(newValue) {
        this._picklistValue = newValue;

        if (this.connected) {
          this._internalValue = this.getInternalValue(newValue);
        }
      }

      get value() {
        return this._picklistValue;
      } // only works for multi-select picklists


      set size(value) {
        this._size = this.normalizeSize(value);
      }

      get size() {
        return this._size;
      }

      set options(newOptions) {
        this._options = newOptions;

        if (this.connected) {
          this.updatePicklistOptions(newOptions);
        }
      }

      get options() {
        return this._options;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple || false;
      }

      set required(value) {
        this._required = normalizeBoolean(value); // reset the flag that hides the required indicator when we have no options

        this._requiredButDisabled = false;
      }

      get required() {
        return this._required;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value); // There are two ways a picklist could end up in a disabled state:
        // 1- explicitly setting disabled and 2- when the picklist has no options
        // If the element is explicitly set to be disabled, it should always remain disabled even when new options are provided

        this._externalDisabled = value;
      }

      get disabled() {
        return this._disabled;
      }

      set showActivityIndicator(value) {
        this._showActivityIndicator = normalizeBoolean(value);
      }

      get showActivityIndicator() {
        return this._showActivityIndicator || false;
      }

      connectedCallback() {
        this.updatePicklistOptions(this._options, true);
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      focus() {
        if (this.connected) {
          this.getElement.focus();
        }
      }

      blur() {
        if (this.connected) {
          this.getElement.blur();
        }
      }

      get validity() {
        if (this.connected) {
          return this.getElement.validity;
        }

        return null;
      }

      checkValidity() {
        if (this.connected) {
          return this.validity.valid;
        }

        return false;
      }

      setCustomValidity(message) {
        if (this.connected) {
          this.getElement.setCustomValidity(message);
        }
      }

      reportValidity() {
        if (this.connected) {
          return this.getElement.reportValidity();
        }

        return false;
      }

      showHelpMessageIfInvalid() {
        if (this.connected) {
          this.getElement.showHelpMessageIfInvalid();
        }
      }

      get i18n() {
        return i18n$d;
      }

      get internalValue() {
        return this._internalValue;
      }

      get getElement() {
        return this.template.querySelector('lightning-combobox,lightning-dual-listbox,lightning-primitive-select');
      } // disable reordering functionality on dual-listbox


      get disableReordering() {
        return true;
      }

      get isDesktop() {
        return formFactor === 'Large';
      }

      updatePicklistOptions(options, addMissingValues) {
        const newOptions = options ? [...options] : [];
        const existingInternalValue = this.internalValue !== undefined ? this.internalValue : this.getInternalValue(this._picklistValue);

        if (addMissingValues) {
          this.addMissingValuesToOptions(newOptions, existingInternalValue);
        }

        this.maybeAddNoneOption(newOptions);
        this._options = newOptions;
        this.updateDisabledState(options);
        this.updateRequiredState(options);
        const value = this.getValueToSelect(this.options, existingInternalValue);
        this._internalValue = value;

        if (!this.isSameValue(value, existingInternalValue)) {
          this._picklistValue = this.getPicklistValue(value);
          this.dispatchProgrammaticChangeEvent();
        }
      }

      isSameValue(value1, value2) {
        if (Array.isArray(value1) && Array.isArray(value2)) {
          return value1.sort().join(',') === value2.sort().join(',');
        }

        return value1 === value2;
      }

      handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this._picklistValue = this.getPicklistValue(event.detail.value);
        this._internalValue = this.getInternalValue(event.detail.value);
        this.dispatchChangeEvent();
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleOpen() {
        // fire internal event for some force components to leverage
        // e.g. to display the spinner while loading more picklist values
        this.dispatchEvent(new CustomEvent('open'));
      }

      maybeAddNoneOption(options) {
        if (this.shouldAddNoneOption(options.length)) {
          this.addOption(options, this.i18n.noneLabel, '');
        }
      }

      addOption(options, label, value) {
        options.unshift({
          label,
          value
        });
      }

      shouldDisablePicklist(options) {
        if (!options || options.length === 0) {
          return true;
        }

        return false;
      }

      shouldAddNoneOption(numberOfOptions) {
        if (this.multiple) {
          return false;
        } // We could have set required=false if the picklist had no options, see updateDisabledState and updateRequiredState


        const isRequiredPicklist = this.required || this._requiredButDisabled;

        if (isRequiredPicklist && numberOfOptions === 1) {
          return false;
        }

        return true;
      }

      updateDisabledState(options) {
        this._disabled = this._externalDisabled !== undefined ? normalizeBoolean(this._externalDisabled) : this.shouldDisablePicklist(options);
      }

      updateRequiredState(options) {
        const shouldDisable = this.shouldDisablePicklist(options);

        if (shouldDisable) {
          if (this._required) {
            // when disabling the picklist, we should remove the required indicator
            this._required = false;
            this._requiredButDisabled = true;
          }

          if (this.connected && this.validity.valueMissing) {
            // if we're disabling the picklist, we should make sure any existing valueMissing message is cleared
            // eslint-disable-next-line @lwc/lwc/no-async-operation
            requestAnimationFrame(() => {
              this.showHelpMessageIfInvalid();
            });
          }
        } else if (this._requiredButDisabled) {
          // we now have some options and are not going to have a disabled picklist, so we'll put the required flag back to what it was before
          this._requiredButDisabled = false;
          this._required = true;
        }
      }

      getValueToSelect(options, existingValue) {
        if (!options || options.length === 0) {
          return this.multiple ? [] : '';
        }

        if (this.isValueInOptions(existingValue, options)) {
          return existingValue;
        }

        if (this.multiple) {
          return [];
        }

        if (this.shouldAddNoneOption([...options].length)) {
          return '';
        }

        return options[0].value;
      }

      isValueInOptions(value, options) {
        if (!options || options.length === 0) {
          return false;
        }

        const valueIsInOptions = valueToCheck => options.some(option => {
          return option.value === valueToCheck;
        });

        let valueExists = false;

        if (Array.isArray(value)) {
          valueExists = value.every(valueToCheck => {
            return valueIsInOptions(valueToCheck);
          });
        } else {
          valueExists = valueIsInOptions(value);
        }

        return valueExists;
      } // If values are missing from the options, we will add them to the options.
      // However, since we don't have the label, the same value will be used as label
      // See W-4829389


      addMissingValuesToOptions(newOptions, value) {
        if (!value || Array.isArray(value) && value.length === 0) {
          return;
        }

        const valueIsInOptions = valueToCheck => {
          return newOptions.some(option => {
            return option.value === valueToCheck;
          });
        };

        const maybeAddOption = valueToCheck => {
          if (!valueIsInOptions(valueToCheck)) {
            // Since we don't have the label, we will use the value instead
            this.addOption(newOptions, valueToCheck, valueToCheck);
          }
        };

        if (Array.isArray(value)) {
          value.forEach(valueToCheck => {
            maybeAddOption(valueToCheck);
          });
        } else {
          maybeAddOption(value);
        }
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._picklistValue
          }
        }));
      } // This event is only fired when the value of the picklist is automatically selected without user interaction
      // i.e. when the picklist is required and there's only one option, we auto select that single option
      // or when the value is undefined/null, we select the none option.
      // In these cases we need to notify the dependency manager of the change in order to update any dependent fields accordingly


      dispatchProgrammaticChangeEvent() {
        this.dispatchEvent(new CustomEvent('programmaticchange'));
      }

      getPicklistValue(value) {
        // multi select picklists should have a ';' separated value string
        if (this.multiple && Array.isArray(value)) {
          return value.join(';');
        }

        return value;
      } // This is the value that is passed into the subcomponents dual-listbox and combobox.
      // In the case of dual-listbox, the component accepts an array of selected values.


      getInternalValue(value) {
        if (this.multiple) {
          if (Array.isArray(value)) {
            return value;
          }

          return typeof value === 'string' && value !== '' && value.split(';') || [];
        }

        return value;
      }

      normalizeSize(value) {
        const parsedValue = parseInt(value, 10);

        if (isNaN(parsedValue) || parsedValue < 3 || parsedValue > 10) {
          // A picklist field can only have a size between 3 and 10 when created declaratively
          // however, there seems to be cases where the size can be outside of this range.
          // In such cases, we will use the default value instead of throwing an error
          return 4;
        }

        return parsedValue;
      }

    }

    LightningPicklist.delegatesFocus = true;

    lwc.registerDecorators(LightningPicklist, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        variant: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        value: {
          config: 3
        },
        size: {
          config: 3
        },
        options: {
          config: 3
        },
        multiple: {
          config: 3
        },
        required: {
          config: 3
        },
        disabled: {
          config: 3
        },
        showActivityIndicator: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "setCustomValidity", "reportValidity", "showHelpMessageIfInvalid"],
      track: {
        _internalValue: 1,
        _picklistValue: 1,
        _options: 1,
        _required: 1,
        _disabled: 1,
        _size: 1,
        _showActivityIndicator: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningPicklist = lwc.registerComponent(LightningPicklist, {
      tmpl: _tmpl$p
    });

    function tmpl$r($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 8
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 6
      }, api_iterator($cmp.fieldsMetaData, function (field, index) {
        return api_element("div", {
          classMap: {
            "slds-form-element__row": true
          },
          key: api_key(5, field.name)
        }, [field.isInput ? api_custom_element("lightning-input", _lightningInput, {
          attrs: {
            "data-field": field.name
          },
          props: {
            "name": field.name,
            "label": field.label,
            "value": field.value,
            "maxLength": field.maxlength,
            "placeholder": field.placeholder,
            "required": field.required,
            "disabled": $cmp.disabled,
            "readOnly": $cmp.readOnly
          },
          key: 3,
          on: {
            "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
            "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
            "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
          }
        }, []) : null, field.isCombobox ? api_custom_element("lightning-picklist", _lightningPicklist, {
          attrs: {
            "data-field": field.name
          },
          props: {
            "name": field.name,
            "label": field.label,
            "value": field.value,
            "options": field.options,
            "disabled": $cmp.disabled,
            "placeholder": field.placeholder
          },
          key: 4,
          on: {
            "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
            "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
            "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange))
          }
        }, []) : null]);
      }))])])];
    }

    var _tmpl$q = lwc.registerTemplate(tmpl$r);
    tmpl$r.stylesheets = [];

    if (_implicitStylesheets) {
      tmpl$r.stylesheets.push.apply(tmpl$r.stylesheets, _implicitStylesheets);
    }
    tmpl$r.stylesheetTokens = {
      hostAttribute: "lightning-inputName_inputName-host",
      shadowAttribute: "lightning-inputName_inputName"
    };

    var labelFirstName = 'First Name';

    var labelInformalName = 'Informal Name';

    var labelLastName = 'Last Name';

    var labelMiddleName = 'Middle Name';

    var labelNone = 'None';

    var labelSalutation = 'Salutation';

    var labelSuffix = 'Suffix';

    const FORMAT_CODE_MAP = {
      L: 'lastName',
      M: 'middleName',
      F: 'firstName',
      S: 'salutation',
      X: 'suffix',
      I: 'informalName'
    };
    const parseFieldsFormat = function (format) {
      if (isValidLocaleFormat(format)) {
        return format.toUpperCase().split(/(?=[A-Z])/).map(formatCode => FORMAT_CODE_MAP[formatCode]);
      }

      return [];
    };
    const getFieldsOrder = function () {
      const localeTag = locale.replace(/-/g, '_');
      const inputOrder = parseFieldsFormat(name.getNameInputOrder(localeTag));
      return inputOrder;
    };

    function isValidLocaleFormat(value) {
      return typeof value === 'string' && /^[LMFSXI]+$/i.test(value);
    }

    const FIELD_TYPE = {
      INPUT: 'input',
      PICKLIST: 'combobox'
    };
    const DEFAULT_MAXLENGTH = 40;
    const DEFAULT_FIELD_META = {
      salutation: {
        inputType: FIELD_TYPE.PICKLIST
      },
      firstName: {},
      middleName: {},
      informalName: {},
      lastName: {
        maxlength: 80,
        required: true
      },
      suffix: {}
    };
    const i18n$e = {
      firstName: labelFirstName,
      informalName: labelInformalName,
      lastName: labelLastName,
      middleName: labelMiddleName,
      none: labelNone,
      required: labelRequired,
      salutation: labelSalutation,
      suffix: labelSuffix
    };
    /**
     * Represents a name compound field.
     */

    class LightningInputName extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.salutationLabel = void 0;
        this.firstNameLabel = void 0;
        this.middleNameLabel = void 0;
        this.lastNameLabel = void 0;
        this.suffixLabel = void 0;
        this.informalNameLabel = void 0;
        this.label = void 0;
        this.options = void 0;
        this.fieldsToDisplay = ['firstName', 'salutation', 'lastName'];
        this._salutation = '';
        this._lastName = '';
        this._firstName = '';
        this._middleName = '';
        this._informalName = '';
        this._suffix = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._variant = void 0;
        this._fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element', 'slds-form-compound');
        this.updateClassList();
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.showHelpMessageIfInvalid();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Displays the Salutation field as a dropdown menu. Use the options attribute to provide salutations in an array of label-value pairs.
       * @type {string}
       *
       */


      get salutation() {
        return this._salutation;
      }

      set salutation(value) {
        this._salutation = value;
      }
      /**
       * Displays the First Name field.
       * @type {string}
       *
       */


      get firstName() {
        return this._firstName;
      }

      set firstName(value) {
        this._firstName = value;
      }
      /**
       * Displays the Middle Name field.
       * @type {string}
       *
       */


      get middleName() {
        return this._middleName;
      }

      set middleName(value) {
        this._middleName = value;
      }
      /**
       * Displays the Informal Name field.
       * @type {string}
       *
       */


      get informalName() {
        return this._informalName;
      }

      set informalName(value) {
        this._informalName = value;
      }
      /**
       * Displays the Last Name field.
       * @type {string}
       *
       */


      get lastName() {
        return this._lastName;
      }

      set lastName(value) {
        this._lastName = value;
      }
      /**
       * Displays the Suffix field.
       * @type {string}
       *
       */


      get suffix() {
        return this._suffix;
      }

      set suffix(value) {
        this._suffix = value;
      }
      /**
       * If present, the input name field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the input name field is read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the input name field must be filled out before the form is submitted.
       * A red asterisk is displayed on the Last Name field. An error
       * message is displayed if a user interacts with the Last Name
       * field and does not provide a value.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of a name compound field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and name fields.
       * Use label-stacked to place the label above the name fields.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the first input field.
       */


      focus() {
        this.template.querySelector('[data-field]').focus();
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        const inputs = this.template.querySelectorAll('[data-field]');

        for (let i = 0; i < inputs.length; i++) {
          inputs[i].blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * Returns the valid property value (Boolean) on the ValidityState object to
       * indicate whether input name fields have validity errors.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the input fields if the entries are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the input name fields when
       * the input value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - The name of the input name field.
       */


      setCustomValidityForField(message, fieldName) {
        assert(DEFAULT_FIELD_META[fieldName] !== undefined, `Invalid 'fieldName': ${fieldName}`);

        this._fieldConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        this.fieldsToDisplay.forEach(field => {
          this._reportValidityForField(field);
        });
        return valid;
      }

      get i18n() {
        return i18n$e;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleBlur(event) {
        this.interactingState.leave();
        const field = event.target.dataset.field;

        this._reportValidityForField(field);
      }

      handleChange(event) {
        event.stopPropagation();
        const value = event.detail.value;
        const fieldName = event.target.dataset.field;

        if (this.getFieldValue(fieldName) === value) {
          // Value didn't change. No need to dispatch.
          return;
        } // update the value for changing field


        this[fieldName] = value;
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            salutation: this.salutation,
            firstName: this.firstName,
            middleName: this.middleName,
            lastName: this.lastName,
            informalName: this.informalName,
            suffix: this.suffix,
            validity: this.validity
          }
        }));
      }

      initializeFieldsMetaData(fieldsOrder) {
        const fields = []; // setup what fields are needed with the field name

        fieldsOrder.forEach(fieldName => {
          fields.push({
            name: fieldName
          });
        });
        return fields;
      }

      getFieldObject(field) {
        const fieldDefault = DEFAULT_FIELD_META[field];
        const value = this[field];
        const label = this[`${field}Label`] || this.i18n[field];
        const fieldsToDisplay = this.fieldsToDisplay.map(fieldName => {
          return fieldName.toUpperCase();
        });

        if (fieldsToDisplay.indexOf(field.toUpperCase()) > -1) {
          return {
            isInput: fieldDefault.inputType !== 'combobox',
            isCombobox: fieldDefault.inputType === 'combobox',
            required: fieldDefault.required && this.required,
            options: this.options,
            placeholder: fieldDefault.inputType === 'combobox' ? this.i18n.none : label,
            maxlength: fieldDefault.maxlength || DEFAULT_MAXLENGTH,
            name: field,
            label,
            value
          };
        }

        return null;
      }

      get fieldsMetaData() {
        const fieldsOrder = getFieldsOrder();
        const fieldsData = this.initializeFieldsMetaData(fieldsOrder);
        const fields = [];
        fieldsData.forEach(row => {
          const fieldName = row.name;
          const fieldObject = this.getFieldObject(fieldName);

          if (fieldObject) {
            fields.push(fieldObject);
          }
        });
        return fields;
      }

      getFieldValue(fieldName) {
        return this[fieldName];
      }

      getFieldElement(fieldName) {
        return this.template.querySelector(`[data-field="${fieldName}"]`);
      }

      get _fieldConstraints() {
        if (!this._fieldConstraintApis) {
          // For every field to display create an appropriate constraint
          this._fieldConstraintApis = Object.keys(DEFAULT_FIELD_META).reduce((constraints, field) => {
            constraints[field] = new FieldConstraintApi(() => this.getFieldElement(field), {
              valueMissing: () => !this.disabled && this.required && this.fieldsToDisplay.indexOf(field) >= 0 && DEFAULT_FIELD_META[field].required && isEmptyString(this[field])
            });
            return constraints;
          }, {});
        }

        return this._fieldConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.customError),
            valueMissing: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.valueMissing)
          });
        }

        return this._combinedConstraintApi;
      }

      _reportValidityForField(field) {
        if (this._fieldConstraints[field]) {
          this._fieldConstraints[field].reportValidity(helpMessage => {
            const fieldElement = this.getFieldElement(field);
            fieldElement.setCustomValidity(helpMessage);
            fieldElement.reportValidity();
          });
        }
      }

    }

    LightningInputName.delegatesFocus = true;

    lwc.registerDecorators(LightningInputName, {
      publicProps: {
        salutationLabel: {
          config: 0
        },
        firstNameLabel: {
          config: 0
        },
        middleNameLabel: {
          config: 0
        },
        lastNameLabel: {
          config: 0
        },
        suffixLabel: {
          config: 0
        },
        informalNameLabel: {
          config: 0
        },
        label: {
          config: 0
        },
        options: {
          config: 0
        },
        fieldsToDisplay: {
          config: 0
        },
        salutation: {
          config: 3
        },
        firstName: {
          config: 3
        },
        middleName: {
          config: 3
        },
        informalName: {
          config: 3
        },
        lastName: {
          config: 3
        },
        suffix: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity"],
      track: {
        _salutation: 1,
        _lastName: 1,
        _firstName: 1,
        _middleName: 1,
        _informalName: 1,
        _suffix: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _variant: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningInputName = lwc.registerComponent(LightningInputName, {
      tmpl: _tmpl$q
    });

    function stylesheet$9(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$9 = [stylesheet$9];

    function stylesheet$a(hostSelector, shadowSelector, nativeShadow) {
      return ".slds-non-salseforce-resource" + shadowSelector + " {display: none;}\n";
    }
    var _implicitStylesheets$a = [stylesheet$a];

    function tmpl$s($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("iframe", {
        style: $cmp.frameStyle,
        attrs: {
          "src": $cmp.src,
          "title": $cmp.title,
          "width": $cmp.width,
          "height": $cmp.height
        },
        key: 0,
        on: {
          "load": _m0 || ($ctx._m0 = api_bind($cmp.handleContentLoad))
        }
      }, [])];
    }

    var _tmpl$r = lwc.registerTemplate(tmpl$s);
    tmpl$s.stylesheets = [];

    if (_implicitStylesheets$a) {
      tmpl$s.stylesheets.push.apply(tmpl$s.stylesheets, _implicitStylesheets$a);
    }
    tmpl$s.stylesheetTokens = {
      hostAttribute: "lightning-primitiveIframe_primitiveIframe-host",
      shadowAttribute: "lightning-primitiveIframe_primitiveIframe"
    };

    // Closure to hold the APIs if and when available
    let DispatcherCount = 1;
    const Dispatchers = {};
    const Domains = [];
    const dispatcherState = {
      isMessageEventHandled: false
    };

    function generateDispatchId() {
      return `lightningIframeMessage-${DispatcherCount++}`;
    }
    function registerDomain(domain) {
      if (!domain || domain === '') {
        return;
      }

      const found = Domains.find(item => item.domain === domain);

      if (found) {
        found.ref += 1;
      } else {
        Domains.push({
          domain,
          ref: 1
        });
      }
    }
    function unregisterDomain(domain) {
      if (!domain || domain === '') {
        return;
      }

      const index = Domains.findIndex(item => item.domain === domain);

      if (index >= 0) {
        const found = Domains[index];
        found.ref -= 1;

        if (found.ref === 0) {
          Domains.splice(index, 1);
        }
      }
    }
    function registerMessageHandler(handler) {
      const dispatchId = generateDispatchId();
      Dispatchers[dispatchId] = handler;

      if (!dispatcherState.isMessageEventHandled) {
        dispatcherState.isMessageEventHandled = true;
        window.addEventListener('message', event => {
          dispatchEvent(event);
        });
      }

      return dispatchId;
    }
    function dispatchEvent(event) {
      try {
        const data = event.data ? JSON.parse(event.data) : {};
        const dispatchId = data.arguments ? data.arguments.cmpId : null;

        if (dispatchId && Dispatchers[dispatchId]) {
          Dispatchers[dispatchId](data);
          return true;
        }
      } catch (e) {// Catch JSON parse exception.
      }

      return false;
    }
    function createMessage(dispatcherId, event, params) {
      params.cmpId = dispatcherId;
      return {
        event,
        arguments: params
      };
    }
    function postMessage(handler, message, domain, useObject) {
      if (handler) {
        handler(useObject ? message : JSON.stringify(message || {}), domain);
      }
    }

    /**
     * Class representing primitive iframe.
     * @extends Element
     */

    class LightningPrimitiveIframe extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.src = void 0;
        this.domain = void 0;
        this.width = '100%';
        this.height = '100%';
        this.frameStyle = '';
        this.title = void 0;
      }

      connectedCallback() {
        registerDomain(this.src);
      }

      disconnectedCallback() {
        unregisterDomain(this.src);
      }

      handleContentLoad() {
        const iframeload = new CustomEvent('iframeload', {
          detail: {
            callbacks: {
              postToWindow: this.postToWindow.bind(this)
            }
          }
        });
        this.contentWindow = this.template.querySelector('iframe').contentWindow;
        this.dispatchEvent(iframeload);
      }

      postToWindow(message) {
        if (this.contentWindow) {
          this.contentWindow.postMessage(message, this.domain);
        }
      }

    }

    lwc.registerDecorators(LightningPrimitiveIframe, {
      publicProps: {
        src: {
          config: 0
        },
        domain: {
          config: 0
        },
        width: {
          config: 0
        },
        height: {
          config: 0
        },
        frameStyle: {
          config: 0
        },
        title: {
          config: 0
        }
      },
      publicMethods: ["postToWindow"]
    });

    var _lightningPrimitiveIframe = lwc.registerComponent(LightningPrimitiveIframe, {
      tmpl: _tmpl$r
    });

    function tmpl$t($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [$cmp._isLoaded ? api_element("label", {
        className: $cmp.computedLabelClass,
        key: 0
      }, [api_dynamic($cmp.label)]) : null, $cmp._isLoaded ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 2
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        className: $cmp.computedLookupComboboxClass,
        props: {
          "variant": "lookup",
          "items": $cmp._items,
          "disabled": $cmp.disabled,
          "dropdownAlignment": "auto",
          "placeholder": $cmp.placeholder,
          "inputText": $cmp.inputText,
          "inputIconName": $cmp._inputIconName,
          "showInputActivityIndicator": $cmp.showActivityIndicator,
          "attributionLogoUrl": $cmp._googleLogoUrl,
          "attributionLogoAssistiveText": $cmp._googleLogoText
        },
        key: 1,
        on: {
          "textinput": _m0 || ($ctx._m0 = api_bind($cmp.handleTextInput)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleSelect)),
          "ready": _m2 || ($ctx._m2 = api_bind($cmp.handleComboboxReady))
        }
      }, [])]) : null, api_custom_element("lightning-primitive-iframe", _lightningPrimitiveIframe, {
        styleMap: {
          "display": "none"
        },
        props: {
          "src": $cmp.apiSrc,
          "domain": $cmp.apiDomain
        },
        key: 3,
        on: {
          "iframeload": _m3 || ($ctx._m3 = api_bind($cmp.handleIframeLoad))
        }
      }, [])];
    }

    var _tmpl$s = lwc.registerTemplate(tmpl$t);
    tmpl$t.stylesheets = [];
    tmpl$t.stylesheetTokens = {
      hostAttribute: "lightning-lookupAddress_lookupAddress-host",
      shadowAttribute: "lightning-lookupAddress_lookupAddress"
    };

    function toHighlightParts(text, matchedSubstrings) {
      text = text || '';
      matchedSubstrings = matchedSubstrings || [];
      const parts = [];
      let last = 0;
      let index = 0;

      while (last < text.length && index < matchedSubstrings.length) {
        const part = matchedSubstrings[index++];

        if (part.offset > last) {
          parts.push({
            text: text.substring(last, part.offset),
            highlight: false
          });
        }

        last = part.offset + part.length;
        parts.push({
          text: text.substring(part.offset, last),
          highlight: true
        });
      }

      if (last < text.length) {
        parts.push({
          text: text.substring(last),
          highlight: false
        });
      }

      return parts;
    }

    var appVersion = '224';

    var untrustedContentDomain = '.a.forceusercontent.com';

    // TODO we can probably remove securePort from the url

    const port =  '';
    const MAP_DOMAIN = `https://maps${untrustedContentDomain }${port}`;
    function buildMapSourceUrl(parameters) {
      const version = appVersion ;
      let sourceUrl = `${MAP_DOMAIN}/lightningmaps/mapsloader?version=${version}`;
      Object.keys(parameters).forEach(key => {
        sourceUrl += `&${key}=${encodeURIComponent(parameters[key])}`;
      });
      return sourceUrl;
    }

    const INTERNAL_GOOGLE_LOGO = `/projRes/ui-force-components/img/powered_by_google.png`;
    const POWERED_BY_GOOGLE = 'powered by Google';

    const DEFAULT_LOCATION = {
      lat: 37.790091,
      lng: -122.396848
    };
    const getCurrentPosition = navigator && navigator.geolocation && navigator.geolocation.getCurrentPosition ? navigator.geolocation.getCurrentPosition.bind(navigator.geolocation) : (success, error) => error && error();
    function getLocation() {
      return new Promise(resolve => {
        getCurrentPosition(position => {
          resolve({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        }, () => resolve(DEFAULT_LOCATION));
      });
    }

    const DEFAULT_TYPES = ['geocode'];
    const DEBOUNCE_PERIOD = 250;
    const EVENT_NAME = {
      INITIALIZE_PLACE_API: 'initialize',
      QUERY_PLACE_AUTOCOMPLETE: 'queryAddress',
      QUERY_PLACE_DETAIL: 'selectAddress',
      PLACE_AUTOCOMPLETE: 'force:showAddressSuggestions',
      PLACE_DETAIL: 'force:saveAddressLookup',
      PLACE_API_READY: 'place-api-ready'
    };

    class LightningLookupAddress extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.inputText = '';
        this.placeholder = void 0;
        this._inputIconName = 'utility:search';
        this._items = void 0;
        this._showActivityIndicator = void 0;
        this._variant = void 0;
        this._disabled = void 0;
        this._isLoaded = false;
        this._googleLogoUrl = void 0;
        this._googleLogoText = POWERED_BY_GOOGLE;
        this._labelForId = void 0;
        this.placeIconName = 'utility:checkin';
        this.apiDomain = `*`;
        this.apiSrc = buildMapSourceUrl({
          resource: 'placeApi',
          locale: lang
        });
      }

      connectedCallback() {
        this._items = [];
        this._dispatchId = registerMessageHandler(event => {
          this.handleMessage(event);
        });
        this._debouncedTextInput = debounce(text => {
          this._requestSuggestions(text);
        }, DEBOUNCE_PERIOD);
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      renderedCallback() {
        const label = this.template.querySelector('label');

        if (label) {
          synchronizeAttrs(label, {
            for: this._labelForId
          });
          label.setAttribute('for', this._labelForId);
        }
      }

      handleComboboxReady(e) {
        this._labelForId = e.detail.id;
      }

      handleMessage(data) {
        this._showActivityIndicator = false;

        if (!this._googleLogoUrl) {
          this._googleLogoUrl = INTERNAL_GOOGLE_LOGO;
        }

        if (data.event === EVENT_NAME.PLACE_AUTOCOMPLETE) {
          this._processAutoComplete(data.arguments.addresses);
        } else if (data.event === EVENT_NAME.PLACE_DETAIL) {
          this.dispatchChangeEvent(data.arguments);
        } else if (data.event === EVENT_NAME.PLACE_API_READY) {
          this._isLoaded = true;
        }
      }

      _requestSuggestions(matchString) {
        if (matchString) {
          this._showActivityIndicator = true;
          this.sendMessage(EVENT_NAME.QUERY_PLACE_AUTOCOMPLETE, {
            matchString
          });
        } else {
          this._items = [];
        }
      }

      handleTextInput(evt) {
        this.inputText = evt.detail.text;

        this._debouncedTextInput(evt.detail.text);
      }

      handleIframeLoad(event) {
        this._handler = event.detail.callbacks.postToWindow;
        getLocation().then(location => {
          this.sendMessage(EVENT_NAME.INITIALIZE_PLACE_API, {
            types: DEFAULT_TYPES,
            location
          });
        });
      }

      sendMessage(event, params) {
        if (this._handler) {
          const message = createMessage(this._dispatchId, event, params || {});
          postMessage(this._handler, message, '*');
        }
      }

      handleSelect(evt) {
        if (evt.detail.value) {
          this._showActivityIndicator = true;
          this.sendMessage(EVENT_NAME.QUERY_PLACE_DETAIL, {
            addressCmpId: this._dispatchId,
            placeId: evt.detail.value
          });
        }
      }

      _processAutoComplete(suggestions) {
        this._showActivityIndicator = false;
        this._items = [];

        if (suggestions) {
          this._items = suggestions.map(suggestion => {
            const mainText = suggestion.structured_formatting.main_text;
            const secondaryText = suggestion.structured_formatting.secondary_text;
            const matchedSubstrings = suggestion.structured_formatting.main_text_matched_substrings;
            const parts = toHighlightParts(mainText, matchedSubstrings);
            return {
              type: 'option-card',
              text: parts,
              iconName: this.placeIconName,
              subText: secondaryText,
              value: suggestion.place_id
            };
          });
        }
      }

      dispatchChangeEvent(address) {
        this.dispatchEvent(new CustomEvent('change', {
          detail: {
            address
          }
        }));
      }

    }

    lwc.registerDecorators(LightningLookupAddress, {
      publicProps: {
        label: {
          config: 0
        },
        inputText: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      track: {
        _inputIconName: 1,
        _items: 1,
        _showActivityIndicator: 1,
        _variant: 1,
        _disabled: 1,
        _isLoaded: 1
      },
      fields: ["_googleLogoUrl", "_googleLogoText", "_labelForId", "placeIconName", "apiDomain", "apiSrc"]
    });

    var _lightningLookupAddress = lwc.registerComponent(LightningLookupAddress, {
      tmpl: _tmpl$s
    });

    function stylesheet$b(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$b = [stylesheet$b];

    function tmpl$u($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-grow": true,
          "textarea-container": true
        },
        key: 4
      }, [api_element("textarea", {
        classMap: {
          "slds-textarea": true
        },
        attrs: {
          "id": api_scoped_id("input"),
          "aria-describedby": api_scoped_id($cmp.computedUniqueHelpElementId),
          "name": $cmp.name,
          "maxlength": $cmp.maxLength,
          "minlength": $cmp.minLength,
          "placeholder": $cmp.placeholder,
          "accesskey": $cmp.accessKey
        },
        props: {
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled,
          "required": $cmp.required
        },
        key: 3,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleChange)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleFocus)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleBlur))
        }
      }, [api_dynamic($cmp._defaultValue)])]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "aria-live": "assertive"
        },
        key: 5
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$t = lwc.registerTemplate(tmpl$u);
    tmpl$u.stylesheets = [];

    if (_implicitStylesheets$b) {
      tmpl$u.stylesheets.push.apply(tmpl$u.stylesheets, _implicitStylesheets$b);
    }
    tmpl$u.stylesheetTokens = {
      hostAttribute: "lightning-textarea_textarea-host",
      shadowAttribute: "lightning-textarea_textarea"
    };

    function getPositionY(event) {
      return event.touches ? event.touches[0].screenY : event.screenY;
    }

    function canScroll(el) {
      var canScrollY = el.scrollHeight > el.offsetHeight;
      var canScrollX = el.scrollWidth > el.offsetWidth;
      return canScrollY || canScrollX;
    }

    function alwaysScrolls(el) {
      var isInputRange = el.tagName === 'INPUT' && el.type === 'range';
      return isInputRange;
    }

    function nativeScroll(el) {
      var isTextarea = el.tagName === 'TEXTAREA';
      return isTextarea;
    }

    function isAtTop(el) {
      return el.scrollTop === 0;
    }

    function isAtBottom(el) {
      return el.scrollHeight - el.scrollTop === el.offsetHeight || el.scrollHeight - el.scrollTop === el.clientHeight;
    }

    function skipUiScroller(event) {
      event.cancelScrolling = true;
      event.preventBounce = false;
    }

    function enableUiScroller(event) {
      event.cancelScrolling = false;
      event.preventBounce = true;
    }
    /**
     * Enables touch scrolling that allows child elements like textarea to scroll and bubbles the event
     * up to ui:scroller when the top/bottom scroll boundary is reached.
     */


    class TouchScroller {
      static isMobile() {
        return formFactor !== 'Large';
      }

      constructor(target) {
        this._initialized = false;
        this._startY = null;
        assert(target, 'a non-empty target is required for TouchScroller to add touch listeners to');
        this._target = target;
        this.initialize();
      }

      initialize() {
        if (!this._initialized && this._target) {
          if (TouchScroller.isMobile()) {
            this._target.addEventListener('touchstart', event => this.handleTouchStart(event));

            this._target.addEventListener('touchmove', event => this.handleTouchMove(event));
          }

          this._initialized = true;
        }
      }

      handleTouchStart(event) {
        this._startY = getPositionY(event);
      }

      handleTouchMove(event) {
        const target = event.target; // Elements that have their own scroll behavior such as input type range never cause
        // bouncing or container scrolling.

        if (alwaysScrolls(target)) {
          skipUiScroller(event);
          return;
        } // There are native element such as textarea that can scroll.


        const canScrollTarget = nativeScroll(target) && canScroll(target);

        if (canScrollTarget) {
          const curY = getPositionY(event);
          let atTop, atBottom; // When target is scrollable, we also need to check if the user is trying to scroll
          // past the edge of target.

          if (canScrollTarget && !event.preventBounce) {
            atTop = this._startY < curY && isAtTop(target);
            atBottom = this._startY > curY && isAtBottom(target);
          }

          if (!atTop && !atBottom) {
            skipUiScroller(event);
          } else {
            enableUiScroller(event);
          }
        }
      }

    }

    lwc.registerDecorators(TouchScroller, {
      fields: ["_initialized", "_startY"]
    });

    const i18n$f = {
      required: labelRequired
    };
    /**
     * Represents a multiline text input field.
     */

    class LightningTextarea extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.placeholder = void 0;
        this.name = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenTooShort = void 0;
        this.messageWhenTooLong = void 0;
        this.messageWhenValueMissing = void 0;
        this.accessKey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._defaultValue = '';
        this._disabled = false;
        this._required = false;
        this._readOnly = false;
        this._variant = void 0;
        this._helpMessage = void 0;
        this._fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this._connected = true;
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid());
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      synchronizeA11y() {
        const input = this.template.querySelector('textarea');
        synchronizeAttrs(input, {
          'aria-describedby': this.computedUniqueHelpElementId
        });
      }

      renderedCallback() {
        // IE11: This is needed to work-around IE11 issue where it would append default value to the place holder,
        // instead of actually setting the value on the textarea element.
        if (!this._rendered) {
          this._rendered = true;

          this._setInputValue(this._defaultValue);

          this.synchronizeA11y(); // For non-desktop cases where ui:scroller prevents scrolling within the textarea.
          // The TouchScroller library allows touchmove events to scroll through the content of
          // the textarea but sets appropriate flags in the event to allow ui:scroller to scroll
          // the page when a content boundary is reached.

          const scrollTarget = this.template.querySelector('.textarea-container');
          this.touchScroller = new TouchScroller(scrollTarget);
        }

        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The maximum number of characters allowed in the textarea.
       * @type {number}
       */


      get maxLength() {
        return this._maxLength;
      }

      set maxLength(value) {
        this._maxLength = value;

        this._updateProxyInputAttributes('maxlength');
      }
      /**
       * The minimum number of characters allowed in the textarea.
       * @type {number}
       */


      get minLength() {
        return this._minLength;
      }

      set minLength(value) {
        this._minLength = value;

        this._updateProxyInputAttributes('minlength');
      }
      /**
       * The value of the textarea input, also used as the default value during init.
       * @type {string}
       */


      get value() {
        return this._value;
      }

      set value(value) {
        // W-5026729 - On IE11, set same value again, will trigger another input event.
        if (this._value !== value) {
          this._value = value || '';

          if (this._connected) {
            // We're connected, so no longer need to update the default value, change the actual value instead
            this._setInputValue(this._value);
          } else {
            this._defaultValue = this._value;
          }
        }

        this._updateProxyInputAttributes('value');
      }
      /**
       * If present, the textarea field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        this._updateProxyInputAttributes('disabled');
      }
      /**
       * If present, the textarea field is read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readOnly;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);

        this._updateProxyInputAttributes('readonly');
      }
      /**
       * If present, the textarea field must be filled out before the form can be submitted.
       * @type {boolean}
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);

        this._updateProxyInputAttributes('required');
      }
      /**
       * The variant changes the appearance of the textarea.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and textarea.
       * Use label-stacked to place the label above the textarea.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }
      /**
       * Represents the validity states of the textarea input, with respect to constraint validation.
       * @type {object}
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the textarea meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the textarea.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the textarea value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * The help text that appears in a popover.
       * Set field-level help to provide an informational tooltip on the textarea input field.
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the textarea field.
       */


      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes focus from the textarea field.
       */


      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get i18n() {
        return i18n$f;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleChange(event) {
        // we only fire change event oninput
        // so stop native event here
        event.stopPropagation();
      }

      handleInput(event) {
        event.stopPropagation(); // If the current value is the same as it was prior to last update, don't fire the event.
        // This allows us to fix an issue with IE11 which fires an 'input' event every time the placeholder
        // is changed, since the value isn't affected we're effectively ignoring such events.

        if (!this._connected || this._value === event.target.value) {
          return;
        }

        this.interactingState.interacting();
        this._value = this.inputElement.value;

        this._updateProxyInputAttributes('value'); // the change event needs to propagate to elements outside of the light-DOM, hence making it composed.


        this.dispatchEvent(new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this._value
          }
        }));
      }

      get inputElement() {
        if (this._inputElement) {
          return this._inputElement;
        }

        this._inputElement = this.template.querySelector('textarea');
        decorateInputForDragon(this._inputElement);
        return this._inputElement;
      }

      get computedUniqueHelpElementId() {
        const helpMessage = this.template.querySelector('[data-help-message]');
        return getRealDOMId(helpMessage);
      }

      _setInputValue(value) {
        // The underlying input has been modified to dispatch an 'input' event when a direct value set
        // is used to allow for Dragon Natural Speaking (which sets the value directly on the inputs instead
        // dispatching an input event against the input). Since we're in a programatic set here (ie. set
        // not resulting from a direct user interaction) we want a default setter behaviour that doesn't
        // dispatch any events.
        setDecoratedDragonInputValueWithoutEvent(this.inputElement, value);
      }

      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApiWithProxyInput(() => this, {
            // Override validity.valueMissing, which was broken in Edge until May 2018.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/291588/
            valueMissing: () => this._required && isEmptyString(this._value),
            tooShort: () => this._connected && this.inputElement.validity.tooShort,
            tooLong: () => this._connected && this.inputElement.validity.tooLong
          }, 'textarea');
          this._constraintApiProxyInputUpdater = this._constraint.setInputAttributes({
            value: () => this.value,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            required: () => this.required
          });
        }

        return this._constraintApi;
      }

    }

    LightningTextarea.delegatesFocus = true;

    lwc.registerDecorators(LightningTextarea, {
      publicProps: {
        label: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        maxLength: {
          config: 3
        },
        minLength: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        },
        fieldLevelHelp: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid", "focus", "blur"],
      track: {
        _maxLength: 1,
        _minLength: 1,
        _defaultValue: 1,
        _disabled: 1,
        _required: 1,
        _readOnly: 1,
        _variant: 1,
        _helpMessage: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningTextarea = lwc.registerComponent(LightningTextarea, {
      tmpl: _tmpl$t
    });
    LightningTextarea.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$v($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 11
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.addressLabel)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 10
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 9
      }, api_flatten([$cmp.showAddressLookup ? api_element("div", {
        classMap: {
          "slds-form-element__row": true,
          "slds-grow": true
        },
        key: 4
      }, [api_custom_element("lightning-lookup-address", _lightningLookupAddress, {
        classMap: {
          "slds-form-element": true,
          "slds-show": true,
          "slds-size_6-of-6": true
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 3,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleAddress))
        }
      }, [])]) : null, api_iterator($cmp.domFieldsMeta, function (row, index) {
        return api_element("div", {
          classMap: {
            "slds-form-element__row": true
          },
          key: api_key(8, row.name)
        }, api_iterator(row, function (field) {
          return [field.isInput ? api_custom_element("lightning-input", _lightningInput, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "label": field.label,
              "name": field.name,
              "value": field.value,
              "maxLength": field.maxlength,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled,
              "readOnly": $cmp.readOnly
            },
            key: api_key(5, field.name),
            on: {
              "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
              "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
              "change": _m3 || ($ctx._m3 = api_bind($cmp.handleChange))
            }
          }, []) : null, field.isTextArea ? api_custom_element("lightning-textarea", _lightningTextarea, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "name": field.name,
              "label": field.label,
              "value": field.value,
              "maxLength": field.maxlength,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled,
              "readOnly": $cmp.readOnly
            },
            key: api_key(6, field.name),
            on: {
              "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
              "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
              "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange))
            }
          }, []) : null, field.isPicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "name": field.name,
              "label": field.label,
              "options": field.options,
              "value": field.value,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled
            },
            key: api_key(7, field.name),
            on: {
              "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
              "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
              "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
            }
          }, []) : null];
        }));
      })]))])])];
    }

    var _tmpl$u = lwc.registerTemplate(tmpl$v);
    tmpl$v.stylesheets = [];

    if (_implicitStylesheets$9) {
      tmpl$v.stylesheets.push.apply(tmpl$v.stylesheets, _implicitStylesheets$9);
    }
    tmpl$v.stylesheetTokens = {
      hostAttribute: "lightning-inputAddress_inputAddress-host",
      shadowAttribute: "lightning-inputAddress_inputAddress"
    };

    const FORMAT_CODE_MAP$1 = {
      A: 'street',
      C: 'city',
      S: 'province',
      Z: 'postalCode',
      K: 'country'
    };
    const parseLocaleFormat = function (format) {
      if (isValidFieldFormat(format)) {
        return format.toUpperCase().split(/(?=[A-Z])/).map(formatCode => FORMAT_CODE_MAP$1[formatCode]);
      }

      return [];
    };
    function getInputOrder(langCode, countryCode, hasCountryPicklist) {
      let inputOrder = address.getAddressInputOrderAllField(langCode, countryCode); // always show country picklist as the first field
      // to match aloha behavior

      if (hasCountryPicklist) {
        inputOrder = 'K' + inputOrder.replace('K', '');
      }

      return parseLocaleFormat(inputOrder);
    }
    function getRequiredFields(langCode, countryCode) {
      const requireFields = address.getAddressRequireFields(langCode, countryCode);
      return parseLocaleFormat(requireFields);
    }

    function isValidFieldFormat(value) {
      return typeof value === 'string' && /^[ACSZK]+$/i.test(value);
    }

    // diviisble by 2 and 3, easy for arranging rows with
    // [1/2 field + 1/2 field] and [1/3 field + 2/3 field]
    const MAX_ROW_WIDTH = 6;
    const FIELD_WIDTHS = {
      street: {
        width: 6
      },
      city: {
        width: 4
      },
      province: {
        width: 2
      },
      postalCode: {
        width: 4
      },
      country: {
        width: 2
      }
    };
    function getFieldWidth(fieldName) {
      return FIELD_WIDTHS[fieldName];
    }
    function getFieldWidthClass(field) {
      return `slds-size_${field.width}-of-${MAX_ROW_WIDTH}`;
    }
    function distributeFieldWidth(row) {
      if (row.length === 1) {
        row[0].width = MAX_ROW_WIDTH;
      } else if (row.length > 1) {
        const totalRowWidth = row.reduce((sum, field) => {
          return sum + field.width;
        }, 0);

        if (totalRowWidth < MAX_ROW_WIDTH) {
          row.forEach(field => {
            field.width = MAX_ROW_WIDTH / row.length;
          });
        }
      }
    }
    function getTransformedFieldsMetaForLayout(fieldsMeta, inputOrder) {
      const layoutMetadata = []; // distribute fields to different rows

      let row = [];
      let rowWidth = 0;
      inputOrder.forEach(name => {
        const field = fieldsMeta[name];
        rowWidth += field.width;

        if (rowWidth > MAX_ROW_WIDTH) {
          layoutMetadata.push(row);
          row = [];
          rowWidth = field.width;
        }

        row.push(field);
      });
      layoutMetadata.push(row); // distribute width evenly

      layoutMetadata.forEach(rowFields => {
        distributeFieldWidth(rowFields);
      });
      return layoutMetadata;
    }

    const FIELD_TYPE$1 = {
      TEXTAREA: 'textarea',
      INPUT: 'input',
      PICKLIST: 'combobox'
    };
    const i18n$g = {
      required: labelRequired
    };
    /**
     * Represents an address compound field.
     */

    class LightningInputAddress extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.addressLabel = void 0;
        this.streetLabel = void 0;
        this.cityLabel = void 0;
        this.provinceLabel = void 0;
        this.countryLabel = void 0;
        this.postalCodeLabel = void 0;
        this.provinceOptions = void 0;
        this.countryOptions = void 0;
        this._showAddressLookup = void 0;
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this._street = '';
        this._city = '';
        this._province = '';
        this._country = '';
        this._postalCode = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element', 'slds-form_compound');
        this.updateClassList();
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The street field of the address.
       * @type {string}
       *
       */


      get street() {
        return this._street;
      }

      set street(value) {
        this._street = value;
      }
      /**
       * The city field of the address.
       * @type {string}
       *
       */


      get city() {
        return this._city;
      }

      set city(value) {
        this._city = value;
      }
      /**
       * The province field of the address. If province-options is provided, this province value is selected by default.
       * @type {string}
       *
       */


      get province() {
        return this._province;
      }

      set province(value) {
        this._province = value;
      }
      /**
       * The country field of the address. If country-options is provided, this country value is selected by default.
       * @type {string}
       *
       */


      get country() {
        return this._country;
      }

      set country(value) {
        this._country = value;
      }
      /**
       * The postal code field of the address.
       * @type {string}
       *
       */


      get postalCode() {
        return this._postalCode;
      }

      set postalCode(value) {
        this._postalCode = value;
      }
      /**
       * If present, the address fields are disabled and users cannot interact with them.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, address lookup using Google Maps is enabled.
       * @type {boolean}
       * @default false
       */


      get showAddressLookup() {
        return this._showAddressLookup;
      }

      set showAddressLookup(value) {
        this._showAddressLookup = normalizeBoolean(value);
      }
      /**
       * If present, the address fields are read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the address fields must be filled before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of an input address field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input address field.
       * Use label-stacked to place the label above the input address field.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the address fields if the values are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the specified fieldName when
       * the input address value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - Name of the field, which must be one of the following: street, city, province, postalCode, country.
       */


      setCustomValidityForField(message, fieldName) {
        assert(this.fieldsMeta[fieldName] !== undefined, `Invalid 'fieldName': ${fieldName}`);

        this._fieldConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        this.inputOrder.forEach(field => {
          this._reportValidityForField(field);
        });
        return valid;
      }
      /**
       * Sets focus on the first input element.
       */


      focus() {
        this.template.querySelector('[data-field]').focus();
      }
      /**
       * Removes focus from all input fields.
       */


      blur() {
        Array.prototype.forEach.call(this.template.querySelectorAll('[data-field]'), field => field.blur());
      }

      get searchAddressButtonDisabled() {
        return this.disabled || this.readOnly;
      }

      get i18n() {
        return i18n$g;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get fieldsTypeMeta() {
        return {
          street: {
            name: 'street',
            maxlength: 255,
            type: FIELD_TYPE$1.TEXTAREA
          },
          city: {
            name: 'city',
            maxlength: 40,
            type: FIELD_TYPE$1.INPUT
          },
          province: {
            name: 'province',
            maxlength: 80,
            type: this.isProvincePicklistEnabled() ? FIELD_TYPE$1.PICKLIST : FIELD_TYPE$1.INPUT
          },
          postalCode: {
            name: 'postalCode',
            maxlength: 20,
            type: FIELD_TYPE$1.INPUT
          },
          country: {
            name: 'country',
            maxlength: 80,
            type: this.isCountryPicklistEnabled() ? FIELD_TYPE$1.PICKLIST : FIELD_TYPE$1.INPUT
          }
        };
      }

      get inputOrder() {
        const hasCountryPicklist = this.fieldsTypeMeta.country.type === FIELD_TYPE$1.PICKLIST;
        const [langCode, countryCode] = locale.split('-');
        return getInputOrder(langCode, countryCode, hasCountryPicklist);
      }

      get requiredFields() {
        const [langCode, countryCode] = locale.split('-');
        return getRequiredFields(langCode, countryCode);
      }

      get fieldsMeta() {
        const fieldsMeta = {};
        this.inputOrder.forEach(name => {
          fieldsMeta[name] = Object.assign({}, this.fieldsTypeMeta[name], getFieldWidth(name));
        });
        this.requiredFields.forEach(name => {
          fieldsMeta[name].required = true;
        });
        return fieldsMeta;
      }

      get domFieldsMeta() {
        let rowKey = 0;
        const out = getTransformedFieldsMetaForLayout(this.fieldsMeta, this.inputOrder).map(row => {
          const rowList = row.map(field => {
            const {
              name,
              type,
              required,
              maxlength
            } = field;
            const label = this.getFieldLabel(name);
            const widthClass = getFieldWidthClass(field);
            return {
              isInput: type === FIELD_TYPE$1.INPUT,
              isPicklist: type === FIELD_TYPE$1.PICKLIST,
              isTextArea: type === FIELD_TYPE$1.TEXTAREA,
              value: this.getFieldValue(name),
              options: this.getFieldOptions(name),
              required: this.required && !!required,
              classnames: `slds-form-element slds-show ${widthClass}`,
              placeholder: label,
              label,
              maxlength,
              name
            };
          });
          rowList.name = rowKey++;
          return rowList;
        });
        return out;
      }

      isCountryPicklistEnabled() {
        return Array.isArray(this.countryOptions);
      }

      isProvincePicklistEnabled() {
        return Array.isArray(this.provinceOptions);
      }

      handleAddress(evt) {
        const address = evt.detail.address || {};
        this.street = address.street || '';
        this.city = address.city || '';
        this.province = address.state || '';
        const country = this.isCountryPicklistEnabled() ? address.countryCode : address.country;
        this.country = country || '';
        this.postalCode = address.postalCode || '';
        this.dispatchAddressChangeEvent();
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleBlur(event) {
        this.interactingState.leave();
        const field = event.target.dataset.field;

        this._reportValidityForField(field);
      }

      handleChange(event) {
        event.stopPropagation();
        const fieldName = event.target.dataset.field;
        const value = event.detail.value;

        if (this.getFieldValue(fieldName) === value) {
          // Value didn't change. No need to dispatch.
          return;
        }

        this[fieldName] = value;
        this.dispatchAddressChangeEvent();
      }

      dispatchAddressChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            street: this.street,
            city: this.city,
            province: this.province,
            country: this.country,
            postalCode: this.postalCode,
            validity: this.validity
          }
        }));
      }

      getFieldValue(fieldName) {
        return this[fieldName];
      }

      getFieldOptions(fieldName) {
        return this[`${fieldName}Options`];
      }

      getFieldLabel(fieldName) {
        return this[`${fieldName}Label`];
      }

      getFieldElement(fieldName) {
        return this.template.querySelector(`[data-field="${fieldName}"]`);
      }

      get _fieldConstraints() {
        if (!this._fieldConstraintApis) {
          // For every field to display create an appropriate constraint
          this._fieldConstraintApis = ['street', 'city', 'province', 'country', 'postalCode'].reduce((constraints, field) => {
            constraints[field] = new FieldConstraintApi(() => this.getFieldElement(field), {
              valueMissing: () => !this.disabled && this.required && this.requiredFields.indexOf(field) >= 0 && isEmptyString(this[field])
            });
            return constraints;
          }, {});
        }

        return this._fieldConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.customError),
            valueMissing: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.valueMissing)
          });
        }

        return this._combinedConstraintApi;
      }

      _reportValidityForField(field) {
        if (this._fieldConstraints[field]) {
          this._fieldConstraints[field].reportValidity(helpMessage => {
            const fieldElement = this.getFieldElement(field);
            fieldElement.setCustomValidity(helpMessage);
            fieldElement.reportValidity();
          });
        }
      }

    }

    LightningInputAddress.delegatesFocus = true;

    lwc.registerDecorators(LightningInputAddress, {
      publicProps: {
        addressLabel: {
          config: 0
        },
        streetLabel: {
          config: 0
        },
        cityLabel: {
          config: 0
        },
        provinceLabel: {
          config: 0
        },
        countryLabel: {
          config: 0
        },
        postalCodeLabel: {
          config: 0
        },
        provinceOptions: {
          config: 0
        },
        countryOptions: {
          config: 0
        },
        street: {
          config: 3
        },
        city: {
          config: 3
        },
        province: {
          config: 3
        },
        country: {
          config: 3
        },
        postalCode: {
          config: 3
        },
        disabled: {
          config: 3
        },
        showAddressLookup: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity", "focus", "blur"],
      track: {
        _showAddressLookup: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _street: 1,
        _city: 1,
        _province: 1,
        _country: 1,
        _postalCode: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1
      }
    });

    var _lightningInputAddress = lwc.registerComponent(LightningInputAddress, {
      tmpl: _tmpl$u
    });

    function stylesheet$c(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$c = [stylesheet$c];

    function stylesheet$d(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n.input-rich-text-placeholder" + shadowSelector + " {color: var(--lwc-colorTextPlaceholder);}\n";
    }
    var _implicitStylesheets$d = [stylesheet$d];

    function tmpl$w($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("span", {
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, [])];
    }

    var _tmpl$v = lwc.registerTemplate(tmpl$w);
    tmpl$w.stylesheets = [];
    tmpl$w.stylesheetTokens = {
      hostAttribute: "lightning-formattedRichText_formattedRichText-host",
      shadowAttribute: "lightning-formattedRichText_formattedRichText"
    };

    var freeze$1$2 = Object.freeze || function (x) {
      return x;
    };

    var html = freeze$1$2(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

    var svg = freeze$1$2(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);
    var svgFilters = freeze$1$2(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
    var mathMl = freeze$1$2(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);
    var text = freeze$1$2(['#text']);

    var freeze$2$1 = Object.freeze || function (x) {
      return x;
    };

    var html$1 = freeze$2$1(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);
    var svg$1 = freeze$2$1(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    var mathMl$1 = freeze$2$1(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    var xml = freeze$2$1(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);
    var hasOwnProperty$3 = Object.hasOwnProperty;
    var setPrototypeOf = Object.setPrototypeOf;

    var _ref$1 = typeof Reflect !== 'undefined' && Reflect;

    var apply$1 = _ref$1.apply;

    if (!apply$1) {
      apply$1 = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    /* Add properties to a lookup table */


    function addToSet(set, array) {
      if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
      }

      var l = array.length;

      while (l--) {
        var element = array[l];

        if (typeof element === 'string') {
          var lcElement = element.toLowerCase();

          if (lcElement !== element) {
            // Config presets (e.g. tags.js, attrs.js) are immutable.
            if (!Object.isFrozen(array)) {
              array[l] = lcElement;
            }

            element = lcElement;
          }
        }

        set[element] = true;
      }

      return set;
    }
    /* Shallow clone an object */


    function clone(object) {
      var newObject = {};
      var property = void 0;

      for (property in object) {
        if (apply$1(hasOwnProperty$3, object, [property])) {
          newObject[property] = object[property];
        }
      }

      return newObject;
    }

    var seal = Object.seal || function (x) {
      return x;
    };

    var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

    var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

    var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    );
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g // eslint-disable-line no-control-regex
    );

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      } else {
        return Array.from(arr);
      }
    }

    var _ref = typeof Reflect !== 'undefined' && Reflect;

    var apply = _ref.apply;
    var arraySlice = Array.prototype.slice;
    var freeze$3 = Object.freeze;

    var getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };

    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    /**
     * Creates a no-op policy for internal use only.
     * Don't export this function outside this module!
     * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
     * @param {Document} document The document object (to determine policy name suffix)
     * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
     * are not supported).
     */


    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
      if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      } // Allow the callers to control the unique policy name
      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
      // Policy creation with duplicate names throws in Trusted Types.


      var suffix = null;
      var ATTR_NAME = 'data-tt-policy-suffix';

      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document.currentScript.getAttribute(ATTR_NAME);
      }

      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html$$1) {
            return html$$1;
          }
        });
      } catch (error) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };

    function createDOMPurify() {
      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

      var DOMPurify = function DOMPurify(root) {
        return createDOMPurify(root);
      };
      /**
       * Version label, exposed for easier checks
       * if DOMPurify is up to date or not
       */


      DOMPurify.version = '2.0.6';
      /**
       * Array of elements that DOMPurify removed during sanitation.
       * Empty if nothing was removed.
       */

      DOMPurify.removed = [];

      if (!window || !window.document || window.document.nodeType !== 9) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
      }

      var originalDocument = window.document;
      var useDOMParser = false;
      var removeTitle = false;
      var document = window.document;
      var DocumentFragment = window.DocumentFragment,
          HTMLTemplateElement = window.HTMLTemplateElement,
          Node = window.Node,
          NodeFilter = window.NodeFilter,
          _window$NamedNodeMap = window.NamedNodeMap,
          NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
          Text = window.Text,
          Comment = window.Comment,
          DOMParser = window.DOMParser,
          TrustedTypes = window.TrustedTypes; // As per issue #47, the web-components registry is inherited by a
      // new document created via createHTMLDocument. As per the spec
      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
      // a new empty registry is used when creating a template contents owner
      // document, so we use that as our parent document to ensure nothing
      // is inherited.

      if (typeof HTMLTemplateElement === 'function') {
        var template = document.createElement('template');

        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }

      var trustedTypesPolicy = _createTrustedTypesPolicy(TrustedTypes, originalDocument);

      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
      var _document = document,
          implementation = _document.implementation,
          createNodeIterator = _document.createNodeIterator,
          getElementsByTagName = _document.getElementsByTagName,
          createDocumentFragment = _document.createDocumentFragment;
      var importNode = originalDocument.importNode;
      var hooks = {};
      /**
       * Expose whether this browser supports running the full DOMPurify.
       */

      DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;
      var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
          ERB_EXPR$$1 = ERB_EXPR,
          DATA_ATTR$$1 = DATA_ATTR,
          ARIA_ATTR$$1 = ARIA_ATTR,
          IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
          ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
      var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
      /**
       * We consider the elements and attributes below to be safe. Ideally
       * don't add any new ones but feel free to remove unwanted ones.
       */

      /* allowed element names */

      var ALLOWED_TAGS = null;
      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));
      /* Allowed attribute names */

      var ALLOWED_ATTR = null;
      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));
      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

      var FORBID_TAGS = null;
      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

      var FORBID_ATTR = null;
      /* Decide if ARIA attributes are okay */

      var ALLOW_ARIA_ATTR = true;
      /* Decide if custom data attributes are okay */

      var ALLOW_DATA_ATTR = true;
      /* Decide if unknown protocols are okay */

      var ALLOW_UNKNOWN_PROTOCOLS = false;
      /* Output should be safe for jQuery's $() factory? */

      var SAFE_FOR_JQUERY = false;
      /* Output should be safe for common template engines.
       * This means, DOMPurify removes data attributes, mustaches and ERB
       */

      var SAFE_FOR_TEMPLATES = false;
      /* Decide if document with <html>... should be returned */

      var WHOLE_DOCUMENT = false;
      /* Track whether config is already set on this instance of DOMPurify. */

      var SET_CONFIG = false;
      /* Decide if all elements (e.g. style, script) must be children of
       * document.body. By default, browsers might move them to document.head */

      var FORCE_BODY = false;
      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
       * string (or a TrustedHTML object if Trusted Types are supported).
       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
       */

      var RETURN_DOM = false;
      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
       * string  (or a TrustedHTML object if Trusted Types are supported) */

      var RETURN_DOM_FRAGMENT = false;
      /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
       * `Node` is imported into the current `Document`. If this flag is not enabled the
       * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
       * DOMPurify. */

      var RETURN_DOM_IMPORT = false;
      /* Try to return a Trusted Type object instead of a string, retrun a string in
       * case Trusted Types are not supported  */

      var RETURN_TRUSTED_TYPE = false;
      /* Output should be free from DOM clobbering attacks? */

      var SANITIZE_DOM = true;
      /* Keep element content when removing element? */

      var KEEP_CONTENT = true;
      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
       * of importing it into a new Document and returning a sanitized copy */

      var IN_PLACE = false;
      /* Allow usage of profiles like html, svg and mathMl */

      var USE_PROFILES = {};
      /* Tags to ignore content of when KEEP_CONTENT is true */

      var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'script', 'style', 'template', 'thead', 'title', 'svg', 'video']);
      /* Tags that are safe for data: URIs */

      var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);
      /* Attributes safe for values like "javascript:" */

      var URI_SAFE_ATTRIBUTES = null;
      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);
      /* Keep a reference to config to pass to hooks */

      var CONFIG = null;
      /* Ideally, do not touch anything below this line */

      /* ______________________________________________ */

      var formElement = document.createElement('form');
      /**
       * _parseConfig
       *
       * @param  {Object} cfg optional config literal
       */
      // eslint-disable-next-line complexity

      var _parseConfig = function _parseConfig(cfg) {
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        /* Shield configuration object from tampering */


        if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
          cfg = {};
        }
        /* Set configuration parameters */


        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

        SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false

        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

        RETURN_DOM = cfg.RETURN_DOM || false; // Default false

        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

        RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false

        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

        FORCE_BODY = cfg.FORCE_BODY || false; // Default false

        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

        IN_PLACE = cfg.IN_PLACE || false; // Default false

        IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;

        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }

        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        /* Parse profile info */


        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));
          ALLOWED_ATTR = [];

          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html);
            addToSet(ALLOWED_ATTR, html$1);
          }

          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg);
            addToSet(ALLOWED_ATTR, svg$1);
            addToSet(ALLOWED_ATTR, xml);
          }

          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg$1);
            addToSet(ALLOWED_ATTR, xml);
          }

          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl);
            addToSet(ALLOWED_ATTR, mathMl$1);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        /* Merge configuration parameters */


        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }

          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
        }

        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }

          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
        }

        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }
        /* Add #text in case KEEP_CONTENT is set to true */


        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        } // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.


        if (freeze$3) {
          freeze$3(cfg);
        }

        CONFIG = cfg;
      };
      /**
       * _forceRemove
       *
       * @param  {Node} node a DOM node
       */


      var _forceRemove = function _forceRemove(node) {
        DOMPurify.removed.push({
          element: node
        });

        try {
          node.parentNode.removeChild(node);
        } catch (error) {
          node.outerHTML = emptyHTML;
        }
      };
      /**
       * _removeAttribute
       *
       * @param  {String} name an Attribute name
       * @param  {Node} node a DOM node
       */


      var _removeAttribute = function _removeAttribute(name, node) {
        try {
          DOMPurify.removed.push({
            attribute: node.getAttributeNode(name),
            from: node
          });
        } catch (error) {
          DOMPurify.removed.push({
            attribute: null,
            from: node
          });
        }

        node.removeAttribute(name);
      };
      /**
       * _initDocument
       *
       * @param  {String} dirty a string of dirty markup
       * @return {Document} a DOM, filled with the dirty markup
       */


      var _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */
        var doc = void 0;
        var leadingWhitespace = void 0;

        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
          var matches = dirty.match(/^[\s]+/);
          leadingWhitespace = matches && matches[0];

          if (leadingWhitespace) {
            dirty = dirty.slice(leadingWhitespace.length);
          }
        }
        /* Use DOMParser to workaround Firefox bug (see comment below) */


        if (useDOMParser) {
          try {
            doc = new DOMParser().parseFromString(dirty, 'text/html');
          } catch (error) {}
        }
        /* Remove title to fix a mXSS bug in older MS Edge */


        if (removeTitle) {
          addToSet(FORBID_TAGS, ['title']);
        }
        /* Otherwise use createHTMLDocument, because DOMParser is unsafe in
        Safari (see comment below) */


        if (!doc || !doc.documentElement) {
          doc = implementation.createHTMLDocument('');
          var _doc = doc,
              body = _doc.body;
          body.parentNode.removeChild(body.parentNode.firstElementChild);
          body.outerHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        if (leadingWhitespace) {
          doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */


        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }; // Firefox uses a different parser for innerHTML rather than
      // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)
      // which means that you *must* use DOMParser, otherwise the output may
      // not be safe if used in a document.write context later.
      //
      // So we feature detect the Firefox bug and use the DOMParser if necessary.
      //
      // Chrome 77 and other versions ship an mXSS bug that caused a bypass to
      // happen. We now check for the mXSS trigger and react accordingly.


      if (DOMPurify.isSupported) {
        (function () {
          try {
            var doc = _initDocument('<svg><p><textarea><img src="</textarea><img src=x abc=1//">');

            if (doc.querySelector('svg img')) {
              useDOMParser = true;
            }
          } catch (error) {}
        })();

        (function () {
          try {
            var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');

            if (/<\/title/.test(doc.querySelector('title').innerHTML)) {
              removeTitle = true;
            }
          } catch (error) {}
        })();
      }
      /**
       * _createIterator
       *
       * @param  {Document} root document/fragment to create iterator for
       * @return {Iterator} iterator instance
       */


      var _createIterator = function _createIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
          return NodeFilter.FILTER_ACCEPT;
        }, false);
      };
      /**
       * _isClobbered
       *
       * @param  {Node} elm element to check for clobbering attacks
       * @return {Boolean} true if clobbered, false if safe
       */


      var _isClobbered = function _isClobbered(elm) {
        if (elm instanceof Text || elm instanceof Comment) {
          return false;
        }

        if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string') {
          return true;
        }

        return false;
      };
      /**
       * _isNode
       *
       * @param  {Node} obj object to check whether it's a DOM node
       * @return {Boolean} true is object is a DOM node
       */


      var _isNode = function _isNode(obj) {
        return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
      };
      /**
       * _executeHook
       * Execute user configurable hooks
       *
       * @param  {String} entryPoint  Name of the hook's entry point
       * @param  {Node} currentNode node to work on with the hook
       * @param  {Object} data additional hook parameters
       */


      var _executeHook = function _executeHook(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
          return;
        }

        hooks[entryPoint].forEach(function (hook) {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      };
      /**
       * _sanitizeElements
       *
       * @protect nodeName
       * @protect textContent
       * @protect removeChild
       *
       * @param   {Node} currentNode to check for permission to exist
       * @return  {Boolean} true if node was killed, false if left alive
       */
      // eslint-disable-next-line complexity


      var _sanitizeElements = function _sanitizeElements(currentNode) {
        var content = void 0;
        /* Execute a hook if present */

        _executeHook('beforeSanitizeElements', currentNode, null);
        /* Check if element is clobbered or can clobber */


        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Now let's check the element's type and name */


        var tagName = currentNode.nodeName.toLowerCase();
        /* Execute a hook if present */

        _executeHook('uponSanitizeElement', currentNode, {
          tagName: tagName,
          allowedTags: ALLOWED_TAGS
        });
        /* Take care of an mXSS pattern using p, br inside svg, math */


        if ((tagName === 'svg' || tagName === 'math') && currentNode.querySelectorAll('p, br').length !== 0) {
          _forceRemove(currentNode);

          return true;
        }
        /* Remove element if anything forbids its presence */


        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          /* Keep content except for black-listed elements */
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
            try {
              var htmlToInsert = currentNode.innerHTML;
              currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);
            } catch (error) {}
          }

          _forceRemove(currentNode);

          return true;
        }
        /* Remove in case a noscript/noembed XSS is suspected */


        if (tagName === 'noscript' && /<\/noscript/i.test(currentNode.innerHTML)) {
          _forceRemove(currentNode);

          return true;
        }

        if (tagName === 'noembed' && /<\/noembed/i.test(currentNode.innerHTML)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Convert markup to cover jQuery behavior */


        if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent)) {
          DOMPurify.removed.push({
            element: currentNode.cloneNode()
          });

          if (currentNode.innerHTML) {
            currentNode.innerHTML = currentNode.innerHTML.replace(/</g, '&lt;');
          } else {
            currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');
          }
        }
        /* Sanitize element content to be template-safe */


        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
          /* Get the element's text content */
          content = currentNode.textContent;
          content = content.replace(MUSTACHE_EXPR$$1, ' ');
          content = content.replace(ERB_EXPR$$1, ' ');

          if (currentNode.textContent !== content) {
            DOMPurify.removed.push({
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeElements', currentNode, null);

        return false;
      };
      /**
       * _isValidAttribute
       *
       * @param  {string} lcTag Lowercase tag name of containing element.
       * @param  {string} lcName Lowercase attribute name.
       * @param  {string} value Attribute value.
       * @return {Boolean} Returns true if `value` is valid, otherwise false.
       */
      // eslint-disable-next-line complexity


      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */


        if (ALLOW_DATA_ATTR && DATA_ATTR$$1.test(lcName)) ; else if (ALLOW_ARIA_ATTR && ARIA_ATTR$$1.test(lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          return false;
          /* Check value is safe. First, is attr inert? If so, is safe */
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && value.indexOf('data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
          return false;
        }

        return true;
      };
      /**
       * _sanitizeAttributes
       *
       * @protect attributes
       * @protect nodeName
       * @protect removeAttribute
       * @protect setAttribute
       *
       * @param  {Node} currentNode to sanitize
       */


      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        var attr = void 0;
        var value = void 0;
        var lcName = void 0;
        var idAttr = void 0;
        var l = void 0;
        /* Execute a hook if present */

        _executeHook('beforeSanitizeAttributes', currentNode, null);

        var attributes = currentNode.attributes;
        /* Check if we have attributes; if not we might have a text node */

        if (!attributes) {
          return;
        }

        var hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */

        while (l--) {
          attr = attributes[l];
          var _attr = attr,
              name = _attr.name,
              namespaceURI = _attr.namespaceURI;
          value = attr.value.trim();
          lcName = name.toLowerCase();
          /* Execute a hook if present */

          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;

          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

          value = hookEvent.attrValue;
          /* Remove attribute */
          // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
          // remove a "name" attribute from an <img> tag that has an "id"
          // attribute at the time.

          if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {
            idAttr = attributes.id;
            attributes = apply(arraySlice, attributes, []);

            _removeAttribute('id', currentNode);

            _removeAttribute(name, currentNode);

            if (attributes.indexOf(idAttr) > l) {
              currentNode.setAttribute('id', idAttr.value);
            }
          } else if ( // This works around a bug in Safari, where input[type=file]
          // cannot be dynamically set after type has been removed
          currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
            continue;
          } else {
            // This avoids a crash in Safari v9.0 with double-ids.
            // The trick is to first set the id to be empty and then to
            // remove the attribute
            if (name === 'id') {
              currentNode.setAttribute(name, '');
            }

            _removeAttribute(name, currentNode);
          }
          /* Did the hooks approve of the attribute? */


          if (!hookEvent.keepAttr) {
            continue;
          }
          /* Sanitize attribute content to be template-safe */


          if (SAFE_FOR_TEMPLATES) {
            value = value.replace(MUSTACHE_EXPR$$1, ' ');
            value = value.replace(ERB_EXPR$$1, ' ');
          }
          /* Is `value` valid for this attribute? */


          var lcTag = currentNode.nodeName.toLowerCase();

          if (!_isValidAttribute(lcTag, lcName, value)) {
            continue;
          }
          /* Handle invalid data-* attribute set by try-catching it */


          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
              currentNode.setAttribute(name, value);
            }

            DOMPurify.removed.pop();
          } catch (error) {}
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeAttributes', currentNode, null);
      };
      /**
       * _sanitizeShadowDOM
       *
       * @param  {DocumentFragment} fragment to iterate over recursively
       */


      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        var shadowNode = void 0;

        var shadowIterator = _createIterator(fragment);
        /* Execute a hook if present */


        _executeHook('beforeSanitizeShadowDOM', fragment, null);

        while (shadowNode = shadowIterator.nextNode()) {
          /* Execute a hook if present */
          _executeHook('uponSanitizeShadowNode', shadowNode, null);
          /* Sanitize tags and elements */


          if (_sanitizeElements(shadowNode)) {
            continue;
          }
          /* Deep shadow DOM detected */


          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
          /* Check attributes, sanitize if necessary */


          _sanitizeAttributes(shadowNode);
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeShadowDOM', fragment, null);
      };
      /**
       * Sanitize
       * Public method providing core sanitation functionality
       *
       * @param {String|Node} dirty string or DOM node
       * @param {Object} configuration object
       */
      // eslint-disable-next-line complexity


      DOMPurify.sanitize = function (dirty, cfg) {
        var body = void 0;
        var importedNode = void 0;
        var currentNode = void 0;
        var oldNode = void 0;
        var returnNode = void 0;
        /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */

        if (!dirty) {
          dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */


        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          // eslint-disable-next-line no-negated-condition
          if (typeof dirty.toString !== 'function') {
            throw new TypeError('toString is not a function');
          } else {
            dirty = dirty.toString();

            if (typeof dirty !== 'string') {
              throw new TypeError('dirty is not a string, aborting');
            }
          }
        }
        /* Check we can run. Otherwise fall back or ignore */


        if (!DOMPurify.isSupported) {
          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
            if (typeof dirty === 'string') {
              return window.toStaticHTML(dirty);
            }

            if (_isNode(dirty)) {
              return window.toStaticHTML(dirty.outerHTML);
            }
          }

          return dirty;
        }
        /* Assign config vars */


        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        /* Clean up removed elements */


        DOMPurify.removed = [];

        if (IN_PLACE) ; else if (dirty instanceof Node) {
          /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
          body = _initDocument('<!-->');
          importedNode = body.ownerDocument.importNode(dirty, true);

          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
            /* Node is already a body, use as is */
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            // eslint-disable-next-line unicorn/prefer-node-append
            body.appendChild(importedNode);
          }
        } else {
          /* Exit directly if we have nothing to do */
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && RETURN_TRUSTED_TYPE && dirty.indexOf('<') === -1) {
            return trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          /* Initialize the document to work on */


          body = _initDocument(dirty);
          /* Check we have a DOM node from the data */

          if (!body) {
            return RETURN_DOM ? null : emptyHTML;
          }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */


        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        /* Get node iterator */


        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */


        while (currentNode = nodeIterator.nextNode()) {
          /* Fix IE's strange behavior with manipulated textNodes #89 */
          if (currentNode.nodeType === 3 && currentNode === oldNode) {
            continue;
          }
          /* Sanitize tags and elements */


          if (_sanitizeElements(currentNode)) {
            continue;
          }
          /* Shadow DOM detected, sanitize it */


          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
          /* Check attributes, sanitize if necessary */


          _sanitizeAttributes(currentNode);

          oldNode = currentNode;
        }

        oldNode = null;
        /* If we sanitized `dirty` in-place, return it. */

        if (IN_PLACE) {
          return dirty;
        }
        /* Return sanitized string or DOM */


        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);

            while (body.firstChild) {
              // eslint-disable-next-line unicorn/prefer-node-append
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }

          if (RETURN_DOM_IMPORT) {
            /* AdoptNode() is not used because internal state is not reset
                   (e.g. the past names map of a HTMLFormElement), this is safe
                   in theory but we would rather not risk another attack vector.
                   The state that is cloned by importNode() is explicitly defined
                   by the specs. */
            returnNode = importNode.call(originalDocument, returnNode, true);
          }

          return returnNode;
        }

        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Sanitize final string template-safe */

        if (SAFE_FOR_TEMPLATES) {
          serializedHTML = serializedHTML.replace(MUSTACHE_EXPR$$1, ' ');
          serializedHTML = serializedHTML.replace(ERB_EXPR$$1, ' ');
        }

        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      /**
       * Public method to set the configuration once
       * setConfig
       *
       * @param {Object} cfg configuration object
       */


      DOMPurify.setConfig = function (cfg) {
        _parseConfig(cfg);

        SET_CONFIG = true;
      };
      /**
       * Public method to remove the configuration
       * clearConfig
       *
       */


      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      /**
       * Public method to check if an attribute value is valid.
       * Uses last set config, if any. Otherwise, uses config defaults.
       * isValidAttribute
       *
       * @param  {string} tag Tag name of containing element.
       * @param  {string} attr Attribute name.
       * @param  {string} value Attribute value.
       * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
       */


      DOMPurify.isValidAttribute = function (tag, attr, value) {
        /* Initialize shared config vars if necessary. */
        if (!CONFIG) {
          _parseConfig({});
        }

        var lcTag = tag.toLowerCase();
        var lcName = attr.toLowerCase();
        return _isValidAttribute(lcTag, lcName, value);
      };
      /**
       * AddHook
       * Public method to add DOMPurify hooks
       *
       * @param {String} entryPoint entry point for the hook to add
       * @param {Function} hookFunction function to execute
       */


      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }

        hooks[entryPoint] = hooks[entryPoint] || [];
        hooks[entryPoint].push(hookFunction);
      };
      /**
       * RemoveHook
       * Public method to remove a DOMPurify hook at a given entryPoint
       * (pops it from the stack of hooks if more are present)
       *
       * @param {String} entryPoint entry point for the hook to remove
       */


      DOMPurify.removeHook = function (entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint].pop();
        }
      };
      /**
       * RemoveHooks
       * Public method to remove all DOMPurify hooks at a given entryPoint
       *
       * @param  {String} entryPoint entry point for the hooks to remove
       */


      DOMPurify.removeHooks = function (entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint] = [];
        }
      };
      /**
       * RemoveAllHooks
       * Public method to remove all DOMPurify hooks
       *
       */


      DOMPurify.removeAllHooks = function () {
        hooks = {};
      };

      return DOMPurify;
    }

    var purify = createDOMPurify();
    var purify$1 = lwc.registerComponent(purify, {
      tmpl: _tmpl$3
    });

    /**
     * Sanitize method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     * @return {String} sanitized string
     */

    function sanitizeHTML(dirty, config) {
      return purify$1.sanitize(dirty, config);
    }

    const linkRegex$1 = new RegExp(`${tagRegexString}|${urlRegexString}|${emailRegexString}`, 'gi');

    const createHttpLink = function (match) {
      const href = createHttpHref(match);
      return `<a href="${href}" target="_blank" rel="noopener">${match}</a>`;
    };

    const createEmailLink = function (match) {
      const href = createEmailHref(match);
      return `<a href="${href}">${match}</a>`;
    };

    const linkify = function (text) {
      if (typeof text !== 'string') {
        return '';
      }

      return text.replace(linkRegex$1, (match, tagMatch, hrefMatch, emailMatch) => {
        if (tagMatch) {
          return tagMatch;
        } else if (hrefMatch) {
          const endsWithQuote = hrefMatch.endsWith('&quot');
          let href = hrefMatch;

          if (endsWithQuote) {
            href = hrefMatch.slice(0, hrefMatch.lastIndexOf('&quot'));
          }

          return createHttpLink(href) + (endsWithQuote ? '&quot' : '');
        } else if (emailMatch) {
          return createEmailLink(emailMatch);
        }

        return match;
      });
    };

    const tagsWhitelist = Object.freeze(['a', 'abbr', 'acronym', 'address', 'b', 'br', 'big', 'blockquote', 'caption', 'cite', 'code', 'col', 'colgroup', 'del', 'div', 'dl', 'dd', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'mark', 'p', 'param', 'pre', 'q', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'strike', 'font']);
    const attrWhitelist = Object.freeze(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'data-fileid']);
    const richTextConfig = Object.freeze({
      ALLOWED_TAGS: tagsWhitelist,
      ALLOWED_ATTR: attrWhitelist,
      ALLOW_UNKNOWN_PROTOCOLS: false
    });

    const GET_LINK_INFO_EVENT = 'lightningroutingservicegetlinkinfo';
    const urlTypes = {
      standard: 'standard_webPage'
    };
    /*
     * Mock getLinkInfo
     *
     * @returns {Promise[LinkInfo]}
     */

    function getLinkInfo(element, stateRef) {
      return new Promise((resolve, reject) => {
        // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments
        const getLinkInfoEvent = new CustomEvent(GET_LINK_INFO_EVENT, {
          detail: {
            stateRef,
            callback: (err, linkInfo) => {
              if (err) {
                reject(err);
              } else {
                resolve(linkInfo);
              }
            }
          },
          bubbles: true,
          composed: true,
          cancelable: true
        });
        element.dispatchEvent(getLinkInfoEvent);
      });
    }
    /**
     * Determines the route for the given url and updates the element
     * state with the correct url and dispatcher.
     *
     * @param {HTMLElement} element Element from which to dispatch the routing event
     * @param {Object} url Link to route, target Target of the link
     * @param {function} callback on the returned LinkInfo
     *
     * @returns {Promise} Promise[LinkInfo]
     */

    function updateRawLinkInfo(element, {
      url,
      target
    }) {
      if (url === undefined || url === null) {
        // eslint-disable-next-line no-console
        console.error('url must be specified');
      }

      if (target === '_blank') {
        // Have a no-op dispatcher if target is blank
        return new Promise(resolve => {
          resolve({
            url,
            dispatcher: () => {}
          });
        });
      }

      return getLinkInfo(element, {
        stateType: urlTypes.standard,
        attributes: {
          url,
          target
        }
      });
    }

    function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$6(target, key, source[key]); }); } return target; }

    function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    /**
     * Displays rich text that's formatted with whitelisted tags and attributes.
     * Other tags and attributes are removed and only their text content is displayed.
     */

    class LightningFormattedRichText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.initialRender = true;
        this._value = '';
        this._disableLinkify = false;
        this.connected = false;
        this.clean = false;
      }

      /**
       * If present, the component does not create links in the rich text.
       * @type {boolean}
       * @default false
       */
      get disableLinkify() {
        return this._disableLinkify;
      }

      set disableLinkify(val) {
        this._disableLinkify = normalizeBoolean(val);
        this.renderRichText();
      }
      /**
       * Sets the rich text to display.
       * @type {string}
       *
       */


      get value() {
        return this._value;
      }

      set value(val) {
        this._value = val === undefined || val === null ? '' : String(val);
        this.renderRichText();
      }

      renderedCallback() {
        if (this.initialRender) {
          this.renderRichText();
          this.initialRender = false;
        }
      }

      connectedCallback() {
        this.classList.add('slds-rich-text-editor__output');
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      handleClick(event) {
        const anchor = this.findNearestAnchor(event.target);

        if (anchor == null) {
          return;
        }

        const target = anchor.target;
        const url = anchor.href; // Grab the link info onclick and dispatch

        updateRawLinkInfo(this, {
          url,
          target
        }).then(linkInfo => {
          anchor.href = linkInfo.url;
          linkInfo.dispatcher(event);
        });
      }

      sanitize(value) {
        this.clean = false;
        let displayValue;
        let computedRichTextConfig = richTextConfig;

        if (hasOnlyAllowedVideoIframes(value)) {
          // richTextConfig is shared across all formatted-rich-text components;
          // so create and modify copy of richTextConfig to whitelist iframes for each component
          computedRichTextConfig = _objectSpread$6({}, richTextConfig, {
            ALLOWED_TAGS: richTextConfig.ALLOWED_TAGS.concat(['iframe'])
          });
        }

        try {
          displayValue = sanitizeHTML(value, computedRichTextConfig);
          this.clean = true;
        } catch (e) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-formatted-rich-text> Exception caught when attempting to sanitize: `, e);
          displayValue = value;
          this.clean = false;
        }

        return displayValue;
      }

      renderRichText() {
        if (this.connected) {
          const richText = this.sanitize(this.disableLinkify ? this.value : linkify(this.value));
          const container = this.getContainer();

          if (this.clean) {
            // eslint-disable-next-line @lwc/lwc/no-inner-html
            container.innerHTML = richText;
          } else {
            const textNode = document.createTextNode(richText);

            while (container.hasChildNodes()) {
              container.removeChild(container.lastChild);
            }

            container.appendChild(textNode);
          }
        }
      }

      getContainer() {
        return this.template.querySelector('span');
      }

      findNearestAnchor(startingElement) {
        const container = this.getContainer();
        let element = startingElement;

        while (element !== null && element !== container) {
          if (element.tagName === 'A') {
            return element;
          }

          element = element.parentNode;
        }

        return null;
      }

    }

    lwc.registerDecorators(LightningFormattedRichText, {
      publicProps: {
        disableLinkify: {
          config: 3
        },
        value: {
          config: 3
        }
      },
      fields: ["initialRender", "_value", "_disableLinkify", "connected", "clean"]
    });

    var _lightningFormattedRichText = lwc.registerComponent(LightningFormattedRichText, {
      tmpl: _tmpl$v
    });

    function tmpl$x($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "accesskey": $cmp.computedAccessKey,
          "title": $cmp.computedTitle,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-label": $cmp.computedAriaLabel,
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonBlur))
        }
      }, [$cmp.showIconLeft ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 0
      }, []) : null, api_dynamic($cmp.label), $cmp.showIconRight ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 1
      }, []) : null])];
    }

    var _tmpl$w = lwc.registerTemplate(tmpl$x);
    tmpl$x.stylesheets = [];
    tmpl$x.stylesheetTokens = {
      hostAttribute: "lightning-button_button-host",
      shadowAttribute: "lightning-button_button"
    };

    /**
     * A clickable element used to perform an action.
     */

    class LightningButton extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.label = void 0;
        this.variant = 'neutral';
        this.iconName = void 0;
        this.iconPosition = 'left';
        this.type = 'button';
        this.title = null;
        this._order = null;
      }

      render() {
        return _tmpl$w;
      }

      get computedButtonClass() {
        return classSet('slds-button').add({
          'slds-button_neutral': this.normalizedVariant === 'neutral',
          'slds-button_brand': this.normalizedVariant === 'brand',
          'slds-button_outline-brand': this.normalizedVariant === 'brand-outline',
          'slds-button_destructive': this.normalizedVariant === 'destructive',
          'slds-button_text-destructive': this.normalizedVariant === 'destructive-text',
          'slds-button_inverse': this.normalizedVariant === 'inverse',
          'slds-button_success': this.normalizedVariant === 'success',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedTitle() {
        return this.title;
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'neutral',
          validValues: ['base', 'neutral', 'brand', 'brand-outline', 'destructive', 'destructive-text', 'inverse', 'success']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: 'button',
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedIconPosition() {
        return normalizeString(this.iconPosition, {
          fallbackValue: 'left',
          validValues: ['left', 'right']
        });
      }

      get showIconLeft() {
        return this.iconName && this.normalizedIconPosition === 'left';
      }

      get showIconRight() {
        return this.iconName && this.normalizedIconPosition === 'right';
      }

      get computedIconClass() {
        return classSet('slds-button__icon').add({
          'slds-button__icon_left': this.normalizedIconPosition === 'left',
          'slds-button__icon_right': this.normalizedIconPosition === 'right'
        }).toString();
      }

      handleButtonFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleButtonBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        if (this._connected) {
          this.template.querySelector('button').focus();
        }
      }
      /**
       * Clicks the button.
       */


      click() {
        if (this._connected) {
          this.template.querySelector('button').click();
        }
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        this._connected = true;
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButton.delegatesFocus = true;

    lwc.registerDecorators(LightningButton, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        type: {
          config: 0
        }
      },
      publicMethods: ["focus", "click"],
      track: {
        title: 1,
        _order: 1
      }
    });

    var _lightningButton = lwc.registerComponent(LightningButton, {
      tmpl: _tmpl$w
    });
    LightningButton.interopMap = {
      exposeNativeEvent: {
        click: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$y($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16
      } = $ctx;
      return [$cmp.renderLabel ? api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("label"),
          "data-label": true
        },
        key: 0
      }, [api_dynamic($cmp.computedLabel)]) : null, api_element("div", {
        classMap: {
          "slds-rich-text-editor": true,
          "slds-grid": true,
          "slds-grid_vertical": true,
          "slds-nowrap": true
        },
        key: 28,
        on: {
          "click": _m10 || ($ctx._m10 = api_bind($cmp.activateEditor))
        }
      }, [$cmp.isBottomToolbar ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true,
          "editor": true
        },
        key: 1
      }, []) : null, $cmp.isBottomToolbar ? $cmp.quillNotReady ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true
        },
        key: 4
      }, [api_element("div", {
        classMap: {
          "slds-rich-text-area__content": true,
          "slds-grow": true,
          "slds-text-color-weak": true,
          "standin": true
        },
        key: 3,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleStandInClick))
        }
      }, [api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText, {
        props: {
          "value": $cmp.value,
          "disableLinkify": true
        },
        key: 2
      }, [])])]) : null : null, $cmp.isBottomToolbar ? !$cmp.valid ? api_element("div", {
        classMap: {
          "slds-form-element__help": true,
          "slds-p-around_small": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true
        },
        key: 5
      }, [api_dynamic($cmp.errorMessage)]) : null : null, api_element("div", {
        classMap: {
          "slds-rich-text-editor__toolbar": true,
          "slds-shrink-none": true
        },
        attrs: {
          "role": "toolbar",
          "aria-label": $cmp.toolbarAriaLabel
        },
        key: 21,
        on: {
          "keydown": _m8 || ($ctx._m8 = api_bind($cmp.navigateToolbar))
        }
      }, api_flatten([$cmp.isFontMenusVisible ? api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-wrap": true
        },
        attrs: {
          "role": "group",
          "aria-label": $cmp.i18n.formatFont
        },
        key: 14
      }, [$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true
        },
        key: 7
      }, [api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "value": $cmp.selectedFontValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.font,
          "options": $cmp.fontMenus.fontList,
          "disabled": $cmp.disabled,
          "dropdownAlignment": "auto"
        },
        key: 6,
        on: {
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.activateEditor)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.selectFont))
        }
      }, [])]) : null, $cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_xx-small": true
        },
        key: 9
      }, [api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "value": $cmp.selectedSizeValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.fontSize,
          "options": $cmp.fontMenus.sizeList,
          "disabled": $cmp.disabled,
          "dropdownAlignment": "auto"
        },
        key: 8,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.activateEditor)),
          "change": _m4 || ($ctx._m4 = api_bind($cmp.selectSize))
        }
      }, [])]) : null, !$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_x-small": true
        },
        key: 11
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.selectedFontValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.font,
          "options": $cmp.fontMenus.fontList,
          "disabled": $cmp.disabled
        },
        key: 10,
        on: {
          "change": _m5 || ($ctx._m5 = api_bind($cmp.selectFont))
        }
      }, [])]) : null, !$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_xx-small": true
        },
        key: 13
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.selectedSizeValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.fontSize,
          "options": $cmp.fontMenus.sizeList,
          "disabled": $cmp.disabled
        },
        key: 12,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.selectSize))
        }
      }, [])]) : null]) : null, $cmp.isColorpickerVisible ? api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton, {
        props: {
          "disabled": $cmp.disabled,
          "value": $cmp.selectedTextColorValue
        },
        key: 15,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleColorUpdate))
        }
      }, []) : null, api_iterator($cmp.computedCategories, function (category) {
        return api_element("ul", {
          classMap: {
            "slds-button-group-list": true
          },
          attrs: {
            "aria-label": category.label
          },
          key: api_key(20, category.label)
        }, api_iterator(category.buttons, function (button) {
          return api_element("li", {
            key: api_key(19, button.key)
          }, [api_element("button", {
            className: button.computedClass,
            attrs: {
              "type": "button",
              "value": button.value,
              "title": button.label,
              "data-format": button.format,
              "aria-pressed": "false"
            },
            key: 18
          }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
            props: {
              "iconName": button.iconName,
              "svgClass": "slds-button__icon",
              "variant": "bare"
            },
            key: 16
          }, []), api_element("span", {
            classMap: {
              "slds-assistive-text": true
            },
            key: 17
          }, [api_dynamic(button.label)])])]);
        }));
      })])), !$cmp.isBottomToolbar ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true,
          "editor": true
        },
        key: 22
      }, []) : null, !$cmp.isBottomToolbar ? $cmp.quillNotReady ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true
        },
        key: 26
      }, [api_element("div", {
        classMap: {
          "slds-rich-text-area__content": true,
          "slds-grow": true,
          "slds-text-color-weak": true,
          "standin": true
        },
        key: 25,
        on: {
          "click": _m9 || ($ctx._m9 = api_bind($cmp.handleStandInClick))
        }
      }, [!$cmp.shouldShowPlaceholder ? api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText, {
        props: {
          "value": $cmp.value,
          "disableLinkify": true
        },
        key: 23
      }, []) : null, $cmp.shouldShowPlaceholder ? api_element("p", {
        classMap: {
          "input-rich-text-placeholder": true
        },
        key: 24
      }, [api_dynamic($cmp.placeholder)]) : null])]) : null : null, !$cmp.isBottomToolbar ? !$cmp.valid ? api_element("div", {
        classMap: {
          "slds-form-element__help": true,
          "slds-p-around_small": true
        },
        attrs: {
          "id": api_scoped_id("error-message-bottom"),
          "data-error-message": true
        },
        key: 27
      }, [api_dynamic($cmp.errorMessage)]) : null : null]), $cmp.linkPanelOpen ? api_element("div", {
        classMap: {
          "slds-popover": true,
          "slds-popover__body": true
        },
        key: 33,
        on: {
          "focusout": _m15 || ($ctx._m15 = api_bind($cmp.handleLinkPanelFocusOut)),
          "focusin": _m16 || ($ctx._m16 = api_bind($cmp.handleLinkPanelFocusIn))
        }
      }, [api_custom_element("lightning-input", _lightningInput, {
        classMap: {
          "link-input": true
        },
        props: {
          "name": "link-input",
          "value": $cmp.showLinkValue,
          "label": $cmp.i18n.linkInput
        },
        key: 29,
        on: {
          "change": _m11 || ($ctx._m11 = api_bind($cmp.handleLinkValueChange)),
          "keydown": _m12 || ($ctx._m12 = api_bind($cmp.linkKeyboardPress))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-m-top_small": true
        },
        key: 32
      }, [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "variant": "brand",
          "label": $cmp.i18n.linkSave
        },
        key: 30,
        on: {
          "click": _m13 || ($ctx._m13 = api_bind($cmp.saveLink))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        styleMap: {
          "marginLeft": ".25rem"
        },
        props: {
          "variant": "bare",
          "label": $cmp.i18n.linkCancel
        },
        key: 31,
        on: {
          "click": _m14 || ($ctx._m14 = api_bind($cmp.cancelLink))
        }
      }, [])])]) : null];
    }

    var _tmpl$x = lwc.registerTemplate(tmpl$y);
    tmpl$y.stylesheets = [];

    if (_implicitStylesheets$d) {
      tmpl$y.stylesheets.push.apply(tmpl$y.stylesheets, _implicitStylesheets$d);
    }
    tmpl$y.stylesheetTokens = {
      hostAttribute: "lightning-inputRichText_inputRichText-host",
      shadowAttribute: "lightning-inputRichText_inputRichText"
    };

    var labelAlignText = 'Align text';

    var labelBold = 'Bold';

    var labelBullet = 'Bulleted list';

    var labelCenterAlign = 'Center align text';

    var labelComposeText = 'Compose text';

    var labelFont = 'Font';

    var labelFontSize = 'Font Size';

    var labelFormatBackground = 'Format background and text color';

    var labelFormatBody = 'Format body';

    var labelFormatFont = 'Format font family and size';

    var labelFormatText = 'Format text';

    var labelIndent = 'Indent';

    var labelInsertContent = 'Insert content';

    var labelItalic = 'Italic';

    var labelLeftAlign = 'Left align text';

    var labelLink = 'Link';

    var labelImage = 'Image';

    var labelLinkCancel = 'Cancel';

    var labelLinkInput = 'Link URL';

    var labelLinkSave = 'Save';

    var labelNumber = 'Numbered list';

    var labelOutdent = 'Outdent';

    var labelRemoveFormatting = 'Remove formatting';

    var labelRightAlign = 'Right align text';

    var labelStrike = 'Strikethrough';

    var labelUnderline = 'Underline';

    /*
     * Copyright (C) 2016 salesforce.com, inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /*
    Quill

    Copyright (c) 2014, Jason Chen
    Copyright (c) 2013, salesforce.com
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

    3. Neither the name of the copyright holder nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
      return module = {
        exports: {}
      }, fn(module, module.exports), module.exports;
    }

    var quill = createCommonjsModule(function (module, exports) {
      (function webpackUniversalModuleDefinition(root, factory) {
        module.exports = factory();
      })(typeof self !== 'undefined' ? self : commonjsGlobal, function () {
        return function (modules) {
          var installedModules = {};

          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }

            var module = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.l = true;
            return module.exports;
          }

          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;

          __webpack_require__.d = function (exports, name, getter) {
            if (!__webpack_require__.o(exports, name)) {
              Object.defineProperty(exports, name, {
                configurable: false,
                enumerable: true,
                get: getter
              });
            }
          };

          __webpack_require__.n = function (module) {
            var getter = module && module.__esModule ? function getDefault() {
              return module['default'];
            } : function getModuleExports() {
              return module;
            };

            __webpack_require__.d(getter, 'a', getter);

            return getter;
          };

          __webpack_require__.o = function (object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };

          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 109);
        }([function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var container_1 = __webpack_require__(17);

          var format_1 = __webpack_require__(18);

          var leaf_1 = __webpack_require__(19);

          var scroll_1 = __webpack_require__(45);

          var inline_1 = __webpack_require__(46);

          var block_1 = __webpack_require__(47);

          var embed_1 = __webpack_require__(48);

          var text_1 = __webpack_require__(49);

          var attributor_1 = __webpack_require__(12);

          var class_1 = __webpack_require__(32);

          var style_1 = __webpack_require__(33);

          var store_1 = __webpack_require__(31);

          var Registry = __webpack_require__(1);

          var Parchment = {
            Scope: Registry.Scope,
            create: Registry.create,
            find: Registry.find,
            query: Registry.query,
            register: Registry.register,
            Container: container_1.default,
            Format: format_1.default,
            Leaf: leaf_1.default,
            Embed: embed_1.default,
            Scroll: scroll_1.default,
            Block: block_1.default,
            Inline: inline_1.default,
            Text: text_1.default,
            Attributor: {
              Attribute: attributor_1.default,
              Class: class_1.default,
              Style: style_1.default,
              Store: store_1.default
            }
          };
          exports.default = Parchment;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var ParchmentError = function (_super) {
            __extends(ParchmentError, _super);

            function ParchmentError(message) {
              var _this = this;

              message = '[Parchment] ' + message;
              _this = _super.call(this, message) || this;
              _this.message = message;
              _this.name = _this.constructor.name;
              return _this;
            }

            return ParchmentError;
          }(Error);

          exports.ParchmentError = ParchmentError;
          var attributes = {};
          var classes = {};
          var tags = {};
          var types = {};
          exports.DATA_KEY = '__blot';
          var Scope;

          (function (Scope) {
            Scope[Scope["TYPE"] = 3] = "TYPE";
            Scope[Scope["LEVEL"] = 12] = "LEVEL";
            Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
            Scope[Scope["BLOT"] = 14] = "BLOT";
            Scope[Scope["INLINE"] = 7] = "INLINE";
            Scope[Scope["BLOCK"] = 11] = "BLOCK";
            Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
            Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
            Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
            Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
            Scope[Scope["ANY"] = 15] = "ANY";
          })(Scope = exports.Scope || (exports.Scope = {}));

          function create(input, value) {
            var match = query(input);

            if (match == null) {
              throw new ParchmentError("Unable to create " + input + " blot");
            }

            var BlotClass = match;
            var node = input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
            return new BlotClass(node, value);
          }

          exports.create = create;

          function find(node, bubble) {
            if (bubble === void 0) {
              bubble = false;
            }

            if (node == null) return null;
            if (node[exports.DATA_KEY] != null) return node[exports.DATA_KEY].blot;
            if (bubble) return find(node.parentNode, bubble);
            return null;
          }

          exports.find = find;

          function query(query, scope) {
            if (scope === void 0) {
              scope = Scope.ANY;
            }

            var match;

            if (typeof query === 'string') {
              match = types[query] || attributes[query];
            } else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
              match = types['text'];
            } else if (typeof query === 'number') {
              if (query & Scope.LEVEL & Scope.BLOCK) {
                match = types['block'];
              } else if (query & Scope.LEVEL & Scope.INLINE) {
                match = types['inline'];
              }
            } else if (query instanceof HTMLElement) {
              var names = (query.getAttribute('class') || '').split(/\s+/);

              for (var i in names) {
                match = classes[names[i]];
                if (match) break;
              }

              match = match || tags[query.tagName];
            }

            if (match == null) return null;
            if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) return match;
            return null;
          }

          exports.query = query;

          function register() {
            var Definitions = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              Definitions[_i] = arguments[_i];
            }

            if (Definitions.length > 1) {
              return Definitions.map(function (d) {
                return register(d);
              });
            }

            var Definition = Definitions[0];

            if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
              throw new ParchmentError('Invalid definition');
            } else if (Definition.blotName === 'abstract') {
              throw new ParchmentError('Cannot register abstract class');
            }

            types[Definition.blotName || Definition.attrName] = Definition;

            if (typeof Definition.keyName === 'string') {
              attributes[Definition.keyName] = Definition;
            } else {
              if (Definition.className != null) {
                classes[Definition.className] = Definition;
              }

              if (Definition.tagName != null) {
                if (Array.isArray(Definition.tagName)) {
                  Definition.tagName = Definition.tagName.map(function (tagName) {
                    return tagName.toUpperCase();
                  });
                } else {
                  Definition.tagName = Definition.tagName.toUpperCase();
                }

                var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                tagNames.forEach(function (tag) {
                  if (tags[tag] == null || Definition.className == null) {
                    tags[tag] = Definition;
                  }
                });
              }
            }

            return Definition;
          }

          exports.register = register;
        }, function (module, exports, __webpack_require__) {
          var diff = __webpack_require__(51);

          var equal = __webpack_require__(11);

          var extend = __webpack_require__(3);

          var op = __webpack_require__(20);

          var NULL_CHARACTER = String.fromCharCode(0);

          var Delta = function (ops) {
            if (Array.isArray(ops)) {
              this.ops = ops;
            } else if (ops != null && Array.isArray(ops.ops)) {
              this.ops = ops.ops;
            } else {
              this.ops = [];
            }
          };

          Delta.prototype.insert = function (text, attributes) {
            var newOp = {};
            if (text.length === 0) return this;
            newOp.insert = text;

            if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }

            return this.push(newOp);
          };

          Delta.prototype['delete'] = function (length) {
            if (length <= 0) return this;
            return this.push({
              'delete': length
            });
          };

          Delta.prototype.retain = function (length, attributes) {
            if (length <= 0) return this;
            var newOp = {
              retain: length
            };

            if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }

            return this.push(newOp);
          };

          Delta.prototype.push = function (newOp) {
            var index = this.ops.length;
            var lastOp = this.ops[index - 1];
            newOp = extend(true, {}, newOp);

            if (typeof lastOp === 'object') {
              if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
                this.ops[index - 1] = {
                  'delete': lastOp['delete'] + newOp['delete']
                };
                return this;
              }

              if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
                index -= 1;
                lastOp = this.ops[index - 1];

                if (typeof lastOp !== 'object') {
                  this.ops.unshift(newOp);
                  return this;
                }
              }

              if (equal(newOp.attributes, lastOp.attributes)) {
                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
                  this.ops[index - 1] = {
                    insert: lastOp.insert + newOp.insert
                  };
                  if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                  return this;
                } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
                  this.ops[index - 1] = {
                    retain: lastOp.retain + newOp.retain
                  };
                  if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
                  return this;
                }
              }
            }

            if (index === this.ops.length) {
              this.ops.push(newOp);
            } else {
              this.ops.splice(index, 0, newOp);
            }

            return this;
          };

          Delta.prototype.chop = function () {
            var lastOp = this.ops[this.ops.length - 1];

            if (lastOp && lastOp.retain && !lastOp.attributes) {
              this.ops.pop();
            }

            return this;
          };

          Delta.prototype.filter = function (predicate) {
            return this.ops.filter(predicate);
          };

          Delta.prototype.forEach = function (predicate) {
            this.ops.forEach(predicate);
          };

          Delta.prototype.map = function (predicate) {
            return this.ops.map(predicate);
          };

          Delta.prototype.partition = function (predicate) {
            var passed = [],
                failed = [];
            this.forEach(function (op) {
              var target = predicate(op) ? passed : failed;
              target.push(op);
            });
            return [passed, failed];
          };

          Delta.prototype.reduce = function (predicate, initial) {
            return this.ops.reduce(predicate, initial);
          };

          Delta.prototype.changeLength = function () {
            return this.reduce(function (length, elem) {
              if (elem.insert) {
                return length + op.length(elem);
              } else if (elem.delete) {
                return length - elem.delete;
              }

              return length;
            }, 0);
          };

          Delta.prototype.length = function () {
            return this.reduce(function (length, elem) {
              return length + op.length(elem);
            }, 0);
          };

          Delta.prototype.slice = function (start, end) {
            start = start || 0;
            if (typeof end !== 'number') end = Infinity;
            var ops = [];
            var iter = op.iterator(this.ops);
            var index = 0;

            while (index < end && iter.hasNext()) {
              var nextOp;

              if (index < start) {
                nextOp = iter.next(start - index);
              } else {
                nextOp = iter.next(end - index);
                ops.push(nextOp);
              }

              index += op.length(nextOp);
            }

            return new Delta(ops);
          };

          Delta.prototype.compose = function (other) {
            var thisIter = op.iterator(this.ops);
            var otherIter = op.iterator(other.ops);
            var ops = [];
            var firstOther = otherIter.peek();

            if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
              var firstLeft = firstOther.retain;

              while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
                firstLeft -= thisIter.peekLength();
                ops.push(thisIter.next());
              }

              if (firstOther.retain - firstLeft > 0) {
                otherIter.next(firstOther.retain - firstLeft);
              }
            }

            var delta = new Delta(ops);

            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (otherIter.peekType() === 'insert') {
                delta.push(otherIter.next());
              } else if (thisIter.peekType() === 'delete') {
                delta.push(thisIter.next());
              } else {
                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                var thisOp = thisIter.next(length);
                var otherOp = otherIter.next(length);

                if (typeof otherOp.retain === 'number') {
                  var newOp = {};

                  if (typeof thisOp.retain === 'number') {
                    newOp.retain = length;
                  } else {
                    newOp.insert = thisOp.insert;
                  }

                  var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
                  if (attributes) newOp.attributes = attributes;
                  delta.push(newOp);

                  if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                    var rest = new Delta(thisIter.rest());
                    return delta.concat(rest).chop();
                  }
                } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
                  delta.push(otherOp);
                }
              }
            }

            return delta.chop();
          };

          Delta.prototype.concat = function (other) {
            var delta = new Delta(this.ops.slice());

            if (other.ops.length > 0) {
              delta.push(other.ops[0]);
              delta.ops = delta.ops.concat(other.ops.slice(1));
            }

            return delta;
          };

          Delta.prototype.diff = function (other, index) {
            if (this.ops === other.ops) {
              return new Delta();
            }

            var strings = [this, other].map(function (delta) {
              return delta.map(function (op) {
                if (op.insert != null) {
                  return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
                }

                var prep = delta === other ? 'on' : 'with';
                throw new Error('diff() called ' + prep + ' non-document');
              }).join('');
            });
            var delta = new Delta();
            var diffResult = diff(strings[0], strings[1], index);
            var thisIter = op.iterator(this.ops);
            var otherIter = op.iterator(other.ops);
            diffResult.forEach(function (component) {
              var length = component[1].length;

              while (length > 0) {
                var opLength = 0;

                switch (component[0]) {
                  case diff.INSERT:
                    opLength = Math.min(otherIter.peekLength(), length);
                    delta.push(otherIter.next(opLength));
                    break;

                  case diff.DELETE:
                    opLength = Math.min(length, thisIter.peekLength());
                    thisIter.next(opLength);
                    delta['delete'](opLength);
                    break;

                  case diff.EQUAL:
                    opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                    var thisOp = thisIter.next(opLength);
                    var otherOp = otherIter.next(opLength);

                    if (equal(thisOp.insert, otherOp.insert)) {
                      delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                    } else {
                      delta.push(otherOp)['delete'](opLength);
                    }

                    break;
                }

                length -= opLength;
              }
            });
            return delta.chop();
          };

          Delta.prototype.eachLine = function (predicate, newline) {
            newline = newline || '\n';
            var iter = op.iterator(this.ops);
            var line = new Delta();
            var i = 0;

            while (iter.hasNext()) {
              if (iter.peekType() !== 'insert') return;
              var thisOp = iter.peek();
              var start = op.length(thisOp) - iter.peekLength();
              var index = typeof thisOp.insert === 'string' ? thisOp.insert.indexOf(newline, start) - start : -1;

              if (index < 0) {
                line.push(iter.next());
              } else if (index > 0) {
                line.push(iter.next(index));
              } else {
                if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                  return;
                }

                i += 1;
                line = new Delta();
              }
            }

            if (line.length() > 0) {
              predicate(line, {}, i);
            }
          };

          Delta.prototype.transform = function (other, priority) {
            priority = !!priority;

            if (typeof other === 'number') {
              return this.transformPosition(other, priority);
            }

            var thisIter = op.iterator(this.ops);
            var otherIter = op.iterator(other.ops);
            var delta = new Delta();

            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
                delta.retain(op.length(thisIter.next()));
              } else if (otherIter.peekType() === 'insert') {
                delta.push(otherIter.next());
              } else {
                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                var thisOp = thisIter.next(length);
                var otherOp = otherIter.next(length);

                if (thisOp['delete']) {
                  continue;
                } else if (otherOp['delete']) {
                  delta.push(otherOp);
                } else {
                  delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
                }
              }
            }

            return delta.chop();
          };

          Delta.prototype.transformPosition = function (index, priority) {
            priority = !!priority;
            var thisIter = op.iterator(this.ops);
            var offset = 0;

            while (thisIter.hasNext() && offset <= index) {
              var length = thisIter.peekLength();
              var nextType = thisIter.peekType();
              thisIter.next();

              if (nextType === 'delete') {
                index -= Math.min(length, index - offset);
                continue;
              } else if (nextType === 'insert' && (offset < index || !priority)) {
                index += length;
              }

              offset += length;
            }

            return index;
          };

          module.exports = Delta;
        }, function (module, exports) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var toStr = Object.prototype.toString;
          var defineProperty = Object.defineProperty;
          var gOPD = Object.getOwnPropertyDescriptor;

          var isArray = function isArray(arr) {
            if (typeof Array.isArray === 'function') {
              return Array.isArray(arr);
            }

            return toStr.call(arr) === '[object Array]';
          };

          var isPlainObject = function isPlainObject(obj) {
            if (!obj || toStr.call(obj) !== '[object Object]') {
              return false;
            }

            var hasOwnConstructor = hasOwn.call(obj, 'constructor');
            var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');

            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
              return false;
            }

            var key;

            for (key in obj) {}

            return typeof key === 'undefined' || hasOwn.call(obj, key);
          };

          var setProperty = function setProperty(target, options) {
            if (defineProperty && options.name === '__proto__') {
              defineProperty(target, options.name, {
                enumerable: true,
                configurable: true,
                value: options.newValue,
                writable: true
              });
            } else {
              target[options.name] = options.newValue;
            }
          };

          var getProperty = function getProperty(obj, name) {
            if (name === '__proto__') {
              if (!hasOwn.call(obj, name)) {
                return void 0;
              } else if (gOPD) {
                return gOPD(obj, name).value;
              }
            }

            return obj[name];
          };

          module.exports = function extend() {
            var options, name, src, copy, copyIsArray, clone;
            var target = arguments[0];
            var i = 1;
            var length = arguments.length;
            var deep = false;

            if (typeof target === 'boolean') {
              deep = target;
              target = arguments[1] || {};
              i = 2;
            }

            if (target == null || typeof target !== 'object' && typeof target !== 'function') {
              target = {};
            }

            for (; i < length; ++i) {
              options = arguments[i];

              if (options != null) {
                for (name in options) {
                  src = getProperty(target, name);
                  copy = getProperty(options, name);

                  if (target !== copy) {
                    if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                      if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && isArray(src) ? src : [];
                      } else {
                        clone = src && isPlainObject(src) ? src : {};
                      }

                      setProperty(target, {
                        name: name,
                        newValue: extend(deep, clone, copy)
                      });
                    } else if (typeof copy !== 'undefined') {
                      setProperty(target, {
                        name: name,
                        newValue: copy
                      });
                    }
                  }
                }
              }
            }

            return target;
          };
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _extend = __webpack_require__(3);

          var _extend2 = _interopRequireDefault(_extend);

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _break = __webpack_require__(16);

          var _break2 = _interopRequireDefault(_break);

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          var _text = __webpack_require__(7);

          var _text2 = _interopRequireDefault(_text);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var NEWLINE_LENGTH = 1;

          var BlockEmbed = function (_Parchment$Embed) {
            _inherits(BlockEmbed, _Parchment$Embed);

            function BlockEmbed() {
              _classCallCheck(this, BlockEmbed);

              return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
            }

            _createClass(BlockEmbed, [{
              key: 'attach',
              value: function attach() {
                _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);

                this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
              }
            }, {
              key: 'delta',
              value: function delta() {
                return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
              }
            }, {
              key: 'format',
              value: function format(name, value) {
                var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);

                if (attribute != null) {
                  this.attributes.attribute(attribute, value);
                }
              }
            }, {
              key: 'formatAt',
              value: function formatAt(index, length, name, value) {
                this.format(name, value);
              }
            }, {
              key: 'insertAt',
              value: function insertAt(index, value, def) {
                if (typeof value === 'string' && value.endsWith('\n')) {
                  var block = _parchment2.default.create(Block.blotName);

                  this.parent.insertBefore(block, index === 0 ? this : this.next);
                  block.insertAt(0, value.slice(0, -1));
                } else {
                  _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
                }
              }
            }]);

            return BlockEmbed;
          }(_parchment2.default.Embed);

          BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;

          var Block = function (_Parchment$Block) {
            _inherits(Block, _Parchment$Block);

            function Block(domNode) {
              _classCallCheck(this, Block);

              var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));

              _this2.cache = {};
              return _this2;
            }

            _createClass(Block, [{
              key: 'delta',
              value: function delta() {
                if (this.cache.delta == null) {
                  this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {
                    if (leaf.length() === 0) {
                      return delta;
                    } else {
                      return delta.insert(leaf.value(), bubbleFormats(leaf));
                    }
                  }, new _quillDelta2.default()).insert('\n', bubbleFormats(this));
                }

                return this.cache.delta;
              }
            }, {
              key: 'deleteAt',
              value: function deleteAt(index, length) {
                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);

                this.cache = {};
              }
            }, {
              key: 'formatAt',
              value: function formatAt(index, length, name, value) {
                if (length <= 0) return;

                if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                  if (index + length === this.length()) {
                    this.format(name, value);
                  }
                } else {
                  _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
                }

                this.cache = {};
              }
            }, {
              key: 'insertAt',
              value: function insertAt(index, value, def) {
                if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
                if (value.length === 0) return;
                var lines = value.split('\n');
                var text = lines.shift();

                if (text.length > 0) {
                  if (index < this.length() - 1 || this.children.tail == null) {
                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
                  } else {
                    this.children.tail.insertAt(this.children.tail.length(), text);
                  }

                  this.cache = {};
                }

                var block = this;
                lines.reduce(function (index, line) {
                  block = block.split(index, true);
                  block.insertAt(0, line);
                  return line.length;
                }, index + text.length);
              }
            }, {
              key: 'insertBefore',
              value: function insertBefore(blot, ref) {
                var head = this.children.head;

                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);

                if (head instanceof _break2.default) {
                  head.remove();
                }

                this.cache = {};
              }
            }, {
              key: 'length',
              value: function length() {
                if (this.cache.length == null) {
                  this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
                }

                return this.cache.length;
              }
            }, {
              key: 'moveChildren',
              value: function moveChildren(target, ref) {
                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);

                this.cache = {};
              }
            }, {
              key: 'optimize',
              value: function optimize(context) {
                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);

                this.cache = {};
              }
            }, {
              key: 'path',
              value: function path(index) {
                return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
              }
            }, {
              key: 'removeChild',
              value: function removeChild(child) {
                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);

                this.cache = {};
              }
            }, {
              key: 'split',
              value: function split(index) {
                var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
                  var clone = this.clone();

                  if (index === 0) {
                    this.parent.insertBefore(clone, this);
                    return this;
                  } else {
                    this.parent.insertBefore(clone, this.next);
                    return clone;
                  }
                } else {
                  var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);

                  this.cache = {};
                  return next;
                }
              }
            }]);

            return Block;
          }(_parchment2.default.Block);

          Block.blotName = 'block';
          Block.tagName = 'P';
          Block.defaultChild = 'break';
          Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];

          function bubbleFormats(blot) {
            var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (blot == null) return formats;

            if (typeof blot.formats === 'function') {
              formats = (0, _extend2.default)(formats, blot.formats());
            }

            if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
              return formats;
            }

            return bubbleFormats(blot.parent, formats);
          }

          exports.bubbleFormats = bubbleFormats;
          exports.BlockEmbed = BlockEmbed;
          exports.default = Block;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.overload = exports.expandConfig = undefined;

          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          __webpack_require__(50);

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _editor = __webpack_require__(14);

          var _editor2 = _interopRequireDefault(_editor);

          var _emitter3 = __webpack_require__(8);

          var _emitter4 = _interopRequireDefault(_emitter3);

          var _module = __webpack_require__(9);

          var _module2 = _interopRequireDefault(_module);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _selection = __webpack_require__(15);

          var _selection2 = _interopRequireDefault(_selection);

          var _extend = __webpack_require__(3);

          var _extend2 = _interopRequireDefault(_extend);

          var _logger = __webpack_require__(10);

          var _logger2 = _interopRequireDefault(_logger);

          var _theme = __webpack_require__(34);

          var _theme2 = _interopRequireDefault(_theme);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }

            return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var debug = (0, _logger2.default)('quill');

          var Quill = function () {
            _createClass(Quill, null, [{
              key: 'debug',
              value: function debug(limit) {
                if (limit === true) {
                  limit = 'log';
                }

                _logger2.default.level(limit);
              }
            }, {
              key: 'find',
              value: function find(node) {
                return node.__quill || _parchment2.default.find(node);
              }
            }, {
              key: 'import',
              value: function _import(name) {
                if (this.imports[name] == null) {
                  debug.error('Cannot import ' + name + '. Are you sure it was registered?');
                }

                return this.imports[name];
              }
            }, {
              key: 'register',
              value: function register(path, target) {
                var _this = this;

                var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

                if (typeof path !== 'string') {
                  var name = path.attrName || path.blotName;

                  if (typeof name === 'string') {
                    this.register('formats/' + name, path, target);
                  } else {
                    Object.keys(path).forEach(function (key) {
                      _this.register(key, path[key], target);
                    });
                  }
                } else {
                  if (this.imports[path] != null && !overwrite) {
                    debug.warn('Overwriting ' + path + ' with', target);
                  }

                  this.imports[path] = target;

                  if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
                    _parchment2.default.register(target);
                  } else if (path.startsWith('modules') && typeof target.register === 'function') {
                    target.register();
                  }
                }
              }
            }]);

            function Quill(container) {
              var _this2 = this;

              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              _classCallCheck(this, Quill);

              this.options = expandConfig(container, options);
              this.container = this.options.container;

              if (this.container == null) {
                return debug.error('Invalid Quill container', container);
              }

              if (this.options.debug) {
                Quill.debug(this.options.debug);
              }

              var html = this.container.innerHTML.trim();
              this.container.classList.add('ql-container');
              this.container.innerHTML = '';
              this.container.__quill = this;
              this.root = this.addContainer('ql-editor');
              this.root.classList.add('ql-blank');
              this.root.setAttribute('data-gramm', false);
              this.scrollingContainer = this.options.scrollingContainer || this.root;
              this.emitter = new _emitter4.default();
              this.scroll = _parchment2.default.create(this.root, {
                emitter: this.emitter,
                whitelist: this.options.formats
              });
              this.editor = new _editor2.default(this.scroll);
              this.selection = new _selection2.default(this.scroll, this.emitter);
              this.theme = new this.options.theme(this, this.options);
              this.keyboard = this.theme.addModule('keyboard');
              this.clipboard = this.theme.addModule('clipboard');
              this.history = this.theme.addModule('history');
              this.theme.init();
              this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {
                if (type === _emitter4.default.events.TEXT_CHANGE) {
                  _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
                }
              });
              this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {
                var range = _this2.selection.lastRange;
                var index = range && range.length === 0 ? range.index : undefined;
                modify.call(_this2, function () {
                  return _this2.editor.update(null, mutations, index);
                }, source);
              });
              var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
              this.setContents(contents);
              this.history.clear();

              if (this.options.placeholder) {
                this.root.setAttribute('data-placeholder', this.options.placeholder);
              }

              if (this.options.readOnly) {
                this.disable();
              }
            }

            _createClass(Quill, [{
              key: 'addContainer',
              value: function addContainer(container) {
                var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                if (typeof container === 'string') {
                  var className = container;
                  container = document.createElement('div');
                  container.classList.add(className);
                }

                this.container.insertBefore(container, refNode);
                return container;
              }
            }, {
              key: 'blur',
              value: function blur() {
                this.selection.setRange(null);
              }
            }, {
              key: 'deleteText',
              value: function deleteText(index, length, source) {
                var _this3 = this;

                var _overload = overload(index, length, source);

                var _overload2 = _slicedToArray(_overload, 4);

                index = _overload2[0];
                length = _overload2[1];
                source = _overload2[3];
                return modify.call(this, function () {
                  return _this3.editor.deleteText(index, length);
                }, source, index, -1 * length);
              }
            }, {
              key: 'disable',
              value: function disable() {
                this.enable(false);
              }
            }, {
              key: 'enable',
              value: function enable() {
                var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                this.scroll.enable(enabled);
                this.container.classList.toggle('ql-disabled', !enabled);
              }
            }, {
              key: 'focus',
              value: function focus() {
                var scrollTop = this.scrollingContainer.scrollTop;
                this.selection.focus();
                this.scrollingContainer.scrollTop = scrollTop;
                this.scrollIntoView();
              }
            }, {
              key: 'format',
              value: function format(name, value) {
                var _this4 = this;

                var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;
                return modify.call(this, function () {
                  var range = _this4.getSelection(true);

                  var change = new _quillDelta2.default();

                  if (range == null) {
                    return change;
                  } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                    change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
                  } else if (range.length === 0) {
                    _this4.selection.format(name, value);

                    return change;
                  } else {
                    change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
                  }

                  _this4.setSelection(range, _emitter4.default.sources.SILENT);

                  return change;
                }, source);
              }
            }, {
              key: 'formatLine',
              value: function formatLine(index, length, name, value, source) {
                var _this5 = this;

                var formats = void 0;

                var _overload3 = overload(index, length, name, value, source);

                var _overload4 = _slicedToArray(_overload3, 4);

                index = _overload4[0];
                length = _overload4[1];
                formats = _overload4[2];
                source = _overload4[3];
                return modify.call(this, function () {
                  return _this5.editor.formatLine(index, length, formats);
                }, source, index, 0);
              }
            }, {
              key: 'formatText',
              value: function formatText(index, length, name, value, source) {
                var _this6 = this;

                var formats = void 0;

                var _overload5 = overload(index, length, name, value, source);

                var _overload6 = _slicedToArray(_overload5, 4);

                index = _overload6[0];
                length = _overload6[1];
                formats = _overload6[2];
                source = _overload6[3];
                return modify.call(this, function () {
                  return _this6.editor.formatText(index, length, formats);
                }, source, index, 0);
              }
            }, {
              key: 'getBounds',
              value: function getBounds(index) {
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var bounds = void 0;

                if (typeof index === 'number') {
                  bounds = this.selection.getBounds(index, length);
                } else {
                  bounds = this.selection.getBounds(index.index, index.length);
                }

                var containerBounds = this.container.getBoundingClientRect();
                return {
                  bottom: bounds.bottom - containerBounds.top,
                  height: bounds.height,
                  left: bounds.left - containerBounds.left,
                  right: bounds.right - containerBounds.left,
                  top: bounds.top - containerBounds.top,
                  width: bounds.width
                };
              }
            }, {
              key: 'getContents',
              value: function getContents() {
                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

                var _overload7 = overload(index, length);

                var _overload8 = _slicedToArray(_overload7, 2);

                index = _overload8[0];
                length = _overload8[1];
                return this.editor.getContents(index, length);
              }
            }, {
              key: 'getFormat',
              value: function getFormat() {
                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

                if (typeof index === 'number') {
                  return this.editor.getFormat(index, length);
                } else {
                  return this.editor.getFormat(index.index, index.length);
                }
              }
            }, {
              key: 'getIndex',
              value: function getIndex(blot) {
                return blot.offset(this.scroll);
              }
            }, {
              key: 'getLength',
              value: function getLength() {
                return this.scroll.length();
              }
            }, {
              key: 'getLeaf',
              value: function getLeaf(index) {
                return this.scroll.leaf(index);
              }
            }, {
              key: 'getLine',
              value: function getLine(index) {
                return this.scroll.line(index);
              }
            }, {
              key: 'getLines',
              value: function getLines() {
                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

                if (typeof index !== 'number') {
                  return this.scroll.lines(index.index, index.length);
                } else {
                  return this.scroll.lines(index, length);
                }
              }
            }, {
              key: 'getModule',
              value: function getModule(name) {
                return this.theme.modules[name];
              }
            }, {
              key: 'getSelection',
              value: function getSelection() {
                var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                if (focus) this.focus();
                this.update();
                return this.selection.getRange()[0];
              }
            }, {
              key: 'getText',
              value: function getText() {
                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

                var _overload9 = overload(index, length);

                var _overload10 = _slicedToArray(_overload9, 2);

                index = _overload10[0];
                length = _overload10[1];
                return this.editor.getText(index, length);
              }
            }, {
              key: 'hasFocus',
              value: function hasFocus() {
                return this.selection.hasFocus();
              }
            }, {
              key: 'insertEmbed',
              value: function insertEmbed(index, embed, value) {
                var _this7 = this;

                var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;
                return modify.call(this, function () {
                  return _this7.editor.insertEmbed(index, embed, value);
                }, source, index);
              }
            }, {
              key: 'insertText',
              value: function insertText(index, text, name, value, source) {
                var _this8 = this;

                var formats = void 0;

                var _overload11 = overload(index, 0, name, value, source);

                var _overload12 = _slicedToArray(_overload11, 4);

                index = _overload12[0];
                formats = _overload12[2];
                source = _overload12[3];
                return modify.call(this, function () {
                  return _this8.editor.insertText(index, text, formats);
                }, source, index, text.length);
              }
            }, {
              key: 'isEnabled',
              value: function isEnabled() {
                return !this.container.classList.contains('ql-disabled');
              }
            }, {
              key: 'off',
              value: function off() {
                return this.emitter.off.apply(this.emitter, arguments);
              }
            }, {
              key: 'on',
              value: function on() {
                return this.emitter.on.apply(this.emitter, arguments);
              }
            }, {
              key: 'once',
              value: function once() {
                return this.emitter.once.apply(this.emitter, arguments);
              }
            }, {
              key: 'pasteHTML',
              value: function pasteHTML(index, html, source) {
                this.clipboard.dangerouslyPasteHTML(index, html, source);
              }
            }, {
              key: 'removeFormat',
              value: function removeFormat(index, length, source) {
                var _this9 = this;

                var _overload13 = overload(index, length, source);

                var _overload14 = _slicedToArray(_overload13, 4);

                index = _overload14[0];
                length = _overload14[1];
                source = _overload14[3];
                return modify.call(this, function () {
                  return _this9.editor.removeFormat(index, length);
                }, source, index);
              }
            }, {
              key: 'scrollIntoView',
              value: function scrollIntoView() {
                this.selection.scrollIntoView(this.scrollingContainer);
              }
            }, {
              key: 'setContents',
              value: function setContents(delta) {
                var _this10 = this;

                var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                return modify.call(this, function () {
                  delta = new _quillDelta2.default(delta);

                  var length = _this10.getLength();

                  var deleted = _this10.editor.deleteText(0, length);

                  var applied = _this10.editor.applyDelta(delta);

                  var lastOp = applied.ops[applied.ops.length - 1];

                  if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
                    _this10.editor.deleteText(_this10.getLength() - 1, 1);

                    applied.delete(1);
                  }

                  var ret = deleted.compose(applied);
                  return ret;
                }, source);
              }
            }, {
              key: 'setSelection',
              value: function setSelection(index, length, source) {
                if (index == null) {
                  this.selection.setRange(null, length || Quill.sources.API);
                } else {
                  var _overload15 = overload(index, length, source);

                  var _overload16 = _slicedToArray(_overload15, 4);

                  index = _overload16[0];
                  length = _overload16[1];
                  source = _overload16[3];
                  this.selection.setRange(new _selection.Range(index, length), source);

                  if (source !== _emitter4.default.sources.SILENT) {
                    this.selection.scrollIntoView(this.scrollingContainer);
                  }
                }
              }
            }, {
              key: 'setText',
              value: function setText(text) {
                var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                var delta = new _quillDelta2.default().insert(text);
                return this.setContents(delta, source);
              }
            }, {
              key: 'update',
              value: function update() {
                var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                var change = this.scroll.update(source);
                this.selection.update(source);
                return change;
              }
            }, {
              key: 'updateContents',
              value: function updateContents(delta) {
                var _this11 = this;

                var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;
                return modify.call(this, function () {
                  delta = new _quillDelta2.default(delta);
                  return _this11.editor.applyDelta(delta, source);
                }, source, true);
              }
            }]);

            return Quill;
          }();

          Quill.DEFAULTS = {
            bounds: null,
            formats: null,
            modules: {},
            placeholder: '',
            readOnly: false,
            scrollingContainer: null,
            strict: true,
            theme: 'default'
          };
          Quill.events = _emitter4.default.events;
          Quill.sources = _emitter4.default.sources;
          Quill.version = "1.3.7";
          Quill.imports = {
            'delta': _quillDelta2.default,
            'parchment': _parchment2.default,
            'core/module': _module2.default,
            'core/theme': _theme2.default
          };

          function expandConfig(container, userConfig) {
            userConfig = (0, _extend2.default)(true, {
              container: container,
              modules: {
                clipboard: true,
                keyboard: true,
                history: true
              }
            }, userConfig);

            if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
              userConfig.theme = _theme2.default;
            } else {
              userConfig.theme = Quill.import('themes/' + userConfig.theme);

              if (userConfig.theme == null) {
                throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
              }
            }

            var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
            [themeConfig, userConfig].forEach(function (config) {
              config.modules = config.modules || {};
              Object.keys(config.modules).forEach(function (module) {
                if (config.modules[module] === true) {
                  config.modules[module] = {};
                }
              });
            });
            var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
            var moduleConfig = moduleNames.reduce(function (config, name) {
              var moduleClass = Quill.import('modules/' + name);

              if (moduleClass == null) {
                debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
              } else {
                config[name] = moduleClass.DEFAULTS || {};
              }

              return config;
            }, {});

            if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
              userConfig.modules.toolbar = {
                container: userConfig.modules.toolbar
              };
            }

            userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, {
              modules: moduleConfig
            }, themeConfig, userConfig);
            ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
              if (typeof userConfig[key] === 'string') {
                userConfig[key] = document.querySelector(userConfig[key]);
              }
            });
            userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
              if (userConfig.modules[name]) {
                config[name] = userConfig.modules[name];
              }

              return config;
            }, {});
            return userConfig;
          }

          function modify(modifier, source, index, shift) {
            if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
              return new _quillDelta2.default();
            }

            var range = index == null ? null : this.getSelection();
            var oldDelta = this.editor.delta;
            var change = modifier();

            if (range != null) {
              if (index === true) index = range.index;

              if (shift == null) {
                range = shiftRange(range, change, source);
              } else if (shift !== 0) {
                range = shiftRange(range, index, shift, source);
              }

              this.setSelection(range, _emitter4.default.sources.SILENT);
            }

            if (change.length() > 0) {
              var _emitter;

              var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];

              (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));

              if (source !== _emitter4.default.sources.SILENT) {
                var _emitter2;

                (_emitter2 = this.emitter).emit.apply(_emitter2, args);
              }
            }

            return change;
          }

          function overload(index, length, name, value, source) {
            var formats = {};

            if (typeof index.index === 'number' && typeof index.length === 'number') {
              if (typeof length !== 'number') {
                source = value, value = name, name = length, length = index.length, index = index.index;
              } else {
                length = index.length, index = index.index;
              }
            } else if (typeof length !== 'number') {
              source = value, value = name, name = length, length = 0;
            }

            if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
              formats = name;
              source = value;
            } else if (typeof name === 'string') {
              if (value != null) {
                formats[name] = value;
              } else {
                source = name;
              }
            }

            source = source || _emitter4.default.sources.API;
            return [index, length, formats, source];
          }

          function shiftRange(range, index, length, source) {
            if (range == null) return null;
            var start = void 0,
                end = void 0;

            if (index instanceof _quillDelta2.default) {
              var _map = [range.index, range.index + range.length].map(function (pos) {
                return index.transformPosition(pos, source !== _emitter4.default.sources.USER);
              });

              var _map2 = _slicedToArray(_map, 2);

              start = _map2[0];
              end = _map2[1];
            } else {
              var _map3 = [range.index, range.index + range.length].map(function (pos) {
                if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;

                if (length >= 0) {
                  return pos + length;
                } else {
                  return Math.max(index, pos + length);
                }
              });

              var _map4 = _slicedToArray(_map3, 2);

              start = _map4[0];
              end = _map4[1];
            }

            return new _selection.Range(start, end - start);
          }

          exports.expandConfig = expandConfig;
          exports.overload = overload;
          exports.default = Quill;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _text = __webpack_require__(7);

          var _text2 = _interopRequireDefault(_text);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Inline = function (_Parchment$Inline) {
            _inherits(Inline, _Parchment$Inline);

            function Inline() {
              _classCallCheck(this, Inline);

              return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
            }

            _createClass(Inline, [{
              key: 'formatAt',
              value: function formatAt(index, length, name, value) {
                if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
                  var blot = this.isolate(index, length);

                  if (value) {
                    blot.wrap(name, value);
                  }
                } else {
                  _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
                }
              }
            }, {
              key: 'optimize',
              value: function optimize(context) {
                _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);

                if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                  var parent = this.parent.isolate(this.offset(), this.length());
                  this.moveChildren(parent);
                  parent.wrap(this);
                }
              }
            }], [{
              key: 'compare',
              value: function compare(self, other) {
                var selfIndex = Inline.order.indexOf(self);
                var otherIndex = Inline.order.indexOf(other);

                if (selfIndex >= 0 || otherIndex >= 0) {
                  return selfIndex - otherIndex;
                } else if (self === other) {
                  return 0;
                } else if (self < other) {
                  return -1;
                } else {
                  return 1;
                }
              }
            }]);

            return Inline;
          }(_parchment2.default.Inline);

          Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
          Inline.order = ['cursor', 'inline', 'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code'];
          exports.default = Inline;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var TextBlot = function (_Parchment$Text) {
            _inherits(TextBlot, _Parchment$Text);

            function TextBlot() {
              _classCallCheck(this, TextBlot);

              return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
            }

            return TextBlot;
          }(_parchment2.default.Text);

          exports.default = TextBlot;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _eventemitter = __webpack_require__(54);

          var _eventemitter2 = _interopRequireDefault(_eventemitter);

          var _logger = __webpack_require__(10);

          var _logger2 = _interopRequireDefault(_logger);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var debug = (0, _logger2.default)('quill:events');
          var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];
          EVENTS.forEach(function (eventName) {
            document.addEventListener(eventName, function () {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
                if (node.__quill && node.__quill.emitter) {
                  var _node$__quill$emitter;

                  (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
                }
              });
            });
          });

          var Emitter = function (_EventEmitter) {
            _inherits(Emitter, _EventEmitter);

            function Emitter() {
              _classCallCheck(this, Emitter);

              var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));

              _this.listeners = {};

              _this.on('error', debug.error);

              return _this;
            }

            _createClass(Emitter, [{
              key: 'emit',
              value: function emit() {
                debug.log.apply(debug, arguments);

                _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
              }
            }, {
              key: 'handleDOM',
              value: function handleDOM(event) {
                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }

                (this.listeners[event.type] || []).forEach(function (_ref) {
                  var node = _ref.node,
                      handler = _ref.handler;

                  if (event.target === node || node.contains(event.target)) {
                    handler.apply(undefined, [event].concat(args));
                  }
                });
              }
            }, {
              key: 'listenDOM',
              value: function listenDOM(eventName, node, handler) {
                if (!this.listeners[eventName]) {
                  this.listeners[eventName] = [];
                }

                this.listeners[eventName].push({
                  node: node,
                  handler: handler
                });
              }
            }]);

            return Emitter;
          }(_eventemitter2.default);

          Emitter.events = {
            EDITOR_CHANGE: 'editor-change',
            SCROLL_BEFORE_UPDATE: 'scroll-before-update',
            SCROLL_OPTIMIZE: 'scroll-optimize',
            SCROLL_UPDATE: 'scroll-update',
            SELECTION_CHANGE: 'selection-change',
            TEXT_CHANGE: 'text-change'
          };
          Emitter.sources = {
            API: 'api',
            SILENT: 'silent',
            USER: 'user'
          };
          exports.default = Emitter;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var Module = function Module(quill) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            _classCallCheck(this, Module);

            this.quill = quill;
            this.options = options;
          };

          Module.DEFAULTS = {};
          exports.default = Module;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          var levels = ['error', 'warn', 'log', 'info'];
          var level = 'warn';

          function debug(method) {
            if (levels.indexOf(method) <= levels.indexOf(level)) {
              var _console;

              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }

              (_console = console)[method].apply(_console, args);
            }
          }

          function namespace(ns) {
            return levels.reduce(function (logger, method) {
              logger[method] = debug.bind(console, method, ns);
              return logger;
            }, {});
          }

          debug.level = namespace.level = function (newLevel) {
            level = newLevel;
          };

          exports.default = namespace;
        }, function (module, exports, __webpack_require__) {
          var pSlice = Array.prototype.slice;

          var objectKeys = __webpack_require__(52);

          var isArguments = __webpack_require__(53);

          var deepEqual = module.exports = function (actual, expected, opts) {
            if (!opts) opts = {};

            if (actual === expected) {
              return true;
            } else if (actual instanceof Date && expected instanceof Date) {
              return actual.getTime() === expected.getTime();
            } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
              return opts.strict ? actual === expected : actual == expected;
            } else {
              return objEquiv(actual, expected, opts);
            }
          };

          function isUndefinedOrNull(value) {
            return value === null || value === undefined;
          }

          function isBuffer(x) {
            if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;

            if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
              return false;
            }

            if (x.length > 0 && typeof x[0] !== 'number') return false;
            return true;
          }

          function objEquiv(a, b, opts) {
            var i, key;
            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
            if (a.prototype !== b.prototype) return false;

            if (isArguments(a)) {
              if (!isArguments(b)) {
                return false;
              }

              a = pSlice.call(a);
              b = pSlice.call(b);
              return deepEqual(a, b, opts);
            }

            if (isBuffer(a)) {
              if (!isBuffer(b)) {
                return false;
              }

              if (a.length !== b.length) return false;

              for (i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
              }

              return true;
            }

            try {
              var ka = objectKeys(a),
                  kb = objectKeys(b);
            } catch (e) {
              return false;
            }

            if (ka.length != kb.length) return false;
            ka.sort();
            kb.sort();

            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] != kb[i]) return false;
            }

            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!deepEqual(a[key], b[key], opts)) return false;
            }

            return typeof a === typeof b;
          }
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var Registry = __webpack_require__(1);

          var Attributor = function () {
            function Attributor(attrName, keyName, options) {
              if (options === void 0) {
                options = {};
              }

              this.attrName = attrName;
              this.keyName = keyName;
              var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;

              if (options.scope != null) {
                this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;
              } else {
                this.scope = Registry.Scope.ATTRIBUTE;
              }

              if (options.whitelist != null) this.whitelist = options.whitelist;
            }

            Attributor.keys = function (node) {
              return [].map.call(node.attributes, function (item) {
                return item.name;
              });
            };

            Attributor.prototype.add = function (node, value) {
              if (!this.canAdd(node, value)) return false;
              node.setAttribute(this.keyName, value);
              return true;
            };

            Attributor.prototype.canAdd = function (node, value) {
              var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
              if (match == null) return false;
              if (this.whitelist == null) return true;

              if (typeof value === 'string') {
                return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
              } else {
                return this.whitelist.indexOf(value) > -1;
              }
            };

            Attributor.prototype.remove = function (node) {
              node.removeAttribute(this.keyName);
            };

            Attributor.prototype.value = function (node) {
              var value = node.getAttribute(this.keyName);

              if (this.canAdd(node, value) && value) {
                return value;
              }

              return '';
            };

            return Attributor;
          }();

          exports.default = Attributor;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.Code = undefined;

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          var _text = __webpack_require__(7);

          var _text2 = _interopRequireDefault(_text);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Code = function (_Inline) {
            _inherits(Code, _Inline);

            function Code() {
              _classCallCheck(this, Code);

              return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
            }

            return Code;
          }(_inline2.default);

          Code.blotName = 'code';
          Code.tagName = 'CODE';

          var CodeBlock = function (_Block) {
            _inherits(CodeBlock, _Block);

            function CodeBlock() {
              _classCallCheck(this, CodeBlock);

              return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
            }

            _createClass(CodeBlock, [{
              key: 'delta',
              value: function delta() {
                var _this3 = this;

                var text = this.domNode.textContent;

                if (text.endsWith('\n')) {
                  text = text.slice(0, -1);
                }

                return text.split('\n').reduce(function (delta, frag) {
                  return delta.insert(frag).insert('\n', _this3.formats());
                }, new _quillDelta2.default());
              }
            }, {
              key: 'format',
              value: function format(name, value) {
                if (name === this.statics.blotName && value) return;

                var _descendant = this.descendant(_text2.default, this.length() - 1),
                    _descendant2 = _slicedToArray(_descendant, 1),
                    text = _descendant2[0];

                if (text != null) {
                  text.deleteAt(text.length() - 1, 1);
                }

                _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
              }
            }, {
              key: 'formatAt',
              value: function formatAt(index, length, name, value) {
                if (length === 0) return;

                if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                  return;
                }

                var nextNewline = this.newlineIndex(index);
                if (nextNewline < 0 || nextNewline >= index + length) return;
                var prevNewline = this.newlineIndex(index, true) + 1;
                var isolateLength = nextNewline - prevNewline + 1;
                var blot = this.isolate(prevNewline, isolateLength);
                var next = blot.next;
                blot.format(name, value);

                if (next instanceof CodeBlock) {
                  next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
                }
              }
            }, {
              key: 'insertAt',
              value: function insertAt(index, value, def) {
                if (def != null) return;

                var _descendant3 = this.descendant(_text2.default, index),
                    _descendant4 = _slicedToArray(_descendant3, 2),
                    text = _descendant4[0],
                    offset = _descendant4[1];

                text.insertAt(offset, value);
              }
            }, {
              key: 'length',
              value: function length() {
                var length = this.domNode.textContent.length;

                if (!this.domNode.textContent.endsWith('\n')) {
                  return length + 1;
                }

                return length;
              }
            }, {
              key: 'newlineIndex',
              value: function newlineIndex(searchIndex) {
                var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                if (!reverse) {
                  var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
                  return offset > -1 ? searchIndex + offset : -1;
                } else {
                  return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
                }
              }
            }, {
              key: 'optimize',
              value: function optimize(context) {
                if (!this.domNode.textContent.endsWith('\n')) {
                  this.appendChild(_parchment2.default.create('text', '\n'));
                }

                _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);

                var next = this.next;

                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                  next.optimize(context);
                  next.moveChildren(this);
                  next.remove();
                }
              }
            }, {
              key: 'replace',
              value: function replace(target) {
                _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);

                [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
                  var blot = _parchment2.default.find(node);

                  if (blot == null) {
                    node.parentNode.removeChild(node);
                  } else if (blot instanceof _parchment2.default.Embed) {
                    blot.remove();
                  } else {
                    blot.unwrap();
                  }
                });
              }
            }], [{
              key: 'create',
              value: function create(value) {
                var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);

                domNode.setAttribute('spellcheck', false);
                return domNode;
              }
            }, {
              key: 'formats',
              value: function formats() {
                return true;
              }
            }]);

            return CodeBlock;
          }(_block2.default);

          CodeBlock.blotName = 'code-block';
          CodeBlock.tagName = 'PRE';
          CodeBlock.TAB = '  ';
          exports.Code = Code;
          exports.default = CodeBlock;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _op = __webpack_require__(20);

          var _op2 = _interopRequireDefault(_op);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _code = __webpack_require__(13);

          var _code2 = _interopRequireDefault(_code);

          var _cursor = __webpack_require__(24);

          var _cursor2 = _interopRequireDefault(_cursor);

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          var _break = __webpack_require__(16);

          var _break2 = _interopRequireDefault(_break);

          var _clone = __webpack_require__(21);

          var _clone2 = _interopRequireDefault(_clone);

          var _deepEqual = __webpack_require__(11);

          var _deepEqual2 = _interopRequireDefault(_deepEqual);

          var _extend = __webpack_require__(3);

          var _extend2 = _interopRequireDefault(_extend);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }

            return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var ASCII = /^[ -~]*$/;

          var Editor = function () {
            function Editor(scroll) {
              _classCallCheck(this, Editor);

              this.scroll = scroll;
              this.delta = this.getDelta();
            }

            _createClass(Editor, [{
              key: 'applyDelta',
              value: function applyDelta(delta) {
                var _this = this;

                var consumeNextNewline = false;
                this.scroll.update();
                var scrollLength = this.scroll.length();
                this.scroll.batchStart();
                delta = normalizeDelta(delta);
                delta.reduce(function (index, op) {
                  var length = op.retain || op.delete || op.insert.length || 1;
                  var attributes = op.attributes || {};

                  if (op.insert != null) {
                    if (typeof op.insert === 'string') {
                      var text = op.insert;

                      if (text.endsWith('\n') && consumeNextNewline) {
                        consumeNextNewline = false;
                        text = text.slice(0, -1);
                      }

                      if (index >= scrollLength && !text.endsWith('\n')) {
                        consumeNextNewline = true;
                      }

                      _this.scroll.insertAt(index, text);

                      var _scroll$line = _this.scroll.line(index),
                          _scroll$line2 = _slicedToArray(_scroll$line, 2),
                          line = _scroll$line2[0],
                          offset = _scroll$line2[1];

                      var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));

                      if (line instanceof _block2.default) {
                        var _line$descendant = line.descendant(_parchment2.default.Leaf, offset),
                            _line$descendant2 = _slicedToArray(_line$descendant, 1),
                            leaf = _line$descendant2[0];

                        formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                      }

                      attributes = _op2.default.attributes.diff(formats, attributes) || {};
                    } else if (_typeof(op.insert) === 'object') {
                      var key = Object.keys(op.insert)[0];
                      if (key == null) return index;

                      _this.scroll.insertAt(index, key, op.insert[key]);
                    }

                    scrollLength += length;
                  }

                  Object.keys(attributes).forEach(function (name) {
                    _this.scroll.formatAt(index, length, name, attributes[name]);
                  });
                  return index + length;
                }, 0);
                delta.reduce(function (index, op) {
                  if (typeof op.delete === 'number') {
                    _this.scroll.deleteAt(index, op.delete);

                    return index;
                  }

                  return index + (op.retain || op.insert.length || 1);
                }, 0);
                this.scroll.batchEnd();
                return this.update(delta);
              }
            }, {
              key: 'deleteText',
              value: function deleteText(index, length) {
                this.scroll.deleteAt(index, length);
                return this.update(new _quillDelta2.default().retain(index).delete(length));
              }
            }, {
              key: 'formatLine',
              value: function formatLine(index, length) {
                var _this2 = this;

                var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                this.scroll.update();
                Object.keys(formats).forEach(function (format) {
                  if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;

                  var lines = _this2.scroll.lines(index, Math.max(length, 1));

                  var lengthRemaining = length;
                  lines.forEach(function (line) {
                    var lineLength = line.length();

                    if (!(line instanceof _code2.default)) {
                      line.format(format, formats[format]);
                    } else {
                      var codeIndex = index - line.offset(_this2.scroll);
                      var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                      line.formatAt(codeIndex, codeLength, format, formats[format]);
                    }

                    lengthRemaining -= lineLength;
                  });
                });
                this.scroll.optimize();
                return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
              }
            }, {
              key: 'formatText',
              value: function formatText(index, length) {
                var _this3 = this;

                var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                Object.keys(formats).forEach(function (format) {
                  _this3.scroll.formatAt(index, length, format, formats[format]);
                });
                return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
              }
            }, {
              key: 'getContents',
              value: function getContents(index, length) {
                return this.delta.slice(index, index + length);
              }
            }, {
              key: 'getDelta',
              value: function getDelta() {
                return this.scroll.lines().reduce(function (delta, line) {
                  return delta.concat(line.delta());
                }, new _quillDelta2.default());
              }
            }, {
              key: 'getFormat',
              value: function getFormat(index) {
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var lines = [],
                    leaves = [];

                if (length === 0) {
                  this.scroll.path(index).forEach(function (path) {
                    var _path = _slicedToArray(path, 1),
                        blot = _path[0];

                    if (blot instanceof _block2.default) {
                      lines.push(blot);
                    } else if (blot instanceof _parchment2.default.Leaf) {
                      leaves.push(blot);
                    }
                  });
                } else {
                  lines = this.scroll.lines(index, length);
                  leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);
                }

                var formatsArr = [lines, leaves].map(function (blots) {
                  if (blots.length === 0) return {};
                  var formats = (0, _block.bubbleFormats)(blots.shift());

                  while (Object.keys(formats).length > 0) {
                    var blot = blots.shift();
                    if (blot == null) return formats;
                    formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                  }

                  return formats;
                });
                return _extend2.default.apply(_extend2.default, formatsArr);
              }
            }, {
              key: 'getText',
              value: function getText(index, length) {
                return this.getContents(index, length).filter(function (op) {
                  return typeof op.insert === 'string';
                }).map(function (op) {
                  return op.insert;
                }).join('');
              }
            }, {
              key: 'insertEmbed',
              value: function insertEmbed(index, embed, value) {
                this.scroll.insertAt(index, embed, value);
                return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));
              }
            }, {
              key: 'insertText',
              value: function insertText(index, text) {
                var _this4 = this;

                var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                this.scroll.insertAt(index, text);
                Object.keys(formats).forEach(function (format) {
                  _this4.scroll.formatAt(index, text.length, format, formats[format]);
                });
                return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));
              }
            }, {
              key: 'isBlank',
              value: function isBlank() {
                if (this.scroll.children.length == 0) return true;
                if (this.scroll.children.length > 1) return false;
                var block = this.scroll.children.head;
                if (block.statics.blotName !== _block2.default.blotName) return false;
                if (block.children.length > 1) return false;
                return block.children.head instanceof _break2.default;
              }
            }, {
              key: 'removeFormat',
              value: function removeFormat(index, length) {
                var text = this.getText(index, length);

                var _scroll$line3 = this.scroll.line(index + length),
                    _scroll$line4 = _slicedToArray(_scroll$line3, 2),
                    line = _scroll$line4[0],
                    offset = _scroll$line4[1];

                var suffixLength = 0,
                    suffix = new _quillDelta2.default();

                if (line != null) {
                  if (!(line instanceof _code2.default)) {
                    suffixLength = line.length() - offset;
                  } else {
                    suffixLength = line.newlineIndex(offset) - offset + 1;
                  }

                  suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
                }

                var contents = this.getContents(index, length + suffixLength);
                var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
                var delta = new _quillDelta2.default().retain(index).concat(diff);
                return this.applyDelta(delta);
              }
            }, {
              key: 'update',
              value: function update(change) {
                var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
                var oldDelta = this.delta;

                if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                  var textBlot = _parchment2.default.find(mutations[0].target);

                  var formats = (0, _block.bubbleFormats)(textBlot);
                  var index = textBlot.offset(this.scroll);
                  var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');
                  var oldText = new _quillDelta2.default().insert(oldValue);
                  var newText = new _quillDelta2.default().insert(textBlot.value());
                  var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));
                  change = diffDelta.reduce(function (delta, op) {
                    if (op.insert) {
                      return delta.insert(op.insert, formats);
                    } else {
                      return delta.push(op);
                    }
                  }, new _quillDelta2.default());
                  this.delta = oldDelta.compose(change);
                } else {
                  this.delta = this.getDelta();

                  if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                    change = oldDelta.diff(this.delta, cursorIndex);
                  }
                }

                return change;
              }
            }]);

            return Editor;
          }();

          function combineFormats(formats, combined) {
            return Object.keys(combined).reduce(function (merged, name) {
              if (formats[name] == null) return merged;

              if (combined[name] === formats[name]) {
                merged[name] = combined[name];
              } else if (Array.isArray(combined[name])) {
                if (combined[name].indexOf(formats[name]) < 0) {
                  merged[name] = combined[name].concat([formats[name]]);
                }
              } else {
                merged[name] = [combined[name], formats[name]];
              }

              return merged;
            }, {});
          }

          function normalizeDelta(delta) {
            return delta.reduce(function (delta, op) {
              if (op.insert === 1) {
                var attributes = (0, _clone2.default)(op.attributes);
                delete attributes['image'];
                return delta.insert({
                  image: op.attributes.image
                }, attributes);
              }

              if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
                op = (0, _clone2.default)(op);

                if (op.attributes.list) {
                  op.attributes.list = 'ordered';
                } else {
                  op.attributes.list = 'bullet';
                  delete op.attributes.bullet;
                }
              }

              if (typeof op.insert === 'string') {
                var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                return delta.insert(text, op.attributes);
              }

              return delta.push(op);
            }, new _quillDelta2.default());
          }

          exports.default = Editor;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.Range = undefined;

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _clone = __webpack_require__(21);

          var _clone2 = _interopRequireDefault(_clone);

          var _deepEqual = __webpack_require__(11);

          var _deepEqual2 = _interopRequireDefault(_deepEqual);

          var _emitter3 = __webpack_require__(8);

          var _emitter4 = _interopRequireDefault(_emitter3);

          var _logger = __webpack_require__(10);

          var _logger2 = _interopRequireDefault(_logger);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
              for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
              }

              return arr2;
            } else {
              return Array.from(arr);
            }
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var debug = (0, _logger2.default)('quill:selection');

          var Range = function Range(index) {
            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            _classCallCheck(this, Range);

            this.index = index;
            this.length = length;
          };

          var Selection = function () {
            function Selection(scroll, emitter) {
              var _this = this;

              _classCallCheck(this, Selection);

              this.emitter = emitter;
              this.scroll = scroll;
              this.composing = false;
              this.mouseDown = false;
              this.root = this.scroll.domNode;
              this.cursor = _parchment2.default.create('cursor', this);
              this.lastRange = this.savedRange = new Range(0, 0);
              this.handleComposition();
              this.handleDragging();
              this.emitter.listenDOM('selectionchange', document, function () {
                if (!_this.mouseDown) {
                  setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
                }
              });
              this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {
                if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
                  _this.update(_emitter4.default.sources.SILENT);
                }
              });
              this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {
                if (!_this.hasFocus()) return;

                var native = _this.getNativeRange();

                if (native == null) return;
                if (native.start.node === _this.cursor.textNode) return;

                _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {
                  try {
                    _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                  } catch (ignored) {}
                });
              });
              this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {
                if (context.range) {
                  var _context$range = context.range,
                      startNode = _context$range.startNode,
                      startOffset = _context$range.startOffset,
                      endNode = _context$range.endNode,
                      endOffset = _context$range.endOffset;

                  _this.setNativeRange(startNode, startOffset, endNode, endOffset);
                }
              });
              this.update(_emitter4.default.sources.SILENT);
            }

            _createClass(Selection, [{
              key: 'handleComposition',
              value: function handleComposition() {
                var _this2 = this;

                this.root.addEventListener('compositionstart', function () {
                  _this2.composing = true;
                });
                this.root.addEventListener('compositionend', function () {
                  _this2.composing = false;

                  if (_this2.cursor.parent) {
                    var range = _this2.cursor.restore();

                    if (!range) return;
                    setTimeout(function () {
                      _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
                    }, 1);
                  }
                });
              }
            }, {
              key: 'handleDragging',
              value: function handleDragging() {
                var _this3 = this;

                this.emitter.listenDOM('mousedown', document.body, function () {
                  _this3.mouseDown = true;
                });
                this.emitter.listenDOM('mouseup', document.body, function () {
                  _this3.mouseDown = false;

                  _this3.update(_emitter4.default.sources.USER);
                });
              }
            }, {
              key: 'focus',
              value: function focus() {
                if (this.hasFocus()) return;
                this.root.focus();
                this.setRange(this.savedRange);
              }
            }, {
              key: 'format',
              value: function format(_format, value) {
                if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
                this.scroll.update();
                var nativeRange = this.getNativeRange();
                if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;

                if (nativeRange.start.node !== this.cursor.textNode) {
                  var blot = _parchment2.default.find(nativeRange.start.node, false);

                  if (blot == null) return;

                  if (blot instanceof _parchment2.default.Leaf) {
                    var after = blot.split(nativeRange.start.offset);
                    blot.parent.insertBefore(this.cursor, after);
                  } else {
                    blot.insertBefore(this.cursor, nativeRange.start.node);
                  }

                  this.cursor.attach();
                }

                this.cursor.format(_format, value);
                this.scroll.optimize();
                this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                this.update();
              }
            }, {
              key: 'getBounds',
              value: function getBounds(index) {
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var scrollLength = this.scroll.length();
                index = Math.min(index, scrollLength - 1);
                length = Math.min(index + length, scrollLength - 1) - index;

                var node = void 0,
                    _scroll$leaf = this.scroll.leaf(index),
                    _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),
                    leaf = _scroll$leaf2[0],
                    offset = _scroll$leaf2[1];

                if (leaf == null) return null;

                var _leaf$position = leaf.position(offset, true);

                var _leaf$position2 = _slicedToArray(_leaf$position, 2);

                node = _leaf$position2[0];
                offset = _leaf$position2[1];
                var range = document.createRange();

                if (length > 0) {
                  range.setStart(node, offset);

                  var _scroll$leaf3 = this.scroll.leaf(index + length);

                  var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);

                  leaf = _scroll$leaf4[0];
                  offset = _scroll$leaf4[1];
                  if (leaf == null) return null;

                  var _leaf$position3 = leaf.position(offset, true);

                  var _leaf$position4 = _slicedToArray(_leaf$position3, 2);

                  node = _leaf$position4[0];
                  offset = _leaf$position4[1];
                  range.setEnd(node, offset);
                  return range.getBoundingClientRect();
                } else {
                  var side = 'left';
                  var rect = void 0;

                  if (node instanceof Text) {
                    if (offset < node.data.length) {
                      range.setStart(node, offset);
                      range.setEnd(node, offset + 1);
                    } else {
                      range.setStart(node, offset - 1);
                      range.setEnd(node, offset);
                      side = 'right';
                    }

                    rect = range.getBoundingClientRect();
                  } else {
                    rect = leaf.domNode.getBoundingClientRect();
                    if (offset > 0) side = 'right';
                  }

                  return {
                    bottom: rect.top + rect.height,
                    height: rect.height,
                    left: rect[side],
                    right: rect[side],
                    top: rect.top,
                    width: 0
                  };
                }
              }
            }, {
              key: 'getNativeRange',
              value: function getNativeRange() {
                var selection = document.getSelection();
                if (selection == null || selection.rangeCount <= 0) return null;
                var nativeRange = selection.getRangeAt(0);
                if (nativeRange == null) return null;
                var range = this.normalizeNative(nativeRange);
                debug.info('getNativeRange', range);
                return range;
              }
            }, {
              key: 'getRange',
              value: function getRange() {
                var normalized = this.getNativeRange();
                if (normalized == null) return [null, null];
                var range = this.normalizedToRange(normalized);
                return [range, normalized];
              }
            }, {
              key: 'hasFocus',
              value: function hasFocus() {
                return document.activeElement === this.root;
              }
            }, {
              key: 'normalizedToRange',
              value: function normalizedToRange(range) {
                var _this4 = this;

                var positions = [[range.start.node, range.start.offset]];

                if (!range.native.collapsed) {
                  positions.push([range.end.node, range.end.offset]);
                }

                var indexes = positions.map(function (position) {
                  var _position = _slicedToArray(position, 2),
                      node = _position[0],
                      offset = _position[1];

                  var blot = _parchment2.default.find(node, true);

                  var index = blot.offset(_this4.scroll);

                  if (offset === 0) {
                    return index;
                  } else if (blot instanceof _parchment2.default.Container) {
                    return index + blot.length();
                  } else {
                    return index + blot.index(node, offset);
                  }
                });
                var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
                var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
                return new Range(start, end - start);
              }
            }, {
              key: 'normalizeNative',
              value: function normalizeNative(nativeRange) {
                if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
                  return null;
                }

                var range = {
                  start: {
                    node: nativeRange.startContainer,
                    offset: nativeRange.startOffset
                  },
                  end: {
                    node: nativeRange.endContainer,
                    offset: nativeRange.endOffset
                  },
                  native: nativeRange
                };
                [range.start, range.end].forEach(function (position) {
                  var node = position.node,
                      offset = position.offset;

                  while (!(node instanceof Text) && node.childNodes.length > 0) {
                    if (node.childNodes.length > offset) {
                      node = node.childNodes[offset];
                      offset = 0;
                    } else if (node.childNodes.length === offset) {
                      node = node.lastChild;
                      offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                    } else {
                      break;
                    }
                  }

                  position.node = node, position.offset = offset;
                });
                return range;
              }
            }, {
              key: 'rangeToNative',
              value: function rangeToNative(range) {
                var _this5 = this;

                var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
                var args = [];
                var scrollLength = this.scroll.length();
                indexes.forEach(function (index, i) {
                  index = Math.min(scrollLength - 1, index);

                  var node = void 0,
                      _scroll$leaf5 = _this5.scroll.leaf(index),
                      _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),
                      leaf = _scroll$leaf6[0],
                      offset = _scroll$leaf6[1];

                  var _leaf$position5 = leaf.position(offset, i !== 0);

                  var _leaf$position6 = _slicedToArray(_leaf$position5, 2);

                  node = _leaf$position6[0];
                  offset = _leaf$position6[1];
                  args.push(node, offset);
                });

                if (args.length < 2) {
                  args = args.concat(args);
                }

                return args;
              }
            }, {
              key: 'scrollIntoView',
              value: function scrollIntoView(scrollingContainer) {
                var range = this.lastRange;
                if (range == null) return;
                var bounds = this.getBounds(range.index, range.length);
                if (bounds == null) return;
                var limit = this.scroll.length() - 1;

                var _scroll$line = this.scroll.line(Math.min(range.index, limit)),
                    _scroll$line2 = _slicedToArray(_scroll$line, 1),
                    first = _scroll$line2[0];

                var last = first;

                if (range.length > 0) {
                  var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));

                  var _scroll$line4 = _slicedToArray(_scroll$line3, 1);

                  last = _scroll$line4[0];
                }

                if (first == null || last == null) return;
                var scrollBounds = scrollingContainer.getBoundingClientRect();

                if (bounds.top < scrollBounds.top) {
                  scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
                } else if (bounds.bottom > scrollBounds.bottom) {
                  scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
                }
              }
            }, {
              key: 'setNativeRange',
              value: function setNativeRange(startNode, startOffset) {
                var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
                var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
                var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);

                if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                  return;
                }

                var selection = document.getSelection();
                if (selection == null) return;

                if (startNode != null) {
                  if (!this.hasFocus()) this.root.focus();
                  var native = (this.getNativeRange() || {}).native;

                  if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                    if (startNode.tagName == "BR") {
                      startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                      startNode = startNode.parentNode;
                    }

                    if (endNode.tagName == "BR") {
                      endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                      endNode = endNode.parentNode;
                    }

                    var range = document.createRange();
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                    selection.removeAllRanges();
                    selection.addRange(range);
                  }
                } else {
                  selection.removeAllRanges();
                  this.root.blur();
                  document.body.focus();
                }
              }
            }, {
              key: 'setRange',
              value: function setRange(range) {
                var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;

                if (typeof force === 'string') {
                  source = force;
                  force = false;
                }

                debug.info('setRange', range);

                if (range != null) {
                  var args = this.rangeToNative(range);
                  this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
                } else {
                  this.setNativeRange(null);
                }

                this.update(source);
              }
            }, {
              key: 'update',
              value: function update() {
                var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;
                var oldRange = this.lastRange;

                var _getRange = this.getRange(),
                    _getRange2 = _slicedToArray(_getRange, 2),
                    lastRange = _getRange2[0],
                    nativeRange = _getRange2[1];

                this.lastRange = lastRange;

                if (this.lastRange != null) {
                  this.savedRange = this.lastRange;
                }

                if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                  var _emitter;

                  if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                    this.cursor.restore();
                  }

                  var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];

                  (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));

                  if (source !== _emitter4.default.sources.SILENT) {
                    var _emitter2;

                    (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                  }
                }
              }
            }]);

            return Selection;
          }();

          function contains(parent, descendant) {
            try {
              descendant.parentNode;
            } catch (e) {
              return false;
            }

            if (descendant instanceof Text) {
              descendant = descendant.parentNode;
            }

            return parent.contains(descendant);
          }

          exports.Range = Range;
          exports.default = Selection;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Break = function (_Parchment$Embed) {
            _inherits(Break, _Parchment$Embed);

            function Break() {
              _classCallCheck(this, Break);

              return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
            }

            _createClass(Break, [{
              key: 'insertInto',
              value: function insertInto(parent, ref) {
                if (parent.children.length === 0) {
                  _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
                } else {
                  this.remove();
                }
              }
            }, {
              key: 'length',
              value: function length() {
                return 0;
              }
            }, {
              key: 'value',
              value: function value() {
                return '';
              }
            }], [{
              key: 'value',
              value: function value() {
                return undefined;
              }
            }]);

            return Break;
          }(_parchment2.default.Embed);

          Break.blotName = 'break';
          Break.tagName = 'BR';
          exports.default = Break;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var linked_list_1 = __webpack_require__(44);

          var shadow_1 = __webpack_require__(30);

          var Registry = __webpack_require__(1);

          var ContainerBlot = function (_super) {
            __extends(ContainerBlot, _super);

            function ContainerBlot(domNode) {
              var _this = _super.call(this, domNode) || this;

              _this.build();

              return _this;
            }

            ContainerBlot.prototype.appendChild = function (other) {
              this.insertBefore(other);
            };

            ContainerBlot.prototype.attach = function () {
              _super.prototype.attach.call(this);

              this.children.forEach(function (child) {
                child.attach();
              });
            };

            ContainerBlot.prototype.build = function () {
              var _this = this;

              this.children = new linked_list_1.default();
              [].slice.call(this.domNode.childNodes).reverse().forEach(function (node) {
                try {
                  var child = makeBlot(node);

                  _this.insertBefore(child, _this.children.head || undefined);
                } catch (err) {
                  if (err instanceof Registry.ParchmentError) return;else throw err;
                }
              });
            };

            ContainerBlot.prototype.deleteAt = function (index, length) {
              if (index === 0 && length === this.length()) {
                return this.remove();
              }

              this.children.forEachAt(index, length, function (child, offset, length) {
                child.deleteAt(offset, length);
              });
            };

            ContainerBlot.prototype.descendant = function (criteria, index) {
              var _a = this.children.find(index),
                  child = _a[0],
                  offset = _a[1];

              if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                return [child, offset];
              } else if (child instanceof ContainerBlot) {
                return child.descendant(criteria, offset);
              } else {
                return [null, -1];
              }
            };

            ContainerBlot.prototype.descendants = function (criteria, index, length) {
              if (index === void 0) {
                index = 0;
              }

              if (length === void 0) {
                length = Number.MAX_VALUE;
              }

              var descendants = [];
              var lengthLeft = length;
              this.children.forEachAt(index, length, function (child, index, length) {
                if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                  descendants.push(child);
                }

                if (child instanceof ContainerBlot) {
                  descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
                }

                lengthLeft -= length;
              });
              return descendants;
            };

            ContainerBlot.prototype.detach = function () {
              this.children.forEach(function (child) {
                child.detach();
              });

              _super.prototype.detach.call(this);
            };

            ContainerBlot.prototype.formatAt = function (index, length, name, value) {
              this.children.forEachAt(index, length, function (child, offset, length) {
                child.formatAt(offset, length, name, value);
              });
            };

            ContainerBlot.prototype.insertAt = function (index, value, def) {
              var _a = this.children.find(index),
                  child = _a[0],
                  offset = _a[1];

              if (child) {
                child.insertAt(offset, value, def);
              } else {
                var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                this.appendChild(blot);
              }
            };

            ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
              if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (child) {
                return childBlot instanceof child;
              })) {
                throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
              }

              childBlot.insertInto(this, refBlot);
            };

            ContainerBlot.prototype.length = function () {
              return this.children.reduce(function (memo, child) {
                return memo + child.length();
              }, 0);
            };

            ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
              this.children.forEach(function (child) {
                targetParent.insertBefore(child, refNode);
              });
            };

            ContainerBlot.prototype.optimize = function (context) {
              _super.prototype.optimize.call(this, context);

              if (this.children.length === 0) {
                if (this.statics.defaultChild != null) {
                  var child = Registry.create(this.statics.defaultChild);
                  this.appendChild(child);
                  child.optimize(context);
                } else {
                  this.remove();
                }
              }
            };

            ContainerBlot.prototype.path = function (index, inclusive) {
              if (inclusive === void 0) {
                inclusive = false;
              }

              var _a = this.children.find(index, inclusive),
                  child = _a[0],
                  offset = _a[1];

              var position = [[this, index]];

              if (child instanceof ContainerBlot) {
                return position.concat(child.path(offset, inclusive));
              } else if (child != null) {
                position.push([child, offset]);
              }

              return position;
            };

            ContainerBlot.prototype.removeChild = function (child) {
              this.children.remove(child);
            };

            ContainerBlot.prototype.replace = function (target) {
              if (target instanceof ContainerBlot) {
                target.moveChildren(this);
              }

              _super.prototype.replace.call(this, target);
            };

            ContainerBlot.prototype.split = function (index, force) {
              if (force === void 0) {
                force = false;
              }

              if (!force) {
                if (index === 0) return this;
                if (index === this.length()) return this.next;
              }

              var after = this.clone();
              this.parent.insertBefore(after, this.next);
              this.children.forEachAt(index, this.length(), function (child, offset, length) {
                child = child.split(offset, force);
                after.appendChild(child);
              });
              return after;
            };

            ContainerBlot.prototype.unwrap = function () {
              this.moveChildren(this.parent, this.next);
              this.remove();
            };

            ContainerBlot.prototype.update = function (mutations, context) {
              var _this = this;

              var addedNodes = [];
              var removedNodes = [];
              mutations.forEach(function (mutation) {
                if (mutation.target === _this.domNode && mutation.type === 'childList') {
                  addedNodes.push.apply(addedNodes, mutation.addedNodes);
                  removedNodes.push.apply(removedNodes, mutation.removedNodes);
                }
              });
              removedNodes.forEach(function (node) {
                if (node.parentNode != null && node.tagName !== 'IFRAME' && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                  return;
                }

                var blot = Registry.find(node);
                if (blot == null) return;

                if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                  blot.detach();
                }
              });
              addedNodes.filter(function (node) {
                return node.parentNode == _this.domNode;
              }).sort(function (a, b) {
                if (a === b) return 0;

                if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                  return 1;
                }

                return -1;
              }).forEach(function (node) {
                var refBlot = null;

                if (node.nextSibling != null) {
                  refBlot = Registry.find(node.nextSibling);
                }

                var blot = makeBlot(node);

                if (blot.next != refBlot || blot.next == null) {
                  if (blot.parent != null) {
                    blot.parent.removeChild(_this);
                  }

                  _this.insertBefore(blot, refBlot || undefined);
                }
              });
            };

            return ContainerBlot;
          }(shadow_1.default);

          function makeBlot(node) {
            var blot = Registry.find(node);

            if (blot == null) {
              try {
                blot = Registry.create(node);
              } catch (e) {
                blot = Registry.create(Registry.Scope.INLINE);
                [].slice.call(node.childNodes).forEach(function (child) {
                  blot.domNode.appendChild(child);
                });

                if (node.parentNode) {
                  node.parentNode.replaceChild(blot.domNode, node);
                }

                blot.attach();
              }
            }

            return blot;
          }

          exports.default = ContainerBlot;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var attributor_1 = __webpack_require__(12);

          var store_1 = __webpack_require__(31);

          var container_1 = __webpack_require__(17);

          var Registry = __webpack_require__(1);

          var FormatBlot = function (_super) {
            __extends(FormatBlot, _super);

            function FormatBlot(domNode) {
              var _this = _super.call(this, domNode) || this;

              _this.attributes = new store_1.default(_this.domNode);
              return _this;
            }

            FormatBlot.formats = function (domNode) {
              if (typeof this.tagName === 'string') {
                return true;
              } else if (Array.isArray(this.tagName)) {
                return domNode.tagName.toLowerCase();
              }

              return undefined;
            };

            FormatBlot.prototype.format = function (name, value) {
              var format = Registry.query(name);

              if (format instanceof attributor_1.default) {
                this.attributes.attribute(format, value);
              } else if (value) {
                if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                  this.replaceWith(name, value);
                }
              }
            };

            FormatBlot.prototype.formats = function () {
              var formats = this.attributes.values();
              var format = this.statics.formats(this.domNode);

              if (format != null) {
                formats[this.statics.blotName] = format;
              }

              return formats;
            };

            FormatBlot.prototype.replaceWith = function (name, value) {
              var replacement = _super.prototype.replaceWith.call(this, name, value);

              this.attributes.copy(replacement);
              return replacement;
            };

            FormatBlot.prototype.update = function (mutations, context) {
              var _this = this;

              _super.prototype.update.call(this, mutations, context);

              if (mutations.some(function (mutation) {
                return mutation.target === _this.domNode && mutation.type === 'attributes';
              })) {
                this.attributes.build();
              }
            };

            FormatBlot.prototype.wrap = function (name, value) {
              var wrapper = _super.prototype.wrap.call(this, name, value);

              if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
                this.attributes.move(wrapper);
              }

              return wrapper;
            };

            return FormatBlot;
          }(container_1.default);

          exports.default = FormatBlot;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var shadow_1 = __webpack_require__(30);

          var Registry = __webpack_require__(1);

          var LeafBlot = function (_super) {
            __extends(LeafBlot, _super);

            function LeafBlot() {
              return _super !== null && _super.apply(this, arguments) || this;
            }

            LeafBlot.value = function (domNode) {
              return true;
            };

            LeafBlot.prototype.index = function (node, offset) {
              if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                return Math.min(offset, 1);
              }

              return -1;
            };

            LeafBlot.prototype.position = function (index, inclusive) {
              var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
              if (index > 0) offset += 1;
              return [this.parent.domNode, offset];
            };

            LeafBlot.prototype.value = function () {
              var _a;

              return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
            };

            LeafBlot.scope = Registry.Scope.INLINE_BLOT;
            return LeafBlot;
          }(shadow_1.default);

          exports.default = LeafBlot;
        }, function (module, exports, __webpack_require__) {
          var equal = __webpack_require__(11);

          var extend = __webpack_require__(3);

          var lib = {
            attributes: {
              compose: function (a, b, keepNull) {
                if (typeof a !== 'object') a = {};
                if (typeof b !== 'object') b = {};
                var attributes = extend(true, {}, b);

                if (!keepNull) {
                  attributes = Object.keys(attributes).reduce(function (copy, key) {
                    if (attributes[key] != null) {
                      copy[key] = attributes[key];
                    }

                    return copy;
                  }, {});
                }

                for (var key in a) {
                  if (a[key] !== undefined && b[key] === undefined) {
                    attributes[key] = a[key];
                  }
                }

                return Object.keys(attributes).length > 0 ? attributes : undefined;
              },
              diff: function (a, b) {
                if (typeof a !== 'object') a = {};
                if (typeof b !== 'object') b = {};
                var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
                  if (!equal(a[key], b[key])) {
                    attributes[key] = b[key] === undefined ? null : b[key];
                  }

                  return attributes;
                }, {});
                return Object.keys(attributes).length > 0 ? attributes : undefined;
              },
              transform: function (a, b, priority) {
                if (typeof a !== 'object') return b;
                if (typeof b !== 'object') return undefined;
                if (!priority) return b;
                var attributes = Object.keys(b).reduce(function (attributes, key) {
                  if (a[key] === undefined) attributes[key] = b[key];
                  return attributes;
                }, {});
                return Object.keys(attributes).length > 0 ? attributes : undefined;
              }
            },
            iterator: function (ops) {
              return new Iterator(ops);
            },
            length: function (op) {
              if (typeof op['delete'] === 'number') {
                return op['delete'];
              } else if (typeof op.retain === 'number') {
                return op.retain;
              } else {
                return typeof op.insert === 'string' ? op.insert.length : 1;
              }
            }
          };

          function Iterator(ops) {
            this.ops = ops;
            this.index = 0;
            this.offset = 0;
          }

          Iterator.prototype.hasNext = function () {
            return this.peekLength() < Infinity;
          };

          Iterator.prototype.next = function (length) {
            if (!length) length = Infinity;
            var nextOp = this.ops[this.index];

            if (nextOp) {
              var offset = this.offset;
              var opLength = lib.length(nextOp);

              if (length >= opLength - offset) {
                length = opLength - offset;
                this.index += 1;
                this.offset = 0;
              } else {
                this.offset += length;
              }

              if (typeof nextOp['delete'] === 'number') {
                return {
                  'delete': length
                };
              } else {
                var retOp = {};

                if (nextOp.attributes) {
                  retOp.attributes = nextOp.attributes;
                }

                if (typeof nextOp.retain === 'number') {
                  retOp.retain = length;
                } else if (typeof nextOp.insert === 'string') {
                  retOp.insert = nextOp.insert.substr(offset, length);
                } else {
                  retOp.insert = nextOp.insert;
                }

                return retOp;
              }
            } else {
              return {
                retain: Infinity
              };
            }
          };

          Iterator.prototype.peek = function () {
            return this.ops[this.index];
          };

          Iterator.prototype.peekLength = function () {
            if (this.ops[this.index]) {
              return lib.length(this.ops[this.index]) - this.offset;
            } else {
              return Infinity;
            }
          };

          Iterator.prototype.peekType = function () {
            if (this.ops[this.index]) {
              if (typeof this.ops[this.index]['delete'] === 'number') {
                return 'delete';
              } else if (typeof this.ops[this.index].retain === 'number') {
                return 'retain';
              } else {
                return 'insert';
              }
            }

            return 'retain';
          };

          Iterator.prototype.rest = function () {
            if (!this.hasNext()) {
              return [];
            } else if (this.offset === 0) {
              return this.ops.slice(this.index);
            } else {
              var offset = this.offset;
              var index = this.index;
              var next = this.next();
              var rest = this.ops.slice(this.index);
              this.offset = offset;
              this.index = index;
              return [next].concat(rest);
            }
          };

          module.exports = lib;
        }, function (module, exports) {
          var clone = function () {
            function _instanceof(obj, type) {
              return type != null && obj instanceof type;
            }

            var nativeMap;

            try {
              nativeMap = Map;
            } catch (_) {
              nativeMap = function () {};
            }

            var nativeSet;

            try {
              nativeSet = Set;
            } catch (_) {
              nativeSet = function () {};
            }

            var nativePromise;

            try {
              nativePromise = Promise;
            } catch (_) {
              nativePromise = function () {};
            }

            function clone(parent, circular, depth, prototype, includeNonEnumerable) {
              if (typeof circular === 'object') {
                depth = circular.depth;
                prototype = circular.prototype;
                includeNonEnumerable = circular.includeNonEnumerable;
                circular = circular.circular;
              }

              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != 'undefined';
              if (typeof circular == 'undefined') circular = true;
              if (typeof depth == 'undefined') depth = Infinity;

              function _clone(parent, depth) {
                if (parent === null) return null;
                if (depth === 0) return parent;
                var child;
                var proto;

                if (typeof parent != 'object') {
                  return parent;
                }

                if (_instanceof(parent, nativeMap)) {
                  child = new nativeMap();
                } else if (_instanceof(parent, nativeSet)) {
                  child = new nativeSet();
                } else if (_instanceof(parent, nativePromise)) {
                  child = new nativePromise(function (resolve, reject) {
                    parent.then(function (value) {
                      resolve(_clone(value, depth - 1));
                    }, function (err) {
                      reject(_clone(err, depth - 1));
                    });
                  });
                } else if (clone.__isArray(parent)) {
                  child = [];
                } else if (clone.__isRegExp(parent)) {
                  child = new RegExp(parent.source, __getRegExpFlags(parent));
                  if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                } else if (clone.__isDate(parent)) {
                  child = new Date(parent.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent)) {
                  if (Buffer.allocUnsafe) {
                    child = Buffer.allocUnsafe(parent.length);
                  } else {
                    child = new Buffer(parent.length);
                  }

                  parent.copy(child);
                  return child;
                } else if (_instanceof(parent, Error)) {
                  child = Object.create(parent);
                } else {
                  if (typeof prototype == 'undefined') {
                    proto = Object.getPrototypeOf(parent);
                    child = Object.create(proto);
                  } else {
                    child = Object.create(prototype);
                    proto = prototype;
                  }
                }

                if (circular) {
                  var index = allParents.indexOf(parent);

                  if (index != -1) {
                    return allChildren[index];
                  }

                  allParents.push(parent);
                  allChildren.push(child);
                }

                if (_instanceof(parent, nativeMap)) {
                  parent.forEach(function (value, key) {
                    var keyChild = _clone(key, depth - 1);

                    var valueChild = _clone(value, depth - 1);

                    child.set(keyChild, valueChild);
                  });
                }

                if (_instanceof(parent, nativeSet)) {
                  parent.forEach(function (value) {
                    var entryChild = _clone(value, depth - 1);

                    child.add(entryChild);
                  });
                }

                for (var i in parent) {
                  var attrs;

                  if (proto) {
                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                  }

                  if (attrs && attrs.set == null) {
                    continue;
                  }

                  child[i] = _clone(parent[i], depth - 1);
                }

                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(parent);

                  for (var i = 0; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);

                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                      continue;
                    }

                    child[symbol] = _clone(parent[symbol], depth - 1);

                    if (!descriptor.enumerable) {
                      Object.defineProperty(child, symbol, {
                        enumerable: false
                      });
                    }
                  }
                }

                if (includeNonEnumerable) {
                  var allPropertyNames = Object.getOwnPropertyNames(parent);

                  for (var i = 0; i < allPropertyNames.length; i++) {
                    var propertyName = allPropertyNames[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);

                    if (descriptor && descriptor.enumerable) {
                      continue;
                    }

                    child[propertyName] = _clone(parent[propertyName], depth - 1);
                    Object.defineProperty(child, propertyName, {
                      enumerable: false
                    });
                  }
                }

                return child;
              }

              return _clone(parent, depth);
            }

            clone.clonePrototype = function clonePrototype(parent) {
              if (parent === null) return null;

              var c = function () {};

              c.prototype = parent;
              return new c();
            };

            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }

            clone.__objToStr = __objToStr;

            function __isDate(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Date]';
            }

            clone.__isDate = __isDate;

            function __isArray(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Array]';
            }

            clone.__isArray = __isArray;

            function __isRegExp(o) {
              return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
            }

            clone.__isRegExp = __isRegExp;

            function __getRegExpFlags(re) {
              var flags = '';
              if (re.global) flags += 'g';
              if (re.ignoreCase) flags += 'i';
              if (re.multiline) flags += 'm';
              return flags;
            }

            clone.__getRegExpFlags = __getRegExpFlags;
            return clone;
          }();

          if (typeof module === 'object' && module.exports) {
            module.exports = clone;
          }
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _emitter = __webpack_require__(8);

          var _emitter2 = _interopRequireDefault(_emitter);

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          var _break = __webpack_require__(16);

          var _break2 = _interopRequireDefault(_break);

          var _code = __webpack_require__(13);

          var _code2 = _interopRequireDefault(_code);

          var _container = __webpack_require__(25);

          var _container2 = _interopRequireDefault(_container);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          function isLine(blot) {
            return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
          }

          var Scroll = function (_Parchment$Scroll) {
            _inherits(Scroll, _Parchment$Scroll);

            function Scroll(domNode, config) {
              _classCallCheck(this, Scroll);

              var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));

              _this.emitter = config.emitter;

              if (Array.isArray(config.whitelist)) {
                _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
                  whitelist[format] = true;
                  return whitelist;
                }, {});
              }

              _this.domNode.addEventListener('DOMNodeInserted', function () {});

              _this.optimize();

              _this.enable();

              return _this;
            }

            _createClass(Scroll, [{
              key: 'batchStart',
              value: function batchStart() {
                this.batch = true;
              }
            }, {
              key: 'batchEnd',
              value: function batchEnd() {
                this.batch = false;
                this.optimize();
              }
            }, {
              key: 'deleteAt',
              value: function deleteAt(index, length) {
                var _line = this.line(index),
                    _line2 = _slicedToArray(_line, 2),
                    first = _line2[0],
                    offset = _line2[1];

                var _line3 = this.line(index + length),
                    _line4 = _slicedToArray(_line3, 1),
                    last = _line4[0];

                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);

                if (last != null && first !== last && offset > 0) {
                  if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
                    this.optimize();
                    return;
                  }

                  if (first instanceof _code2.default) {
                    var newlineIndex = first.newlineIndex(first.length(), true);

                    if (newlineIndex > -1) {
                      first = first.split(newlineIndex + 1);

                      if (first === last) {
                        this.optimize();
                        return;
                      }
                    }
                  } else if (last instanceof _code2.default) {
                    var _newlineIndex = last.newlineIndex(0);

                    if (_newlineIndex > -1) {
                      last.split(_newlineIndex + 1);
                    }
                  }

                  var ref = last.children.head instanceof _break2.default ? null : last.children.head;
                  first.moveChildren(last, ref);
                  first.remove();
                }

                this.optimize();
              }
            }, {
              key: 'enable',
              value: function enable() {
                var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                this.domNode.setAttribute('contenteditable', enabled);
              }
            }, {
              key: 'formatAt',
              value: function formatAt(index, length, format, value) {
                if (this.whitelist != null && !this.whitelist[format]) return;

                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);

                this.optimize();
              }
            }, {
              key: 'insertAt',
              value: function insertAt(index, value, def) {
                if (def != null && this.whitelist != null && !this.whitelist[value]) return;

                if (index >= this.length()) {
                  if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                    var blot = _parchment2.default.create(this.statics.defaultChild);

                    this.appendChild(blot);

                    if (def == null && value.endsWith('\n')) {
                      value = value.slice(0, -1);
                    }

                    blot.insertAt(0, value, def);
                  } else {
                    var embed = _parchment2.default.create(value, def);

                    this.appendChild(embed);
                  }
                } else {
                  _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
                }

                this.optimize();
              }
            }, {
              key: 'insertBefore',
              value: function insertBefore(blot, ref) {
                if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                  var wrapper = _parchment2.default.create(this.statics.defaultChild);

                  wrapper.appendChild(blot);
                  blot = wrapper;
                }

                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
              }
            }, {
              key: 'leaf',
              value: function leaf(index) {
                return this.path(index).pop() || [null, -1];
              }
            }, {
              key: 'line',
              value: function line(index) {
                if (index === this.length()) {
                  return this.line(index - 1);
                }

                return this.descendant(isLine, index);
              }
            }, {
              key: 'lines',
              value: function lines() {
                var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

                var getLines = function getLines(blot, index, length) {
                  var lines = [],
                      lengthLeft = length;
                  blot.children.forEachAt(index, length, function (child, index, length) {
                    if (isLine(child)) {
                      lines.push(child);
                    } else if (child instanceof _parchment2.default.Container) {
                      lines = lines.concat(getLines(child, index, lengthLeft));
                    }

                    lengthLeft -= length;
                  });
                  return lines;
                };

                return getLines(this, index, length);
              }
            }, {
              key: 'optimize',
              value: function optimize() {
                var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                if (this.batch === true) return;

                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);

                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
                }
              }
            }, {
              key: 'path',
              value: function path(index) {
                return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1);
              }
            }, {
              key: 'update',
              value: function update(mutations) {
                if (this.batch === true) return;
                var source = _emitter2.default.sources.USER;

                if (typeof mutations === 'string') {
                  source = mutations;
                }

                if (!Array.isArray(mutations)) {
                  mutations = this.observer.takeRecords();
                }

                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
                }

                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([]));

                if (mutations.length > 0) {
                  this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
                }
              }
            }]);

            return Scroll;
          }(_parchment2.default.Scroll);

          Scroll.blotName = 'scroll';
          Scroll.className = 'ql-editor';
          Scroll.tagName = 'DIV';
          Scroll.defaultChild = 'block';
          Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
          exports.default = Scroll;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SHORTKEY = exports.default = undefined;

          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _clone = __webpack_require__(21);

          var _clone2 = _interopRequireDefault(_clone);

          var _deepEqual = __webpack_require__(11);

          var _deepEqual2 = _interopRequireDefault(_deepEqual);

          var _extend = __webpack_require__(3);

          var _extend2 = _interopRequireDefault(_extend);

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _op = __webpack_require__(20);

          var _op2 = _interopRequireDefault(_op);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _quill = __webpack_require__(5);

          var _quill2 = _interopRequireDefault(_quill);

          var _logger = __webpack_require__(10);

          var _logger2 = _interopRequireDefault(_logger);

          var _module = __webpack_require__(9);

          var _module2 = _interopRequireDefault(_module);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }

            return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var debug = (0, _logger2.default)('quill:keyboard');
          var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';

          var Keyboard = function (_Module) {
            _inherits(Keyboard, _Module);

            _createClass(Keyboard, null, [{
              key: 'match',
              value: function match(evt, binding) {
                binding = normalize(binding);

                if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
                  return !!binding[key] !== evt[key] && binding[key] !== null;
                })) {
                  return false;
                }

                return binding.key === (evt.which || evt.keyCode);
              }
            }]);

            function Keyboard(quill, options) {
              _classCallCheck(this, Keyboard);

              var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));

              _this.bindings = {};
              Object.keys(_this.options.bindings).forEach(function (name) {
                if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
                  return;
                }

                if (_this.options.bindings[name]) {
                  _this.addBinding(_this.options.bindings[name]);
                }
              });

              _this.addBinding({
                key: Keyboard.keys.ENTER,
                shiftKey: null
              }, handleEnter);

              _this.addBinding({
                key: Keyboard.keys.ENTER,
                metaKey: null,
                ctrlKey: null,
                altKey: null
              }, function () {});

              if (/Firefox/i.test(navigator.userAgent)) {
                _this.addBinding({
                  key: Keyboard.keys.BACKSPACE
                }, {
                  collapsed: true
                }, handleBackspace);

                _this.addBinding({
                  key: Keyboard.keys.DELETE
                }, {
                  collapsed: true
                }, handleDelete);
              } else {
                _this.addBinding({
                  key: Keyboard.keys.BACKSPACE
                }, {
                  collapsed: true,
                  prefix: /^.?$/
                }, handleBackspace);

                _this.addBinding({
                  key: Keyboard.keys.DELETE
                }, {
                  collapsed: true,
                  suffix: /^.?$/
                }, handleDelete);
              }

              _this.addBinding({
                key: Keyboard.keys.BACKSPACE
              }, {
                collapsed: false
              }, handleDeleteRange);

              _this.addBinding({
                key: Keyboard.keys.DELETE
              }, {
                collapsed: false
              }, handleDeleteRange);

              _this.addBinding({
                key: Keyboard.keys.BACKSPACE,
                altKey: null,
                ctrlKey: null,
                metaKey: null,
                shiftKey: null
              }, {
                collapsed: true,
                offset: 0
              }, handleBackspace);

              _this.listen();

              return _this;
            }

            _createClass(Keyboard, [{
              key: 'addBinding',
              value: function addBinding(key) {
                var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                var binding = normalize(key);

                if (binding == null || binding.key == null) {
                  return debug.warn('Attempted to add invalid keyboard binding', binding);
                }

                if (typeof context === 'function') {
                  context = {
                    handler: context
                  };
                }

                if (typeof handler === 'function') {
                  handler = {
                    handler: handler
                  };
                }

                binding = (0, _extend2.default)(binding, context, handler);
                this.bindings[binding.key] = this.bindings[binding.key] || [];
                this.bindings[binding.key].push(binding);
              }
            }, {
              key: 'listen',
              value: function listen() {
                var _this2 = this;

                this.quill.root.addEventListener('keydown', function (evt) {
                  if (evt.defaultPrevented) return;
                  var which = evt.which || evt.keyCode;
                  var bindings = (_this2.bindings[which] || []).filter(function (binding) {
                    return Keyboard.match(evt, binding);
                  });
                  if (bindings.length === 0) return;

                  var range = _this2.quill.getSelection();

                  if (range == null || !_this2.quill.hasFocus()) return;

                  var _quill$getLine = _this2.quill.getLine(range.index),
                      _quill$getLine2 = _slicedToArray(_quill$getLine, 2),
                      line = _quill$getLine2[0],
                      offset = _quill$getLine2[1];

                  var _quill$getLeaf = _this2.quill.getLeaf(range.index),
                      _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),
                      leafStart = _quill$getLeaf2[0],
                      offsetStart = _quill$getLeaf2[1];

                  var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),
                      _ref2 = _slicedToArray(_ref, 2),
                      leafEnd = _ref2[0],
                      offsetEnd = _ref2[1];

                  var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';
                  var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';
                  var curContext = {
                    collapsed: range.length === 0,
                    empty: range.length === 0 && line.length() <= 1,
                    format: _this2.quill.getFormat(range),
                    offset: offset,
                    prefix: prefixText,
                    suffix: suffixText
                  };
                  var prevented = bindings.some(function (binding) {
                    if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
                    if (binding.empty != null && binding.empty !== curContext.empty) return false;
                    if (binding.offset != null && binding.offset !== curContext.offset) return false;

                    if (Array.isArray(binding.format)) {
                      if (binding.format.every(function (name) {
                        return curContext.format[name] == null;
                      })) {
                        return false;
                      }
                    } else if (_typeof(binding.format) === 'object') {
                      if (!Object.keys(binding.format).every(function (name) {
                        if (binding.format[name] === true) return curContext.format[name] != null;
                        if (binding.format[name] === false) return curContext.format[name] == null;
                        return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                      })) {
                        return false;
                      }
                    }

                    if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
                    if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
                    return binding.handler.call(_this2, range, curContext) !== true;
                  });

                  if (prevented) {
                    evt.preventDefault();
                  }
                });
              }
            }]);

            return Keyboard;
          }(_module2.default);

          Keyboard.keys = {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            ESCAPE: 27,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            DELETE: 46
          };
          Keyboard.DEFAULTS = {
            bindings: {
              'bold': makeFormatHandler('bold'),
              'italic': makeFormatHandler('italic'),
              'underline': makeFormatHandler('underline'),
              'indent': {
                key: Keyboard.keys.TAB,
                format: ['blockquote', 'indent', 'list'],
                handler: function handler(range, context) {
                  if (context.collapsed && context.offset !== 0) return true;
                  this.quill.format('indent', '+1', _quill2.default.sources.USER);
                }
              },
              'outdent': {
                key: Keyboard.keys.TAB,
                shiftKey: true,
                format: ['blockquote', 'indent', 'list'],
                handler: function handler(range, context) {
                  if (context.collapsed && context.offset !== 0) return true;
                  this.quill.format('indent', '-1', _quill2.default.sources.USER);
                }
              },
              'outdent backspace': {
                key: Keyboard.keys.BACKSPACE,
                collapsed: true,
                shiftKey: null,
                metaKey: null,
                ctrlKey: null,
                altKey: null,
                format: ['indent', 'list'],
                offset: 0,
                handler: function handler(range, context) {
                  if (context.format.indent != null) {
                    this.quill.format('indent', '-1', _quill2.default.sources.USER);
                  } else if (context.format.list != null) {
                    this.quill.format('list', false, _quill2.default.sources.USER);
                  }
                }
              },
              'indent code-block': makeCodeBlockHandler(true),
              'outdent code-block': makeCodeBlockHandler(false),
              'remove tab': {
                key: Keyboard.keys.TAB,
                shiftKey: true,
                collapsed: true,
                prefix: /\t$/,
                handler: function handler(range) {
                  this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
                }
              },
              'tab': {
                key: Keyboard.keys.TAB,
                handler: function handler(range) {
                  this.quill.history.cutoff();
                  var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                }
              },
              'list empty enter': {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ['list'],
                empty: true,
                handler: function handler(range, context) {
                  this.quill.format('list', false, _quill2.default.sources.USER);

                  if (context.format.indent) {
                    this.quill.format('indent', false, _quill2.default.sources.USER);
                  }
                }
              },
              'checklist enter': {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: {
                  list: 'checked'
                },
                handler: function handler(range) {
                  var _quill$getLine3 = this.quill.getLine(range.index),
                      _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),
                      line = _quill$getLine4[0],
                      offset = _quill$getLine4[1];

                  var formats = (0, _extend2.default)({}, line.formats(), {
                    list: 'checked'
                  });
                  var delta = new _quillDelta2.default().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, {
                    list: 'unchecked'
                  });
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                  this.quill.scrollIntoView();
                }
              },
              'header enter': {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ['header'],
                suffix: /^$/,
                handler: function handler(range, context) {
                  var _quill$getLine5 = this.quill.getLine(range.index),
                      _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),
                      line = _quill$getLine6[0],
                      offset = _quill$getLine6[1];

                  var delta = new _quillDelta2.default().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, {
                    header: null
                  });
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
                  this.quill.scrollIntoView();
                }
              },
              'list autofill': {
                key: ' ',
                collapsed: true,
                format: {
                  list: false
                },
                prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
                handler: function handler(range, context) {
                  var length = context.prefix.length;

                  var _quill$getLine7 = this.quill.getLine(range.index),
                      _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),
                      line = _quill$getLine8[0],
                      offset = _quill$getLine8[1];

                  if (offset > length) return true;
                  var value = void 0;

                  switch (context.prefix.trim()) {
                    case '[]':
                    case '[ ]':
                      value = 'unchecked';
                      break;

                    case '[x]':
                      value = 'checked';
                      break;

                    case '-':
                    case '*':
                      value = 'bullet';
                      break;

                    default:
                      value = 'ordered';
                  }

                  this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
                    list: value
                  });
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                  this.quill.history.cutoff();
                  this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);
                }
              },
              'code exit': {
                key: Keyboard.keys.ENTER,
                collapsed: true,
                format: ['code-block'],
                prefix: /\n\n$/,
                suffix: /^\s+$/,
                handler: function handler(range) {
                  var _quill$getLine9 = this.quill.getLine(range.index),
                      _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),
                      line = _quill$getLine10[0],
                      offset = _quill$getLine10[1];

                  var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, {
                    'code-block': null
                  }).delete(1);
                  this.quill.updateContents(delta, _quill2.default.sources.USER);
                }
              },
              'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
              'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
              'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
              'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
            }
          };

          function makeEmbedArrowHandler(key, shiftKey) {
            var _ref3;

            var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
            return _ref3 = {
              key: key,
              shiftKey: shiftKey,
              altKey: null
            }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
              var index = range.index;

              if (key === Keyboard.keys.RIGHT) {
                index += range.length + 1;
              }

              var _quill$getLeaf3 = this.quill.getLeaf(index),
                  _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),
                  leaf = _quill$getLeaf4[0];

              if (!(leaf instanceof _parchment2.default.Embed)) return true;

              if (key === Keyboard.keys.LEFT) {
                if (shiftKey) {
                  this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
                } else {
                  this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
                }
              } else {
                if (shiftKey) {
                  this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
                } else {
                  this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
                }
              }

              return false;
            }), _ref3;
          }

          function handleBackspace(range, context) {
            if (range.index === 0 || this.quill.getLength() <= 1) return;

            var _quill$getLine11 = this.quill.getLine(range.index),
                _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),
                line = _quill$getLine12[0];

            var formats = {};

            if (context.offset === 0) {
              var _quill$getLine13 = this.quill.getLine(range.index - 1),
                  _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),
                  prev = _quill$getLine14[0];

              if (prev != null && prev.length() > 1) {
                var curFormats = line.formats();
                var prevFormats = this.quill.getFormat(range.index - 1, 1);
                formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
              }
            }

            var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
            this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);

            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);
            }

            this.quill.focus();
          }

          function handleDelete(range, context) {
            var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
            if (range.index >= this.quill.getLength() - length) return;
            var formats = {},
                nextLength = 0;

            var _quill$getLine15 = this.quill.getLine(range.index),
                _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),
                line = _quill$getLine16[0];

            if (context.offset >= line.length() - 1) {
              var _quill$getLine17 = this.quill.getLine(range.index + 1),
                  _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),
                  next = _quill$getLine18[0];

              if (next) {
                var curFormats = line.formats();
                var nextFormats = this.quill.getFormat(range.index, 1);
                formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
                nextLength = next.length();
              }
            }

            this.quill.deleteText(range.index, length, _quill2.default.sources.USER);

            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
            }
          }

          function handleDeleteRange(range) {
            var lines = this.quill.getLines(range);
            var formats = {};

            if (lines.length > 1) {
              var firstFormats = lines[0].formats();
              var lastFormats = lines[lines.length - 1].formats();
              formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
            }

            this.quill.deleteText(range, _quill2.default.sources.USER);

            if (Object.keys(formats).length > 0) {
              this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
            }

            this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
            this.quill.focus();
          }

          function handleEnter(range, context) {
            var _this3 = this;

            if (range.length > 0) {
              this.quill.scroll.deleteAt(range.index, range.length);
            }

            var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
              if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
                lineFormats[format] = context.format[format];
              }

              return lineFormats;
            }, {});
            this.quill.insertText(range.index, '\n', lineFormats, _quill2.default.sources.USER);
            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
            this.quill.focus();
            Object.keys(context.format).forEach(function (name) {
              if (lineFormats[name] != null) return;
              if (Array.isArray(context.format[name])) return;
              if (name === 'link') return;

              _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
            });
          }

          function makeCodeBlockHandler(indent) {
            return {
              key: Keyboard.keys.TAB,
              shiftKey: !indent,
              format: {
                'code-block': true
              },
              handler: function handler(range) {
                var CodeBlock = _parchment2.default.query('code-block');

                var index = range.index,
                    length = range.length;

                var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),
                    _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                    block = _quill$scroll$descend2[0],
                    offset = _quill$scroll$descend2[1];

                if (block == null) return;
                var scrollIndex = this.quill.getIndex(block);
                var start = block.newlineIndex(offset, true) + 1;
                var end = block.newlineIndex(scrollIndex + offset + length);
                var lines = block.domNode.textContent.slice(start, end).split('\n');
                offset = 0;
                lines.forEach(function (line, i) {
                  if (indent) {
                    block.insertAt(start + offset, CodeBlock.TAB);
                    offset += CodeBlock.TAB.length;

                    if (i === 0) {
                      index += CodeBlock.TAB.length;
                    } else {
                      length += CodeBlock.TAB.length;
                    }
                  } else if (line.startsWith(CodeBlock.TAB)) {
                    block.deleteAt(start + offset, CodeBlock.TAB.length);
                    offset -= CodeBlock.TAB.length;

                    if (i === 0) {
                      index -= CodeBlock.TAB.length;
                    } else {
                      length -= CodeBlock.TAB.length;
                    }
                  }

                  offset += line.length + 1;
                });
                this.quill.update(_quill2.default.sources.USER);
                this.quill.setSelection(index, length, _quill2.default.sources.SILENT);
              }
            };
          }

          function makeFormatHandler(format) {
            return {
              key: format[0].toUpperCase(),
              shortKey: true,
              handler: function handler(range, context) {
                this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
              }
            };
          }

          function normalize(binding) {
            if (typeof binding === 'string' || typeof binding === 'number') {
              return normalize({
                key: binding
              });
            }

            if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {
              binding = (0, _clone2.default)(binding, false);
            }

            if (typeof binding.key === 'string') {
              if (Keyboard.keys[binding.key.toUpperCase()] != null) {
                binding.key = Keyboard.keys[binding.key.toUpperCase()];
              } else if (binding.key.length === 1) {
                binding.key = binding.key.toUpperCase().charCodeAt(0);
              } else {
                return null;
              }
            }

            if (binding.shortKey) {
              binding[SHORTKEY] = binding.shortKey;
              delete binding.shortKey;
            }

            return binding;
          }

          exports.default = Keyboard;
          exports.SHORTKEY = SHORTKEY;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _text = __webpack_require__(7);

          var _text2 = _interopRequireDefault(_text);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Cursor = function (_Parchment$Embed) {
            _inherits(Cursor, _Parchment$Embed);

            _createClass(Cursor, null, [{
              key: 'value',
              value: function value() {
                return undefined;
              }
            }]);

            function Cursor(domNode, selection) {
              _classCallCheck(this, Cursor);

              var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));

              _this.selection = selection;
              _this.textNode = document.createTextNode(Cursor.CONTENTS);

              _this.domNode.appendChild(_this.textNode);

              _this._length = 0;
              return _this;
            }

            _createClass(Cursor, [{
              key: 'detach',
              value: function detach() {
                if (this.parent != null) this.parent.removeChild(this);
              }
            }, {
              key: 'format',
              value: function format(name, value) {
                if (this._length !== 0) {
                  return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
                }

                var target = this,
                    index = 0;

                while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                  index += target.offset(target.parent);
                  target = target.parent;
                }

                if (target != null) {
                  this._length = Cursor.CONTENTS.length;
                  target.optimize();
                  target.formatAt(index, Cursor.CONTENTS.length, name, value);
                  this._length = 0;
                }
              }
            }, {
              key: 'index',
              value: function index(node, offset) {
                if (node === this.textNode) return 0;
                return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
              }
            }, {
              key: 'length',
              value: function length() {
                return this._length;
              }
            }, {
              key: 'position',
              value: function position() {
                return [this.textNode, this.textNode.data.length];
              }
            }, {
              key: 'remove',
              value: function remove() {
                _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);

                this.parent = null;
              }
            }, {
              key: 'restore',
              value: function restore() {
                if (this.selection.composing || this.parent == null) return;
                var textNode = this.textNode;
                var range = this.selection.getNativeRange();
                var restoreText = void 0,
                    start = void 0,
                    end = void 0;

                if (range != null && range.start.node === textNode && range.end.node === textNode) {
                  var _ref = [textNode, range.start.offset, range.end.offset];
                  restoreText = _ref[0];
                  start = _ref[1];
                  end = _ref[2];
                }

                while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                  this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
                }

                if (this.textNode.data !== Cursor.CONTENTS) {
                  var text = this.textNode.data.split(Cursor.CONTENTS).join('');

                  if (this.next instanceof _text2.default) {
                    restoreText = this.next.domNode;
                    this.next.insertAt(0, text);
                    this.textNode.data = Cursor.CONTENTS;
                  } else {
                    this.textNode.data = text;
                    this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                    this.textNode = document.createTextNode(Cursor.CONTENTS);
                    this.domNode.appendChild(this.textNode);
                  }
                }

                this.remove();

                if (start != null) {
                  var _map = [start, end].map(function (offset) {
                    return Math.max(0, Math.min(restoreText.data.length, offset - 1));
                  });

                  var _map2 = _slicedToArray(_map, 2);

                  start = _map2[0];
                  end = _map2[1];
                  return {
                    startNode: restoreText,
                    startOffset: start,
                    endNode: restoreText,
                    endOffset: end
                  };
                }
              }
            }, {
              key: 'update',
              value: function update(mutations, context) {
                var _this2 = this;

                if (mutations.some(function (mutation) {
                  return mutation.type === 'characterData' && mutation.target === _this2.textNode;
                })) {
                  var range = this.restore();
                  if (range) context.range = range;
                }
              }
            }, {
              key: 'value',
              value: function value() {
                return '';
              }
            }]);

            return Cursor;
          }(_parchment2.default.Embed);

          Cursor.blotName = 'cursor';
          Cursor.className = 'ql-cursor';
          Cursor.tagName = 'span';
          Cursor.CONTENTS = '\uFEFF';
          exports.default = Cursor;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Container = function (_Parchment$Container) {
            _inherits(Container, _Parchment$Container);

            function Container() {
              _classCallCheck(this, Container);

              return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
            }

            return Container;
          }(_parchment2.default.Container);

          Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];
          exports.default = Container;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var ColorAttributor = function (_Parchment$Attributor) {
            _inherits(ColorAttributor, _Parchment$Attributor);

            function ColorAttributor() {
              _classCallCheck(this, ColorAttributor);

              return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
            }

            _createClass(ColorAttributor, [{
              key: 'value',
              value: function value(domNode) {
                var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);

                if (!value.startsWith('rgb(')) return value;
                value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
                return '#' + value.split(',').map(function (component) {
                  return ('00' + parseInt(component).toString(16)).slice(-2);
                }).join('');
              }
            }]);

            return ColorAttributor;
          }(_parchment2.default.Attributor.Style);

          var ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {
            scope: _parchment2.default.Scope.INLINE
          });
          var ColorStyle = new ColorAttributor('color', 'color', {
            scope: _parchment2.default.Scope.INLINE
          });
          exports.ColorAttributor = ColorAttributor;
          exports.ColorClass = ColorClass;
          exports.ColorStyle = ColorStyle;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.sanitize = exports.default = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Link = function (_Inline) {
            _inherits(Link, _Inline);

            function Link() {
              _classCallCheck(this, Link);

              return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
            }

            _createClass(Link, [{
              key: 'format',
              value: function format(name, value) {
                if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
                value = this.constructor.sanitize(value);
                this.domNode.setAttribute('href', value);
              }
            }], [{
              key: 'create',
              value: function create(value) {
                var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);

                value = this.sanitize(value);
                node.setAttribute('href', value);
                node.setAttribute('rel', 'noopener noreferrer');
                node.setAttribute('target', '_blank');
                return node;
              }
            }, {
              key: 'formats',
              value: function formats(domNode) {
                return domNode.getAttribute('href');
              }
            }, {
              key: 'sanitize',
              value: function sanitize(url) {
                return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
              }
            }]);

            return Link;
          }(_inline2.default);

          Link.blotName = 'link';
          Link.tagName = 'A';
          Link.SANITIZED_URL = 'about:blank';
          Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];

          function _sanitize(url, protocols) {
            var anchor = document.createElement('a');
            anchor.href = url;
            var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
            return protocols.indexOf(protocol) > -1;
          }

          exports.default = Link;
          exports.sanitize = _sanitize;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _keyboard = __webpack_require__(23);

          var _keyboard2 = _interopRequireDefault(_keyboard);

          var _dropdown = __webpack_require__(107);

          var _dropdown2 = _interopRequireDefault(_dropdown);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var optionsCounter = 0;

          function toggleAriaAttribute(element, attribute) {
            element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
          }

          var Picker = function () {
            function Picker(select) {
              var _this = this;

              _classCallCheck(this, Picker);

              this.select = select;
              this.container = document.createElement('span');
              this.buildPicker();
              this.select.style.display = 'none';
              this.select.parentNode.insertBefore(this.container, this.select);
              this.label.addEventListener('mousedown', function () {
                _this.togglePicker();
              });
              this.label.addEventListener('keydown', function (event) {
                switch (event.keyCode) {
                  case _keyboard2.default.keys.ENTER:
                    _this.togglePicker();

                    break;

                  case _keyboard2.default.keys.ESCAPE:
                    _this.escape();

                    event.preventDefault();
                    break;
                }
              });
              this.select.addEventListener('change', this.update.bind(this));
            }

            _createClass(Picker, [{
              key: 'togglePicker',
              value: function togglePicker() {
                this.container.classList.toggle('ql-expanded');
                toggleAriaAttribute(this.label, 'aria-expanded');
                toggleAriaAttribute(this.options, 'aria-hidden');
              }
            }, {
              key: 'buildItem',
              value: function buildItem(option) {
                var _this2 = this;

                var item = document.createElement('span');
                item.tabIndex = '0';
                item.setAttribute('role', 'button');
                item.classList.add('ql-picker-item');

                if (option.hasAttribute('value')) {
                  item.setAttribute('data-value', option.getAttribute('value'));
                }

                if (option.textContent) {
                  item.setAttribute('data-label', option.textContent);
                }

                item.addEventListener('click', function () {
                  _this2.selectItem(item, true);
                });
                item.addEventListener('keydown', function (event) {
                  switch (event.keyCode) {
                    case _keyboard2.default.keys.ENTER:
                      _this2.selectItem(item, true);

                      event.preventDefault();
                      break;

                    case _keyboard2.default.keys.ESCAPE:
                      _this2.escape();

                      event.preventDefault();
                      break;
                  }
                });
                return item;
              }
            }, {
              key: 'buildLabel',
              value: function buildLabel() {
                var label = document.createElement('span');
                label.classList.add('ql-picker-label');
                label.innerHTML = _dropdown2.default;
                label.tabIndex = '0';
                label.setAttribute('role', 'button');
                label.setAttribute('aria-expanded', 'false');
                this.container.appendChild(label);
                return label;
              }
            }, {
              key: 'buildOptions',
              value: function buildOptions() {
                var _this3 = this;

                var options = document.createElement('span');
                options.classList.add('ql-picker-options');
                options.setAttribute('aria-hidden', 'true');
                options.tabIndex = '-1';
                options.id = 'ql-picker-options-' + optionsCounter;
                optionsCounter += 1;
                this.label.setAttribute('aria-controls', options.id);
                this.options = options;
                [].slice.call(this.select.options).forEach(function (option) {
                  var item = _this3.buildItem(option);

                  options.appendChild(item);

                  if (option.selected === true) {
                    _this3.selectItem(item);
                  }
                });
                this.container.appendChild(options);
              }
            }, {
              key: 'buildPicker',
              value: function buildPicker() {
                var _this4 = this;

                [].slice.call(this.select.attributes).forEach(function (item) {
                  _this4.container.setAttribute(item.name, item.value);
                });
                this.container.classList.add('ql-picker');
                this.label = this.buildLabel();
                this.buildOptions();
              }
            }, {
              key: 'escape',
              value: function escape() {
                var _this5 = this;

                this.close();
                setTimeout(function () {
                  return _this5.label.focus();
                }, 1);
              }
            }, {
              key: 'close',
              value: function close() {
                this.container.classList.remove('ql-expanded');
                this.label.setAttribute('aria-expanded', 'false');
                this.options.setAttribute('aria-hidden', 'true');
              }
            }, {
              key: 'selectItem',
              value: function selectItem(item) {
                var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var selected = this.container.querySelector('.ql-selected');
                if (item === selected) return;

                if (selected != null) {
                  selected.classList.remove('ql-selected');
                }

                if (item == null) return;
                item.classList.add('ql-selected');
                this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);

                if (item.hasAttribute('data-value')) {
                  this.label.setAttribute('data-value', item.getAttribute('data-value'));
                } else {
                  this.label.removeAttribute('data-value');
                }

                if (item.hasAttribute('data-label')) {
                  this.label.setAttribute('data-label', item.getAttribute('data-label'));
                } else {
                  this.label.removeAttribute('data-label');
                }

                if (trigger) {
                  if (typeof Event === 'function') {
                    this.select.dispatchEvent(new Event('change'));
                  } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {
                    var event = document.createEvent('Event');
                    event.initEvent('change', true, true);
                    this.select.dispatchEvent(event);
                  }

                  this.close();
                }
              }
            }, {
              key: 'update',
              value: function update() {
                var option = void 0;

                if (this.select.selectedIndex > -1) {
                  var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
                  option = this.select.options[this.select.selectedIndex];
                  this.selectItem(item);
                } else {
                  this.selectItem(null);
                }

                var isActive = option != null && option !== this.select.querySelector('option[selected]');
                this.label.classList.toggle('ql-active', isActive);
              }
            }]);

            return Picker;
          }();

          exports.default = Picker;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _quill = __webpack_require__(5);

          var _quill2 = _interopRequireDefault(_quill);

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          var _break = __webpack_require__(16);

          var _break2 = _interopRequireDefault(_break);

          var _container = __webpack_require__(25);

          var _container2 = _interopRequireDefault(_container);

          var _cursor = __webpack_require__(24);

          var _cursor2 = _interopRequireDefault(_cursor);

          var _embed = __webpack_require__(35);

          var _embed2 = _interopRequireDefault(_embed);

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          var _scroll = __webpack_require__(22);

          var _scroll2 = _interopRequireDefault(_scroll);

          var _text = __webpack_require__(7);

          var _text2 = _interopRequireDefault(_text);

          var _clipboard = __webpack_require__(55);

          var _clipboard2 = _interopRequireDefault(_clipboard);

          var _history = __webpack_require__(42);

          var _history2 = _interopRequireDefault(_history);

          var _keyboard = __webpack_require__(23);

          var _keyboard2 = _interopRequireDefault(_keyboard);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          _quill2.default.register({
            'blots/block': _block2.default,
            'blots/block/embed': _block.BlockEmbed,
            'blots/break': _break2.default,
            'blots/container': _container2.default,
            'blots/cursor': _cursor2.default,
            'blots/embed': _embed2.default,
            'blots/inline': _inline2.default,
            'blots/scroll': _scroll2.default,
            'blots/text': _text2.default,
            'modules/clipboard': _clipboard2.default,
            'modules/history': _history2.default,
            'modules/keyboard': _keyboard2.default
          });

          _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);

          exports.default = _quill2.default;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var Registry = __webpack_require__(1);

          var ShadowBlot = function () {
            function ShadowBlot(domNode) {
              this.domNode = domNode;
              this.domNode[Registry.DATA_KEY] = {
                blot: this
              };
            }

            Object.defineProperty(ShadowBlot.prototype, "statics", {
              get: function () {
                return this.constructor;
              },
              enumerable: true,
              configurable: true
            });

            ShadowBlot.create = function (value) {
              if (this.tagName == null) {
                throw new Registry.ParchmentError('Blot definition missing tagName');
              }

              var node;

              if (Array.isArray(this.tagName)) {
                if (typeof value === 'string') {
                  value = value.toUpperCase();

                  if (parseInt(value).toString() === value) {
                    value = parseInt(value);
                  }
                }

                if (typeof value === 'number') {
                  node = document.createElement(this.tagName[value - 1]);
                } else if (this.tagName.indexOf(value) > -1) {
                  node = document.createElement(value);
                } else {
                  node = document.createElement(this.tagName[0]);
                }
              } else {
                node = document.createElement(this.tagName);
              }

              if (this.className) {
                node.classList.add(this.className);
              }

              return node;
            };

            ShadowBlot.prototype.attach = function () {
              if (this.parent != null) {
                this.scroll = this.parent.scroll;
              }
            };

            ShadowBlot.prototype.clone = function () {
              var domNode = this.domNode.cloneNode(false);
              return Registry.create(domNode);
            };

            ShadowBlot.prototype.detach = function () {
              if (this.parent != null) this.parent.removeChild(this);
              delete this.domNode[Registry.DATA_KEY];
            };

            ShadowBlot.prototype.deleteAt = function (index, length) {
              var blot = this.isolate(index, length);
              blot.remove();
            };

            ShadowBlot.prototype.formatAt = function (index, length, name, value) {
              var blot = this.isolate(index, length);

              if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
                blot.wrap(name, value);
              } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
                var parent = Registry.create(this.statics.scope);
                blot.wrap(parent);
                parent.format(name, value);
              }
            };

            ShadowBlot.prototype.insertAt = function (index, value, def) {
              var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
              var ref = this.split(index);
              this.parent.insertBefore(blot, ref);
            };

            ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
              if (refBlot === void 0) {
                refBlot = null;
              }

              if (this.parent != null) {
                this.parent.children.remove(this);
              }

              var refDomNode = null;
              parentBlot.children.insertBefore(this, refBlot);

              if (refBlot != null) {
                refDomNode = refBlot.domNode;
              }

              if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
                parentBlot.domNode.insertBefore(this.domNode, refDomNode);
              }

              this.parent = parentBlot;
              this.attach();
            };

            ShadowBlot.prototype.isolate = function (index, length) {
              var target = this.split(index);
              target.split(length);
              return target;
            };

            ShadowBlot.prototype.length = function () {
              return 1;
            };

            ShadowBlot.prototype.offset = function (root) {
              if (root === void 0) {
                root = this.parent;
              }

              if (this.parent == null || this == root) return 0;
              return this.parent.children.offset(this) + this.parent.offset(root);
            };

            ShadowBlot.prototype.optimize = function (context) {
              if (this.domNode[Registry.DATA_KEY] != null) {
                delete this.domNode[Registry.DATA_KEY].mutations;
              }
            };

            ShadowBlot.prototype.remove = function () {
              if (this.domNode.parentNode != null) {
                this.domNode.parentNode.removeChild(this.domNode);
              }

              this.detach();
            };

            ShadowBlot.prototype.replace = function (target) {
              if (target.parent == null) return;
              target.parent.insertBefore(this, target.next);
              target.remove();
            };

            ShadowBlot.prototype.replaceWith = function (name, value) {
              var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
              replacement.replace(this);
              return replacement;
            };

            ShadowBlot.prototype.split = function (index, force) {
              return index === 0 ? this : this.next;
            };

            ShadowBlot.prototype.update = function (mutations, context) {};

            ShadowBlot.prototype.wrap = function (name, value) {
              var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;

              if (this.parent != null) {
                this.parent.insertBefore(wrapper, this.next);
              }

              wrapper.appendChild(this);
              return wrapper;
            };

            ShadowBlot.blotName = 'abstract';
            return ShadowBlot;
          }();

          exports.default = ShadowBlot;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var attributor_1 = __webpack_require__(12);

          var class_1 = __webpack_require__(32);

          var style_1 = __webpack_require__(33);

          var Registry = __webpack_require__(1);

          var AttributorStore = function () {
            function AttributorStore(domNode) {
              this.attributes = {};
              this.domNode = domNode;
              this.build();
            }

            AttributorStore.prototype.attribute = function (attribute, value) {
              if (value) {
                if (attribute.add(this.domNode, value)) {
                  if (attribute.value(this.domNode) != null) {
                    this.attributes[attribute.attrName] = attribute;
                  } else {
                    delete this.attributes[attribute.attrName];
                  }
                }
              } else {
                attribute.remove(this.domNode);
                delete this.attributes[attribute.attrName];
              }
            };

            AttributorStore.prototype.build = function () {
              var _this = this;

              this.attributes = {};
              var attributes = attributor_1.default.keys(this.domNode);
              var classes = class_1.default.keys(this.domNode);
              var styles = style_1.default.keys(this.domNode);
              attributes.concat(classes).concat(styles).forEach(function (name) {
                var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);

                if (attr instanceof attributor_1.default) {
                  _this.attributes[attr.attrName] = attr;
                }
              });
            };

            AttributorStore.prototype.copy = function (target) {
              var _this = this;

              Object.keys(this.attributes).forEach(function (key) {
                var value = _this.attributes[key].value(_this.domNode);

                target.format(key, value);
              });
            };

            AttributorStore.prototype.move = function (target) {
              var _this = this;

              this.copy(target);
              Object.keys(this.attributes).forEach(function (key) {
                _this.attributes[key].remove(_this.domNode);
              });
              this.attributes = {};
            };

            AttributorStore.prototype.values = function () {
              var _this = this;

              return Object.keys(this.attributes).reduce(function (attributes, name) {
                attributes[name] = _this.attributes[name].value(_this.domNode);
                return attributes;
              }, {});
            };

            return AttributorStore;
          }();

          exports.default = AttributorStore;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var attributor_1 = __webpack_require__(12);

          function match(node, prefix) {
            var className = node.getAttribute('class') || '';
            return className.split(/\s+/).filter(function (name) {
              return name.indexOf(prefix + "-") === 0;
            });
          }

          var ClassAttributor = function (_super) {
            __extends(ClassAttributor, _super);

            function ClassAttributor() {
              return _super !== null && _super.apply(this, arguments) || this;
            }

            ClassAttributor.keys = function (node) {
              return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
                return name.split('-').slice(0, -1).join('-');
              });
            };

            ClassAttributor.prototype.add = function (node, value) {
              if (!this.canAdd(node, value)) return false;
              this.remove(node);
              node.classList.add(this.keyName + "-" + value);
              return true;
            };

            ClassAttributor.prototype.remove = function (node) {
              var matches = match(node, this.keyName);
              matches.forEach(function (name) {
                node.classList.remove(name);
              });

              if (node.classList.length === 0) {
                node.removeAttribute('class');
              }
            };

            ClassAttributor.prototype.value = function (node) {
              var result = match(node, this.keyName)[0] || '';
              var value = result.slice(this.keyName.length + 1);
              return this.canAdd(node, value) ? value : '';
            };

            return ClassAttributor;
          }(attributor_1.default);

          exports.default = ClassAttributor;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var attributor_1 = __webpack_require__(12);

          function camelize(name) {
            var parts = name.split('-');
            var rest = parts.slice(1).map(function (part) {
              return part[0].toUpperCase() + part.slice(1);
            }).join('');
            return parts[0] + rest;
          }

          var StyleAttributor = function (_super) {
            __extends(StyleAttributor, _super);

            function StyleAttributor() {
              return _super !== null && _super.apply(this, arguments) || this;
            }

            StyleAttributor.keys = function (node) {
              return (node.getAttribute('style') || '').split(';').map(function (value) {
                var arr = value.split(':');
                return arr[0].trim();
              });
            };

            StyleAttributor.prototype.add = function (node, value) {
              if (!this.canAdd(node, value)) return false;
              node.style[camelize(this.keyName)] = value;
              return true;
            };

            StyleAttributor.prototype.remove = function (node) {
              node.style[camelize(this.keyName)] = '';

              if (!node.getAttribute('style')) {
                node.removeAttribute('style');
              }
            };

            StyleAttributor.prototype.value = function (node) {
              var value = node.style[camelize(this.keyName)];
              return this.canAdd(node, value) ? value : '';
            };

            return StyleAttributor;
          }(attributor_1.default);

          exports.default = StyleAttributor;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var Theme = function () {
            function Theme(quill, options) {
              _classCallCheck(this, Theme);

              this.quill = quill;
              this.options = options;
              this.modules = {};
            }

            _createClass(Theme, [{
              key: 'init',
              value: function init() {
                var _this = this;

                Object.keys(this.options.modules).forEach(function (name) {
                  if (_this.modules[name] == null) {
                    _this.addModule(name);
                  }
                });
              }
            }, {
              key: 'addModule',
              value: function addModule(name) {
                var moduleClass = this.quill.constructor.import('modules/' + name);
                this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
                return this.modules[name];
              }
            }]);

            return Theme;
          }();

          Theme.DEFAULTS = {
            modules: {}
          };
          Theme.themes = {
            'default': Theme
          };
          exports.default = Theme;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _text = __webpack_require__(7);

          var _text2 = _interopRequireDefault(_text);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var GUARD_TEXT = '\uFEFF';

          var Embed = function (_Parchment$Embed) {
            _inherits(Embed, _Parchment$Embed);

            function Embed(node) {
              _classCallCheck(this, Embed);

              var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));

              _this.contentNode = document.createElement('span');

              _this.contentNode.setAttribute('contenteditable', false);

              [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
                _this.contentNode.appendChild(childNode);
              });
              _this.leftGuard = document.createTextNode(GUARD_TEXT);
              _this.rightGuard = document.createTextNode(GUARD_TEXT);

              _this.domNode.appendChild(_this.leftGuard);

              _this.domNode.appendChild(_this.contentNode);

              _this.domNode.appendChild(_this.rightGuard);

              return _this;
            }

            _createClass(Embed, [{
              key: 'index',
              value: function index(node, offset) {
                if (node === this.leftGuard) return 0;
                if (node === this.rightGuard) return 1;
                return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
              }
            }, {
              key: 'restore',
              value: function restore(node) {
                var range = void 0,
                    textNode = void 0;
                var text = node.data.split(GUARD_TEXT).join('');

                if (node === this.leftGuard) {
                  if (this.prev instanceof _text2.default) {
                    var prevLength = this.prev.length();
                    this.prev.insertAt(prevLength, text);
                    range = {
                      startNode: this.prev.domNode,
                      startOffset: prevLength + text.length
                    };
                  } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(_parchment2.default.create(textNode), this);
                    range = {
                      startNode: textNode,
                      startOffset: text.length
                    };
                  }
                } else if (node === this.rightGuard) {
                  if (this.next instanceof _text2.default) {
                    this.next.insertAt(0, text);
                    range = {
                      startNode: this.next.domNode,
                      startOffset: text.length
                    };
                  } else {
                    textNode = document.createTextNode(text);
                    this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                    range = {
                      startNode: textNode,
                      startOffset: text.length
                    };
                  }
                }

                node.data = GUARD_TEXT;
                return range;
              }
            }, {
              key: 'update',
              value: function update(mutations, context) {
                var _this2 = this;

                mutations.forEach(function (mutation) {
                  if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                    var range = _this2.restore(mutation.target);

                    if (range) context.range = range;
                  }
                });
              }
            }]);

            return Embed;
          }(_parchment2.default.Embed);

          exports.default = Embed;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          var config = {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: ['right', 'center', 'justify']
          };
          var AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);
          var AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);
          var AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);
          exports.AlignAttribute = AlignAttribute;
          exports.AlignClass = AlignClass;
          exports.AlignStyle = AlignStyle;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BackgroundStyle = exports.BackgroundClass = undefined;

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _color = __webpack_require__(26);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          var BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {
            scope: _parchment2.default.Scope.INLINE
          });
          var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
            scope: _parchment2.default.Scope.INLINE
          });
          exports.BackgroundClass = BackgroundClass;
          exports.BackgroundStyle = BackgroundStyle;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          var config = {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: ['rtl']
          };
          var DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);
          var DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);
          var DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);
          exports.DirectionAttribute = DirectionAttribute;
          exports.DirectionClass = DirectionClass;
          exports.DirectionStyle = DirectionStyle;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FontClass = exports.FontStyle = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var config = {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ['serif', 'monospace']
          };
          var FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);

          var FontStyleAttributor = function (_Parchment$Attributor) {
            _inherits(FontStyleAttributor, _Parchment$Attributor);

            function FontStyleAttributor() {
              _classCallCheck(this, FontStyleAttributor);

              return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
            }

            _createClass(FontStyleAttributor, [{
              key: 'value',
              value: function value(node) {
                return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
              }
            }]);

            return FontStyleAttributor;
          }(_parchment2.default.Attributor.Style);

          var FontStyle = new FontStyleAttributor('font', 'font-family', config);
          exports.FontStyle = FontStyle;
          exports.FontClass = FontClass;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SizeStyle = exports.SizeClass = undefined;

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          var SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ['small', 'large', 'huge']
          });
          var SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {
            scope: _parchment2.default.Scope.INLINE,
            whitelist: ['10px', '18px', '32px']
          });
          exports.SizeClass = SizeClass;
          exports.SizeStyle = SizeStyle;
        }, function (module, exports, __webpack_require__) {
          module.exports = {
            'align': {
              '': __webpack_require__(76),
              'center': __webpack_require__(77),
              'right': __webpack_require__(78),
              'justify': __webpack_require__(79)
            },
            'background': __webpack_require__(80),
            'blockquote': __webpack_require__(81),
            'bold': __webpack_require__(82),
            'clean': __webpack_require__(83),
            'code': __webpack_require__(58),
            'code-block': __webpack_require__(58),
            'color': __webpack_require__(84),
            'direction': {
              '': __webpack_require__(85),
              'rtl': __webpack_require__(86)
            },
            'float': {
              'center': __webpack_require__(87),
              'full': __webpack_require__(88),
              'left': __webpack_require__(89),
              'right': __webpack_require__(90)
            },
            'formula': __webpack_require__(91),
            'header': {
              '1': __webpack_require__(92),
              '2': __webpack_require__(93)
            },
            'italic': __webpack_require__(94),
            'image': __webpack_require__(95),
            'indent': {
              '+1': __webpack_require__(96),
              '-1': __webpack_require__(97)
            },
            'link': __webpack_require__(98),
            'list': {
              'ordered': __webpack_require__(99),
              'bullet': __webpack_require__(100),
              'check': __webpack_require__(101)
            },
            'script': {
              'sub': __webpack_require__(102),
              'super': __webpack_require__(103)
            },
            'strike': __webpack_require__(104),
            'underline': __webpack_require__(105),
            'video': __webpack_require__(106)
          };
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getLastChangeIndex = exports.default = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _quill = __webpack_require__(5);

          var _quill2 = _interopRequireDefault(_quill);

          var _module = __webpack_require__(9);

          var _module2 = _interopRequireDefault(_module);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var History = function (_Module) {
            _inherits(History, _Module);

            function History(quill, options) {
              _classCallCheck(this, History);

              var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));

              _this.lastRecorded = 0;
              _this.ignoreChange = false;

              _this.clear();

              _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
                if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;

                if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                  _this.record(delta, oldDelta);
                } else {
                  _this.transform(delta);
                }
              });

              _this.quill.keyboard.addBinding({
                key: 'Z',
                shortKey: true
              }, _this.undo.bind(_this));

              _this.quill.keyboard.addBinding({
                key: 'Z',
                shortKey: true,
                shiftKey: true
              }, _this.redo.bind(_this));

              if (/Win/i.test(navigator.platform)) {
                _this.quill.keyboard.addBinding({
                  key: 'Y',
                  shortKey: true
                }, _this.redo.bind(_this));
              }

              return _this;
            }

            _createClass(History, [{
              key: 'change',
              value: function change(source, dest) {
                if (this.stack[source].length === 0) return;
                var delta = this.stack[source].pop();
                this.stack[dest].push(delta);
                this.lastRecorded = 0;
                this.ignoreChange = true;
                this.quill.updateContents(delta[source], _quill2.default.sources.USER);
                this.ignoreChange = false;
                var index = getLastChangeIndex(delta[source]);
                this.quill.setSelection(index);
              }
            }, {
              key: 'clear',
              value: function clear() {
                this.stack = {
                  undo: [],
                  redo: []
                };
              }
            }, {
              key: 'cutoff',
              value: function cutoff() {
                this.lastRecorded = 0;
              }
            }, {
              key: 'record',
              value: function record(changeDelta, oldDelta) {
                if (changeDelta.ops.length === 0) return;
                this.stack.redo = [];
                var undoDelta = this.quill.getContents().diff(oldDelta);
                var timestamp = Date.now();

                if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                  var delta = this.stack.undo.pop();
                  undoDelta = undoDelta.compose(delta.undo);
                  changeDelta = delta.redo.compose(changeDelta);
                } else {
                  this.lastRecorded = timestamp;
                }

                this.stack.undo.push({
                  redo: changeDelta,
                  undo: undoDelta
                });

                if (this.stack.undo.length > this.options.maxStack) {
                  this.stack.undo.shift();
                }
              }
            }, {
              key: 'redo',
              value: function redo() {
                this.change('redo', 'undo');
              }
            }, {
              key: 'transform',
              value: function transform(delta) {
                this.stack.undo.forEach(function (change) {
                  change.undo = delta.transform(change.undo, true);
                  change.redo = delta.transform(change.redo, true);
                });
                this.stack.redo.forEach(function (change) {
                  change.undo = delta.transform(change.undo, true);
                  change.redo = delta.transform(change.redo, true);
                });
              }
            }, {
              key: 'undo',
              value: function undo() {
                this.change('undo', 'redo');
              }
            }]);

            return History;
          }(_module2.default);

          History.DEFAULTS = {
            delay: 1000,
            maxStack: 100,
            userOnly: false
          };

          function endsWithNewlineChange(delta) {
            var lastOp = delta.ops[delta.ops.length - 1];
            if (lastOp == null) return false;

            if (lastOp.insert != null) {
              return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
            }

            if (lastOp.attributes != null) {
              return Object.keys(lastOp.attributes).some(function (attr) {
                return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
              });
            }

            return false;
          }

          function getLastChangeIndex(delta) {
            var deleteLength = delta.reduce(function (length, op) {
              length += op.delete || 0;
              return length;
            }, 0);
            var changeIndex = delta.length() - deleteLength;

            if (endsWithNewlineChange(delta)) {
              changeIndex -= 1;
            }

            return changeIndex;
          }

          exports.default = History;
          exports.getLastChangeIndex = getLastChangeIndex;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.BaseTooltip = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _extend = __webpack_require__(3);

          var _extend2 = _interopRequireDefault(_extend);

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _emitter = __webpack_require__(8);

          var _emitter2 = _interopRequireDefault(_emitter);

          var _keyboard = __webpack_require__(23);

          var _keyboard2 = _interopRequireDefault(_keyboard);

          var _theme = __webpack_require__(34);

          var _theme2 = _interopRequireDefault(_theme);

          var _colorPicker = __webpack_require__(59);

          var _colorPicker2 = _interopRequireDefault(_colorPicker);

          var _iconPicker = __webpack_require__(60);

          var _iconPicker2 = _interopRequireDefault(_iconPicker);

          var _picker = __webpack_require__(28);

          var _picker2 = _interopRequireDefault(_picker);

          var _tooltip = __webpack_require__(61);

          var _tooltip2 = _interopRequireDefault(_tooltip);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var ALIGNS = [false, 'center', 'right', 'justify'];
          var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
          var FONTS = [false, 'serif', 'monospace'];
          var HEADERS = ['1', '2', '3', false];
          var SIZES = ['small', false, 'large', 'huge'];

          var BaseTheme = function (_Theme) {
            _inherits(BaseTheme, _Theme);

            function BaseTheme(quill, options) {
              _classCallCheck(this, BaseTheme);

              var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));

              var listener = function listener(e) {
                if (!document.body.contains(quill.root)) {
                  return document.body.removeEventListener('click', listener);
                }

                if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                  _this.tooltip.hide();
                }

                if (_this.pickers != null) {
                  _this.pickers.forEach(function (picker) {
                    if (!picker.container.contains(e.target)) {
                      picker.close();
                    }
                  });
                }
              };

              quill.emitter.listenDOM('click', document.body, listener);
              return _this;
            }

            _createClass(BaseTheme, [{
              key: 'addModule',
              value: function addModule(name) {
                var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);

                if (name === 'toolbar') {
                  this.extendToolbar(module);
                }

                return module;
              }
            }, {
              key: 'buildButtons',
              value: function buildButtons(buttons, icons) {
                buttons.forEach(function (button) {
                  var className = button.getAttribute('class') || '';
                  className.split(/\s+/).forEach(function (name) {
                    if (!name.startsWith('ql-')) return;
                    name = name.slice('ql-'.length);
                    if (icons[name] == null) return;

                    if (name === 'direction') {
                      button.innerHTML = icons[name][''] + icons[name]['rtl'];
                    } else if (typeof icons[name] === 'string') {
                      button.innerHTML = icons[name];
                    } else {
                      var value = button.value || '';

                      if (value != null && icons[name][value]) {
                        button.innerHTML = icons[name][value];
                      }
                    }
                  });
                });
              }
            }, {
              key: 'buildPickers',
              value: function buildPickers(selects, icons) {
                var _this2 = this;

                this.pickers = selects.map(function (select) {
                  if (select.classList.contains('ql-align')) {
                    if (select.querySelector('option') == null) {
                      fillSelect(select, ALIGNS);
                    }

                    return new _iconPicker2.default(select, icons.align);
                  } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
                    var format = select.classList.contains('ql-background') ? 'background' : 'color';

                    if (select.querySelector('option') == null) {
                      fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
                    }

                    return new _colorPicker2.default(select, icons[format]);
                  } else {
                    if (select.querySelector('option') == null) {
                      if (select.classList.contains('ql-font')) {
                        fillSelect(select, FONTS);
                      } else if (select.classList.contains('ql-header')) {
                        fillSelect(select, HEADERS);
                      } else if (select.classList.contains('ql-size')) {
                        fillSelect(select, SIZES);
                      }
                    }

                    return new _picker2.default(select);
                  }
                });

                var update = function update() {
                  _this2.pickers.forEach(function (picker) {
                    picker.update();
                  });
                };

                this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
              }
            }]);

            return BaseTheme;
          }(_theme2.default);

          BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  formula: function formula() {
                    this.quill.theme.tooltip.edit('formula');
                  },
                  image: function image() {
                    var _this3 = this;

                    var fileInput = this.container.querySelector('input.ql-image[type=file]');

                    if (fileInput == null) {
                      fileInput = document.createElement('input');
                      fileInput.setAttribute('type', 'file');
                      fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
                      fileInput.classList.add('ql-image');
                      fileInput.addEventListener('change', function () {
                        if (fileInput.files != null && fileInput.files[0] != null) {
                          var reader = new FileReader();

                          reader.onload = function (e) {
                            var range = _this3.quill.getSelection(true);

                            _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({
                              image: e.target.result
                            }), _emitter2.default.sources.USER);

                            _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);

                            fileInput.value = "";
                          };

                          reader.readAsDataURL(fileInput.files[0]);
                        }
                      });
                      this.container.appendChild(fileInput);
                    }

                    fileInput.click();
                  },
                  video: function video() {
                    this.quill.theme.tooltip.edit('video');
                  }
                }
              }
            }
          });

          var BaseTooltip = function (_Tooltip) {
            _inherits(BaseTooltip, _Tooltip);

            function BaseTooltip(quill, boundsContainer) {
              _classCallCheck(this, BaseTooltip);

              var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));

              _this4.textbox = _this4.root.querySelector('input[type="text"]');

              _this4.listen();

              return _this4;
            }

            _createClass(BaseTooltip, [{
              key: 'listen',
              value: function listen() {
                var _this5 = this;

                this.textbox.addEventListener('keydown', function (event) {
                  if (_keyboard2.default.match(event, 'enter')) {
                    _this5.save();

                    event.preventDefault();
                  } else if (_keyboard2.default.match(event, 'escape')) {
                    _this5.cancel();

                    event.preventDefault();
                  }
                });
              }
            }, {
              key: 'cancel',
              value: function cancel() {
                this.hide();
              }
            }, {
              key: 'edit',
              value: function edit() {
                var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
                var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                this.root.classList.remove('ql-hidden');
                this.root.classList.add('ql-editing');

                if (preview != null) {
                  this.textbox.value = preview;
                } else if (mode !== this.root.getAttribute('data-mode')) {
                  this.textbox.value = '';
                }

                this.position(this.quill.getBounds(this.quill.selection.savedRange));
                this.textbox.select();
                this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
                this.root.setAttribute('data-mode', mode);
              }
            }, {
              key: 'restoreFocus',
              value: function restoreFocus() {
                var scrollTop = this.quill.scrollingContainer.scrollTop;
                this.quill.focus();
                this.quill.scrollingContainer.scrollTop = scrollTop;
              }
            }, {
              key: 'save',
              value: function save() {
                var value = this.textbox.value;

                switch (this.root.getAttribute('data-mode')) {
                  case 'link':
                    {
                      var scrollTop = this.quill.root.scrollTop;

                      if (this.linkRange) {
                        this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);
                        delete this.linkRange;
                      } else {
                        this.restoreFocus();
                        this.quill.format('link', value, _emitter2.default.sources.USER);
                      }

                      this.quill.root.scrollTop = scrollTop;
                      break;
                    }

                  case 'video':
                    {
                      value = extractVideoUrl(value);
                    }

                  case 'formula':
                    {
                      if (!value) break;
                      var range = this.quill.getSelection(true);

                      if (range != null) {
                        var index = range.index + range.length;
                        this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);

                        if (this.root.getAttribute('data-mode') === 'formula') {
                          this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);
                        }

                        this.quill.setSelection(index + 2, _emitter2.default.sources.USER);
                      }

                      break;
                    }
                }

                this.textbox.value = '';
                this.hide();
              }
            }]);

            return BaseTooltip;
          }(_tooltip2.default);

          function extractVideoUrl(url) {
            var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);

            if (match) {
              return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
            }

            if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
              return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
            }

            return url;
          }

          function fillSelect(select, values) {
            var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            values.forEach(function (value) {
              var option = document.createElement('option');

              if (value === defaultValue) {
                option.setAttribute('selected', 'selected');
              } else {
                option.setAttribute('value', value);
              }

              select.appendChild(option);
            });
          }

          exports.BaseTooltip = BaseTooltip;
          exports.default = BaseTheme;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var LinkedList = function () {
            function LinkedList() {
              this.head = this.tail = null;
              this.length = 0;
            }

            LinkedList.prototype.append = function () {
              var nodes = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
              }

              this.insertBefore(nodes[0], null);

              if (nodes.length > 1) {
                this.append.apply(this, nodes.slice(1));
              }
            };

            LinkedList.prototype.contains = function (node) {
              var cur,
                  next = this.iterator();

              while (cur = next()) {
                if (cur === node) return true;
              }

              return false;
            };

            LinkedList.prototype.insertBefore = function (node, refNode) {
              if (!node) return;
              node.next = refNode;

              if (refNode != null) {
                node.prev = refNode.prev;

                if (refNode.prev != null) {
                  refNode.prev.next = node;
                }

                refNode.prev = node;

                if (refNode === this.head) {
                  this.head = node;
                }
              } else if (this.tail != null) {
                this.tail.next = node;
                node.prev = this.tail;
                this.tail = node;
              } else {
                node.prev = null;
                this.head = this.tail = node;
              }

              this.length += 1;
            };

            LinkedList.prototype.offset = function (target) {
              var index = 0,
                  cur = this.head;

              while (cur != null) {
                if (cur === target) return index;
                index += cur.length();
                cur = cur.next;
              }

              return -1;
            };

            LinkedList.prototype.remove = function (node) {
              if (!this.contains(node)) return;
              if (node.prev != null) node.prev.next = node.next;
              if (node.next != null) node.next.prev = node.prev;
              if (node === this.head) this.head = node.next;
              if (node === this.tail) this.tail = node.prev;
              this.length -= 1;
            };

            LinkedList.prototype.iterator = function (curNode) {
              if (curNode === void 0) {
                curNode = this.head;
              }

              return function () {
                var ret = curNode;
                if (curNode != null) curNode = curNode.next;
                return ret;
              };
            };

            LinkedList.prototype.find = function (index, inclusive) {
              if (inclusive === void 0) {
                inclusive = false;
              }

              var cur,
                  next = this.iterator();

              while (cur = next()) {
                var length = cur.length();

                if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {
                  return [cur, index];
                }

                index -= length;
              }

              return [null, 0];
            };

            LinkedList.prototype.forEach = function (callback) {
              var cur,
                  next = this.iterator();

              while (cur = next()) {
                callback(cur);
              }
            };

            LinkedList.prototype.forEachAt = function (index, length, callback) {
              if (length <= 0) return;

              var _a = this.find(index),
                  startNode = _a[0],
                  offset = _a[1];

              var cur,
                  curIndex = index - offset,
                  next = this.iterator(startNode);

              while ((cur = next()) && curIndex < index + length) {
                var curLength = cur.length();

                if (index > curIndex) {
                  callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
                } else {
                  callback(cur, 0, Math.min(curLength, index + length - curIndex));
                }

                curIndex += curLength;
              }
            };

            LinkedList.prototype.map = function (callback) {
              return this.reduce(function (memo, cur) {
                memo.push(callback(cur));
                return memo;
              }, []);
            };

            LinkedList.prototype.reduce = function (callback, memo) {
              var cur,
                  next = this.iterator();

              while (cur = next()) {
                memo = callback(memo, cur);
              }

              return memo;
            };

            return LinkedList;
          }();

          exports.default = LinkedList;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var container_1 = __webpack_require__(17);

          var Registry = __webpack_require__(1);

          var OBSERVER_CONFIG = {
            attributes: true,
            characterData: true,
            characterDataOldValue: true,
            childList: true,
            subtree: true
          };
          var MAX_OPTIMIZE_ITERATIONS = 100;

          var ScrollBlot = function (_super) {
            __extends(ScrollBlot, _super);

            function ScrollBlot(node) {
              var _this = _super.call(this, node) || this;

              _this.scroll = _this;
              _this.observer = new MutationObserver(function (mutations) {
                _this.update(mutations);
              });

              _this.observer.observe(_this.domNode, OBSERVER_CONFIG);

              _this.attach();

              return _this;
            }

            ScrollBlot.prototype.detach = function () {
              _super.prototype.detach.call(this);

              this.observer.disconnect();
            };

            ScrollBlot.prototype.deleteAt = function (index, length) {
              this.update();

              if (index === 0 && length === this.length()) {
                this.children.forEach(function (child) {
                  child.remove();
                });
              } else {
                _super.prototype.deleteAt.call(this, index, length);
              }
            };

            ScrollBlot.prototype.formatAt = function (index, length, name, value) {
              this.update();

              _super.prototype.formatAt.call(this, index, length, name, value);
            };

            ScrollBlot.prototype.insertAt = function (index, value, def) {
              this.update();

              _super.prototype.insertAt.call(this, index, value, def);
            };

            ScrollBlot.prototype.optimize = function (mutations, context) {
              var _this = this;

              if (mutations === void 0) {
                mutations = [];
              }

              if (context === void 0) {
                context = {};
              }

              _super.prototype.optimize.call(this, context);

              var records = [].slice.call(this.observer.takeRecords());

              while (records.length > 0) mutations.push(records.pop());

              var mark = function (blot, markParent) {
                if (markParent === void 0) {
                  markParent = true;
                }

                if (blot == null || blot === _this) return;
                if (blot.domNode.parentNode == null) return;

                if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                  blot.domNode[Registry.DATA_KEY].mutations = [];
                }

                if (markParent) mark(blot.parent);
              };

              var optimize = function (blot) {
                if (blot.domNode[Registry.DATA_KEY] == null || blot.domNode[Registry.DATA_KEY].mutations == null) {
                  return;
                }

                if (blot instanceof container_1.default) {
                  blot.children.forEach(optimize);
                }

                blot.optimize(context);
              };

              var remaining = mutations;

              for (var i = 0; remaining.length > 0; i += 1) {
                if (i >= MAX_OPTIMIZE_ITERATIONS) {
                  throw new Error('[Parchment] Maximum optimize iterations reached');
                }

                remaining.forEach(function (mutation) {
                  var blot = Registry.find(mutation.target, true);
                  if (blot == null) return;

                  if (blot.domNode === mutation.target) {
                    if (mutation.type === 'childList') {
                      mark(Registry.find(mutation.previousSibling, false));
                      [].forEach.call(mutation.addedNodes, function (node) {
                        var child = Registry.find(node, false);
                        mark(child, false);

                        if (child instanceof container_1.default) {
                          child.children.forEach(function (grandChild) {
                            mark(grandChild, false);
                          });
                        }
                      });
                    } else if (mutation.type === 'attributes') {
                      mark(blot.prev);
                    }
                  }

                  mark(blot);
                });
                this.children.forEach(optimize);
                remaining = [].slice.call(this.observer.takeRecords());
                records = remaining.slice();

                while (records.length > 0) mutations.push(records.pop());
              }
            };

            ScrollBlot.prototype.update = function (mutations, context) {
              var _this = this;

              if (context === void 0) {
                context = {};
              }

              mutations = mutations || this.observer.takeRecords();
              mutations.map(function (mutation) {
                var blot = Registry.find(mutation.target, true);
                if (blot == null) return null;

                if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                  blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                  return blot;
                } else {
                  blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                  return null;
                }
              }).forEach(function (blot) {
                if (blot == null || blot === _this || blot.domNode[Registry.DATA_KEY] == null) return;
                blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
              });

              if (this.domNode[Registry.DATA_KEY].mutations != null) {
                _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
              }

              this.optimize(mutations, context);
            };

            ScrollBlot.blotName = 'scroll';
            ScrollBlot.defaultChild = 'block';
            ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
            ScrollBlot.tagName = 'DIV';
            return ScrollBlot;
          }(container_1.default);

          exports.default = ScrollBlot;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var format_1 = __webpack_require__(18);

          var Registry = __webpack_require__(1);

          function isEqual(obj1, obj2) {
            if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;

            for (var prop in obj1) {
              if (obj1[prop] !== obj2[prop]) return false;
            }

            return true;
          }

          var InlineBlot = function (_super) {
            __extends(InlineBlot, _super);

            function InlineBlot() {
              return _super !== null && _super.apply(this, arguments) || this;
            }

            InlineBlot.formats = function (domNode) {
              if (domNode.tagName === InlineBlot.tagName) return undefined;
              return _super.formats.call(this, domNode);
            };

            InlineBlot.prototype.format = function (name, value) {
              var _this = this;

              if (name === this.statics.blotName && !value) {
                this.children.forEach(function (child) {
                  if (!(child instanceof format_1.default)) {
                    child = child.wrap(InlineBlot.blotName, true);
                  }

                  _this.attributes.copy(child);
                });
                this.unwrap();
              } else {
                _super.prototype.format.call(this, name, value);
              }
            };

            InlineBlot.prototype.formatAt = function (index, length, name, value) {
              if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
                var blot = this.isolate(index, length);
                blot.format(name, value);
              } else {
                _super.prototype.formatAt.call(this, index, length, name, value);
              }
            };

            InlineBlot.prototype.optimize = function (context) {
              _super.prototype.optimize.call(this, context);

              var formats = this.formats();

              if (Object.keys(formats).length === 0) {
                return this.unwrap();
              }

              var next = this.next;

              if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
                next.moveChildren(this);
                next.remove();
              }
            };

            InlineBlot.blotName = 'inline';
            InlineBlot.scope = Registry.Scope.INLINE_BLOT;
            InlineBlot.tagName = 'SPAN';
            return InlineBlot;
          }(format_1.default);

          exports.default = InlineBlot;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var format_1 = __webpack_require__(18);

          var Registry = __webpack_require__(1);

          var BlockBlot = function (_super) {
            __extends(BlockBlot, _super);

            function BlockBlot() {
              return _super !== null && _super.apply(this, arguments) || this;
            }

            BlockBlot.formats = function (domNode) {
              var tagName = Registry.query(BlockBlot.blotName).tagName;
              if (domNode.tagName === tagName) return undefined;
              return _super.formats.call(this, domNode);
            };

            BlockBlot.prototype.format = function (name, value) {
              if (Registry.query(name, Registry.Scope.BLOCK) == null) {
                return;
              } else if (name === this.statics.blotName && !value) {
                this.replaceWith(BlockBlot.blotName);
              } else {
                _super.prototype.format.call(this, name, value);
              }
            };

            BlockBlot.prototype.formatAt = function (index, length, name, value) {
              if (Registry.query(name, Registry.Scope.BLOCK) != null) {
                this.format(name, value);
              } else {
                _super.prototype.formatAt.call(this, index, length, name, value);
              }
            };

            BlockBlot.prototype.insertAt = function (index, value, def) {
              if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                _super.prototype.insertAt.call(this, index, value, def);
              } else {
                var after = this.split(index);
                var blot = Registry.create(value, def);
                after.parent.insertBefore(blot, after);
              }
            };

            BlockBlot.prototype.update = function (mutations, context) {
              if (navigator.userAgent.match(/Trident/)) {
                this.build();
              } else {
                _super.prototype.update.call(this, mutations, context);
              }
            };

            BlockBlot.blotName = 'block';
            BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
            BlockBlot.tagName = 'P';
            return BlockBlot;
          }(format_1.default);

          exports.default = BlockBlot;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var leaf_1 = __webpack_require__(19);

          var EmbedBlot = function (_super) {
            __extends(EmbedBlot, _super);

            function EmbedBlot() {
              return _super !== null && _super.apply(this, arguments) || this;
            }

            EmbedBlot.formats = function (domNode) {
              return undefined;
            };

            EmbedBlot.prototype.format = function (name, value) {
              _super.prototype.formatAt.call(this, 0, this.length(), name, value);
            };

            EmbedBlot.prototype.formatAt = function (index, length, name, value) {
              if (index === 0 && length === this.length()) {
                this.format(name, value);
              } else {
                _super.prototype.formatAt.call(this, index, length, name, value);
              }
            };

            EmbedBlot.prototype.formats = function () {
              return this.statics.formats(this.domNode);
            };

            return EmbedBlot;
          }(leaf_1.default);

          exports.default = EmbedBlot;
        }, function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function () {
            var extendStatics = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (d, b) {
              d.__proto__ = b;
            } || function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

            return function (d, b) {
              extendStatics(d, b);

              function __() {
                this.constructor = d;
              }

              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var leaf_1 = __webpack_require__(19);

          var Registry = __webpack_require__(1);

          var TextBlot = function (_super) {
            __extends(TextBlot, _super);

            function TextBlot(node) {
              var _this = _super.call(this, node) || this;

              _this.text = _this.statics.value(_this.domNode);
              return _this;
            }

            TextBlot.create = function (value) {
              return document.createTextNode(value);
            };

            TextBlot.value = function (domNode) {
              var text = domNode.data;
              if (text['normalize']) text = text['normalize']();
              return text;
            };

            TextBlot.prototype.deleteAt = function (index, length) {
              this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
            };

            TextBlot.prototype.index = function (node, offset) {
              if (this.domNode === node) {
                return offset;
              }

              return -1;
            };

            TextBlot.prototype.insertAt = function (index, value, def) {
              if (def == null) {
                this.text = this.text.slice(0, index) + value + this.text.slice(index);
                this.domNode.data = this.text;
              } else {
                _super.prototype.insertAt.call(this, index, value, def);
              }
            };

            TextBlot.prototype.length = function () {
              return this.text.length;
            };

            TextBlot.prototype.optimize = function (context) {
              _super.prototype.optimize.call(this, context);

              this.text = this.statics.value(this.domNode);

              if (this.text.length === 0) {
                this.remove();
              } else if (this.next instanceof TextBlot && this.next.prev === this) {
                this.insertAt(this.length(), this.next.value());
                this.next.remove();
              }
            };

            TextBlot.prototype.position = function (index, inclusive) {

              return [this.domNode, index];
            };

            TextBlot.prototype.split = function (index, force) {
              if (force === void 0) {
                force = false;
              }

              if (!force) {
                if (index === 0) return this;
                if (index === this.length()) return this.next;
              }

              var after = Registry.create(this.domNode.splitText(index));
              this.parent.insertBefore(after, this.next);
              this.text = this.statics.value(this.domNode);
              return after;
            };

            TextBlot.prototype.update = function (mutations, context) {
              var _this = this;

              if (mutations.some(function (mutation) {
                return mutation.type === 'characterData' && mutation.target === _this.domNode;
              })) {
                this.text = this.statics.value(this.domNode);
              }
            };

            TextBlot.prototype.value = function () {
              return this.text;
            };

            TextBlot.blotName = 'text';
            TextBlot.scope = Registry.Scope.INLINE_BLOT;
            return TextBlot;
          }(leaf_1.default);

          exports.default = TextBlot;
        }, function (module, exports, __webpack_require__) {
          var elem = document.createElement('div');
          elem.classList.toggle('test-class', false);

          if (elem.classList.contains('test-class')) {
            var _toggle = DOMTokenList.prototype.toggle;

            DOMTokenList.prototype.toggle = function (token, force) {
              if (arguments.length > 1 && !this.contains(token) === !force) {
                return force;
              } else {
                return _toggle.call(this, token);
              }
            };
          }

          if (!String.prototype.startsWith) {
            String.prototype.startsWith = function (searchString, position) {
              position = position || 0;
              return this.substr(position, searchString.length) === searchString;
            };
          }

          if (!String.prototype.endsWith) {
            String.prototype.endsWith = function (searchString, position) {
              var subjectString = this.toString();

              if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
                position = subjectString.length;
              }

              position -= searchString.length;
              var lastIndex = subjectString.indexOf(searchString, position);
              return lastIndex !== -1 && lastIndex === position;
            };
          }

          if (!Array.prototype.find) {
            Object.defineProperty(Array.prototype, "find", {
              value: function value(predicate) {
                if (this === null) {
                  throw new TypeError('Array.prototype.find called on null or undefined');
                }

                if (typeof predicate !== 'function') {
                  throw new TypeError('predicate must be a function');
                }

                var list = Object(this);
                var length = list.length >>> 0;
                var thisArg = arguments[1];
                var value;

                for (var i = 0; i < length; i++) {
                  value = list[i];

                  if (predicate.call(thisArg, value, i, list)) {
                    return value;
                  }
                }

                return undefined;
              }
            });
          }

          document.addEventListener("DOMContentLoaded", function () {
            document.execCommand("enableObjectResizing", false, false);
            document.execCommand("autoUrlDetect", false, false);
          });
        }, function (module, exports) {
          var DIFF_DELETE = -1;
          var DIFF_INSERT = 1;
          var DIFF_EQUAL = 0;

          function diff_main(text1, text2, cursor_pos) {
            if (text1 == text2) {
              if (text1) {
                return [[DIFF_EQUAL, text1]];
              }

              return [];
            }

            if (cursor_pos < 0 || text1.length < cursor_pos) {
              cursor_pos = null;
            }

            var commonlength = diff_commonPrefix(text1, text2);
            var commonprefix = text1.substring(0, commonlength);
            text1 = text1.substring(commonlength);
            text2 = text2.substring(commonlength);
            commonlength = diff_commonSuffix(text1, text2);
            var commonsuffix = text1.substring(text1.length - commonlength);
            text1 = text1.substring(0, text1.length - commonlength);
            text2 = text2.substring(0, text2.length - commonlength);
            var diffs = diff_compute_(text1, text2);

            if (commonprefix) {
              diffs.unshift([DIFF_EQUAL, commonprefix]);
            }

            if (commonsuffix) {
              diffs.push([DIFF_EQUAL, commonsuffix]);
            }

            diff_cleanupMerge(diffs);

            if (cursor_pos != null) {
              diffs = fix_cursor(diffs, cursor_pos);
            }

            diffs = fix_emoji(diffs);
            return diffs;
          }

          function diff_compute_(text1, text2) {
            var diffs;

            if (!text1) {
              return [[DIFF_INSERT, text2]];
            }

            if (!text2) {
              return [[DIFF_DELETE, text1]];
            }

            var longtext = text1.length > text2.length ? text1 : text2;
            var shorttext = text1.length > text2.length ? text2 : text1;
            var i = longtext.indexOf(shorttext);

            if (i != -1) {
              diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];

              if (text1.length > text2.length) {
                diffs[0][0] = diffs[2][0] = DIFF_DELETE;
              }

              return diffs;
            }

            if (shorttext.length == 1) {
              return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
            }

            var hm = diff_halfMatch_(text1, text2);

            if (hm) {
              var text1_a = hm[0];
              var text1_b = hm[1];
              var text2_a = hm[2];
              var text2_b = hm[3];
              var mid_common = hm[4];
              var diffs_a = diff_main(text1_a, text2_a);
              var diffs_b = diff_main(text1_b, text2_b);
              return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
            }

            return diff_bisect_(text1, text2);
          }

          function diff_bisect_(text1, text2) {
            var text1_length = text1.length;
            var text2_length = text2.length;
            var max_d = Math.ceil((text1_length + text2_length) / 2);
            var v_offset = max_d;
            var v_length = 2 * max_d;
            var v1 = new Array(v_length);
            var v2 = new Array(v_length);

            for (var x = 0; x < v_length; x++) {
              v1[x] = -1;
              v2[x] = -1;
            }

            v1[v_offset + 1] = 0;
            v2[v_offset + 1] = 0;
            var delta = text1_length - text2_length;
            var front = delta % 2 != 0;
            var k1start = 0;
            var k1end = 0;
            var k2start = 0;
            var k2end = 0;

            for (var d = 0; d < max_d; d++) {
              for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                var k1_offset = v_offset + k1;
                var x1;

                if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                  x1 = v1[k1_offset + 1];
                } else {
                  x1 = v1[k1_offset - 1] + 1;
                }

                var y1 = x1 - k1;

                while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                  x1++;
                  y1++;
                }

                v1[k1_offset] = x1;

                if (x1 > text1_length) {
                  k1end += 2;
                } else if (y1 > text2_length) {
                  k1start += 2;
                } else if (front) {
                  var k2_offset = v_offset + delta - k1;

                  if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                    var x2 = text1_length - v2[k2_offset];

                    if (x1 >= x2) {
                      return diff_bisectSplit_(text1, text2, x1, y1);
                    }
                  }
                }
              }

              for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                var k2_offset = v_offset + k2;
                var x2;

                if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                  x2 = v2[k2_offset + 1];
                } else {
                  x2 = v2[k2_offset - 1] + 1;
                }

                var y2 = x2 - k2;

                while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
                  x2++;
                  y2++;
                }

                v2[k2_offset] = x2;

                if (x2 > text1_length) {
                  k2end += 2;
                } else if (y2 > text2_length) {
                  k2start += 2;
                } else if (!front) {
                  var k1_offset = v_offset + delta - k2;

                  if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                    var x1 = v1[k1_offset];
                    var y1 = v_offset + x1 - k1_offset;
                    x2 = text1_length - x2;

                    if (x1 >= x2) {
                      return diff_bisectSplit_(text1, text2, x1, y1);
                    }
                  }
                }
              }
            }

            return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
          }

          function diff_bisectSplit_(text1, text2, x, y) {
            var text1a = text1.substring(0, x);
            var text2a = text2.substring(0, y);
            var text1b = text1.substring(x);
            var text2b = text2.substring(y);
            var diffs = diff_main(text1a, text2a);
            var diffsb = diff_main(text1b, text2b);
            return diffs.concat(diffsb);
          }

          function diff_commonPrefix(text1, text2) {
            if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
              return 0;
            }

            var pointermin = 0;
            var pointermax = Math.min(text1.length, text2.length);
            var pointermid = pointermax;
            var pointerstart = 0;

            while (pointermin < pointermid) {
              if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
                pointermin = pointermid;
                pointerstart = pointermin;
              } else {
                pointermax = pointermid;
              }

              pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }

            return pointermid;
          }

          function diff_commonSuffix(text1, text2) {
            if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
              return 0;
            }

            var pointermin = 0;
            var pointermax = Math.min(text1.length, text2.length);
            var pointermid = pointermax;
            var pointerend = 0;

            while (pointermin < pointermid) {
              if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                pointermin = pointermid;
                pointerend = pointermin;
              } else {
                pointermax = pointermid;
              }

              pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }

            return pointermid;
          }

          function diff_halfMatch_(text1, text2) {
            var longtext = text1.length > text2.length ? text1 : text2;
            var shorttext = text1.length > text2.length ? text2 : text1;

            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
              return null;
            }

            function diff_halfMatchI_(longtext, shorttext, i) {
              var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
              var j = -1;
              var best_common = '';
              var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;

              while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
                var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
                var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));

                if (best_common.length < suffixLength + prefixLength) {
                  best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                  best_longtext_a = longtext.substring(0, i - suffixLength);
                  best_longtext_b = longtext.substring(i + prefixLength);
                  best_shorttext_a = shorttext.substring(0, j - suffixLength);
                  best_shorttext_b = shorttext.substring(j + prefixLength);
                }
              }

              if (best_common.length * 2 >= longtext.length) {
                return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
              } else {
                return null;
              }
            }

            var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
            var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
            var hm;

            if (!hm1 && !hm2) {
              return null;
            } else if (!hm2) {
              hm = hm1;
            } else if (!hm1) {
              hm = hm2;
            } else {
              hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
            }

            var text1_a, text1_b, text2_a, text2_b;

            if (text1.length > text2.length) {
              text1_a = hm[0];
              text1_b = hm[1];
              text2_a = hm[2];
              text2_b = hm[3];
            } else {
              text2_a = hm[0];
              text2_b = hm[1];
              text1_a = hm[2];
              text1_b = hm[3];
            }

            var mid_common = hm[4];
            return [text1_a, text1_b, text2_a, text2_b, mid_common];
          }

          function diff_cleanupMerge(diffs) {
            diffs.push([DIFF_EQUAL, '']);
            var pointer = 0;
            var count_delete = 0;
            var count_insert = 0;
            var text_delete = '';
            var text_insert = '';
            var commonlength;

            while (pointer < diffs.length) {
              switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                  count_insert++;
                  text_insert += diffs[pointer][1];
                  pointer++;
                  break;

                case DIFF_DELETE:
                  count_delete++;
                  text_delete += diffs[pointer][1];
                  pointer++;
                  break;

                case DIFF_EQUAL:
                  if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                      commonlength = diff_commonPrefix(text_insert, text_delete);

                      if (commonlength !== 0) {
                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                          diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                        } else {
                          diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                          pointer++;
                        }

                        text_insert = text_insert.substring(commonlength);
                        text_delete = text_delete.substring(commonlength);
                      }

                      commonlength = diff_commonSuffix(text_insert, text_delete);

                      if (commonlength !== 0) {
                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                        text_insert = text_insert.substring(0, text_insert.length - commonlength);
                        text_delete = text_delete.substring(0, text_delete.length - commonlength);
                      }
                    }

                    if (count_delete === 0) {
                      diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
                    } else if (count_insert === 0) {
                      diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
                    } else {
                      diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                    }

                    pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                  } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - 1][1] += diffs[pointer][1];
                    diffs.splice(pointer, 1);
                  } else {
                    pointer++;
                  }

                  count_insert = 0;
                  count_delete = 0;
                  text_delete = '';
                  text_insert = '';
                  break;
              }
            }

            if (diffs[diffs.length - 1][1] === '') {
              diffs.pop();
            }

            var changes = false;
            pointer = 1;

            while (pointer < diffs.length - 1) {
              if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
                if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                  diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                  diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                  diffs.splice(pointer - 1, 1);
                  changes = true;
                } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                  diffs[pointer - 1][1] += diffs[pointer + 1][1];
                  diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                  diffs.splice(pointer + 1, 1);
                  changes = true;
                }
              }

              pointer++;
            }

            if (changes) {
              diff_cleanupMerge(diffs);
            }
          }

          var diff = diff_main;
          diff.INSERT = DIFF_INSERT;
          diff.DELETE = DIFF_DELETE;
          diff.EQUAL = DIFF_EQUAL;
          module.exports = diff;

          function cursor_normalize_diff(diffs, cursor_pos) {
            if (cursor_pos === 0) {
              return [DIFF_EQUAL, diffs];
            }

            for (var current_pos = 0, i = 0; i < diffs.length; i++) {
              var d = diffs[i];

              if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
                var next_pos = current_pos + d[1].length;

                if (cursor_pos === next_pos) {
                  return [i + 1, diffs];
                } else if (cursor_pos < next_pos) {
                  diffs = diffs.slice();
                  var split_pos = cursor_pos - current_pos;
                  var d_left = [d[0], d[1].slice(0, split_pos)];
                  var d_right = [d[0], d[1].slice(split_pos)];
                  diffs.splice(i, 1, d_left, d_right);
                  return [i + 1, diffs];
                } else {
                  current_pos = next_pos;
                }
              }
            }

            throw new Error('cursor_pos is out of bounds!');
          }

          function fix_cursor(diffs, cursor_pos) {
            var norm = cursor_normalize_diff(diffs, cursor_pos);
            var ndiffs = norm[1];
            var cursor_pointer = norm[0];
            var d = ndiffs[cursor_pointer];
            var d_next = ndiffs[cursor_pointer + 1];

            if (d == null) {
              return diffs;
            } else if (d[0] !== DIFF_EQUAL) {
              return diffs;
            } else {
              if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
                ndiffs.splice(cursor_pointer, 2, d_next, d);
                return merge_tuples(ndiffs, cursor_pointer, 2);
              } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
                ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
                var suffix = d_next[1].slice(d[1].length);

                if (suffix.length > 0) {
                  ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
                }

                return merge_tuples(ndiffs, cursor_pointer, 3);
              } else {
                return diffs;
              }
            }
          }

          function fix_emoji(diffs) {
            var compact = false;

            var starts_with_pair_end = function (str) {
              return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
            };

            var ends_with_pair_start = function (str) {
              return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
            };

            for (var i = 2; i < diffs.length; i += 1) {
              if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
                compact = true;
                diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
                diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
                diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
              }
            }

            if (!compact) {
              return diffs;
            }

            var fixed_diffs = [];

            for (var i = 0; i < diffs.length; i += 1) {
              if (diffs[i][1].length > 0) {
                fixed_diffs.push(diffs[i]);
              }
            }

            return fixed_diffs;
          }

          function merge_tuples(diffs, start, length) {
            for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
              if (i + 1 < diffs.length) {
                var left_d = diffs[i];
                var right_d = diffs[i + 1];

                if (left_d[0] === right_d[1]) {
                  diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
                }
              }
            }

            return diffs;
          }
        }, function (module, exports) {
          exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
          exports.shim = shim;

          function shim(obj) {
            var keys = [];

            for (var key in obj) keys.push(key);

            return keys;
          }
        }, function (module, exports) {
          var supportsArgumentsClass = function () {
            return Object.prototype.toString.call(arguments);
          }() == '[object Arguments]';

          exports = module.exports = supportsArgumentsClass ? supported : unsupported;
          exports.supported = supported;

          function supported(object) {
            return Object.prototype.toString.call(object) == '[object Arguments]';
          }

          exports.unsupported = unsupported;

          function unsupported(object) {
            return object && typeof object == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
          }
        }, function (module, exports) {
          var has = Object.prototype.hasOwnProperty,
              prefix = '~';

          function Events() {}

          if (Object.create) {
            Events.prototype = Object.create(null);
            if (!new Events().__proto__) prefix = false;
          }

          function EE(fn, context, once) {
            this.fn = fn;
            this.context = context;
            this.once = once || false;
          }

          function EventEmitter() {
            this._events = new Events();
            this._eventsCount = 0;
          }

          EventEmitter.prototype.eventNames = function eventNames() {
            var names = [],
                events,
                name;
            if (this._eventsCount === 0) return names;

            for (name in events = this._events) {
              if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
            }

            if (Object.getOwnPropertySymbols) {
              return names.concat(Object.getOwnPropertySymbols(events));
            }

            return names;
          };

          EventEmitter.prototype.listeners = function listeners(event, exists) {
            var evt = prefix ? prefix + event : event,
                available = this._events[evt];
            if (exists) return !!available;
            if (!available) return [];
            if (available.fn) return [available.fn];

            for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
              ee[i] = available[i].fn;
            }

            return ee;
          };

          EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return false;
            var listeners = this._events[evt],
                len = arguments.length,
                args,
                i;

            if (listeners.fn) {
              if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

              switch (len) {
                case 1:
                  return listeners.fn.call(listeners.context), true;

                case 2:
                  return listeners.fn.call(listeners.context, a1), true;

                case 3:
                  return listeners.fn.call(listeners.context, a1, a2), true;

                case 4:
                  return listeners.fn.call(listeners.context, a1, a2, a3), true;

                case 5:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

                case 6:
                  return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
              }

              for (i = 1, args = new Array(len - 1); i < len; i++) {
                args[i - 1] = arguments[i];
              }

              listeners.fn.apply(listeners.context, args);
            } else {
              var length = listeners.length,
                  j;

              for (i = 0; i < length; i++) {
                if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

                switch (len) {
                  case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;

                  case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;

                  case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;

                  case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;

                  default:
                    if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                    listeners[i].fn.apply(listeners[i].context, args);
                }
              }
            }

            return true;
          };

          EventEmitter.prototype.on = function on(event, fn, context) {
            var listener = new EE(fn, context || this),
                evt = prefix ? prefix + event : event;
            if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
            return this;
          };

          EventEmitter.prototype.once = function once(event, fn, context) {
            var listener = new EE(fn, context || this, true),
                evt = prefix ? prefix + event : event;
            if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
            return this;
          };

          EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return this;

            if (!fn) {
              if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
              return this;
            }

            var listeners = this._events[evt];

            if (listeners.fn) {
              if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
              }
            } else {
              for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                  events.push(listeners[i]);
                }
              }

              if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
            }

            return this;
          };

          EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
            var evt;

            if (event) {
              evt = prefix ? prefix + event : event;

              if (this._events[evt]) {
                if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];
              }
            } else {
              this._events = new Events();
              this._eventsCount = 0;
            }

            return this;
          };

          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.addListener = EventEmitter.prototype.on;

          EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
            return this;
          };

          EventEmitter.prefixed = prefix;
          EventEmitter.EventEmitter = EventEmitter;

          if ('undefined' !== typeof module) {
            module.exports = EventEmitter;
          }
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;

          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
            return typeof obj;
          } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _extend2 = __webpack_require__(3);

          var _extend3 = _interopRequireDefault(_extend2);

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _quill = __webpack_require__(5);

          var _quill2 = _interopRequireDefault(_quill);

          var _logger = __webpack_require__(10);

          var _logger2 = _interopRequireDefault(_logger);

          var _module = __webpack_require__(9);

          var _module2 = _interopRequireDefault(_module);

          var _align = __webpack_require__(36);

          var _background = __webpack_require__(37);

          var _code = __webpack_require__(13);

          var _code2 = _interopRequireDefault(_code);

          var _color = __webpack_require__(26);

          var _direction = __webpack_require__(38);

          var _font = __webpack_require__(39);

          var _size = __webpack_require__(40);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }

            return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var debug = (0, _logger2.default)('quill:clipboard');
          var DOM_KEY = '__ql-matcher';
          var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];
          var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
            memo[attr.keyName] = attr;
            return memo;
          }, {});
          var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
            memo[attr.keyName] = attr;
            return memo;
          }, {});

          var Clipboard = function (_Module) {
            _inherits(Clipboard, _Module);

            function Clipboard(quill, options) {
              _classCallCheck(this, Clipboard);

              var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));

              _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));

              _this.container = _this.quill.addContainer('ql-clipboard');

              _this.container.setAttribute('contenteditable', true);

              _this.container.setAttribute('tabindex', -1);

              _this.matchers = [];
              CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                    selector = _ref2[0],
                    matcher = _ref2[1];

                if (!options.matchVisual && matcher === matchSpacing) return;

                _this.addMatcher(selector, matcher);
              });
              return _this;
            }

            _createClass(Clipboard, [{
              key: 'addMatcher',
              value: function addMatcher(selector, matcher) {
                this.matchers.push([selector, matcher]);
              }
            }, {
              key: 'convert',
              value: function convert(html) {
                if (typeof html === 'string') {
                  this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><');
                  return this.convert();
                }

                var formats = this.quill.getFormat(this.quill.selection.savedRange.index);

                if (formats[_code2.default.blotName]) {
                  var text = this.container.innerText;
                  this.container.innerHTML = '';
                  return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));
                }

                var _prepareMatching = this.prepareMatching(),
                    _prepareMatching2 = _slicedToArray(_prepareMatching, 2),
                    elementMatchers = _prepareMatching2[0],
                    textMatchers = _prepareMatching2[1];

                var delta = traverse(this.container, elementMatchers, textMatchers);

                if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
                  delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
                }

                debug.log('convert', this.container.innerHTML, delta);
                this.container.innerHTML = '';
                return delta;
              }
            }, {
              key: 'dangerouslyPasteHTML',
              value: function dangerouslyPasteHTML(index, html) {
                var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;

                if (typeof index === 'string') {
                  this.quill.setContents(this.convert(index), html);
                  this.quill.setSelection(0, _quill2.default.sources.SILENT);
                } else {
                  var paste = this.convert(html);
                  this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);
                  this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);
                }
              }
            }, {
              key: 'onPaste',
              value: function onPaste(e) {
                var _this2 = this;

                if (e.defaultPrevented || !this.quill.isEnabled()) return;
                var range = this.quill.getSelection();
                var delta = new _quillDelta2.default().retain(range.index);
                var scrollTop = this.quill.scrollingContainer.scrollTop;
                this.container.focus();
                this.quill.selection.update(_quill2.default.sources.SILENT);
                setTimeout(function () {
                  delta = delta.concat(_this2.convert()).delete(range.length);

                  _this2.quill.updateContents(delta, _quill2.default.sources.USER);

                  _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);

                  _this2.quill.scrollingContainer.scrollTop = scrollTop;

                  _this2.quill.focus();
                }, 1);
              }
            }, {
              key: 'prepareMatching',
              value: function prepareMatching() {
                var _this3 = this;

                var elementMatchers = [],
                    textMatchers = [];
                this.matchers.forEach(function (pair) {
                  var _pair = _slicedToArray(pair, 2),
                      selector = _pair[0],
                      matcher = _pair[1];

                  switch (selector) {
                    case Node.TEXT_NODE:
                      textMatchers.push(matcher);
                      break;

                    case Node.ELEMENT_NODE:
                      elementMatchers.push(matcher);
                      break;

                    default:
                      [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
                        node[DOM_KEY] = node[DOM_KEY] || [];
                        node[DOM_KEY].push(matcher);
                      });
                      break;
                  }
                });
                return [elementMatchers, textMatchers];
              }
            }]);

            return Clipboard;
          }(_module2.default);

          Clipboard.DEFAULTS = {
            matchers: [],
            matchVisual: true
          };

          function applyFormat(delta, format, value) {
            if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
              return Object.keys(format).reduce(function (delta, key) {
                return applyFormat(delta, key, format[key]);
              }, delta);
            } else {
              return delta.reduce(function (delta, op) {
                if (op.attributes && op.attributes[format]) {
                  return delta.push(op);
                } else {
                  return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));
                }
              }, new _quillDelta2.default());
            }
          }

          function computeStyle(node) {
            if (node.nodeType !== Node.ELEMENT_NODE) return {};
            var DOM_KEY = '__ql-computed-style';
            return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
          }

          function deltaEndsWith(delta, text) {
            var endText = "";

            for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
              var op = delta.ops[i];
              if (typeof op.insert !== 'string') break;
              endText = op.insert + endText;
            }

            return endText.slice(-1 * text.length) === text;
          }

          function isLine(node) {
            if (node.childNodes.length === 0) return false;
            var style = computeStyle(node);
            return ['block', 'list-item'].indexOf(style.display) > -1;
          }

          function traverse(node, elementMatchers, textMatchers) {
            if (node.nodeType === node.TEXT_NODE) {
              return textMatchers.reduce(function (delta, matcher) {
                return matcher(node, delta);
              }, new _quillDelta2.default());
            } else if (node.nodeType === node.ELEMENT_NODE) {
              return [].reduce.call(node.childNodes || [], function (delta, childNode) {
                var childrenDelta = traverse(childNode, elementMatchers, textMatchers);

                if (childNode.nodeType === node.ELEMENT_NODE) {
                  childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
                    return matcher(childNode, childrenDelta);
                  }, childrenDelta);
                  childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
                    return matcher(childNode, childrenDelta);
                  }, childrenDelta);
                }

                return delta.concat(childrenDelta);
              }, new _quillDelta2.default());
            } else {
              return new _quillDelta2.default();
            }
          }

          function matchAlias(format, node, delta) {
            return applyFormat(delta, format, true);
          }

          function matchAttributor(node, delta) {
            var attributes = _parchment2.default.Attributor.Attribute.keys(node);

            var classes = _parchment2.default.Attributor.Class.keys(node);

            var styles = _parchment2.default.Attributor.Style.keys(node);

            var formats = {};
            attributes.concat(classes).concat(styles).forEach(function (name) {
              var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);

              if (attr != null) {
                formats[attr.attrName] = attr.value(node);
                if (formats[attr.attrName]) return;
              }

              attr = ATTRIBUTE_ATTRIBUTORS[name];

              if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                formats[attr.attrName] = attr.value(node) || undefined;
              }

              attr = STYLE_ATTRIBUTORS[name];

              if (attr != null && (attr.attrName === name || attr.keyName === name)) {
                attr = STYLE_ATTRIBUTORS[name];
                formats[attr.attrName] = attr.value(node) || undefined;
              }
            });

            if (Object.keys(formats).length > 0) {
              delta = applyFormat(delta, formats);
            }

            return delta;
          }

          function matchBlot(node, delta) {
            var match = _parchment2.default.query(node);

            if (match == null) return delta;

            if (match.prototype instanceof _parchment2.default.Embed) {
              var embed = {};
              var value = match.value(node);

              if (value != null) {
                embed[match.blotName] = value;
                delta = new _quillDelta2.default().insert(embed, match.formats(node));
              }
            } else if (typeof match.formats === 'function') {
              delta = applyFormat(delta, match.blotName, match.formats(node));
            }

            return delta;
          }

          function matchBreak(node, delta) {
            if (!deltaEndsWith(delta, '\n')) {
              delta.insert('\n');
            }

            return delta;
          }

          function matchIgnore() {
            return new _quillDelta2.default();
          }

          function matchIndent(node, delta) {
            var match = _parchment2.default.query(node);

            if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
              return delta;
            }

            var indent = -1,
                parent = node.parentNode;

            while (!parent.classList.contains('ql-clipboard')) {
              if ((_parchment2.default.query(parent) || {}).blotName === 'list') {
                indent += 1;
              }

              parent = parent.parentNode;
            }

            if (indent <= 0) return delta;
            return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, {
              indent: indent
            }));
          }

          function matchNewline(node, delta) {
            if (!deltaEndsWith(delta, '\n')) {
              if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
                delta.insert('\n');
              }
            }

            return delta;
          }

          function matchSpacing(node, delta) {
            if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
              var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);

              if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
                delta.insert('\n');
              }
            }

            return delta;
          }

          function matchStyles(node, delta) {
            var formats = {};
            var style = node.style || {};

            if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
              formats.italic = true;
            }

            if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
              formats.bold = true;
            }

            if (Object.keys(formats).length > 0) {
              delta = applyFormat(delta, formats);
            }

            if (parseFloat(style.textIndent || 0) > 0) {
              delta = new _quillDelta2.default().insert('\t').concat(delta);
            }

            return delta;
          }

          function matchText(node, delta) {
            var text = node.data;

            if (node.parentNode.tagName === 'O:P') {
              return delta.insert(text.trim());
            }

            if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
              return delta;
            }

            if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
              var replacer = function replacer(collapse, match) {
                match = match.replace(/[^\u00a0]/g, '');
                return match.length < 1 && collapse ? ' ' : match;
              };

              text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
              text = text.replace(/\s\s+/g, replacer.bind(replacer, true));

              if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
                text = text.replace(/^\s+/, replacer.bind(replacer, false));
              }

              if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
                text = text.replace(/\s+$/, replacer.bind(replacer, false));
              }
            }

            return delta.insert(text);
          }

          exports.default = Clipboard;
          exports.matchAttributor = matchAttributor;
          exports.matchBlot = matchBlot;
          exports.matchNewline = matchNewline;
          exports.matchSpacing = matchSpacing;
          exports.matchText = matchText;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Bold = function (_Inline) {
            _inherits(Bold, _Inline);

            function Bold() {
              _classCallCheck(this, Bold);

              return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
            }

            _createClass(Bold, [{
              key: 'optimize',
              value: function optimize(context) {
                _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);

                if (this.domNode.tagName !== this.statics.tagName[0]) {
                  this.replaceWith(this.statics.blotName);
                }
              }
            }], [{
              key: 'create',
              value: function create() {
                return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
              }
            }, {
              key: 'formats',
              value: function formats() {
                return true;
              }
            }]);

            return Bold;
          }(_inline2.default);

          Bold.blotName = 'bold';
          Bold.tagName = ['STRONG', 'B'];
          exports.default = Bold;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.addControls = exports.default = undefined;

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _quillDelta = __webpack_require__(2);

          var _quillDelta2 = _interopRequireDefault(_quillDelta);

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _quill = __webpack_require__(5);

          var _quill2 = _interopRequireDefault(_quill);

          var _logger = __webpack_require__(10);

          var _logger2 = _interopRequireDefault(_logger);

          var _module = __webpack_require__(9);

          var _module2 = _interopRequireDefault(_module);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }

            return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var debug = (0, _logger2.default)('quill:toolbar');

          var Toolbar = function (_Module) {
            _inherits(Toolbar, _Module);

            function Toolbar(quill, options) {
              _classCallCheck(this, Toolbar);

              var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));

              if (Array.isArray(_this.options.container)) {
                var container = document.createElement('div');
                addControls(container, _this.options.container);
                quill.container.parentNode.insertBefore(container, quill.container);
                _this.container = container;
              } else if (typeof _this.options.container === 'string') {
                _this.container = document.querySelector(_this.options.container);
              } else {
                _this.container = _this.options.container;
              }

              if (!(_this.container instanceof HTMLElement)) {
                var _ret;

                return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
              }

              _this.container.classList.add('ql-toolbar');

              _this.controls = [];
              _this.handlers = {};
              Object.keys(_this.options.handlers).forEach(function (format) {
                _this.addHandler(format, _this.options.handlers[format]);
              });
              [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
                _this.attach(input);
              });

              _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {
                if (type === _quill2.default.events.SELECTION_CHANGE) {
                  _this.update(range);
                }
              });

              _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                var _this$quill$selection = _this.quill.selection.getRange(),
                    _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
                    range = _this$quill$selection2[0];

                _this.update(range);
              });

              return _this;
            }

            _createClass(Toolbar, [{
              key: 'addHandler',
              value: function addHandler(format, handler) {
                this.handlers[format] = handler;
              }
            }, {
              key: 'attach',
              value: function attach(input) {
                var _this2 = this;

                var format = [].find.call(input.classList, function (className) {
                  return className.indexOf('ql-') === 0;
                });
                if (!format) return;
                format = format.slice('ql-'.length);

                if (input.tagName === 'BUTTON') {
                  input.setAttribute('type', 'button');
                }

                if (this.handlers[format] == null) {
                  if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
                    debug.warn('ignoring attaching to disabled format', format, input);
                    return;
                  }

                  if (_parchment2.default.query(format) == null) {
                    debug.warn('ignoring attaching to nonexistent format', format, input);
                    return;
                  }
                }

                var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
                input.addEventListener(eventName, function (e) {
                  var value = void 0;

                  if (input.tagName === 'SELECT') {
                    if (input.selectedIndex < 0) return;
                    var selected = input.options[input.selectedIndex];

                    if (selected.hasAttribute('selected')) {
                      value = false;
                    } else {
                      value = selected.value || false;
                    }
                  } else {
                    if (input.classList.contains('ql-active')) {
                      value = false;
                    } else {
                      value = input.value || !input.hasAttribute('value');
                    }

                    e.preventDefault();
                  }

                  _this2.quill.focus();

                  var _quill$selection$getR = _this2.quill.selection.getRange(),
                      _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),
                      range = _quill$selection$getR2[0];

                  if (_this2.handlers[format] != null) {
                    _this2.handlers[format].call(_this2, value);
                  } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
                    value = prompt('Enter ' + format);
                    if (!value) return;

                    _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);
                  } else {
                    _this2.quill.format(format, value, _quill2.default.sources.USER);
                  }

                  _this2.update(range);
                });
                this.controls.push([format, input]);
              }
            }, {
              key: 'update',
              value: function update(range) {
                var formats = range == null ? {} : this.quill.getFormat(range);
                this.controls.forEach(function (pair) {
                  var _pair = _slicedToArray(pair, 2),
                      format = _pair[0],
                      input = _pair[1];

                  if (input.tagName === 'SELECT') {
                    var option = void 0;

                    if (range == null) {
                      option = null;
                    } else if (formats[format] == null) {
                      option = input.querySelector('option[selected]');
                    } else if (!Array.isArray(formats[format])) {
                      var value = formats[format];

                      if (typeof value === 'string') {
                        value = value.replace(/\"/g, '\\"');
                      }

                      option = input.querySelector('option[value="' + value + '"]');
                    }

                    if (option == null) {
                      input.value = '';
                      input.selectedIndex = -1;
                    } else {
                      option.selected = true;
                    }
                  } else {
                    if (range == null) {
                      input.classList.remove('ql-active');
                    } else if (input.hasAttribute('value')) {
                      var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
                      input.classList.toggle('ql-active', isActive);
                    } else {
                      input.classList.toggle('ql-active', formats[format] != null);
                    }
                  }
                });
              }
            }]);

            return Toolbar;
          }(_module2.default);

          Toolbar.DEFAULTS = {};

          function addButton(container, format, value) {
            var input = document.createElement('button');
            input.setAttribute('type', 'button');
            input.classList.add('ql-' + format);

            if (value != null) {
              input.value = value;
            }

            container.appendChild(input);
          }

          function addControls(container, groups) {
            if (!Array.isArray(groups[0])) {
              groups = [groups];
            }

            groups.forEach(function (controls) {
              var group = document.createElement('span');
              group.classList.add('ql-formats');
              controls.forEach(function (control) {
                if (typeof control === 'string') {
                  addButton(group, control);
                } else {
                  var format = Object.keys(control)[0];
                  var value = control[format];

                  if (Array.isArray(value)) {
                    addSelect(group, format, value);
                  } else {
                    addButton(group, format, value);
                  }
                }
              });
              container.appendChild(group);
            });
          }

          function addSelect(container, format, values) {
            var input = document.createElement('select');
            input.classList.add('ql-' + format);
            values.forEach(function (value) {
              var option = document.createElement('option');

              if (value !== false) {
                option.setAttribute('value', value);
              } else {
                option.setAttribute('selected', 'selected');
              }

              input.appendChild(option);
            });
            container.appendChild(input);
          }

          Toolbar.DEFAULTS = {
            container: null,
            handlers: {
              clean: function clean() {
                var _this3 = this;

                var range = this.quill.getSelection();
                if (range == null) return;

                if (range.length == 0) {
                  var formats = this.quill.getFormat();
                  Object.keys(formats).forEach(function (name) {
                    if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                      _this3.quill.format(name, false);
                    }
                  });
                } else {
                  this.quill.removeFormat(range, _quill2.default.sources.USER);
                }
              },
              direction: function direction(value) {
                var align = this.quill.getFormat()['align'];

                if (value === 'rtl' && align == null) {
                  this.quill.format('align', 'right', _quill2.default.sources.USER);
                } else if (!value && align === 'right') {
                  this.quill.format('align', false, _quill2.default.sources.USER);
                }

                this.quill.format('direction', value, _quill2.default.sources.USER);
              },
              indent: function indent(value) {
                var range = this.quill.getSelection();
                var formats = this.quill.getFormat(range);
                var indent = parseInt(formats.indent || 0);

                if (value === '+1' || value === '-1') {
                  var modifier = value === '+1' ? 1 : -1;
                  if (formats.direction === 'rtl') modifier *= -1;
                  this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);
                }
              },
              link: function link(value) {
                if (value === true) {
                  value = prompt('Enter link URL:');
                }

                this.quill.format('link', value, _quill2.default.sources.USER);
              },
              list: function list(value) {
                var range = this.quill.getSelection();
                var formats = this.quill.getFormat(range);

                if (value === 'check') {
                  if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
                    this.quill.format('list', false, _quill2.default.sources.USER);
                  } else {
                    this.quill.format('list', 'unchecked', _quill2.default.sources.USER);
                  }
                } else {
                  this.quill.format('list', value, _quill2.default.sources.USER);
                }
              }
            }
          };
          exports.default = Toolbar;
          exports.addControls = addControls;
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _picker = __webpack_require__(28);

          var _picker2 = _interopRequireDefault(_picker);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var ColorPicker = function (_Picker) {
            _inherits(ColorPicker, _Picker);

            function ColorPicker(select, label) {
              _classCallCheck(this, ColorPicker);

              var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));

              _this.label.innerHTML = label;

              _this.container.classList.add('ql-color-picker');

              [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
                item.classList.add('ql-primary');
              });
              return _this;
            }

            _createClass(ColorPicker, [{
              key: 'buildItem',
              value: function buildItem(option) {
                var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);

                item.style.backgroundColor = option.getAttribute('value') || '';
                return item;
              }
            }, {
              key: 'selectItem',
              value: function selectItem(item, trigger) {
                _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);

                var colorLabel = this.label.querySelector('.ql-color-label');
                var value = item ? item.getAttribute('data-value') || '' : '';

                if (colorLabel) {
                  if (colorLabel.tagName === 'line') {
                    colorLabel.style.stroke = value;
                  } else {
                    colorLabel.style.fill = value;
                  }
                }
              }
            }]);

            return ColorPicker;
          }(_picker2.default);

          exports.default = ColorPicker;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _picker = __webpack_require__(28);

          var _picker2 = _interopRequireDefault(_picker);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var IconPicker = function (_Picker) {
            _inherits(IconPicker, _Picker);

            function IconPicker(select, icons) {
              _classCallCheck(this, IconPicker);

              var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));

              _this.container.classList.add('ql-icon-picker');

              [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
                item.innerHTML = icons[item.getAttribute('data-value') || ''];
              });
              _this.defaultItem = _this.container.querySelector('.ql-selected');

              _this.selectItem(_this.defaultItem);

              return _this;
            }

            _createClass(IconPicker, [{
              key: 'selectItem',
              value: function selectItem(item, trigger) {
                _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);

                item = item || this.defaultItem;
                this.label.innerHTML = item.innerHTML;
              }
            }]);

            return IconPicker;
          }(_picker2.default);

          exports.default = IconPicker;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var Tooltip = function () {
            function Tooltip(quill, boundsContainer) {
              var _this = this;

              _classCallCheck(this, Tooltip);

              this.quill = quill;
              this.boundsContainer = boundsContainer || document.body;
              this.root = quill.addContainer('ql-tooltip');
              this.root.innerHTML = this.constructor.TEMPLATE;

              if (this.quill.root === this.quill.scrollingContainer) {
                this.quill.root.addEventListener('scroll', function () {
                  _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
                });
              }

              this.hide();
            }

            _createClass(Tooltip, [{
              key: 'hide',
              value: function hide() {
                this.root.classList.add('ql-hidden');
              }
            }, {
              key: 'position',
              value: function position(reference) {
                var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
                var top = reference.bottom + this.quill.root.scrollTop;
                this.root.style.left = left + 'px';
                this.root.style.top = top + 'px';
                this.root.classList.remove('ql-flip');
                var containerBounds = this.boundsContainer.getBoundingClientRect();
                var rootBounds = this.root.getBoundingClientRect();
                var shift = 0;

                if (rootBounds.right > containerBounds.right) {
                  shift = containerBounds.right - rootBounds.right;
                  this.root.style.left = left + shift + 'px';
                }

                if (rootBounds.left < containerBounds.left) {
                  shift = containerBounds.left - rootBounds.left;
                  this.root.style.left = left + shift + 'px';
                }

                if (rootBounds.bottom > containerBounds.bottom) {
                  var height = rootBounds.bottom - rootBounds.top;
                  var verticalShift = reference.bottom - reference.top + height;
                  this.root.style.top = top - verticalShift + 'px';
                  this.root.classList.add('ql-flip');
                }

                return shift;
              }
            }, {
              key: 'show',
              value: function show() {
                this.root.classList.remove('ql-editing');
                this.root.classList.remove('ql-hidden');
              }
            }]);

            return Tooltip;
          }();

          exports.default = Tooltip;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;

              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);

                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }

              return _arr;
            }

            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _extend = __webpack_require__(3);

          var _extend2 = _interopRequireDefault(_extend);

          var _emitter = __webpack_require__(8);

          var _emitter2 = _interopRequireDefault(_emitter);

          var _base = __webpack_require__(43);

          var _base2 = _interopRequireDefault(_base);

          var _link = __webpack_require__(27);

          var _link2 = _interopRequireDefault(_link);

          var _selection = __webpack_require__(15);

          var _icons = __webpack_require__(41);

          var _icons2 = _interopRequireDefault(_icons);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var TOOLBAR_CONFIG = [[{
            header: ['1', '2', '3', false]
          }], ['bold', 'italic', 'underline', 'link'], [{
            list: 'ordered'
          }, {
            list: 'bullet'
          }], ['clean']];

          var SnowTheme = function (_BaseTheme) {
            _inherits(SnowTheme, _BaseTheme);

            function SnowTheme(quill, options) {
              _classCallCheck(this, SnowTheme);

              if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                options.modules.toolbar.container = TOOLBAR_CONFIG;
              }

              var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));

              _this.quill.container.classList.add('ql-snow');

              return _this;
            }

            _createClass(SnowTheme, [{
              key: 'extendToolbar',
              value: function extendToolbar(toolbar) {
                toolbar.container.classList.add('ql-snow');
                this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
                this.tooltip = new SnowTooltip(this.quill, this.options.bounds);

                if (toolbar.container.querySelector('.ql-link')) {
                  this.quill.keyboard.addBinding({
                    key: 'K',
                    shortKey: true
                  }, function (range, context) {
                    toolbar.handlers['link'].call(toolbar, !context.format.link);
                  });
                }
              }
            }]);

            return SnowTheme;
          }(_base2.default);

          SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  link: function link(value) {
                    if (value) {
                      var range = this.quill.getSelection();
                      if (range == null || range.length == 0) return;
                      var preview = this.quill.getText(range);

                      if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
                        preview = 'mailto:' + preview;
                      }

                      var tooltip = this.quill.theme.tooltip;
                      tooltip.edit('link', preview);
                    } else {
                      this.quill.format('link', false);
                    }
                  }
                }
              }
            }
          });

          var SnowTooltip = function (_BaseTooltip) {
            _inherits(SnowTooltip, _BaseTooltip);

            function SnowTooltip(quill, bounds) {
              _classCallCheck(this, SnowTooltip);

              var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));

              _this2.preview = _this2.root.querySelector('a.ql-preview');
              return _this2;
            }

            _createClass(SnowTooltip, [{
              key: 'listen',
              value: function listen() {
                var _this3 = this;

                _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);

                this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
                  if (_this3.root.classList.contains('ql-editing')) {
                    _this3.save();
                  } else {
                    _this3.edit('link', _this3.preview.textContent);
                  }

                  event.preventDefault();
                });
                this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
                  if (_this3.linkRange != null) {
                    var range = _this3.linkRange;

                    _this3.restoreFocus();

                    _this3.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);

                    delete _this3.linkRange;
                  }

                  event.preventDefault();

                  _this3.hide();
                });
                this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function (range, oldRange, source) {
                  if (range == null) return;

                  if (range.length === 0 && source === _emitter2.default.sources.USER) {
                    var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index),
                        _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                        link = _quill$scroll$descend2[0],
                        offset = _quill$scroll$descend2[1];

                    if (link != null) {
                      _this3.linkRange = new _selection.Range(range.index - offset, link.length());

                      var preview = _link2.default.formats(link.domNode);

                      _this3.preview.textContent = preview;

                      _this3.preview.setAttribute('href', preview);

                      _this3.show();

                      _this3.position(_this3.quill.getBounds(_this3.linkRange));

                      return;
                    }
                  } else {
                    delete _this3.linkRange;
                  }

                  _this3.hide();
                });
              }
            }, {
              key: 'show',
              value: function show() {
                _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);

                this.root.removeAttribute('data-mode');
              }
            }]);

            return SnowTooltip;
          }(_base.BaseTooltip);

          SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');
          exports.default = SnowTheme;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _core = __webpack_require__(29);

          var _core2 = _interopRequireDefault(_core);

          var _align = __webpack_require__(36);

          var _direction = __webpack_require__(38);

          var _indent = __webpack_require__(64);

          var _blockquote = __webpack_require__(65);

          var _blockquote2 = _interopRequireDefault(_blockquote);

          var _header = __webpack_require__(66);

          var _header2 = _interopRequireDefault(_header);

          var _list = __webpack_require__(67);

          var _list2 = _interopRequireDefault(_list);

          var _background = __webpack_require__(37);

          var _color = __webpack_require__(26);

          var _font = __webpack_require__(39);

          var _size = __webpack_require__(40);

          var _bold = __webpack_require__(56);

          var _bold2 = _interopRequireDefault(_bold);

          var _italic = __webpack_require__(68);

          var _italic2 = _interopRequireDefault(_italic);

          var _link = __webpack_require__(27);

          var _link2 = _interopRequireDefault(_link);

          var _script = __webpack_require__(69);

          var _script2 = _interopRequireDefault(_script);

          var _strike = __webpack_require__(70);

          var _strike2 = _interopRequireDefault(_strike);

          var _underline = __webpack_require__(71);

          var _underline2 = _interopRequireDefault(_underline);

          var _image = __webpack_require__(72);

          var _image2 = _interopRequireDefault(_image);

          var _video = __webpack_require__(73);

          var _video2 = _interopRequireDefault(_video);

          var _code = __webpack_require__(13);

          var _code2 = _interopRequireDefault(_code);

          var _formula = __webpack_require__(74);

          var _formula2 = _interopRequireDefault(_formula);

          var _syntax = __webpack_require__(75);

          var _syntax2 = _interopRequireDefault(_syntax);

          var _toolbar = __webpack_require__(57);

          var _toolbar2 = _interopRequireDefault(_toolbar);

          var _icons = __webpack_require__(41);

          var _icons2 = _interopRequireDefault(_icons);

          var _picker = __webpack_require__(28);

          var _picker2 = _interopRequireDefault(_picker);

          var _colorPicker = __webpack_require__(59);

          var _colorPicker2 = _interopRequireDefault(_colorPicker);

          var _iconPicker = __webpack_require__(60);

          var _iconPicker2 = _interopRequireDefault(_iconPicker);

          var _tooltip = __webpack_require__(61);

          var _tooltip2 = _interopRequireDefault(_tooltip);

          var _bubble = __webpack_require__(108);

          var _bubble2 = _interopRequireDefault(_bubble);

          var _snow = __webpack_require__(62);

          var _snow2 = _interopRequireDefault(_snow);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          _core2.default.register({
            'attributors/attribute/direction': _direction.DirectionAttribute,
            'attributors/class/align': _align.AlignClass,
            'attributors/class/background': _background.BackgroundClass,
            'attributors/class/color': _color.ColorClass,
            'attributors/class/direction': _direction.DirectionClass,
            'attributors/class/font': _font.FontClass,
            'attributors/class/size': _size.SizeClass,
            'attributors/style/align': _align.AlignStyle,
            'attributors/style/background': _background.BackgroundStyle,
            'attributors/style/color': _color.ColorStyle,
            'attributors/style/direction': _direction.DirectionStyle,
            'attributors/style/font': _font.FontStyle,
            'attributors/style/size': _size.SizeStyle
          }, true);

          _core2.default.register({
            'formats/align': _align.AlignClass,
            'formats/direction': _direction.DirectionClass,
            'formats/indent': _indent.IndentClass,
            'formats/background': _background.BackgroundStyle,
            'formats/color': _color.ColorStyle,
            'formats/font': _font.FontClass,
            'formats/size': _size.SizeClass,
            'formats/blockquote': _blockquote2.default,
            'formats/code-block': _code2.default,
            'formats/header': _header2.default,
            'formats/list': _list2.default,
            'formats/bold': _bold2.default,
            'formats/code': _code.Code,
            'formats/italic': _italic2.default,
            'formats/link': _link2.default,
            'formats/script': _script2.default,
            'formats/strike': _strike2.default,
            'formats/underline': _underline2.default,
            'formats/image': _image2.default,
            'formats/video': _video2.default,
            'formats/list/item': _list.ListItem,
            'modules/formula': _formula2.default,
            'modules/syntax': _syntax2.default,
            'modules/toolbar': _toolbar2.default,
            'themes/bubble': _bubble2.default,
            'themes/snow': _snow2.default,
            'ui/icons': _icons2.default,
            'ui/picker': _picker2.default,
            'ui/icon-picker': _iconPicker2.default,
            'ui/color-picker': _colorPicker2.default,
            'ui/tooltip': _tooltip2.default
          }, true);

          exports.default = _core2.default;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.IndentClass = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var IdentAttributor = function (_Parchment$Attributor) {
            _inherits(IdentAttributor, _Parchment$Attributor);

            function IdentAttributor() {
              _classCallCheck(this, IdentAttributor);

              return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
            }

            _createClass(IdentAttributor, [{
              key: 'add',
              value: function add(node, value) {
                if (value === '+1' || value === '-1') {
                  var indent = this.value(node) || 0;
                  value = value === '+1' ? indent + 1 : indent - 1;
                }

                if (value === 0) {
                  this.remove(node);
                  return true;
                } else {
                  return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
                }
              }
            }, {
              key: 'canAdd',
              value: function canAdd(node, value) {
                return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
              }
            }, {
              key: 'value',
              value: function value(node) {
                return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined;
              }
            }]);

            return IdentAttributor;
          }(_parchment2.default.Attributor.Class);

          var IndentClass = new IdentAttributor('indent', 'ql-indent', {
            scope: _parchment2.default.Scope.BLOCK,
            whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
          });
          exports.IndentClass = IndentClass;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Blockquote = function (_Block) {
            _inherits(Blockquote, _Block);

            function Blockquote() {
              _classCallCheck(this, Blockquote);

              return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
            }

            return Blockquote;
          }(_block2.default);

          Blockquote.blotName = 'blockquote';
          Blockquote.tagName = 'blockquote';
          exports.default = Blockquote;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Header = function (_Block) {
            _inherits(Header, _Block);

            function Header() {
              _classCallCheck(this, Header);

              return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
            }

            _createClass(Header, null, [{
              key: 'formats',
              value: function formats(domNode) {
                return this.tagName.indexOf(domNode.tagName) + 1;
              }
            }]);

            return Header;
          }(_block2.default);

          Header.blotName = 'header';
          Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
          exports.default = Header;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.ListItem = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _block = __webpack_require__(4);

          var _block2 = _interopRequireDefault(_block);

          var _container = __webpack_require__(25);

          var _container2 = _interopRequireDefault(_container);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }

            return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var ListItem = function (_Block) {
            _inherits(ListItem, _Block);

            function ListItem() {
              _classCallCheck(this, ListItem);

              return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
            }

            _createClass(ListItem, [{
              key: 'format',
              value: function format(name, value) {
                if (name === List.blotName && !value) {
                  this.replaceWith(_parchment2.default.create(this.statics.scope));
                } else {
                  _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
                }
              }
            }, {
              key: 'remove',
              value: function remove() {
                if (this.prev == null && this.next == null) {
                  this.parent.remove();
                } else {
                  _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
                }
              }
            }, {
              key: 'replaceWith',
              value: function replaceWith(name, value) {
                this.parent.isolate(this.offset(this.parent), this.length());

                if (name === this.parent.statics.blotName) {
                  this.parent.replaceWith(name, value);
                  return this;
                } else {
                  this.parent.unwrap();
                  return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
                }
              }
            }], [{
              key: 'formats',
              value: function formats(domNode) {
                return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
              }
            }]);

            return ListItem;
          }(_block2.default);

          ListItem.blotName = 'list-item';
          ListItem.tagName = 'LI';

          var List = function (_Container) {
            _inherits(List, _Container);

            _createClass(List, null, [{
              key: 'create',
              value: function create(value) {
                var tagName = value === 'ordered' ? 'OL' : 'UL';

                var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);

                if (value === 'checked' || value === 'unchecked') {
                  node.setAttribute('data-checked', value === 'checked');
                }

                return node;
              }
            }, {
              key: 'formats',
              value: function formats(domNode) {
                if (domNode.tagName === 'OL') return 'ordered';

                if (domNode.tagName === 'UL') {
                  if (domNode.hasAttribute('data-checked')) {
                    return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
                  } else {
                    return 'bullet';
                  }
                }

                return undefined;
              }
            }]);

            function List(domNode) {
              _classCallCheck(this, List);

              var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));

              var listEventHandler = function listEventHandler(e) {
                if (e.target.parentNode !== domNode) return;

                var format = _this2.statics.formats(domNode);

                var blot = _parchment2.default.find(e.target);

                if (format === 'checked') {
                  blot.format('list', 'unchecked');
                } else if (format === 'unchecked') {
                  blot.format('list', 'checked');
                }
              };

              domNode.addEventListener('touchstart', listEventHandler);
              domNode.addEventListener('mousedown', listEventHandler);
              return _this2;
            }

            _createClass(List, [{
              key: 'format',
              value: function format(name, value) {
                if (this.children.length > 0) {
                  this.children.tail.format(name, value);
                }
              }
            }, {
              key: 'formats',
              value: function formats() {
                return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
              }
            }, {
              key: 'insertBefore',
              value: function insertBefore(blot, ref) {
                if (blot instanceof ListItem) {
                  _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
                } else {
                  var index = ref == null ? this.length() : ref.offset(this);
                  var after = this.split(index);
                  after.parent.insertBefore(blot, after);
                }
              }
            }, {
              key: 'optimize',
              value: function optimize(context) {
                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);

                var next = this.next;

                if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
                  next.moveChildren(this);
                  next.remove();
                }
              }
            }, {
              key: 'replace',
              value: function replace(target) {
                if (target.statics.blotName !== this.statics.blotName) {
                  var item = _parchment2.default.create(this.statics.defaultChild);

                  target.moveChildren(item);
                  this.appendChild(item);
                }

                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
              }
            }]);

            return List;
          }(_container2.default);

          List.blotName = 'list';
          List.scope = _parchment2.default.Scope.BLOCK_BLOT;
          List.tagName = ['OL', 'UL'];
          List.defaultChild = 'list-item';
          List.allowedChildren = [ListItem];
          exports.ListItem = ListItem;
          exports.default = List;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _bold = __webpack_require__(56);

          var _bold2 = _interopRequireDefault(_bold);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Italic = function (_Bold) {
            _inherits(Italic, _Bold);

            function Italic() {
              _classCallCheck(this, Italic);

              return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
            }

            return Italic;
          }(_bold2.default);

          Italic.blotName = 'italic';
          Italic.tagName = ['EM', 'I'];
          exports.default = Italic;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Script = function (_Inline) {
            _inherits(Script, _Inline);

            function Script() {
              _classCallCheck(this, Script);

              return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
            }

            _createClass(Script, null, [{
              key: 'create',
              value: function create(value) {
                if (value === 'super') {
                  return document.createElement('sup');
                } else if (value === 'sub') {
                  return document.createElement('sub');
                } else {
                  return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
                }
              }
            }, {
              key: 'formats',
              value: function formats(domNode) {
                if (domNode.tagName === 'SUB') return 'sub';
                if (domNode.tagName === 'SUP') return 'super';
                return undefined;
              }
            }]);

            return Script;
          }(_inline2.default);

          Script.blotName = 'script';
          Script.tagName = ['SUB', 'SUP'];
          exports.default = Script;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Strike = function (_Inline) {
            _inherits(Strike, _Inline);

            function Strike() {
              _classCallCheck(this, Strike);

              return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
            }

            return Strike;
          }(_inline2.default);

          Strike.blotName = 'strike';
          Strike.tagName = 'S';
          exports.default = Strike;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _inline = __webpack_require__(6);

          var _inline2 = _interopRequireDefault(_inline);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var Underline = function (_Inline) {
            _inherits(Underline, _Inline);

            function Underline() {
              _classCallCheck(this, Underline);

              return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
            }

            return Underline;
          }(_inline2.default);

          Underline.blotName = 'underline';
          Underline.tagName = 'U';
          exports.default = Underline;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _link = __webpack_require__(27);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var ATTRIBUTES = ['alt', 'height', 'width'];

          var Image = function (_Parchment$Embed) {
            _inherits(Image, _Parchment$Embed);

            function Image() {
              _classCallCheck(this, Image);

              return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
            }

            _createClass(Image, [{
              key: 'format',
              value: function format(name, value) {
                if (ATTRIBUTES.indexOf(name) > -1) {
                  if (value) {
                    this.domNode.setAttribute(name, value);
                  } else {
                    this.domNode.removeAttribute(name);
                  }
                } else {
                  _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
                }
              }
            }], [{
              key: 'create',
              value: function create(value) {
                var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);

                if (typeof value === 'string') {
                  node.setAttribute('src', this.sanitize(value));
                }

                return node;
              }
            }, {
              key: 'formats',
              value: function formats(domNode) {
                return ATTRIBUTES.reduce(function (formats, attribute) {
                  if (domNode.hasAttribute(attribute)) {
                    formats[attribute] = domNode.getAttribute(attribute);
                  }

                  return formats;
                }, {});
              }
            }, {
              key: 'match',
              value: function match(url) {
                return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
              }
            }, {
              key: 'sanitize',
              value: function sanitize(url) {
                return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
              }
            }, {
              key: 'value',
              value: function value(domNode) {
                return domNode.getAttribute('src');
              }
            }]);

            return Image;
          }(_parchment2.default.Embed);

          Image.blotName = 'image';
          Image.tagName = 'IMG';
          exports.default = Image;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _block = __webpack_require__(4);

          var _link = __webpack_require__(27);

          var _link2 = _interopRequireDefault(_link);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var ATTRIBUTES = ['height', 'width'];

          var Video = function (_BlockEmbed) {
            _inherits(Video, _BlockEmbed);

            function Video() {
              _classCallCheck(this, Video);

              return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
            }

            _createClass(Video, [{
              key: 'format',
              value: function format(name, value) {
                if (ATTRIBUTES.indexOf(name) > -1) {
                  if (value) {
                    this.domNode.setAttribute(name, value);
                  } else {
                    this.domNode.removeAttribute(name);
                  }
                } else {
                  _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
                }
              }
            }], [{
              key: 'create',
              value: function create(value) {
                var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);

                node.setAttribute('frameborder', '0');
                node.setAttribute('allowfullscreen', true);
                node.setAttribute('src', this.sanitize(value));
                return node;
              }
            }, {
              key: 'formats',
              value: function formats(domNode) {
                return ATTRIBUTES.reduce(function (formats, attribute) {
                  if (domNode.hasAttribute(attribute)) {
                    formats[attribute] = domNode.getAttribute(attribute);
                  }

                  return formats;
                }, {});
              }
            }, {
              key: 'sanitize',
              value: function sanitize(url) {
                return _link2.default.sanitize(url);
              }
            }, {
              key: 'value',
              value: function value(domNode) {
                return domNode.getAttribute('src');
              }
            }]);

            return Video;
          }(_block.BlockEmbed);

          Video.blotName = 'video';
          Video.className = 'ql-video';
          Video.tagName = 'IFRAME';
          exports.default = Video;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.FormulaBlot = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _embed = __webpack_require__(35);

          var _embed2 = _interopRequireDefault(_embed);

          var _quill = __webpack_require__(5);

          var _quill2 = _interopRequireDefault(_quill);

          var _module = __webpack_require__(9);

          var _module2 = _interopRequireDefault(_module);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var FormulaBlot = function (_Embed) {
            _inherits(FormulaBlot, _Embed);

            function FormulaBlot() {
              _classCallCheck(this, FormulaBlot);

              return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
            }

            _createClass(FormulaBlot, null, [{
              key: 'create',
              value: function create(value) {
                var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);

                if (typeof value === 'string') {
                  window.katex.render(value, node, {
                    throwOnError: false,
                    errorColor: '#f00'
                  });
                  node.setAttribute('data-value', value);
                }

                return node;
              }
            }, {
              key: 'value',
              value: function value(domNode) {
                return domNode.getAttribute('data-value');
              }
            }]);

            return FormulaBlot;
          }(_embed2.default);

          FormulaBlot.blotName = 'formula';
          FormulaBlot.className = 'ql-formula';
          FormulaBlot.tagName = 'SPAN';

          var Formula = function (_Module) {
            _inherits(Formula, _Module);

            _createClass(Formula, null, [{
              key: 'register',
              value: function register() {
                _quill2.default.register(FormulaBlot, true);
              }
            }]);

            function Formula() {
              _classCallCheck(this, Formula);

              var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));

              if (window.katex == null) {
                throw new Error('Formula module requires KaTeX.');
              }

              return _this2;
            }

            return Formula;
          }(_module2.default);

          exports.FormulaBlot = FormulaBlot;
          exports.default = Formula;
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.CodeToken = exports.CodeBlock = undefined;

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _parchment = __webpack_require__(0);

          var _parchment2 = _interopRequireDefault(_parchment);

          var _quill = __webpack_require__(5);

          var _quill2 = _interopRequireDefault(_quill);

          var _module = __webpack_require__(9);

          var _module2 = _interopRequireDefault(_module);

          var _code = __webpack_require__(13);

          var _code2 = _interopRequireDefault(_code);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var SyntaxCodeBlock = function (_CodeBlock) {
            _inherits(SyntaxCodeBlock, _CodeBlock);

            function SyntaxCodeBlock() {
              _classCallCheck(this, SyntaxCodeBlock);

              return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
            }

            _createClass(SyntaxCodeBlock, [{
              key: 'replaceWith',
              value: function replaceWith(block) {
                this.domNode.textContent = this.domNode.textContent;
                this.attach();

                _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
              }
            }, {
              key: 'highlight',
              value: function highlight(_highlight) {
                var text = this.domNode.textContent;

                if (this.cachedText !== text) {
                  if (text.trim().length > 0 || this.cachedText == null) {
                    this.domNode.innerHTML = _highlight(text);
                    this.domNode.normalize();
                    this.attach();
                  }

                  this.cachedText = text;
                }
              }
            }]);

            return SyntaxCodeBlock;
          }(_code2.default);

          SyntaxCodeBlock.className = 'ql-syntax';
          var CodeToken = new _parchment2.default.Attributor.Class('token', 'hljs', {
            scope: _parchment2.default.Scope.INLINE
          });

          var Syntax = function (_Module) {
            _inherits(Syntax, _Module);

            _createClass(Syntax, null, [{
              key: 'register',
              value: function register() {
                _quill2.default.register(CodeToken, true);

                _quill2.default.register(SyntaxCodeBlock, true);
              }
            }]);

            function Syntax(quill, options) {
              _classCallCheck(this, Syntax);

              var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));

              if (typeof _this2.options.highlight !== 'function') {
                throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
              }

              var timer = null;

              _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
                clearTimeout(timer);
                timer = setTimeout(function () {
                  _this2.highlight();

                  timer = null;
                }, _this2.options.interval);
              });

              _this2.highlight();

              return _this2;
            }

            _createClass(Syntax, [{
              key: 'highlight',
              value: function highlight() {
                var _this3 = this;

                if (this.quill.selection.composing) return;
                this.quill.update(_quill2.default.sources.USER);
                var range = this.quill.getSelection();
                this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
                  code.highlight(_this3.options.highlight);
                });
                this.quill.update(_quill2.default.sources.SILENT);

                if (range != null) {
                  this.quill.setSelection(range, _quill2.default.sources.SILENT);
                }
              }
            }]);

            return Syntax;
          }(_module2.default);

          Syntax.DEFAULTS = {
            highlight: function () {
              if (window.hljs == null) return null;
              return function (text) {
                var result = window.hljs.highlightAuto(text);
                return result.value;
              };
            }(),
            interval: 1000
          };
          exports.CodeBlock = SyntaxCodeBlock;
          exports.CodeToken = CodeToken;
          exports.default = Syntax;
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";
        }, function (module, exports) {
          module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";
        }, function (module, exports) {
          module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";
        }, function (module, exports) {
          module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";
        }, function (module, exports, __webpack_require__) {
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = exports.BubbleTooltip = undefined;

          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);

            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);

              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ("value" in desc) {
              return desc.value;
            } else {
              var getter = desc.get;

              if (getter === undefined) {
                return undefined;
              }

              return getter.call(receiver);
            }
          };

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var _extend = __webpack_require__(3);

          var _extend2 = _interopRequireDefault(_extend);

          var _emitter = __webpack_require__(8);

          var _emitter2 = _interopRequireDefault(_emitter);

          var _base = __webpack_require__(43);

          var _base2 = _interopRequireDefault(_base);

          var _selection = __webpack_require__(15);

          var _icons = __webpack_require__(41);

          var _icons2 = _interopRequireDefault(_icons);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              default: obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (typeof call === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{
            header: 1
          }, {
            header: 2
          }, 'blockquote']];

          var BubbleTheme = function (_BaseTheme) {
            _inherits(BubbleTheme, _BaseTheme);

            function BubbleTheme(quill, options) {
              _classCallCheck(this, BubbleTheme);

              if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
                options.modules.toolbar.container = TOOLBAR_CONFIG;
              }

              var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));

              _this.quill.container.classList.add('ql-bubble');

              return _this;
            }

            _createClass(BubbleTheme, [{
              key: 'extendToolbar',
              value: function extendToolbar(toolbar) {
                this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
                this.tooltip.root.appendChild(toolbar.container);
                this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
                this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
              }
            }]);

            return BubbleTheme;
          }(_base2.default);

          BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
            modules: {
              toolbar: {
                handlers: {
                  link: function link(value) {
                    if (!value) {
                      this.quill.format('link', false);
                    } else {
                      this.quill.theme.tooltip.edit();
                    }
                  }
                }
              }
            }
          });

          var BubbleTooltip = function (_BaseTooltip) {
            _inherits(BubbleTooltip, _BaseTooltip);

            function BubbleTooltip(quill, bounds) {
              _classCallCheck(this, BubbleTooltip);

              var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));

              _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function (type, range, oldRange, source) {
                if (type !== _emitter2.default.events.SELECTION_CHANGE) return;

                if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
                  _this2.show();

                  _this2.root.style.left = '0px';
                  _this2.root.style.width = '';
                  _this2.root.style.width = _this2.root.offsetWidth + 'px';

                  var lines = _this2.quill.getLines(range.index, range.length);

                  if (lines.length === 1) {
                    _this2.position(_this2.quill.getBounds(range));
                  } else {
                    var lastLine = lines[lines.length - 1];

                    var index = _this2.quill.getIndex(lastLine);

                    var length = Math.min(lastLine.length() - 1, range.index + range.length - index);

                    var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));

                    _this2.position(_bounds);
                  }
                } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                  _this2.hide();
                }
              });

              return _this2;
            }

            _createClass(BubbleTooltip, [{
              key: 'listen',
              value: function listen() {
                var _this3 = this;

                _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);

                this.root.querySelector('.ql-close').addEventListener('click', function () {
                  _this3.root.classList.remove('ql-editing');
                });
                this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function () {
                  setTimeout(function () {
                    if (_this3.root.classList.contains('ql-hidden')) return;

                    var range = _this3.quill.getSelection();

                    if (range != null) {
                      _this3.position(_this3.quill.getBounds(range));
                    }
                  }, 1);
                });
              }
            }, {
              key: 'cancel',
              value: function cancel() {
                this.show();
              }
            }, {
              key: 'position',
              value: function position(reference) {
                var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);

                var arrow = this.root.querySelector('.ql-tooltip-arrow');
                arrow.style.marginLeft = '';
                if (shift === 0) return shift;
                arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
              }
            }]);

            return BubbleTooltip;
          }(_base.BaseTooltip);

          BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');
          exports.BubbleTooltip = BubbleTooltip;
          exports.default = BubbleTheme;
        }, function (module, exports, __webpack_require__) {
          module.exports = __webpack_require__(63);
        }])["default"];
      });
    });
    var Quill$1 = unwrapExports(quill);

    var classCallCheck$1 = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass$1 = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var defineProperty = function (obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    };

    var get = function get(object, property, receiver) {
      if (object === null) object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);

      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);

        if (parent === null) {
          return undefined;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;

        if (getter === undefined) {
          return undefined;
        }

        return getter.call(receiver);
      }
    };

    var inherits = function (subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };

    var possibleConstructorReturn = function (self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };

    var Inline = Quill$1.import('blots/inline');

    var BoldBlot = function (_Inline) {
      inherits(BoldBlot, _Inline);

      function BoldBlot() {
        classCallCheck$1(this, BoldBlot);
        return possibleConstructorReturn(this, (BoldBlot.__proto__ || Object.getPrototypeOf(BoldBlot)).apply(this, arguments));
      }

      return BoldBlot;
    }(Inline);

    BoldBlot.blotName = 'bold';
    BoldBlot.tagName = 'b';
    var Inline$1 = Quill$1.import('blots/inline');

    var ItalicBlot = function (_Inline) {
      inherits(ItalicBlot, _Inline);

      function ItalicBlot() {
        classCallCheck$1(this, ItalicBlot);
        return possibleConstructorReturn(this, (ItalicBlot.__proto__ || Object.getPrototypeOf(ItalicBlot)).apply(this, arguments));
      }

      return ItalicBlot;
    }(Inline$1);

    ItalicBlot.blotName = 'italic';
    ItalicBlot.tagName = 'i';
    var BlockEmbed = Quill$1.import('blots/block/embed');

    var Divider = function (_BlockEmbed) {
      inherits(Divider, _BlockEmbed);

      function Divider() {
        classCallCheck$1(this, Divider);
        return possibleConstructorReturn(this, (Divider.__proto__ || Object.getPrototypeOf(Divider)).apply(this, arguments));
      }

      return Divider;
    }(BlockEmbed);

    Divider.blotName = 'divider';
    Divider.tagName = 'hr';
    var BlockEmbed$1 = Quill$1.import('blots/block/embed');
    var SUPPORTED_ATTRS = ["accept", "action", "align", "alt", "autocomplete", "background", "bgcolor", "border", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "coords", "datetime", "default", "dir", "disabled", "download", "enctype", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "ismap", "label", "lang", "list", "loop", "low", "max", "maxlength", "media", "method", "min", "multiple", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "span", "srclang", "start", "src", "step", "style", "summary", "tabindex", "target", "title", "type", "usemap", "valign", "value", "width", "xmlns"];

    var Table = function (_BlockEmbed) {
      inherits(Table, _BlockEmbed);

      function Table() {
        classCallCheck$1(this, Table);
        return possibleConstructorReturn(this, (Table.__proto__ || Object.getPrototypeOf(Table)).apply(this, arguments));
      }

      createClass$1(Table, null, [{
        key: 'create',
        value: function create(value) {
          var node = get(Table.__proto__ || Object.getPrototypeOf(Table), 'create', this).call(this, value);
          node.innerHTML = value.innerHTML;

          for (var attr in value.attributes) {
            if (value.attributes[attr] !== null) {
              node.setAttribute(attr, value.attributes[attr]);
            }
          }

          return node;
        }
      }, {
        key: 'value',
        value: function value(node) {
          var ret = {
            attributes: {}
          };

          if (node.tagName === 'TABLE') {
            SUPPORTED_ATTRS.forEach(function (attr) {
              if (node[attr]) {
                ret.attributes[attr] = node.getAttribute(attr);
              }
            });
            ret.innerHTML = node.innerHTML;
          }

          return ret;
        }
      }]);
      return Table;
    }(BlockEmbed$1);

    Table.blotName = 'table';
    Table.tagName = 'TABLE';
    Table.className = 'ql-table-blob';
    var Inline$2 = Quill$1.import('blots/inline');

    var Abbr = function (_Inline) {
      inherits(Abbr, _Inline);

      function Abbr() {
        classCallCheck$1(this, Abbr);
        return possibleConstructorReturn(this, (Abbr.__proto__ || Object.getPrototypeOf(Abbr)).apply(this, arguments));
      }

      createClass$1(Abbr, null, [{
        key: 'create',
        value: function create(value) {
          var node = get(Abbr.__proto__ || Object.getPrototypeOf(Abbr), 'create', this).call(this);

          if (typeof value === 'string') {
            node.setAttribute('title', value);
          }

          return node;
        }
      }, {
        key: 'formats',
        value: function formats(node) {
          var title = node.getAttribute('title');

          if (title) {
            return title;
          } else {
            return true;
          }
        }
      }]);
      return Abbr;
    }(Inline$2);

    Abbr.blotName = 'abbr';
    Abbr.tagName = 'ABBR';
    var Inline$3 = Quill$1.import('blots/inline');

    var Small = function (_Inline) {
      inherits(Small, _Inline);

      function Small() {
        classCallCheck$1(this, Small);
        return possibleConstructorReturn(this, (Small.__proto__ || Object.getPrototypeOf(Small)).apply(this, arguments));
      }

      return Small;
    }(Inline$3);

    Small.blotName = 'small';
    Small.tagName = 'small';
    var Inline$4 = Quill$1.import('blots/inline');

    var Big = function (_Inline) {
      inherits(Big, _Inline);

      function Big() {
        classCallCheck$1(this, Big);
        return possibleConstructorReturn(this, (Big.__proto__ || Object.getPrototypeOf(Big)).apply(this, arguments));
      }

      return Big;
    }(Inline$4);

    Big.blotName = 'big';
    Big.tagName = 'big';
    var Inline$5 = Quill$1.import('blots/inline');

    var Cite = function (_Inline) {
      inherits(Cite, _Inline);

      function Cite() {
        classCallCheck$1(this, Cite);
        return possibleConstructorReturn(this, (Cite.__proto__ || Object.getPrototypeOf(Cite)).apply(this, arguments));
      }

      return Cite;
    }(Inline$5);

    Cite.blotName = 'cite';
    Cite.tagName = 'cite';
    var Block = Quill$1.import('blots/block');

    var Address = function (_Block) {
      inherits(Address, _Block);

      function Address() {
        classCallCheck$1(this, Address);
        return possibleConstructorReturn(this, (Address.__proto__ || Object.getPrototypeOf(Address)).apply(this, arguments));
      }

      return Address;
    }(Block);

    Address.blotName = 'address';
    Address.tagName = 'ADDRESS';
    var Inline$6 = Quill$1.import('blots/inline');

    var Del = function (_Inline) {
      inherits(Del, _Inline);

      function Del() {
        classCallCheck$1(this, Del);
        return possibleConstructorReturn(this, (Del.__proto__ || Object.getPrototypeOf(Del)).apply(this, arguments));
      }

      return Del;
    }(Inline$6);

    Del.blotName = 'del';
    Del.tagName = 'DEL';
    var Inline$7 = Quill$1.import('blots/inline');

    var Q = function (_Inline) {
      inherits(Q, _Inline);

      function Q() {
        classCallCheck$1(this, Q);
        return possibleConstructorReturn(this, (Q.__proto__ || Object.getPrototypeOf(Q)).apply(this, arguments));
      }

      return Q;
    }(Inline$7);

    Q.blotName = 'q';
    Q.tagName = 'Q';
    var Inline$8 = Quill$1.import('blots/inline');

    var Samp = function (_Inline) {
      inherits(Samp, _Inline);

      function Samp() {
        classCallCheck$1(this, Samp);
        return possibleConstructorReturn(this, (Samp.__proto__ || Object.getPrototypeOf(Samp)).apply(this, arguments));
      }

      return Samp;
    }(Inline$8);

    Samp.blotName = 'samp';
    Samp.tagName = 'SAMP';
    var Inline$9 = Quill$1.import('blots/inline');

    var Var = function (_Inline) {
      inherits(Var, _Inline);

      function Var() {
        classCallCheck$1(this, Var);
        return possibleConstructorReturn(this, (Var.__proto__ || Object.getPrototypeOf(Var)).apply(this, arguments));
      }

      return Var;
    }(Inline$9);

    Var.blotName = 'var';
    Var.tagName = 'VAR';
    var Inline$10 = Quill$1.import('blots/inline');

    var Ins = function (_Inline) {
      inherits(Ins, _Inline);

      function Ins() {
        classCallCheck$1(this, Ins);
        return possibleConstructorReturn(this, (Ins.__proto__ || Object.getPrototypeOf(Ins)).apply(this, arguments));
      }

      return Ins;
    }(Inline$10);

    Ins.blotName = 'ins';
    Ins.tagName = 'INS';
    var Inline$11 = Quill$1.import('blots/inline');

    var Kbd = function (_Inline) {
      inherits(Kbd, _Inline);

      function Kbd() {
        classCallCheck$1(this, Kbd);
        return possibleConstructorReturn(this, (Kbd.__proto__ || Object.getPrototypeOf(Kbd)).apply(this, arguments));
      }

      return Kbd;
    }(Inline$11);

    Kbd.blotName = 'kbd';
    Kbd.tagName = 'KBD';
    var Parchment = Quill$1.import('parchment');
    var config = {
      scope: Parchment.Scope.INLINE
    };

    var FontStyleAttributor = function (_Parchment$Attributor) {
      inherits(FontStyleAttributor, _Parchment$Attributor);

      function FontStyleAttributor() {
        classCallCheck$1(this, FontStyleAttributor);
        return possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
      }

      return FontStyleAttributor;
    }(Parchment.Attributor.Style);

    var FontStyle$1 = new FontStyleAttributor('font', 'font-family', config);
    var Parchment$1 = Quill$1.import('parchment');
    var Block$1 = Quill$1.import('blots/block');
    var Container = Quill$1.import('blots/container');
    var List = Quill$1.import('formats/list');
    var ListItem = Quill$1.import('formats/list/item');

    var Dd = function (_Block) {
      inherits(Dd, _Block);

      function Dd() {
        classCallCheck$1(this, Dd);
        return possibleConstructorReturn(this, (Dd.__proto__ || Object.getPrototypeOf(Dd)).apply(this, arguments));
      }

      createClass$1(Dd, [{
        key: 'format',
        value: function format(name, value) {
          if (name === Dl.blotName && !value) {
            this.replaceWith(Parchment$1.create(this.statics.scope));
          } else {
            get(Dd.prototype.__proto__ || Object.getPrototypeOf(Dd.prototype), 'format', this).call(this, name, value);
          }
        }
      }, {
        key: 'remove',
        value: function remove() {
          if (this.prev == null && this.next == null) {
            this.parent.remove();
          } else {
            get(Dd.prototype.__proto__ || Object.getPrototypeOf(Dd.prototype), 'remove', this).call(this);
          }
        }
      }], [{
        key: 'formats',
        value: function formats(domNode) {
          return domNode.tagName;
        }
      }, {
        key: 'create',
        value: function create(value) {
          var node = get(Dd.__proto__ || Object.getPrototypeOf(Dd), 'create', this).call(this, value);
          return node;
        }
      }]);
      return Dd;
    }(Block$1);

    Dd.blotName = 'dd';
    Dd.tagName = 'DD';

    var Dt = function (_Dd) {
      inherits(Dt, _Dd);

      function Dt() {
        classCallCheck$1(this, Dt);
        return possibleConstructorReturn(this, (Dt.__proto__ || Object.getPrototypeOf(Dt)).apply(this, arguments));
      }

      return Dt;
    }(Dd);

    Dt.blotName = 'dt';
    Dt.tagName = 'DT';

    var Dl = function (_Container) {
      inherits(Dl, _Container);
      createClass$1(Dl, null, [{
        key: 'create',
        value: function create(value) {
          var node = get(Dl.__proto__ || Object.getPrototypeOf(Dl), 'create', this).call(this, value);
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return domNode.tagName.toLowerCase();
        }
      }]);

      function Dl(domNode) {
        classCallCheck$1(this, Dl);
        return possibleConstructorReturn(this, (Dl.__proto__ || Object.getPrototypeOf(Dl)).call(this, domNode));
      }

      createClass$1(Dl, [{
        key: 'format',
        value: function format(name, value) {
          return defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
        }
      }, {
        key: 'insertBefore',
        value: function insertBefore(blot, ref) {
          if (blot instanceof Dd) {
            get(Dl.prototype.__proto__ || Object.getPrototypeOf(Dl.prototype), 'insertBefore', this).call(this, blot, ref);
          } else {
            var index = ref == null ? this.length() : ref.offset(this);
            var after = this.split(index);

            if (after) {
              after.parent.insertBefore(blot, after);
            } else {
              this.parent.insertBefore(blot);
            }
          }
        }
      }, {
        key: 'replace',
        value: function replace(target) {
          var item = void 0;

          if (target.statics.blotName !== this.statics.blotName) {
            if (target.statics.blotName !== Dd.blotName && target.statics.blotName !== Dt.blotName) {
              item = Parchment$1.create(this.statics.defaultChild);
            } else {
              item = Parchment$1.create(target.statics.blotName);
            }

            target.moveChildren(item);
            this.appendChild(item);
          }

          get(Dl.prototype.__proto__ || Object.getPrototypeOf(Dl.prototype), 'replace', this).call(this, target);
        }
      }, {
        key: 'remove',
        value: function remove() {
          if (this.domNode.parentNode != null) {
            this.domNode.parentNode.removeChild(this.domNode);
          }

          this.detach();
        }
      }, {
        key: 'optimize',
        value: function optimize() {
          get(Dl.prototype.__proto__ || Object.getPrototypeOf(Dl.prototype), 'optimize', this).call(this);
          var next = this.next;

          if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName) {
            next.moveChildren(this);
            next.remove();
          }
        }
      }]);
      return Dl;
    }(Container);

    Dl.blotName = 'dl';
    Dl.tagName = 'DL';
    Dl.scope = Parchment$1.Scope.BLOCK_BLOT;
    Dl.defaultChild = 'dt';
    Dl.allowedChildren = [Dt, Dd];
    var Image = Quill$1.import('formats/image');
    var ATTRIBUTES = ['alt', 'height', 'width', 'data-fileid'];

    var SfdcImage = function (_Image) {
      inherits(SfdcImage, _Image);

      function SfdcImage() {
        classCallCheck$1(this, SfdcImage);
        return possibleConstructorReturn(this, (SfdcImage.__proto__ || Object.getPrototypeOf(SfdcImage)).apply(this, arguments));
      }

      createClass$1(SfdcImage, [{
        key: 'format',
        value: function format(name, value) {
          if (ATTRIBUTES.indexOf(name) > -1) {
            if (value) {
              this.domNode.setAttribute(name, value);
            } else {
              this.domNode.removeAttribute(name);
            }
          } else {
            get(SfdcImage.prototype.__proto__ || Object.getPrototypeOf(SfdcImage.prototype), 'format', this).call(this, name, value);
          }
        }
      }], [{
        key: 'formats',
        value: function formats(domNode) {
          return ATTRIBUTES.reduce(function (formats, attribute) {
            if (domNode.hasAttribute(attribute)) {
              formats[attribute] = domNode.getAttribute(attribute);
            }

            return formats;
          }, {});
        }
      }]);
      return SfdcImage;
    }(Image);

    SfdcImage.blotName = 'image';
    SfdcImage.tagName = 'IMG';
    var Block$2 = Quill$1.import('blots/block');
    var Container$1 = Quill$1.import('blots/container');
    var Parchment$2 = Quill$1.import('parchment');

    var QuoteBlock = function (_Block) {
      inherits(QuoteBlock, _Block);

      function QuoteBlock() {
        classCallCheck$1(this, QuoteBlock);
        return possibleConstructorReturn(this, (QuoteBlock.__proto__ || Object.getPrototypeOf(QuoteBlock)).apply(this, arguments));
      }

      createClass$1(QuoteBlock, [{
        key: 'format',
        value: function format(name, value) {
          if (name === Blockquote.blotName && !value) {
            this.replaceWith(Parchment$2.create(this.statics.scope));
          } else {
            get(QuoteBlock.prototype.__proto__ || Object.getPrototypeOf(QuoteBlock.prototype), 'format', this).call(this, name, value);
          }
        }
      }, {
        key: 'remove',
        value: function remove() {
          if (this.prev == null && this.next == null) {
            this.parent.remove();
          } else {
            get(QuoteBlock.prototype.__proto__ || Object.getPrototypeOf(QuoteBlock.prototype), 'remove', this).call(this);
          }
        }
      }, {
        key: 'replaceWith',
        value: function replaceWith(name, value) {
          this.parent.isolate(this.offset(this.parent), this.length());

          if (name === this.parent.statics.blotName) {
            this.parent.replaceWith(name, value);
            return this;
          } else {
            this.parent.unwrap();
            return get(QuoteBlock.prototype.__proto__ || Object.getPrototypeOf(QuoteBlock.prototype), 'replaceWith', this).call(this, name, value);
          }
        }
      }], [{
        key: 'formats',
        value: function formats(domNode) {
          return domNode.tagName === this.tagName ? undefined : get(QuoteBlock.__proto__ || Object.getPrototypeOf(QuoteBlock), 'formats', this).call(this, domNode);
        }
      }]);
      return QuoteBlock;
    }(Block$2);

    QuoteBlock.blotName = 'quote-block';
    QuoteBlock.className = 'ql-quote-block';
    QuoteBlock.tagName = ['P', 'H1', 'H2'];

    var Blockquote = function (_Container) {
      inherits(Blockquote, _Container);
      createClass$1(Blockquote, null, [{
        key: 'create',
        value: function create(value) {
          var node = get(Blockquote.__proto__ || Object.getPrototypeOf(Blockquote), 'create', this).call(this, value);
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return domNode.tagName.toLowerCase();
        }
      }]);

      function Blockquote(domNode) {
        classCallCheck$1(this, Blockquote);
        return possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).call(this, domNode));
      }

      createClass$1(Blockquote, [{
        key: 'format',
        value: function format(name, value) {
          return defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
        }
      }, {
        key: 'insertBefore',
        value: function insertBefore(blot, ref) {
          if (blot instanceof Block$2) {
            get(Blockquote.prototype.__proto__ || Object.getPrototypeOf(Blockquote.prototype), 'insertBefore', this).call(this, blot, ref);
          } else {
            var index = ref == null ? this.length() : ref.offset(this);
            var after = this.split(index);
            after.parent.insertBefore(blot, after);
          }
        }
      }, {
        key: 'replace',
        value: function replace(target) {
          if (target.statics.blotName !== this.statics.blotName) {
            var item = Parchment$2.create(this.statics.defaultChild);
            target.moveChildren(item);
            this.appendChild(item);
          }

          get(Blockquote.prototype.__proto__ || Object.getPrototypeOf(Blockquote.prototype), 'replace', this).call(this, target);
        }
      }, {
        key: 'remove',
        value: function remove() {
          if (this.domNode.parentNode != null) {
            this.domNode.parentNode.removeChild(this.domNode);
          }

          this.detach();
        }
      }, {
        key: 'optimize',
        value: function optimize() {
          get(Blockquote.prototype.__proto__ || Object.getPrototypeOf(Blockquote.prototype), 'optimize', this).call(this);
          var next = this.next;

          if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName) {
            next.moveChildren(this);
            next.remove();
          }
        }
      }]);
      return Blockquote;
    }(Container$1);

    Blockquote.blotName = 'blockquote';
    Blockquote.tagName = 'blockquote';
    Blockquote.scope = Parchment$2.Scope.BLOCK_BLOT;
    Blockquote.defaultChild = 'quote-block';
    Blockquote.allowedChildren = [QuoteBlock];
    var Inline$12 = Quill$1.import('blots/inline');

    var Bdo = function (_Inline) {
      inherits(Bdo, _Inline);

      function Bdo() {
        classCallCheck$1(this, Bdo);
        return possibleConstructorReturn(this, (Bdo.__proto__ || Object.getPrototypeOf(Bdo)).apply(this, arguments));
      }

      createClass$1(Bdo, null, [{
        key: 'create',
        value: function create(value) {
          var node = get(Bdo.__proto__ || Object.getPrototypeOf(Bdo), 'create', this).call(this);
          node.setAttribute('dir', value);
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(node) {
          return node.getAttribute('dir');
        }
      }]);
      return Bdo;
    }(Inline$12);

    Bdo.blotName = 'bdo';
    Bdo.tagName = 'BDO';
    var Inline$13 = Quill$1.import('blots/inline');

    var Dfn = function (_Inline) {
      inherits(Dfn, _Inline);

      function Dfn() {
        classCallCheck$1(this, Dfn);
        return possibleConstructorReturn(this, (Dfn.__proto__ || Object.getPrototypeOf(Dfn)).apply(this, arguments));
      }

      createClass$1(Dfn, null, [{
        key: 'create',
        value: function create(value) {
          var node = get(Dfn.__proto__ || Object.getPrototypeOf(Dfn), 'create', this).call(this);

          if (typeof value === 'string') {
            node.setAttribute('title', value);
          }

          return node;
        }
      }, {
        key: 'formats',
        value: function formats(node) {
          var value = node.getAttribute('title');

          if (value) {
            return value;
          } else {
            return true;
          }
        }
      }]);
      return Dfn;
    }(Inline$13);

    Dfn.blotName = 'dfn';
    Dfn.tagName = 'DFN';
    var Inline$14 = Quill$1.import('blots/inline');

    var Grammarly = function (_Inline) {
      inherits(Grammarly, _Inline);

      function Grammarly() {
        classCallCheck$1(this, Grammarly);
        return possibleConstructorReturn(this, (Grammarly.__proto__ || Object.getPrototypeOf(Grammarly)).apply(this, arguments));
      }

      return Grammarly;
    }(Inline$14);

    Grammarly.tagName = 'G';
    Grammarly.blotName = 'grammarly-inline';
    Grammarly.className = 'gr_';
    var Inline$15 = Quill$1.import('blots/inline');

    var MentionBlot = function (_Inline) {
      inherits(MentionBlot, _Inline);

      function MentionBlot() {
        classCallCheck$1(this, MentionBlot);
        return possibleConstructorReturn(this, (MentionBlot.__proto__ || Object.getPrototypeOf(MentionBlot)).apply(this, arguments));
      }

      createClass$1(MentionBlot, [{
        key: 'format',
        value: function format(name, value) {
          if (name === 'data-mention' && value) {
            this.domNode.setAttribute(name, value);
          } else {
            get(MentionBlot.prototype.__proto__ || Object.getPrototypeOf(MentionBlot.prototype), 'format', this).call(this, name, value);
          }
        }
      }], [{
        key: 'create',
        value: function create(id) {
          var node = get(MentionBlot.__proto__ || Object.getPrototypeOf(MentionBlot), 'create', this).call(this);
          node.classList.add('quill_widget_element');
          node.setAttribute('contenteditable', false);
          node.setAttribute('tabindex', "-1");
          node.setAttribute('data-widget', 'chatterMention');
          node.setAttribute('data-mention', id);
          node.addEventListener('keydown', function (event) {
            if (event.keyCode === 8 || event.keyCode === 46) {
              event.preventDefault();
              var parent = node.parentNode;

              if (parent) {
                parent.removeChild(node);
                parent.dispatchEvent(new CustomEvent('deletemention', {
                  bubbles: true
                }));
              }
            }
          });
          node.addEventListener('click', function (event) {
            node.focus();
            node.dispatchEvent(new CustomEvent('clickmention', {
              bubbles: true
            }));
          });
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return domNode.getAttribute('data-mention');
        }
      }]);
      return MentionBlot;
    }(Inline$15);

    MentionBlot.blotName = 'mention';
    MentionBlot.tagName = 'span';
    MentionBlot.className = 'ql-chatter-mention';
    var BlockEmbed$2 = Quill$1.import('blots/block/embed');

    var CodeSnippet = function (_BlockEmbed) {
      inherits(CodeSnippet, _BlockEmbed);

      function CodeSnippet() {
        classCallCheck$1(this, CodeSnippet);
        return possibleConstructorReturn(this, (CodeSnippet.__proto__ || Object.getPrototypeOf(CodeSnippet)).apply(this, arguments));
      }

      createClass$1(CodeSnippet, null, [{
        key: 'create',
        value: function create(data) {
          var node = get(CodeSnippet.__proto__ || Object.getPrototypeOf(CodeSnippet), 'create', this).call(this);
          node.setAttribute('contenteditable', false);
          node.setAttribute('tabindex', "-1");
          node.classList.add('quill_widget_wrapper');
          node.classList.add('quill_widget_block');
          var pre = document.createElement("pre");
          pre.setAttribute('spellcheck', false);
          pre.setAttribute('data-widget', 'codeSnippet');
          pre.classList.add('quill_widget_element');
          node.appendChild(pre);
          var code = document.createElement("code");
          code.setAttribute('class', 'language-javascript');
          data = data.replace(/</g, "&lt;");
          data = data.replace(/>/g, "&gt;");
          node.setAttribute("data-code", data);

          if (window.Aura && Aura.Quill && Aura.Quill.Prettify) {
            var highlightedCode = Aura.Quill.Prettify.PR.prettyPrintOne(data, "", true);
            highlightedCode = highlightedCode.replace(/<li/gi, "<span");
            highlightedCode = highlightedCode.replace(/<\/li>/gi, "</span>");
            highlightedCode = highlightedCode.replace(/<ol/gi, "<span");
            highlightedCode = highlightedCode.replace(/<\/ol>/gi, "</span>");
            code.innerHTML = highlightedCode;
          } else {
            code.innerHTML = data;
          }

          pre.appendChild(code);
          node.addEventListener('keydown', function (event) {
            if (event.keyCode === 8 || event.keyCode === 46) {
              event.preventDefault();
              event.stopPropagation();
              node.parentNode.removeChild(node);
            }
          });
          node.addEventListener('click', function (event) {
            event.stopPropagation();
            node.focus();
          });
          return node;
        }
      }, {
        key: 'value',
        value: function value(node) {
          if (node.hasAttribute("data-code")) {
            return node.getAttribute("data-code");
          }

          return node.innerText;
        }
      }]);
      return CodeSnippet;
    }(BlockEmbed$2);

    CodeSnippet.blotName = 'code-snippet';
    CodeSnippet.className = 'ql-codesnippet';
    CodeSnippet.tagName = 'pre';
    var Parchment$3 = Quill$1.import('parchment');
    var config$1 = {
      scope: Parchment$3.Scope.BLOCK,
      whitelist: ['', 'left', 'right', 'center', 'justify']
    };
    var AlignStyle = new Parchment$3.Attributor.Style('align', 'text-align', config$1);
    var FontStyle = Quill$1.import('attributors/style/font');
    var SizeStyle = Quill$1.import('attributors/style/size');
    var ColorStyle = Quill$1.import('attributors/style/color');
    var Delta = Quill$1.import('delta');
    SizeStyle.whitelist = null;
    Quill$1.register(BoldBlot, true);
    Quill$1.register(ItalicBlot, true);
    Quill$1.register(AlignStyle, true);
    Quill$1.register(FontStyle$1, true);
    Quill$1.register(SizeStyle, true);
    Quill$1.register(ColorStyle, true);
    Quill$1.register(SfdcImage, true);
    Quill$1.register(Blockquote, true);
    Quill$1.register(QuoteBlock, true);
    Quill$1.register(Table, true);
    Quill$1.register(Abbr, true);
    Quill$1.register(Small, true);
    Quill$1.register(Big, true);
    Quill$1.register(Cite, true);
    Quill$1.register(Address, true);
    Quill$1.register(Del, true);
    Quill$1.register(Samp, true);
    Quill$1.register(Var, true);
    Quill$1.register(Q, true);
    Quill$1.register(Ins, true);
    Quill$1.register(Kbd, true);
    Quill$1.register(Dt, true);
    Quill$1.register(Dl, true);
    Quill$1.register(Dd, true);
    Quill$1.register(Divider, true);
    Quill$1.register(Bdo, true);
    Quill$1.register(Dfn, true);
    Quill$1.register(Grammarly, true);
    Quill$1.register(MentionBlot, true);
    Quill$1.register(CodeSnippet, true);
    Quill$1.Delta = Delta;
    var Quill = lwc.registerComponent(Quill$1, {
      tmpl: _tmpl$3
    });

    var labelImageSizeExceeded = 'The image exceeded the maximum size of 1 MB.';

    var labelImageUploadFailed = 'There was a problem uploading the file.';

    const QUILL_EMITTER_EVENT_LIST = ['selectionchange', 'mousedown', 'mouseup', 'click'];
    const Delta$1 = Quill.Delta;
    const ALLOWED_FORMATS_FOR_API = ['align', 'font', 'size'
    /* the following formats are not enabled for 220,
       leaving them here to simplify enabling them
    'link',
    'indent',
    'list',
    'bold',
    'italic',
    'strike',
    'header',
    'direction',
    'code',
    'code-block',
    'color',
    'script',
    'underline',
    'background',*/
    ];
    const ALLOWED_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
    const FONT_LIST = [{
      label: 'Salesforce Sans',
      value: 'default'
    }, {
      label: 'Arial',
      class: 'sans-serif',
      value: 'sans-serif'
    }, {
      label: 'Courier',
      class: 'courier',
      value: 'courier'
    }, {
      label: 'Verdana',
      class: 'verdana',
      value: 'verdana'
    }, {
      label: 'Tahoma',
      class: 'tahoma',
      value: 'tahoma'
    }, {
      label: 'Garamond',
      class: 'garamond',
      value: 'garamond'
    }, {
      label: 'Times New Roman',
      class: 'serif',
      value: 'serif'
    }];
    const ALLOWED_FONTS = FONT_LIST.map(item => {
      return item.value;
    });
    const ALLOWED_TAGS = ['a', 'abbr', 'acronym', 'address', 'b', 'br', 'big', 'blockquote', 'caption', 'cite', 'code', 'col', 'colgroup', 'del', 'div', 'dl', 'dd', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'p', 'param', 'pre', 'q', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'strike', 'font'];
    const ALLOWED_ATTRS = ['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', // for custom blots
    'data-fileid'];
    const IMAGE_MAX_SIZE = 1048576; // Max size of image: 1MB - 1048576 bytes

    function _sanitize(val) {
      return sanitizeHTML(val, {
        ALLOWED_TAGS,
        ALLOWED_ATTRS
      });
    }

    function computeIndentLevel(node) {
      const indentMatch = node.className.match(/ql-indent-([0-9]+)/);

      if (indentMatch) {
        return parseInt(indentMatch[1], 10);
      }

      return 0;
    } // Patches quill emitter
    // https://github.com/quilljs/quill/blob/5b28603337f3a7a2b651f94cffc9754b61eaeec7/core/emitter.js#L8
    // To fix shadow dom issue


    function applyEmitterShadowDOMFix(quillInstance) {
      const callbacks = {};
      QUILL_EMITTER_EVENT_LIST.forEach(eventName => {
        function callback() {
          const args = ArraySlice.call(arguments, 0);

          if (quillInstance && quillInstance.emitter) {
            quillInstance.emitter.handleDOM(args[0]);
          }
        }

        document.addEventListener(eventName, callback);
        callbacks[eventName] = callback;
      });

      function removeEventListeners() {
        QUILL_EMITTER_EVENT_LIST.forEach(eventName => {
          document.removeEventListener(eventName, callbacks[eventName]);
        });
      }

      return removeEventListeners;
    }
    /**
     * Turn a list with ql- classes into a nested list.
     * Recursive!
     *
     * @param  {Array} list         an array of list items
     * @param  {Number} indentLevel the current indent level
     * @param  {String} type        ol or ul
     * @return {HTMLElement}        A DOM element
     */


    function nestList(list, indentLevel, type) {
      let level;
      let thisNode;
      let lastNode;
      const returnNode = document.createElement(type);

      while (list.length > 0) {
        if (thisNode) {
          lastNode = thisNode;
        }

        thisNode = list[0];
        level = computeIndentLevel(thisNode); // should be a sub-list. Recurse!

        if (lastNode && level > indentLevel) {
          lastNode.appendChild(nestList(list, level, type));
        } else if (level < indentLevel) {
          return returnNode;
        } else {
          thisNode.removeAttribute('class');
          returnNode.appendChild(list.shift());
        }
      }

      return returnNode;
    }
    /**
     * Recursivly flatten a nested list
     * an add quill classes
     *
     * No return, this will TRANSFORM the passed list
     * @param  {HTMLElement} list        This list node
     * @param  {Number} indentLevel The indentation level of the list passed
     */


    function unnestList(list, indentLevel) {
      const children = Array.prototype.slice.call(list.childNodes);
      children.forEach(node => {
        if (indentLevel > 0) {
          node.className = 'ql-indent-' + indentLevel;
        }

        Array.prototype.slice.call(node.childNodes).forEach(childNode => {
          const regex = /ol|ul/i;

          if (regex.test(childNode.tagName)) {
            unnestList(childNode, indentLevel + 1);
          }
        });
      });
    }

    function cleanInput(html) {
      const frag = document.createElement('div'); // eslint-disable-next-line @lwc/lwc/no-inner-html

      frag.innerHTML = _sanitize(html);
      const lists = Array.prototype.slice.call(frag.querySelectorAll('ol,ul'));

      if (lists) {
        lists.forEach(list => {
          unnestList(list, 0);
          const flatList = list.querySelectorAll('li');

          if (flatList.length > 0) {
            for (let i = 0; i < flatList.length; i += 1) {
              list.appendChild(flatList[i]);
            }
          }
        });
      } // eslint-disable-next-line @lwc/lwc/no-inner-html


      return frag.innerHTML;
    }

    function cleanOutput(html) {
      const frag = document.createElement('div'); // eslint-disable-next-line @lwc/lwc/no-inner-html

      frag.innerHTML = html;
      const lists = Array.prototype.slice.call(frag.querySelectorAll('ol,ul'));

      if (lists) {
        lists.forEach(list => {
          const myList = nestList(Array.prototype.slice.call(list.querySelectorAll('li')), 0, list.tagName);
          list.parentNode.replaceChild(myList, list);
        });
      } // eslint-disable-next-line @lwc/lwc/no-inner-html


      return frag.innerHTML;
    }

    function insertEmbed(quillInstance, format, value, attributes) {
      const insert = {};
      const attrs = attributes || {}; // this is important! if the editor
      // is not focused we can't insert.

      quillInstance.focus();
      const range = quillInstance.getSelection(); // TODO: handle alt tags!

      insert[format] = value;
      const delta = new Delta$1().retain(range.index).delete(range.length);
      delta.insert(insert, attrs);
      return quillInstance.updateContents(delta);
    }
    /**
     * 1. Attempt to upload the selected file
     *     a. If the file size exceeds 1MB, the file will not be uploaded
     *     b. If the upload encounters a problem, an error is thrown
     * 2. If the file is uploaded, insert the file/image into the editor
     * @param {Object} quillApi - Quill instance into which the image should be inserted
     * @param {Object} file - The file that needs to be uploaded
     * @param {Object} shareWithEntityId - Entity ID to share the image with
     */


    function uploadAndInsertSelectedFile(quillApi, file, shareWithEntityId) {
      aura.createComponent('force:fileUpload', {
        shareWithEntityId,
        onUpload: serverResponse => {
          if (serverResponse.successful) {
            this.insertEmbed(quillApi, 'image', serverResponse.response.downloadUrl, {
              alt: file.name
            });
          }
        }
      }, (uploadFileCmp, status) => {
        if (status === 'SUCCESS') {
          uploadFileCmp.uploadFile(file);
        }
      });
    }

    function filterFormats(formats) {
      const ret = {};
      const keys = Object.keys(formats);
      keys.forEach(key => {
        let value = formats[key]; // remove formats not in the white list

        if (ALLOWED_FORMATS_FOR_API.indexOf(key) === -1) {
          return;
        } // check font values whitelist


        if (key === 'font' && ALLOWED_FONTS.indexOf(value) === -1) {
          return;
        } // cast size to int, check value, cast back to string later when we set it


        if (key === 'size') {
          const size = parseInt(value, 10); // fast short circuit non number values;

          if (isNaN(size)) {
            return;
          }

          if (ALLOWED_SIZES.indexOf(size) === -1) {
            return;
          }

          value = size;
        }

        ret[key] = value;
      });
      return ret;
    }

    function applyFormats(api, formats) {
      const filtered = filterFormats(formats);
      Object.keys(filtered).forEach(key => {
        let value = formats[key];

        if (key === 'size') {
          value = `${value}px`;
        }

        api.format(key, value);
      });
    }

    const inputRichTextLibrary = {
      Delta: Delta$1,
      filterFormats,
      applyFormats,
      computeIndentLevel,
      nestList,
      unnestList,
      cleanInput,
      cleanOutput,
      insertEmbed,
      uploadAndInsertSelectedFile,
      ALLOWED_SIZES,
      FONT_LIST,
      ALLOWED_ATTRS,
      ALLOWED_TAGS,
      IMAGE_MAX_SIZE,
      labelImageSizeExceeded,
      labelImageUploadFailed
    };
    var lightningQuill = {
      Quill,
      inputRichTextLibrary,
      applyEmitterShadowDOMFix
    };

    const EMPTY_CHARACTER = '\u200B';
    const emptyCharMatcher = new RegExp(EMPTY_CHARACTER, 'g');
    const linesWithOnlyEmptyCharMatcher = new RegExp(`<p>${EMPTY_CHARACTER}</p>`, 'g');

    function isNonCharacterKey(keyCode) {
      return keyCode && keyCode < 48;
    }
    /**
     * Issue: the first couple letters are entered directly without being considered
     *   as part of IME. This has to do with quill trying to create the first text
     *   node and breaking the IME. This only happens to Chrome and IE11.
     * Workaround: on compositionstart, insert empty characters at the beginning of
     *   every line. Remove all the empty chars when selection is changed.
     *
     * We use a class here to store the state of the hack instead of creating private
     * attributes in the component.
     *
     * @param {Object} rte - input rich text LWC instantce
     */


    class IMEHandler {
      constructor(inputRichText) {
        this.inputRichText = void 0;
        this.isEmptyCharInserted = false;
        this.inputRichText = inputRichText;
      }

      initializeEmptyCharHack() {
        const quill = this.inputRichText.quill;
        const editorElement = quill.root;
        let shouldInsertEmptyChar = false;

        if (isChrome) {
          const handleInsertEmptyChar = event => {
            if (isNonCharacterKey(event.keyCode)) {
              return;
            } // Find all the paragraphs that have no text or images - make sure
            // they have an empty char


            const children = editorElement.querySelectorAll('p, li');

            for (let i = 0; i < children.length; i += 1) {
              const child = children[i];

              if (child.textContent.length === 0 && child.getElementsByTagName('img').length === 0) {
                child.textContent = EMPTY_CHARACTER;
              }
            }

            this.isEmptyCharInserted = true;
          };

          editorElement.addEventListener('compositionstart', handleInsertEmptyChar);
          shouldInsertEmptyChar = true;
        } else if (isIE11) {
          const handleInsertEmptyChar = () => {
            // Insert empty character into the editor when there is no content
            // This is to make sure it works in accordance to the hack applied
            // for W-3946761.
            // Using the workaround for Chrome here would cause IE11 to freeze.
            // IE11 also doesn't need every empty line to have empty char.
            if (quill.editor.isBlank()) {
              const child = editorElement.querySelector('p');
              child.textContent = EMPTY_CHARACTER;
              this.isEmptyCharInserted = true;
            }
          };

          ['focus', 'keydown'].forEach(eventName => {
            editorElement.addEventListener(eventName, handleInsertEmptyChar);
          });
          shouldInsertEmptyChar = true;
        }

        if (shouldInsertEmptyChar) {
          quill.on('selection-change', () => {
            if (this.isEmptyCharInserted) {
              this.clearEmptyCharIfTrulyEmpty(quill);
            }
          });
        }
      }

      clearEmptyCharIfTrulyEmpty() {
        const quill = this.inputRichText.quill;
        const text = quill.getText().replace(/\n/, ''); // if the text is only the empty char that means the editor
        // should be empty

        if (!quill.hasFocus() && text === EMPTY_CHARACTER) {
          quill.setText('');
          this.isEmptyCharInserted = false;
        }
      }

      clearEmptyChars(html) {
        if (this.isEmptyCharInserted) {
          /* W-7075801 Ensure empty lines with only empty character are replace with br */
          if (linesWithOnlyEmptyCharMatcher.test(html)) {
            html = html.replace(linesWithOnlyEmptyCharMatcher, '<p><br/></p>');
          }

          return html.replace(emptyCharMatcher, '');
        }

        return html;
      }

    }

    lwc.registerDecorators(IMEHandler, {
      fields: ["inputRichText", "isEmptyCharInserted"]
    });

    var IMEHandler$1 = lwc.registerComponent(IMEHandler, {
      tmpl: _tmpl$3
    });

    const {
      Quill: Quill$2,
      inputRichTextLibrary: inputRichTextLibrary$1,
      applyEmitterShadowDOMFix: applyEmitterShadowDOMFix$1
    } = lightningQuill;
    const TOOLBAR_CATEGORIES = {
      FORMAT_TEXT: 'FORMAT_TEXT',
      FORMAT_BACKGROUND: 'FORMAT_BACKGROUND',
      FORMAT_BODY: 'FORMAT_BODY',
      FORMAT_FONT: 'FORMAT_FONT',
      ALIGN_TEXT: 'ALIGN_TEXT',
      INSERT_CONTENT: 'INSERT_CONTENT',
      REMOVE_FORMATTING: 'REMOVE_FORMATTING'
    };
    const ALLOWED_IMAGE_FORMATS = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif'];
    const CREATE_LINK_PANEL_WIDTH = 320,
          DEFAULT_FONT_NAME_VALUE = 'default',
          DEFAULT_FONT_SIZE_VALUE = '12px',
          DEFAULT_TEXT_COLOR_VALUE = '#000000',
          DEFAULT_CATEGORY = 'FORMAT_TEXT',
          SF_DEFAULT_FORMATS = ['table', 'image', 'link', 'header'],
          BUTTON_CLASSNAMES = 'slds-button slds-button_icon-border-filled',
          TOOLBAR_SELECTOR = '.slds-rich-text-editor__toolbar > ul li .slds-button, .overflow-menu > ul > li .slds-button';
    const i18n$h = {
      alignText: labelAlignText,
      bold: labelBold,
      bullet: labelBullet,
      centerAlign: labelCenterAlign,
      composeText: labelComposeText,
      font: labelFont,
      fontSize: labelFontSize,
      formatBackground: labelFormatBackground,
      formatBody: labelFormatBody,
      formatFont: labelFormatFont,
      formatText: labelFormatText,
      indent: labelIndent,
      insertContent: labelInsertContent,
      italic: labelItalic,
      leftAlign: labelLeftAlign,
      link: labelLink,
      image: labelImage,
      linkCancel: labelLinkCancel,
      linkInput: labelLinkInput,
      linkSave: labelLinkSave,
      number: labelNumber,
      outdent: labelOutdent,
      removeFormatting: labelRemoveFormatting,
      rightAlign: labelRightAlign,
      strike: labelStrike,
      underline: labelUnderline
    };

    function defaults() {
      const textAlignLeftButton = {
        label: i18n$h.leftAlign,
        iconName: 'utility:left_align_text',
        format: 'align',
        value: isRTL() ? 'left' : ''
      };
      const textAlignRightButton = {
        label: i18n$h.rightAlign,
        iconName: 'utility:right_align_text',
        format: 'align',
        value: 'right'
      };
      const textAlignCenterButton = {
        label: i18n$h.centerAlign,
        iconName: 'utility:center_align_text',
        format: 'align',
        value: 'center'
      };
      const textAlignButtons = isRTL() ? [textAlignRightButton, textAlignCenterButton, textAlignLeftButton] : [textAlignLeftButton, textAlignCenterButton, textAlignRightButton];
      return [{
        category: TOOLBAR_CATEGORIES.FORMAT_TEXT,
        label: i18n$h.formatText,
        buttons: [{
          label: i18n$h.bold,
          iconName: 'utility:bold',
          format: 'bold'
        }, {
          label: i18n$h.italic,
          iconName: 'utility:italic',
          format: 'italic'
        }, {
          label: i18n$h.underline,
          iconName: 'utility:underline',
          format: 'underline'
        }, {
          label: i18n$h.strike,
          iconName: 'utility:strikethrough',
          format: 'strike'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.FORMAT_BACKGROUND,
        label: i18n$h.formatBackground,
        buttons: []
      }, {
        category: TOOLBAR_CATEGORIES.FORMAT_BODY,
        label: i18n$h.formatBody,
        buttons: [{
          label: i18n$h.bullet,
          iconName: 'utility:richtextbulletedlist',
          format: 'list',
          value: 'bullet'
        }, {
          label: i18n$h.number,
          iconName: 'utility:richtextnumberedlist',
          format: 'list',
          value: 'ordered'
        }, {
          label: i18n$h.indent,
          iconName: 'utility:richtextindent',
          format: 'indent',
          value: '+1'
        }, {
          label: i18n$h.outdent,
          iconName: 'utility:richtextoutdent',
          format: 'indent',
          value: '-1'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.ALIGN_TEXT,
        label: i18n$h.alignText,
        buttons: textAlignButtons
      }, {
        category: TOOLBAR_CATEGORIES.INSERT_CONTENT,
        label: i18n$h.insertContent,
        buttons: [{
          label: i18n$h.link,
          iconName: 'utility:link',
          format: 'link'
        }, {
          label: i18n$h.image,
          iconName: 'utility:image',
          format: 'image'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.REMOVE_FORMATTING,
        label: i18n$h.removeFormatting,
        buttons: [{
          label: i18n$h.removeFormatting,
          iconName: 'utility:remove_formatting',
          format: 'clean'
        }]
      }];
    }

    const FONT_LIST$1 = inputRichTextLibrary$1.FONT_LIST;
    const ALLOWED_SIZES$1 = [];
    inputRichTextLibrary$1.ALLOWED_SIZES.forEach(size => {
      ALLOWED_SIZES$1.push({
        label: `${size}`,
        value: `${size}px`
      });
    });
    const keyCodes$1 = {
      tab: 9,
      enter: 13,
      escape: 27,
      space: 32,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40
    };
    const bindings = {
      // This will overwrite the default binding also named 'tab'
      // which would normally indent
      tab: {
        key: 9,
        shiftKey: false,

        handler() {
          // this will stop quill from preventingDefault
          // and stopping propigation on this event
          // so it will be handled normally
          return true;
        }

      },
      // names are not used, unique to avoid collision
      lightningOutdent: {
        key: 219,
        // [
        shortKey: true,

        handler() {
          this.quill.format('indent', '-1');
        }

      },
      lightningIndent: {
        key: 221,
        // ]
        shortKey: true,

        handler() {
          this.quill.format('indent', '+1');
        }

      }
    }; // Map for converting the size in <font size=x />
    // to an actual pixel value

    const FONT_SIZE_MAP = {
      1: '9px',
      2: '11px',
      3: '14px',
      4: '16px',
      5: '22px',
      6: '28px',
      7: '48px'
    };
    /**
     * Converts a CSS style value to an integer
     * Ex. "100px" -> 100
     * @param {HTMLElement} element - Element from which to retrieve the style
     * @param {String} style - The CSS style to retrieve from the element
     * @return {Integer} - Converted integer value
     */

    function getStyleAsInt(element, style) {
      return parseInt(element.style[style], 10);
    }
    /**
     * A WYSIWYG editor with a customizable toolbar for entering rich text
     */


    class LightningInputRichText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._pendingFormats = [];
        this._valid = true;
        this._disabled = false;
        this.linkPanelOpen = false;
        this.queueLinkPanelOpen = false;
        this.selectedFontValue = DEFAULT_FONT_NAME_VALUE;
        this.selectedSizeValue = DEFAULT_FONT_SIZE_VALUE;
        this.quillNotReady = true;
        this.selectedTextColorValue = DEFAULT_TEXT_COLOR_VALUE;
        this.label = void 0;
        this.labelVisible = false;
        this.placeholder = void 0;
        this.disabledCategories = '';
        this.formats = '';
        this.variant = void 0;
        this.messageWhenBadInput = void 0;
        this.customButtons = void 0;
        this.shareWithEntityId = void 0;
        this.quill = void 0;
        this.initialRender = true;
        this.internalValue = void 0;
        this.linkValue = '';
        this.fontMenus = {
          fontList: FONT_LIST$1,
          sizeList: ALLOWED_SIZES$1
        };
      }

      /**
       * The HTML content in the rich text editor.
       * @type {string}
       *
       */
      get value() {
        return this.internalValue;
      }

      set value(val) {
        // Change internalValue and paste into editor only if
        // the contents are different from the previously saved value
        if (typeof val === 'string' && this.internalValue !== val) {
          this.internalValue = inputRichTextLibrary$1.cleanInput(val);

          if (!this.internalValue) {
            // eslint-disable-next-line no-console
            console.warn('No html sanitizer found for rich text, make sure to sanitize rich text before using lightning-input-rich-text. Using raw html value');
            this.internalValue = val;
          }

          this.setContent(this.internalValue, 'api');
        }
      }
      /**
       * Specifies whether the editor content is valid. If invalid, the slds-has-error class is added. This value defaults to true.
       * @type {boolean}
       * @default true
       */


      get valid() {
        return this._valid;
      }

      set valid(value) {
        this._valid = normalizeBoolean(value);

        if (this.quill) {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          const editorElement = this.quill.root;

          if (!this.valid) {
            rteElement.classList.add('slds-has-error');
            editorElement.setAttribute('aria-describedby', this.errorMessageId);
          } else {
            rteElement.classList.remove('slds-has-error');
            editorElement.removeAttribute('aria-describedby');
          }
        }
      }
      /**
       * If present, the editor is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * Sets focus on the rich text editor.
       */


      focus() {
        // Focus on inputRichText should activate editor.
        if (!this.quill) {
          this.activateEditor();
        }

        this.quill.root.focus();
      }
      /**
       * Removes focus from the rich text editor.
       */


      blur() {
        if (this.quill) {
          this.quill.root.blur();
        }
      }
      /**
       *
       * Sets a format in the editor from the cursor point onwards.
       * The format also applies to currently selected content.
       *
       * Valid formats are font, size, and align.
       * @param {Object} formats A key-value pair with format names and values.
       */


      setFormat(formats) {
        if (formats && this.quill) {
          inputRichTextLibrary$1.applyFormats(this.quill, deepCopy(formats));
          const selection = this.quill.getSelection();

          if (selection.length === 0) {
            this.syncFontMenus();
          }
        } else if (formats) {
          this._pendingFormats.push(formats);
        }
      }
      /**
       * Returns an object representing the formats applied to the current selection.
       * Only align, font, and size are supported.
       *
       * @returns {Object} format an object representing the formats applied
       *                   to the selection or editor
       */


      getFormat() {
        if (!this.quill) {
          this.activateEditor();
        }

        return inputRichTextLibrary$1.filterFormats(this.quill.getFormat());
      }

      syncFontMenus() {
        const format = this.quill.getFormat();
        this.updateFontMenu(format);
        this.updateSizeMenu(format);
      }

      get showLinkValue() {
        return this.linkValue;
      }

      get isBottomToolbar() {
        return this.variant === 'bottom-toolbar';
      }

      get isColorpickerVisible() {
        return this.formats.indexOf('color') > -1;
      }

      get isFontMenusVisible() {
        if (this.disabledCategories.indexOf(TOOLBAR_CATEGORIES.FORMAT_FONT) !== -1) {
          return false;
        } // If custom formats are specified,
        // hide the fonts menus if font is not a part
        // of the custom formats


        if (this.formats.length > 0) {
          if (this.formats.indexOf('font') === -1) {
            return false;
          }
        }

        return true;
      }

      get errorMessage() {
        return this.messageWhenBadInput;
      }

      get i18n() {
        return i18n$h;
      }

      get labelId() {
        return this.uniqueLabelId;
      }

      get errorMessageId() {
        const msg = this.template.querySelector('[data-error-message]');
        return getRealDOMId(msg);
      }

      get toolbarAriaLabel() {
        return this.disabled ? 'disabled' : '';
      }

      get renderLabel() {
        return this.labelVisible || this.label;
      }

      get computedLabel() {
        return this.label ? this.label : this.i18n.composeText;
      }

      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');
        return classnames.add({
          'slds-assistive-text': !this.labelVisible
        }).toString();
      }
      /**
       * Compute the complete set of buttons to be displayed and
       * add appropriate class names to each button
       *  - If the formats attribute is specified:
       *      Filter out buttons which do not match the specified formats
       *  - Merge the custom buttons with this filtered button set
       *  - Remove an entire category if:
       *      a. There are no remaining buttons in that category
       *      b. If it is a disabled category
       *  - Add the right class names to each remaining button
       * @returns {Object} Filtered set categories and buttons
       */


      get computedCategories() {
        // If custom formats are specified,
        // filter out the buttons which do not match
        // the specified custom formats, within each category
        const customFormats = !!this.formats.length;
        const formatList = this.formats;
        let categories = defaults();

        if (customFormats) {
          categories.forEach(cat => {
            cat.buttons = cat.buttons.filter(button => formatList.includes(button.format));
          });
        } // Merge custom buttons after filtering out default buttons which
        // do not match custom formats, so that the custom buttons may be
        // included even when the custom formats do not specify them


        categories = this.mergeCustomToolbarButtons(categories); // only keep categories that have buttons and not disabled

        categories = categories.filter(cat => cat.buttons && cat.buttons.length > 0 && !this.disabledCategories.includes(cat.category)); // Add additional attributes to each button

        categories.forEach(cat => {
          cat.buttons.forEach(button => {
            // add classes
            if (button.format) {
              button.computedClass = `${BUTTON_CLASSNAMES} ql-${button.format}`;
            } else {
              button.computedClass = BUTTON_CLASSNAMES;
            } // add key for iterations


            button.key = button.label + button.value;
          });
        });
        return categories;
      }
      /**
       * Merge the provided custom buttons with the existing set
       * If custom buttons are provided:
       *      Check if the custom button's category exists in the existing set
       *          If yes, add the button(s) into that category
       *          If no, add that entire category along with button(s) into the existing set
       *      If custom buttons' categories are not specified, add buttons to the default category
       * @param {Array} buttonSet - Set of filtered buttons;
       * If custom formats are provided, this set consists of default
       * buttons with those buttons removed, which do not match the format
       * Else, it is the default set of buttons
       * @returns {Array} Returns the merged set of buttons
       */


      mergeCustomToolbarButtons(buttonSet) {
        if (this.customButtons) {
          let existingCategory = false;
          this.customButtons.forEach(customButton => {
            existingCategory = false;
            buttonSet.forEach(cat => {
              // If the custom button is of an existing category,
              // add the custom button to the existing button set under that category
              // If a category for the custom button was not given
              // add the custom button into the default (Format Text) category
              if (!existingCategory && (cat.category === customButton.category || !customButton.category && cat.category === DEFAULT_CATEGORY)) {
                existingCategory = true;
                cat.buttons = cat.buttons.concat(deepCopy(customButton.buttons));
              }
            }); // If the user button is not part of an existing category,
            // append the button info along with category information
            // to the complete set of buttons

            if (!existingCategory) {
              buttonSet = buttonSet.concat(deepCopy(customButton));
            }
          });
        }

        return buttonSet;
      }
      /**
       * If it is a bottom-toolbar variant, add the appropriate
       * slds class to the toolbar
       */


      setupToolbar() {
        if (this.isBottomToolbar) {
          const toolbar = this.template.querySelector('.slds-rich-text-editor__toolbar');
          toolbar.classList.add('slds-rich-text-editor__toolbar_bottom');
        }
      }
      /**
       * For initial set up of buttons
       * We set the tabindex of every button to -1,
       * except the first button, which is set to 0
       *
       * This is so that tabbing through buttons is disabled
       * Instead ,users will be able to tab onto one button and use
       * arrow keys to navigate to other buttons
       */


      setupButtons() {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);

        if (buttonList.length > 0) {
          this.setButtonTabindex(buttonList, 0);
        }
      }
      /**
       * Helper function to set tabindexes of all buttons to -1,
       * and to set the tabindex of the specified index to 0
       * @param {Array} buttonList - List of buttons to iterate through
       * @param {Number} index - Index of button whose tabindex to set to 0
       */


      setButtonTabindex(buttonList, index) {
        buttonList.forEach(button => {
          button.setAttribute('tabindex', -1);
        });
        buttonList[index].setAttribute('tabindex', 0);
      }
      /**
       * Attach custom handlers to the custom buttons
       * If custom buttons have been provided:
       *      Compare the custom button's format and the rendered
       *      toolbar button's quill class
       *      If they match, attach the provided custom handler as
       *      an onclick handler for that button
       */


      attachCustomButtonHandlers() {
        if (this.customButtons) {
          const renderedButtons = this.template.querySelectorAll(TOOLBAR_SELECTOR);
          this.customButtons.forEach(cat => {
            cat.buttons.forEach(button => {
              renderedButtons.forEach(renderedButton => {
                if (renderedButton.classList.contains('ql-' + button.format)) {
                  // Pass in the inputRichText component so that the handler
                  // has access to the quill instance
                  renderedButton.addEventListener('click', button.handler);
                }
              });
            });
          });
        }
      }
      /**
       * Add slds classes to the editor generated on initialization of Quill
       * @param {HTMLElement} qlEditor - Editor element generated from the
       * initialization of Quill
       */


      addInitialClassesAndAttributesToEditor(qlEditor) {
        qlEditor.classList.add('slds-rich-text-area__content');
        qlEditor.classList.add('slds-grow');
        qlEditor.classList.add('slds-text-color_weak');
        this.setAriaAttributesOnEditor(qlEditor);
      }
      /**
       * Add appropriate aria attributes based on values of label and labelVisible
       * @param {HTMLElement} qlEditor - Editor element on which to set aria attributes
       */


      setAriaAttributesOnEditor(qlEditor) {
        if (this.labelVisible || this.label) {
          qlEditor.setAttribute('aria-labelledby', this.uniqueLabelId);
        } else {
          qlEditor.setAttribute('aria-label', this.i18n.composeText);
        }
      }
      /**
       * Compute the list of formats to be passed in to the Quill configuration
       * If the formats attributes is specified, use that list
       * If formats are not specified:
       *      a. We set the formats of the buttons as the
       *         list of formats to pass into the Quill config
       *      b. Add font menus to list if it is not a disabled category
       * Add the Salesforce default formats to the filtered list - these are
       * on by default
       * @returns {Array} Final list of formats to pass into the Quill config
       */


      computeFormats() {
        let computedFormats = []; // If custom formats are specified, don't do anything
        // we will use this list in the quill config

        if (this.formats.length > 0) {
          return this.formats;
        } // If custom formats are not specified, we should set the
        // formats of the buttons as the formats list in the quill config
        // Visible buttons have already been calculated by the time
        // this stage is reached


        this.computedCategories.forEach(cat => {
          cat.buttons.forEach(button => {
            if (button.format) {
              // to make sure we don't have duplicates
              if (computedFormats.indexOf(button.format) === -1) {
                computedFormats.push(button.format);
              }
            }
          });
        }); // add font separately

        if (this.isFontMenusVisible) {
          computedFormats.push('font');
          computedFormats.push('size');
        }

        computedFormats = computedFormats.concat(SF_DEFAULT_FORMATS);
        return computedFormats;
      }
      /**
       * This is for conversion from <font size="">
       * to a quill size format. The font tag size is defined as
       * an integer between 1-7 with 3 being "normal" or default
       * there is no specified meaning to these sizes, so this is
       * a fairly arbitrary mapping based on experiments in the inspector
       * with font tags and slds
       * @param {Number} fontSize - Refers to the value of the size attribute
       * in a font tag
       * @returns {Number} - Value that corresponds to the right pixel size
       * in the FONT_SIZE_MAP to be rendered
       */


      getNormalizedFontSize(fontSize) {
        const size = fontSize || 3;
        const relativeSize = /^[+-]\d/.test(size) ? Number(size) + 3 : Number(size);
        let normalizedSize = relativeSize > 7 ? 7 : relativeSize;
        normalizedSize = relativeSize < 1 ? 1 : normalizedSize;
        return normalizedSize;
      }
      /**
       * Add matchers to quill so that particular tags can be converted from
       * one to another
       * Conversions:
       *      <font>    -> <span>
       *      <s>       -> <strike>
       *      <tt>      -> <code>
       *      <acronym> -> <abbr>
       *      <table>   -> {tableBlot}
       *      text-decoration
       *          underline    -> <underline>
       *          line-through -> <strike>
       */


      addTagMatchers() {
        // Convert font tags to spans
        this.quill.clipboard.addMatcher('font', (node, delta) => {
          let size = node.getAttribute('size'); // map <font> integers to px sizes

          if (size) {
            size = FONT_SIZE_MAP[this.getNormalizedFontSize(size)];
          } // size may still be undefined, that means it won't be applied
          // so this is fine


          const nodeFormats = {
            font: node.getAttribute('face'),
            // trust the defined font face
            size,
            color: node.getAttribute('color') // color is css compatible

          };
          return delta.compose(new Quill$2.Delta().retain(delta.length(), nodeFormats));
        }); // convert <s> to <strike>

        this.quill.clipboard.addMatcher('s', (node, delta) => {
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            strike: true
          }));
        }); // convert <tt> to <code>

        this.quill.clipboard.addMatcher('tt', (node, delta) => {
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            code: true
          }));
        }); // convert <acronym> to <abbr>

        this.quill.clipboard.addMatcher('acronym', (node, delta) => {
          const title = node.getAttribute('title');
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            abbr: title ? title : true
          }));
        });
        this.quill.clipboard.addMatcher('span[style*=text-decoration]', (node, delta) => {
          const computedStyle = getComputedStyle(node) || node.style;
          const underline = computedStyle.textDecoration.match(/underline/);
          const strike = computedStyle.textDecoration.match(/line-through/);
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            underline: underline ? true : false,
            strike: strike ? true : false
          }));
        }); // This matcher detects tables, and if tables are disabled, returns a normal
        // delta, otherwise it applies the table format

        this.quill.clipboard.addMatcher('table', node => {
          if (this.formats.indexOf('table') === -1) {
            // convert creates a delta from html, in this case the html
            // *inside* the <table>
            return this.quill.clipboard.convert(node.innerHTML); // eslint-disable-line @lwc/lwc/no-inner-html
          }

          const tableBlot = Quill$2.import('formats/table');
          return new Quill$2.Delta().insert({
            table: tableBlot.value(node)
          });
        });
      }
      /**
       * Initialize a new Quill instance and attach the required
       * handlers for various events
       *      1. Compute information required for configuring Quill
       *      2. Initialize Quill by passing in the computed configuration
       *      3. Add slds classes to editor element generated on init of Quill
       *      4. Add handlers for various events:
       *          a. on text change - dispatch change event
       *          b. on selection change update font and size menu values
       *          c. on double click, open link insertion panel if target is anchor
       *          d. attach custom handler for clicking on link insert button
       */


      initializeQuill() {
        const container = this.template.querySelector('.editor');
        const toolbar = this.template.querySelector('.slds-rich-text-editor__toolbar');
        const computedFormats = this.computeFormats();
        const placeholder = this.placeholder;
        this._hasBeenFocused = false; // Quill Configuration: https://quilljs.com/docs/configuration/

        const quillConfig = {
          modules: {
            toolbar,
            keyboard: {
              bindings
            }
          },
          formats: computedFormats,
          placeholder
        }; // Override S -> STRIKE

        const Strike = Quill$2.import('formats/strike');
        Strike.tagName = 'STRIKE'; // Quill uses <s> by default

        Quill$2.register(Strike, true); // Init Quill

        this.quill = new Quill$2(container, quillConfig); // Monkeypatches binding of event emitter
        // As it doesn't work w/ shadow dom out of the box

        this.removeQuillEmitterEventListeners = applyEmitterShadowDOMFix$1(this.quill);
        const editor = this.quill.root;
        this.addInitialClassesAndAttributesToEditor(this.quill.root);
        const imeHandler = new IMEHandler$1(this);
        imeHandler.initializeEmptyCharHack(); // If the editor is 'blank' it still contains a new
        // line (<p><br></p>); check if it is in fact blank
        // If so, we just use an empty string for the value
        // If not blank, clean the editor's contents
        // Fire a change event with the cleaned content as the value

        this.quill.on('text-change', () => {
          let cleanedContent = '';

          if (!this.quill.editor.isBlank()) {
            const editorContents = this.quill.scroll.domNode.innerHTML; // eslint-disable-line @lwc/lwc/no-inner-html

            cleanedContent = inputRichTextLibrary$1.cleanOutput(editorContents);
          } // make sure we don't send the hacky empty characters back to the user


          cleanedContent = imeHandler.clearEmptyChars(cleanedContent);
          this.internalValue = cleanedContent;
          this.dispatchChangeEvent();
        }); // Update the font, font size menu display values and button pressed state
        // depending on where the cursor is at the time

        this.quill.on('selection-change', range => {
          if (!this._hasBeenFocused) {
            // Due to a bug in quill setting the link format before focusing the cursor in
            // the editor causes the `ql-blank` to never be removed, this change prevents enabling
            // the link button until the editor has been focused (by the user)
            const qlLink = this.template.querySelector('.ql-link');

            if (qlLink) {
              qlLink.removeAttribute('disabled');
            }

            this._hasBeenFocused = true;
          }

          let format = null;

          if (range) {
            // If no range, nothing is selected
            format = this.quill.getFormat(range);
            this.updateFontMenu(format);
            this.updateSizeMenu(format);
            this.updateTextColorButton(format);
            this.applyTextAlignment(format);
          }

          this.updateButtonPressedState(range);
        }); // Update button pressed state depending on what the user is typing.

        this.quill.on('scroll-optimize', () => {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            const range = this.quill.selection.getRange()[0];
            this.updateButtonPressedState(range);
          });
        }); // If user double clicks on a link node in the editor,
        // open the link insertion panel with the href value
        // populated in the input

        this.quill.scroll.domNode.addEventListener('dblclick', clickEvt => {
          const linkNode = this.getEnclosingLinkNode(clickEvt.target);

          if (linkNode) {
            this.expandSelectionToNode(linkNode);
            this.openLinkPanel(linkNode.getAttribute('href'));
          }
        });
        const toolbarModule = this.quill.getModule('toolbar');
        toolbarModule.addHandler('link', () => {
          this.linkButtonClickHandler();
        });
        toolbarModule.addHandler('image', () => {
          this.imageButtonClickHandler();
        });
        const previousCleanHandler = toolbarModule.handlers.clean;
        toolbarModule.addHandler('clean', () => {
          previousCleanHandler.call(this);
          const range = this.quill.getSelection();

          if (range) {
            const format = this.quill.getFormat(range);
            this.updateFontMenu(format);
            this.updateSizeMenu(format);
            this.updateTextColorButton(format);
          }

          this.updateButtonPressedState(range);
        }); // Add tag matchers

        this.addTagMatchers(); // Set initial value passed in to the editor

        if (this.internalValue) {
          this.setContent(this.internalValue, 'silent');
        } // When the editor is focused, set the slds-has-focus class and
        // dispatch focus event to execute onfocus method thats passed in


        editor.addEventListener('focus', () => {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.add('slds-has-focus');
          this.dispatchEvent(new CustomEvent('focus'));
        }); // When the editor is blurred, remove the slds-has-focus class and
        // dispatch blur event to execute onblur method thats passed in

        editor.addEventListener('blur', () => {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.remove('slds-has-focus');
          this.dispatchEvent(new CustomEvent('blur'));
        }); // If a file was pasted and is of the image formats supported,
        // proceed to upload the image and insert into the editor

        editor.addEventListener('paste', pasteEvt => {
          const clipboardData = pasteEvt.clipboardData;

          if (clipboardData && clipboardData.files && clipboardData.files.length && clipboardData.types.indexOf('text/html') === -1) {
            const pastedFile = clipboardData.files[0];

            if (ALLOWED_IMAGE_FORMATS.indexOf(pastedFile.type) > -1) {
              pasteEvt.preventDefault();
              pasteEvt.stopPropagation();
              inputRichTextLibrary$1.uploadAndInsertSelectedFile(this.quill, pastedFile, this.shareWithEntityId);
            }
          }
        });

        if (this._pendingFormats) {
          while (this._pendingFormats.length > 0) {
            const toDo = this._pendingFormats.shift();

            this.setFormat(toDo);
            this.syncFontMenus();
          }
        }
      } // Set Editor state to Disabled:
      // Disable Buttons, Comboboxes and the Editor

      /**
       * Set editor's state depending on the disabled attribute value
       * If disabled is set to true:
       *      a. Disable each button
       *      b. Disable the editor
       * If disabled is false:
       *      a. Ensure buttons are not disabled
       *      b. Enable the editor
       * Note: Font and font size menus are disabled directly
       *       based on the disabled attribute
       */


      setEditorAndButtonState() {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);

        if (this.disabled) {
          buttonList.forEach(button => {
            button.setAttribute('disabled', true);
          });

          if (this.quill) {
            this.quill.disable();
          }
        } else {
          buttonList.forEach(button => {
            // prevent link button from being enabled until editor was focused
            if (!this._hasBeenFocused && button.classList.contains('ql-link')) {
              button.setAttribute('disabled', true);
            } else {
              button.removeAttribute('disabled');
            }
          });

          if (this.quill) {
            this.quill.enable();
          }
        }
      }
      /**
       * Set appropriate error classes based on the valid attribute value
       * If valid attribute is false:
       *      a. Set the slds error class on the editor element
       *      b. Unhide the element containing the error message
       *      c. Set aria-describedby to point to error message element
       */


      setEditorValidityState() {
        // Checking validity to append error class
        if (!this.valid) {
          // Add the error class on the editor
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.add('slds-has-error'); // Set editor's aria-describedby to point to error message element

          const editorElement = this.quill.root;
          editorElement.setAttribute('aria-describedby', this.errorMessageId);
        }
      }
      /**
       * Generate a unique id for the errormessage and label
       */


      connectedCallback() {
        this.classList.add('slds-form-element__control');
      }

      get uniqueLabelId() {
        const label = this.template.querySelector('[data-label]');
        return getRealDOMId(label);
      }

      activateEditor(e) {
        // Initialize the Quill instance on initial render
        if (this.initialRender) {
          this.setupToolbar();
          this.setupButtons();
          this.attachCustomButtonHandlers();
          this.initializeQuill();
          this.setEditorValidityState();
          this.initialRender = false;
          this.setEditorAndButtonState();
          this.quillNotReady = false;

          if (e) {
            const shouldFocus = e.target.classList.contains('standin') || e.target.localName === 'lightning-formatted-rich-text';

            if (shouldFocus) {
              this.quill.setSelection(this.quill.getLength());
            }
          }
        }
      }

      disconnectedCallback() {
        // Removes events listener bound by quill emitter fix
        if (this.removeQuillEmitterEventListeners && typeof this.removeQuillEmitterEventListeners === 'function') {
          this.removeQuillEmitterEventListeners();
        }
      }
      /**
       * On the first render cycle:
       *      1. Set up button tabindexes to be accessible
       *      2. Attach custom handlers for custom buttons
       *      3. Initialize the Quill instance
       * On every rerender:
       *      1. Set editor's disabled state based on disabled attribute
       *      2. Set editor's valid state based on the valid attribute
       *      3. Open the link panel if queued
       */


      renderedCallback() {
        this.setEditorAndButtonState();

        if (this.queueLinkPanelOpen) {
          this.queueLinkPanelOpen = false;
          const createLinkPanel = this.template.querySelector('.slds-popover__body');
          const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);
          this.calculateLinkPanelPositioning(createLinkPanel, buttonList);
          this.template.querySelector('.link-input').focus();
        }
      }
      /* *******************************
          Keyboard Button Navigation
      ******************************** */

      /**
       * Move to the next button on the toolbar
       * Wrap around to the first button if currently on last
       * Move to next button by:
       *      1. Setting tabindex to 0 on the new button and -1 on the rest
       *      2. Setting focus on the new button
       * @param {Array} buttonList - Array of toolbar button elements
       * @param {Number} currentIndex - Index on which focus is on currently
       */


      moveToNextButton(buttonList, currentIndex) {
        // Determine next index to move to
        let newIndex = currentIndex + 1;

        if (newIndex === buttonList.length) {
          newIndex = 0;
        } // Set tabindex 0 on new button moved to and -1 on rest


        this.setButtonTabindex(buttonList, newIndex);
        buttonList[newIndex].focus();
      }
      /**
       * Move to the previous button on the toolbar
       * Wrap around to the last button if currently on first
       * Move to previous button by:
       *      1. Setting tabindex to 0 on the new button and -1 on the rest
       *      2. Setting focus on the new button
       * @param {Array} buttonList - Array of toolbar button elements
       * @param {Number} currentIndex - Index on which focus is on currently
       */


      moveToPreviousButton(buttonList, currentIndex) {
        // Determine previous index to move to
        let newIndex = currentIndex - 1;

        if (newIndex === -1) {
          newIndex = buttonList.length - 1;
        } // Set tabindex 0 on new button moved to and -1 on rest


        this.setButtonTabindex(buttonList, newIndex);
        buttonList[newIndex].focus();
      }
      /**
       * Navigate the toolbar buttons based on the keyboard input:
       *      1. Determine the current button by capturing event's target
       *      2. If user pressed the right arrow, move to the next button in toolbar
       *      3. If user pressed the left arrow, move to the previous button in toolbar
       * @param {Event} evt - Keyboard event to retrieve target and keyCode from
       */


      navigateToolbar(evt) {
        this.activateEditor();
        const event = evt || window.event;
        const target = event.target;
        const buttonList = Array.from(this.template.querySelectorAll(TOOLBAR_SELECTOR)).filter(button => !button.disabled);

        if (target && target.classList.contains('slds-button')) {
          const currentIndex = buttonList.indexOf(target);

          if (currentIndex === -1) {
            return; // somehow the button that caught the event is not in the toolbar; ignore
          }

          if (event.keyCode === keyCodes$1.right) {
            this.moveToNextButton(buttonList, currentIndex);
          }

          if (event.keyCode === keyCodes$1.left) {
            this.moveToPreviousButton(buttonList, currentIndex);
          }
        }
      }
      /* ***********************************
           Inline image insertion handling
         *********************************** */

      /**
       * 1. Load the browser's native file selector
       * 2. Upload the selected file
       * 3. Insert the uploaded image into the editor
       */


      imageButtonClickHandler() {
        this.loadNativeFileSelector(fileList => {
          inputRichTextLibrary$1.uploadAndInsertSelectedFile(this.quill, fileList[0], this.shareWithEntityId);
        });
      }
      /**
       * 1. Load the browser's native file selector
       *     a. File selector will only show files of certain file types
       *     b. Supported file types - png, jpg, jpeg, gif
       * 2. Execute callback with the file list as param after a file has been selected
       * @param {Function} callback - Callback to be executed after file selection
       */


      loadNativeFileSelector(callback) {
        const container = document.createDocumentFragment();
        const input = document.createElement('input');
        input.type = 'file';
        input.multiple = false;
        input.accept = ALLOWED_IMAGE_FORMATS;

        input.onchange = function () {
          callback(this.files);
        };

        container.appendChild(input);
        input.click();
      }
      /* ***************************
           Link insertion handling
         *************************** */

      /**
       * Custom handler for onclick of link insertion button
       * 1. Get the text selected by user to insert a link on
       * 2. Get the formatting already present on the selected text
       * 3. If selected text already has a link format on it:
       *     a. If length of selected text is 0
       *         i.  Expand the selection length to the enclosing anchor node
       *         ii. Open create link panel with href value populated in input
       *     b. If length of selected text is more than 0
       *         i. Remove the link formatting from that selection
       * 4. If selected text does not have a link format on it:
       *     a. Open create link panel with 'http://' populated in input
       */


      linkButtonClickHandler() {
        const quillApi = this.quill;
        const selection = quillApi.getSelection();
        const format = quillApi.getFormat();
        quillApi.focus();

        if (format.link) {
          if (selection.length === 0) {
            // when cursor is on a link with no selection, show edit panel
            const nodeOnCursor = quillApi.getLeaf(selection.index)[0].domNode;
            const linkNode = this.getEnclosingLinkNode(nodeOnCursor);
            this.expandSelectionToNode(linkNode);
            this.openLinkPanel(linkNode.getAttribute('href'));
          } else {
            // when a link is selected, unlink it
            quillApi.format('link', false);
          }
        } else {
          this.openLinkPanel();
        }
      }
      /**
       * Update the link value to be saved as user types in create link panel input
       * @param {Event} event - Keyboard event to detect value of input
       */


      handleLinkValueChange(event) {
        event.stopPropagation(); // When pressing ESC after some input, a change evt gets fired too
        // During this case, detail doesn't exist and there is no change in value

        if (event.detail) {
          this.linkValue = event.detail.value;
        }
      }
      /**
       * Open the create link panel with the value of link already set
       * on the selection or the default value if no value is set
       * @param {String} value - Value to populate in create link panel input
       */


      openLinkPanel(value) {
        this.linkValue = value ? value : 'https://';
        this.queueLinkPanelOpen = true;
        this.linkPanelOpen = true;
      }

      closeLinkPanel() {
        this.linkPanelOpen = false;
      }
      /**
       * Set the text selection's format to link type,
       * with the href value being the value typed in by
       * the user in the create link panel input box
       */


      saveLink() {
        const quillApi = this.quill;
        const selection = quillApi.getSelection(true);

        if (selection.length === 0) {
          quillApi.insertText(selection.index, this.linkValue, {
            link: this.linkValue
          });
        } else {
          quillApi.format('link', this.linkValue);
        }

        this.closeLinkPanel();
      }
      /**
       * Close create link panel without saving
       */


      cancelLink() {
        this.closeLinkPanel();
      }
      /**
       * Calculate and position the create link panel correctly based on the editor's bounds
       * 1. Attempt to align the panel's center with the insert link button's center
       * 2. If panel's right edge goes past the editor's right edge, align both the right edges
       * 3. If panel's left edge goes past the editor's left edge, align both the left edges
       * 4. Vertically position the panel based on the toolbar's position
       * @param {HTMLElement} createLinkPanel -
       */


      calculateLinkPanelPositioning(createLinkPanel) {
        const linkButton = this.template.querySelector('.ql-link');
        const toolbar = this.template.querySelector('.ql-toolbar');
        createLinkPanel.style.position = 'absolute';
        createLinkPanel.style.width = CREATE_LINK_PANEL_WIDTH + 'px'; // Horizontal Positioning of Create Link Panel:
        // Align the center of the panel with the center of the button

        const linkButtonCenter = linkButton.offsetLeft + linkButton.offsetWidth / 2;
        createLinkPanel.style.left = linkButtonCenter - CREATE_LINK_PANEL_WIDTH / 2 + 'px';
        const createLinkPanelLeft = getStyleAsInt(createLinkPanel, 'left');
        const createLinkPanelWidth = getStyleAsInt(createLinkPanel, 'width'); // If panel is going out of the editor/toolbar on the right, position the right
        // of the panel to the right of the editor/toolbar

        if (createLinkPanelLeft + createLinkPanelWidth > toolbar.offsetWidth) {
          const diff = createLinkPanelLeft + createLinkPanelWidth - toolbar.offsetWidth;
          createLinkPanel.style.left = createLinkPanelLeft - diff + 'px';
        } // If panel is going out of the editor/toolbar on the left, position the left
        // of the panel to the left of the editor/toolbar


        if (getStyleAsInt(createLinkPanel, 'left') < toolbar.offsetLeft) {
          createLinkPanel.style.left = toolbar.offsetLeft + 'px';
        } // Vertical Positioning of Create Link Panel


        if (this.variant === 'bottom-toolbar') {
          createLinkPanel.style.top = toolbar.offsetTop - createLinkPanel.offsetHeight + 'px';
        } else {
          createLinkPanel.style.top = toolbar.offsetTop + toolbar.offsetHeight + 'px';
        }
      }
      /**
       * Get the enclosing link node.
       * Search upward through parentNode.
       *
       * @param {Object} node - node of which to find enclosing node
       * @returns {Object} returns the enclosing link node
       */


      getEnclosingLinkNode(node) {
        const quillApi = this.quill;
        const endNode = quillApi.scroll.domNode;
        let currentNode = node;

        while (currentNode && currentNode !== endNode) {
          if (currentNode.tagName === 'A') {
            return currentNode;
          }

          currentNode = currentNode.parentNode;
        }

        return null;
      }
      /**
       * Expand selection to the whole node
       * when selection only covers the node partially
       *
       * @param {Object} node - node of which to expand selection
       */


      expandSelectionToNode(node) {
        const quillApi = this.quill;
        const blot = quillApi.constructor.find(node);

        if (blot) {
          quillApi.focus();
          quillApi.setSelection(quillApi.getIndex(blot), blot.length());
        }
      }
      /**
       * Handle the ENTER and ESC keys appropriately:
       *  1. Handle ENTER key to save the input value
       *  2. Handle ESC key to close the create link panel
       *
       * @param {Event} evt Keyboard event to detect and handle the key pressed
       */


      linkKeyboardPress(evt) {
        this.activateEditor();
        let handled = false;

        if (evt.keyCode === keyCodes$1.enter) {
          this.saveLink();
          handled = true;
        } else if (evt.keyCode === keyCodes$1.escape) {
          this.closeLinkPanel();
          handled = true;
        } // If the events are handled,
        // let them die here


        if (handled) {
          evt.stopPropagation();
          evt.preventDefault();
        }
      }

      handleLinkPanelFocusOut() {
        this.linkPanelHasFocus = false; // Check if in the next frame the panel still has focus, and if not, close the panel
        // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          if (!this.linkPanelHasFocus) {
            this.closeLinkPanel();
          }
        });
      }

      handleLinkPanelFocusIn() {
        this.linkPanelHasFocus = true;
      }
      /**
       * Set the format of the text to font selected from the font dropdown
       * If user selects the default font, we do not set a font name when
       * formatting the text
       * Set the selected font so the font menu displays the right value
       * @param {Event} fontChangeEvt - Event fired by dropdown combobox
       */


      selectFont(fontChangeEvt) {
        fontChangeEvt.stopPropagation();
        const selectFont = fontChangeEvt.detail.value;
        let formatFont = selectFont;

        if (formatFont === DEFAULT_FONT_NAME_VALUE) {
          // We don't want quill to set the font name to 'default'
          formatFont = '';
        }

        const quillApi = this.quill;
        quillApi.focus();
        quillApi.format('font', formatFont);
        this.selectedFontValue = selectFont;
      }
      /**
       * Set the format of the text to font size selected from the dropdown
       * @param {Event} sizeChangeEvt - Event fired by dropdown combobox
       */


      selectSize(sizeChangeEvt) {
        sizeChangeEvt.stopPropagation();
        const selectSize = sizeChangeEvt.detail.value;
        const quillApi = this.quill;
        quillApi.focus();
        quillApi.format('size', selectSize);
        this.selectedSizeValue = selectSize;
      }
      /**
       * Update the value shown by the font dropdown based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateFontMenu(format) {
        const newFont = format && format.font ? format.font : DEFAULT_FONT_NAME_VALUE;
        this.selectedFontValue = newFont;
      }
      /**
       * Update the value shown by the font size dropdown based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateSizeMenu(format) {
        const newSize = format && format.size ? format.size : DEFAULT_FONT_SIZE_VALUE;
        this.selectedSizeValue = newSize;
      }
      /**
       * Update the color shown by the color picker button based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateTextColorButton(format) {
        const newTextColor = format && format.color ? format.color : DEFAULT_TEXT_COLOR_VALUE;
        this.selectedTextColorValue = newTextColor;
      }
      /**
       *
       * @param {Object} format - Format of the selected text
       */


      applyTextAlignment(format) {
        // Default to right alignment in RTL if existing selection has no alignment
        if (isRTL() && (!format.align || format.align === '')) {
          this.quill.format('align', 'right', 'silent');
        }
      }
      /**
       * Whenever the color changes, it will trigger quill API color change
       * @param {Object} event - change event with text color from colorpicker.
       */


      handleColorUpdate(event) {
        const quillApi = this.quill;
        this.selectedTextColorValue = event.detail.color;
        quillApi.format('color', this.selectedTextColorValue);
      }
      /**
       * Whenever the quill state changes, update each button's pressed state based on the format of given range.
       * @param {Object} range - text range from quill.
       */


      updateButtonPressedState(range) {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);
        const formats = range ? this.quill.getFormat(range) : {};
        buttonList.forEach(button => {
          if (button) {
            const {
              format
            } = button.dataset;
            const value = button.getAttribute('value');
            let isActive = false;

            if (value === null) {
              isActive = !!formats[format];
            } else if (format === 'align' && value === '' && !isRTL()) {
              isActive = !formats[format] || formats[format] === 'left';
            } else {
              isActive = formats[format] === value;
            }

            button.classList.toggle('slds-is-selected', isActive);
            button.setAttribute('aria-pressed', isActive);
          }
        });
      }
      /**
       * Check if the current device is desktop or not.
       * @returns {boolean} true if its desktop, false otherwise.
       */


      get isDesktop() {
        return formFactor === 'Large';
      }
      /**
       * Fire a change event by passing the contents of the
       * editor as the value
       */


      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this.internalValue
          }
        }));
      }

      get shouldShowPlaceholder() {
        return !this.value && this.placeholder;
      }

      handleStandInClick(event) {
        // prevent any navigation from links being clicked
        event.preventDefault();
      }

      setContent(html, source = 'api') {
        if (this.quill) {
          // convert api is not documented in official doc
          const delta = this.quill.clipboard.convert(this.internalValue);
          this.quill.setContents(delta, source);
        }
      }
      /**
       * Reserved for internal use. Insert text in the rich text editor at cursor position.
       *
       * @param {String} text - text to insert
       */


      insertTextAtCursor(text) {
        if (!this.quill) {
          this.activateEditor();
        }

        const selection = this.quill.getSelection(true);
        const cursorPosition = selection ? selection.index : this.quill.getLength() - 1;

        if (selection && selection.length !== 0) {
          this.quill.deleteText(selection.index, selection.length);
        }

        this.quill.insertText(cursorPosition, text);
      }

    }

    lwc.registerDecorators(LightningInputRichText, {
      publicProps: {
        label: {
          config: 0
        },
        labelVisible: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        disabledCategories: {
          config: 0
        },
        formats: {
          config: 0
        },
        variant: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        customButtons: {
          config: 0
        },
        shareWithEntityId: {
          config: 0
        },
        value: {
          config: 3
        },
        valid: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "setFormat", "getFormat", "insertTextAtCursor"],
      track: {
        _valid: 1,
        _disabled: 1,
        linkPanelOpen: 1,
        queueLinkPanelOpen: 1,
        selectedFontValue: 1,
        selectedSizeValue: 1,
        quillNotReady: 1,
        selectedTextColorValue: 1
      },
      fields: ["_pendingFormats", "quill", "initialRender", "internalValue", "linkValue", "fontMenus"]
    });

    var _lightningInputRichText = lwc.registerComponent(LightningInputRichText, {
      tmpl: _tmpl$x
    });

    function tmpl$z($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_custom_element("lightning-input-rich-text", _lightningInputRichText, {
        props: {
          "value": $cmp._displayValue,
          "formats": $cmp.formats,
          "messageWhenBadInput": $cmp._helpMessage,
          "valid": $cmp._noErrors,
          "disabled": $cmp.disabled,
          "disabledCategories": $cmp.disabledCategories,
          "customButtons": $cmp.customButtons
        },
        key: 3,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleChange)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur))
        }
      }, [])];
    }

    var _tmpl$y = lwc.registerTemplate(tmpl$z);
    tmpl$z.stylesheets = [];

    if (_implicitStylesheets$c) {
      tmpl$z.stylesheets.push.apply(tmpl$z.stylesheets, _implicitStylesheets$c);
    }
    tmpl$z.stylesheetTokens = {
      hostAttribute: "lightning-quill_quill-host",
      shadowAttribute: "lightning-quill_quill"
    };

    const i18n$i = {
      required: labelRequired
    };
    const defaultFormats = ['abbr', 'address', 'align', 'alt', 'background', 'bdo', 'big', 'blockquote', 'bold', 'cite', 'clean', 'code', 'code-block', 'color', 'data-fileid', 'del', 'dfn', 'direction', 'divider', 'dl', 'dd', 'dt', 'font', 'header', 'image', 'indent', 'ins', 'ins', 'italic', 'kbd', 'link', 'list', 'q', 'samp', 'script', 'size', 'small', 'strike', 'sup', 'table', 'tt', 'underline', 'var'];

    class LightningQuill extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._required = false;
        this._helpMessage = '';
        this._noErrors = true;
        this._fieldLevelHelp = void 0;
        this._disabled = false;
        this._displayValue = void 0;
        this.label = void 0;
        this.disabledCategories = '';
        this.messageWhenValueMissing = void 0;
        this.customButtons = void 0;
        this.fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.uniqueId = generateUniqueId();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.reportValidity());
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
        this._displayValue = value ? value : '';
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get disabled() {
        return this._disabled;
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      focus() {
        this.inputRichTextElement.focus();
        this.handleFocus();
      }

      blur() {
        this.inputRichTextElement.blur();
        this.handleBlur();
      }

      get validity() {
        return this._constraint.validity;
      }

      checkValidity() {
        return this._constraint.checkValidity();
      }

      reportValidity() {
        return this._constraint.reportValidity(message => {
          // The errors are shown via the underlying input-rich-text component,
          // we should change it to be more in-line with the other input components
          this._helpMessage = message;
          this._noErrors = message === '';
        });
      }

      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }

      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleChange(event) {
        this._value = event.detail.value;
      }

      get i18n() {
        return i18n$i;
      }

      get formats() {
        return defaultFormats;
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.value)
          });
        }

        return this._constraintApi;
      }

      get inputRichTextElement() {
        return this.template.querySelector('lightning-input-rich-text');
      }

    }

    lwc.registerDecorators(LightningQuill, {
      publicProps: {
        label: {
          config: 0
        },
        disabledCategories: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        customButtons: {
          config: 0
        },
        fieldLevelHelp: {
          config: 0
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _required: 1,
        _helpMessage: 1,
        _noErrors: 1,
        _fieldLevelHelp: 1,
        _disabled: 1,
        _displayValue: 1
      }
    });

    var _lightningQuill = lwc.registerComponent(LightningQuill, {
      tmpl: _tmpl$y
    });

    function stylesheet$e(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$e = [stylesheet$e];

    function stylesheet$f(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$f = [stylesheet$f];

    function stylesheet$g(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$g = [stylesheet$g];

    var labelPillDelete = 'Press delete or backspace to remove';

    var labelPillError = 'Error';

    var labelPillRemove = 'Remove';

    var labelPillWarning = 'Warning';

    var labelPillDeleteAndNavigate = 'Press delete or backspace to remove, press enter to navigate';

    function tmpl$A($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        h: api_element,
        c: api_custom_element,
        d: api_dynamic,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [!$cmp._hasError ? $cmp._hasMedia ? api_element("span", {
        classMap: {
          "slds-pill__icon_container": true
        },
        key: 1
      }, [api_slot("", {
        key: 0
      }, [], $slotset)]) : null : null, $cmp._hasError ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__icon_container": true
        },
        props: {
          "title": $cmp.i18n.pillError,
          "iconName": "utility:error",
          "variant": "bare",
          "svgClass": "slds-icon slds-icon-text-error"
        },
        key: 2
      }, []) : null, $cmp._hasError ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.i18n.pillWarning)]) : null, $cmp.hasHref ? api_element("a", {
        classMap: {
          "slds-pill__action": true
        },
        attrs: {
          "href": $cmp.href
        },
        key: 5
      }, [api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 4
      }, [api_dynamic($cmp.label)])]) : null, !$cmp.hasHref ? api_element("span", {
        classMap: {
          "slds-pill__action": true
        },
        key: 7
      }, [api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 6
      }, [api_dynamic($cmp.label)])]) : null, api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-pill__remove": true
        },
        props: {
          "iconName": "utility:close",
          "variant": "bare",
          "title": $cmp.i18n.pillRemove,
          "tabIndex": api_tab_index($cmp._tabIndex),
          "alternativeText": $cmp.i18n.pillRemove
        },
        key: 8,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, [])];
    }

    var link = lwc.registerTemplate(tmpl$A);
    tmpl$A.slots = [""];
    tmpl$A.stylesheets = [];
    tmpl$A.stylesheetTokens = {
      hostAttribute: "lightning-pill_link-host",
      shadowAttribute: "lightning-pill_link"
    };

    function tmpl$B($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp._hasMedia ? api_slot("", {
        key: 0
      }, [], $slotset) : null, api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 1
      }, [api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__remove": true
        },
        props: {
          "title": $cmp.i18n.pillRemove,
          "iconName": "utility:close",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default",
          "variant": "bare"
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.assistiveText)])];
    }

    var plain = lwc.registerTemplate(tmpl$B);
    tmpl$B.slots = [""];
    tmpl$B.stylesheets = [];
    tmpl$B.stylesheetTokens = {
      hostAttribute: "lightning-pill_plain-host",
      shadowAttribute: "lightning-pill_plain"
    };

    function tmpl$C($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("a", {
        attrs: {
          "href": $cmp.href,
          "tabindex": api_tab_index($cmp._tabIndex),
          "aria-selected": $cmp._ariaSelected,
          "role": $cmp._role
        },
        key: 4,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, [$cmp._hasMedia ? api_slot("", {
        key: 0
      }, [], $slotset) : null, api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 1
      }, [api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__remove": true
        },
        props: {
          "title": $cmp.i18n.pillRemove,
          "iconName": "utility:close",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default",
          "variant": "bare"
        },
        key: 2
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.assistiveText)])])];
    }

    var plainLink = lwc.registerTemplate(tmpl$C);
    tmpl$C.slots = [""];
    tmpl$C.stylesheets = [];
    tmpl$C.stylesheetTokens = {
      hostAttribute: "lightning-pill_plainLink-host",
      shadowAttribute: "lightning-pill_plainLink"
    };

    const i18n$j = {
      pillDelete: labelPillDelete,
      pillError: labelPillError,
      pillRemove: labelPillRemove,
      pillWarning: labelPillWarning,
      pillDeleteAndNavigate: labelPillDeleteAndNavigate
    };
    const VARIANT$1 = {
      PLAIN: 'plain',
      PLAIN_LINK: 'plainLink',
      LINK: 'link'
    };

    function modifyAttribute(el, name, value) {
      if (!el.isPlainLink) {
        if (value !== null && value !== undefined && value !== '') {
          el.setAttribute(name, value);
        } else {
          el.removeAttribute(name);
        }
      } else {
        el.removeAttribute(name);
      }
    }
    /**
     * A pill displays a label that can contain links and can be removed from view.
     * @slot default Placeholder for an image, such as an icon or avatar.
     */


    class LightningPill extends lwc.LightningElement {
      /**
       * The URL of the page that the link goes to.
       * @type {string}
       */
      get href() {
        return this._href;
      }

      set href(value) {
        this._href = value;

        if (this._connected && (this.isPlainLink || this.isLink)) {
          this.updateLinkInfo(value);
        }
      }

      render() {
        switch (this.variant) {
          case VARIANT$1.PLAIN:
            return plain;

          case VARIANT$1.PLAIN_LINK:
            return plainLink;

          case VARIANT$1.LINK:
          default:
            return link;
        }
      }
      /**
       * If present, the pill is shown with a red border and an error icon on the left of the label.
       * @type {boolean}
       * @default false
       */


      get hasError() {
        return this._hasError || false;
      }

      set hasError(value) {
        this._hasError = normalizeBoolean(value);
      }

      get assistiveText() {
        return this.variant === VARIANT$1.PLAIN_LINK ? this.i18n.pillDeleteAndNavigate : this.i18n.pillDelete;
      }

      constructor() {
        super();
        this._href = void 0;
        this.label = void 0;
        this.name = void 0;
        this.variant = VARIANT$1.LINK;
        this._role = void 0;
        this._ariaSelected = void 0;
        this._hasMedia = true;
        this._hasError = void 0;
        this._tabIndex = void 0;
        this._connected = false;

        this._dispatcher = () => {};

        this.addEventListener('keydown', this.handleKeypress.bind(this));
      }

      get pillClass() {
        const cssClass = ['slds-pill'];

        switch (this.variant) {
          case VARIANT$1.PLAIN:
          case VARIANT$1.PLAIN_LINK:
            break;

          case VARIANT$1.LINK:
          default:
            cssClass.push('slds-pill_link');
        }

        return cssClass;
      }

      checkMediaElement() {
        if (!this._mediaElement) {
          this._mediaElement = this.template.querySelector('slot');
        }

        return this._mediaElement && this._mediaElement.assignedNodes().length > 0;
      }

      renderedCallback() {
        const el = this.isPlainLink ? this.template.querySelector('a') : this;
        this.pillClass.forEach(name => el.classList.add(name)); // check if a component was passed into the slot

        this._hasMedia = this.checkMediaElement();
        classListMutation(this.classList, {
          'slds-has-error': this.hasError
        }); // set attributes to self if variant is plain or link

        modifyAttribute(this, 'tabindex', this.tabIndex);
        modifyAttribute(this, 'role', this.role);
        modifyAttribute(this, 'aria-selected', this.ariaSelected);
      }
      /**
       * Reserved for internal use. Specifies whether the element variant is a plain link.
       * @type {boolean}
       * @return {boolean} true if variant is a plain link.
       */


      get isPlainLink() {
        return this.variant === VARIANT$1.PLAIN_LINK;
      }

      get isLink() {
        return this.variant === VARIANT$1.LINK;
      }
      /**
       * Reserved for internal use. Use tabindex instead to indicate if an element should be focusable.
       * A value of 0 means that the pill is focusable and
       * participates in sequential keyboard navigation. A value of -1 means
       * that the pill is focusable but does not participate in keyboard navigation.
       * @type {number}
       */


      get tabIndex() {
        return this._tabIndex;
      }

      set tabIndex(value) {
        this._tabIndex = value;
        modifyAttribute(this, 'tabindex', this._tabIndex);
      }
      /**
       * Specifies the aria-selected of an element.
       */


      get ariaSelected() {
        return this._ariaSelected;
      }

      set ariaSelected(value) {
        this._ariaSelected = normalizeBoolean(value);
        modifyAttribute(this, 'aria-selected', this._ariaSelected);
      }
      /**
       * Specifies the role of an element.
       */


      get role() {
        return this._role;
      }

      set role(value) {
        this._role = value;
        modifyAttribute(this, 'role', this._role);
      }

      get i18n() {
        return i18n$j;
      }

      get hasHref() {
        return !!this.href;
      }

      get labelElement() {
        if (!this._labelElement) {
          this._labelElement = this.template.querySelector('a.slds-pill__label');
        }

        return this._labelElement;
      }

      get removeIconElement() {
        if (!this._removeIconElement) {
          this._removeIconElement = this.template.querySelector('lightning-primitive-icon');
        }

        return this._removeIconElement;
      }

      connectedCallback() {
        this._connected = true;

        if (this.isPlainLink || this.isLink) {
          this.updateLinkInfo(this.href);
        }
      }

      disconnectedCallback() {
        this._connected = false;
      }

      handleKeypress(event) {
        switch (event.keyCode) {
          case keyCodes.delete:
          case keyCodes.backspace:
            this.handleRemove(event);
            break;

          case keyCodes.enter:
            this.handleEnter(event);
            break;
        }
      }

      handleEnter() {
        if (this.isPlainLink) {
          if (this.labelElement) {
            this.labelElement.click();
          }
        }
      }

      handleClick(event) {
        if (event.target === this.removeIconElement) {
          // click on the X icon to remove the item
          event.stopPropagation();
          event.preventDefault();
          this.handleRemove(event);
        } else if (this.isPlainLink || this.isLink) {
          this._dispatcher(event);
        }
      }

      handleRemove(event) {
        const removeEvent = new CustomEvent('remove', {
          cancelable: true,
          detail: {
            name: this.name
          }
        });
        this.dispatchEvent(removeEvent);

        if (removeEvent.defaultPrevented) {
          event.stopPropagation();
        }
      }
      /**
       * Reserved for internal use.
       * Sets focus on the anchor element for a plain link.
       */


      focusLink() {
        const el = this.template.querySelector('A');

        if (el) {
          el.focus();
        }
      }

      updateLinkInfo(url) {
        updateRawLinkInfo(this, {
          url: this.makeAbsoluteUrl(url)
        }).then(linkInfo => {
          this._url = linkInfo.url;
          this._dispatcher = linkInfo.dispatcher;
        });
      }

      makeAbsoluteUrl(url) {
        return isAbsoluteUrl(url) ? url : `http://${url}`;
      }

    }

    lwc.registerDecorators(LightningPill, {
      publicProps: {
        href: {
          config: 3
        },
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        variant: {
          config: 0
        },
        hasError: {
          config: 3
        },
        isPlainLink: {
          config: 1
        },
        tabIndex: {
          config: 3
        },
        ariaSelected: {
          config: 3
        },
        role: {
          config: 3
        }
      },
      publicMethods: ["focusLink"],
      track: {
        _href: 1,
        _role: 1,
        _ariaSelected: 1,
        _hasMedia: 1,
        _hasError: 1,
        _tabIndex: 1
      },
      fields: ["_connected", "_dispatcher"]
    });

    var _lightningPill = lwc.registerComponent(LightningPill, {
      tmpl: _tmpl$3
    });

    function tmpl$D($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp._src ? api_element("img", {
        attrs: {
          "src": $cmp._src,
          "alt": $cmp.alternativeText,
          "title": $cmp.alternativeText
        },
        key: 0,
        on: {
          "error": _m0 || ($ctx._m0 = api_bind($cmp.handleImageError))
        }
      }, []) : null, $cmp.showInitials ? api_element("abbr", {
        className: $cmp.computedInitialsClass,
        attrs: {
          "title": $cmp.alternativeText
        },
        key: 1
      }, [api_dynamic($cmp.initials)]) : null, $cmp.showIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.fallbackIconName,
          "alternativeText": $cmp.alternativeText,
          "title": $cmp.alternativeText
        },
        key: 2
      }, []) : null];
    }

    var _tmpl$z = lwc.registerTemplate(tmpl$D);
    tmpl$D.stylesheets = [];
    tmpl$D.stylesheetTokens = {
      hostAttribute: "lightning-avatar_avatar-host",
      shadowAttribute: "lightning-avatar_avatar"
    };

    const DEFAULT_SIZE$1 = 'medium';
    const DEFAULT_VARIANT$1 = 'square';
    /**
     * A visual representation of an object.
     */

    class LightningAvatar extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = '';
        this.fallbackIconName = void 0;
        this.initials = void 0;
        this._size = DEFAULT_SIZE$1;
        this._src = '';
        this._variant = DEFAULT_VARIANT$1;
      }

      /**
       * The size of the avatar. Valid values are x-small, small, medium, and large. This value defaults to medium.
       *
       * @type {string}
       * @default medium
       */
      get size() {
        return this._size;
      }

      set size(value) {
        this._size = normalizeString(value, {
          fallbackValue: DEFAULT_SIZE$1,
          validValues: ['x-small', 'small', 'medium', 'large']
        });
        this.updateClassList();
      }
      /**
       * The URL for the image.
       *
       * @type {string}
       * @required
       */


      get src() {
        return this._src;
      }

      set src(value) {
        this._src = typeof value === 'string' && value.trim() || '';
      }
      /**
       * The variant changes the shape of the avatar. Valid values are empty,
       * circle, and square. This value defaults to square.
       *
       * @type {string}
       * @default square
       */


      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: DEFAULT_VARIANT$1,
          validValues: ['circle', 'square']
        });
        this.updateClassList();
      }

      connectedCallback() {
        this.updateClassList();
      } // update custom element's classList


      updateClassList() {
        const size = this._size;
        const variant = this._variant;
        const classes = classSet('slds-avatar').add({
          'slds-avatar_x-small': size === 'x-small',
          'slds-avatar_small': size === 'small',
          'slds-avatar_medium': size === 'medium',
          'slds-avatar_large': size === 'large'
        }).add({
          'slds-avatar_circle': variant === 'circle'
        });
        classListMutation(this.classList, classes);
      }

      get computedInitialsClass() {
        return classSet('slds-avatar__initials').add(computeSldsClass(this.fallbackIconName)).toString();
      }

      get showInitials() {
        return !this._src && this.initials;
      }

      get showIcon() {
        return !this._src && !this.initials;
      }

      handleImageError(event) {
        // eslint-disable-next-line no-console
        console.warn(`<lightning-avatar> Image with src="${event.target.src}" failed to load.`);
        this._src = '';
      }

    }

    lwc.registerDecorators(LightningAvatar, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        fallbackIconName: {
          config: 0
        },
        initials: {
          config: 0
        },
        size: {
          config: 3
        },
        src: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      track: {
        _size: 1,
        _src: 1,
        _variant: 1
      }
    });

    var _lightningAvatar = lwc.registerComponent(LightningAvatar, {
      tmpl: _tmpl$z
    });

    function tmpl$E($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        b: api_bind,
        h: api_element,
        c: api_custom_element,
        ti: api_tab_index,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [$cmp._showMore ? api_element("span", {
        classMap: {
          "slds-listbox-toggle": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 1
      }, [api_element("button", {
        classMap: {
          "slds-button": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleMoreClick))
        }
      }, [api_dynamic($cmp.computedPillCountMoreLabel)])]) : null, api_element("ul", {
        className: $cmp.computedListboxClass,
        attrs: {
          "role": "listbox",
          "aria-label": $cmp.label,
          "aria-orientation": "horizontal"
        },
        key: 6,
        on: {
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleClick)),
          "keydown": _m6 || ($ctx._m6 = api_bind($cmp.handleKeyDown))
        }
      }, api_iterator($cmp.pillViewModels, function (pillViewModel, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox-item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(5, pillViewModel.pill.item.label)
        }, [api_custom_element("lightning-pill", _lightningPill, {
          props: {
            "label": pillViewModel.pill.item.label,
            "name": index,
            "href": pillViewModel.pill.item.href,
            "tabIndex": api_tab_index(pillViewModel.tabIndex),
            "role": "option",
            "variant": pillViewModel.pill.variant,
            "ariaSelected": "true"
          },
          key: 4,
          on: {
            "click": _m1 || ($ctx._m1 = api_bind($cmp.handlePillClick)),
            "remove": _m2 || ($ctx._m2 = api_bind($cmp.handleRemove)),
            "blur": _m3 || ($ctx._m3 = api_bind($cmp.handlePillBlur)),
            "focus": _m4 || ($ctx._m4 = api_bind($cmp.handlePillFocus))
          }
        }, [pillViewModel.pill.isIcon ? api_custom_element("lightning-icon", _lightningIcon, {
          classMap: {
            "slds-pill__icon_container": true
          },
          props: {
            "iconName": pillViewModel.pill.item.iconName,
            "alternativeText": pillViewModel.pill.item.alternativeText
          },
          key: 2
        }, []) : null, pillViewModel.pill.isAvatar ? api_custom_element("lightning-avatar", _lightningAvatar, {
          classMap: {
            "slds-pill__icon_container": true
          },
          props: {
            "src": pillViewModel.pill.item.src,
            "fallbackIconName": pillViewModel.pill.item.fallbackIconName,
            "variant": pillViewModel.pill.item.variant,
            "size": "x-small",
            "alternativeText": pillViewModel.pill.item.alternativeText
          },
          key: 3
        }, []) : null])]);
      }))];
    }

    var _tmpl$A = lwc.registerTemplate(tmpl$E);
    tmpl$E.stylesheets = [];
    tmpl$E.stylesheetTokens = {
      hostAttribute: "lightning-pillContainer_pillContainer-host",
      shadowAttribute: "lightning-pillContainer_pillContainer"
    };

    var labelContainerLabel = 'Selected Options:';

    var pillContainerMoreLabel = '+{0} more';

    class LightningPillItem {
      constructor(item) {
        this._item = item;
      }

      get item() {
        return this._item;
      }

      get isAvatar() {
        return this._item.type === 'avatar';
      }

      get isIcon() {
        return this._item.type === 'icon';
      }

      get variant() {
        return this._item.href && this._item.href !== '' ? 'plainLink' : 'plain';
      }

    }

    var LightningPillItem$1 = lwc.registerComponent(LightningPillItem, {
      tmpl: _tmpl$3
    });

    const PILL_SELECTOR = 'lightning-pill';
    const i18n$k = {
      containerLabel: labelContainerLabel
    };
    /**
     * A list of pills grouped in a container. This component requires API version 42.0 and later.
     */

    class LightningPillContainer extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = i18n$k.containerLabel;
        this._variant = void 0;
        this._singleLine = false;
        this._isExpanded = false;
        this._isCollapsible = false;
        this._focusedIndex = 0;
        this._focusedTabIndex = 0;
        this._pillsNotFittingCount = void 0;
        this._pillContainerElementId = void 0;
        this.items = void 0;
      }

      connectedCallback() {
        this._connected = true;

        if (this.variant !== 'bare') {
          this.classList.add('slds-pill_container');
        }
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }
      }

      renderedCallback() {
        if (this._resizeObserver) {
          // If we have a resize observer and the pill container is not collapsible it means it was changed
          // to not collapsible, we should disconnect the resize observer.
          if (!this.isCollapsible) {
            this._resizeObserver.disconnect();

            this._resizeObserver = undefined;
          }
        } else if (this.isCollapsible) {
          // No resize observer and is collapsible, we should setup the resize observer
          this._resizeObserver = this._setupResizeObserver();
        }

        const ul = this.template.querySelector('ul');

        if (this.pills.length === 0) {
          // If no option is present, set ul has the focus (SLDS require UL has focus).
          ul.tabIndex = 0;
        } else {
          ul.tabIndex = -1;
          this.setFocusedItemTabIndex(0); // Consider adding pills programmatically to empty pill container.
          // UL has focus, so should shift focus to pill.

          if (this.template.querySelector('ul:focus')) {
            this.focus();
          }
        }
      }
      /**
       * The variant changes the appearance of the pill container. Accepted variants
       * include standard and bare. This value defaults to standard.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || 'standard';
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: 'standard',
          validValues: ['standard', 'bare']
        });
      }
      /**
       * Specifies whether to keep the pills in a single line.
       * @type {boolean}
       *
       */


      get singleLine() {
        return this._singleLine;
      }

      set singleLine(value) {
        this._singleLine = normalizeBoolean(value);
      }
      /**
       * Specifies whether the pill container can be collapsed.
       * @type {boolean}
       */


      get isCollapsible() {
        return this._isCollapsible;
      }

      set isCollapsible(value) {
        this._isCollapsible = normalizeBoolean(value);
      }
      /**
       * Specifies whether the pill container is expanded.
       * @type {boolean}
       */


      get isExpanded() {
        return this._isExpanded;
      }

      set isExpanded(value) {
        this._isExpanded = normalizeBoolean(value);
        this.classList.toggle('slds-is-expanded', this._isExpanded);
      }
      /**
       * An array of items to be rendered as pills in a container.
       * @type {list}
       */


      get pills() {
        return Array.isArray(this.items) ? this.items : [];
      }

      get pillViewModels() {
        return this.pills.map((item, index) => {
          const pill = new LightningPillItem$1(item);
          return {
            pill,
            tabIndex: this._focusedIndex === index ? this._focusedTabIndex : -1
          };
        });
      }

      get computedListboxClass() {
        const singleLineClass = this.singleLine ? 'slds-listbox_inline' : '';
        return `slds-listbox slds-listbox_horizontal ${singleLineClass}`;
      }

      get focusedIndex() {
        // NOTE: this._pills is manged by getter, setter. So it won't be null or undefined.
        // So call this._pill.length is safe.
        if (this._focusedIndex >= this.pills.length) {
          // Change is due to itemremove event, should move focus to the last one.
          this._focusedIndex = this._deleteLast ? this.pills.length - 1 : 0;
          this._deleteLast = false;
        } else if (this._focusedIndex < 0) {
          this._focusedIndex = this.pills.length - 1;
        }

        return this._focusedIndex;
      }

      set focusedIndex(value) {
        // Host may asynchronous update items. For example, move focus to latest item with right/left key, then host change items.
        // Then at renderedCallback call, need to update which item should has focus, but index > items.length.
        // When set it, the index is valid, but when rendered, index is not valid, so the validation check is happened at getter.
        this._focusedIndex = value;
      }

      get pillNodes() {
        return this.template.querySelectorAll(PILL_SELECTOR) || [];
      }

      get focusedNode() {
        const pills = this.pillNodes;
        return pills.length <= 0 ? null : pills[this.focusedIndex];
      }
      /**
       * Sets focus on the pill list.
       */


      focus() {
        const focusedNode = this.focusedNode;

        if (focusedNode) {
          if (focusedNode.isPlainLink) {
            focusedNode.focusLink();
          } else {
            focusedNode.focus();
          }
        } else {
          const ul = this.template.querySelector('ul');

          if (ul) {
            ul.focus();
          }
        }
      }

      handleRemove(removeEvent) {
        const index = parseInt(removeEvent.detail.name, 10);

        if (typeof index !== 'number' || index < 0) {
          return;
        }

        this.fireEvent(index);
      }

      fireEvent(index) {
        // Mouse click on non-focused pill, switch focus to it.
        if (this.focusedIndex !== index) {
          this.switchFocus(index);
        } // Request to remove the last one, if removed, should move focus to last.


        this._deleteLast = index >= this.pills.length - 1;
        this.dispatchEvent(new CustomEvent('itemremove', {
          detail: {
            item: this.pills[index],
            index
          }
        }));
      }

      setFocusedItemTabIndex(value) {
        const focusedNode = this.focusedNode;

        if (focusedNode) {
          this._focusedTabIndex = value;
        }
      }

      switchFocus(newValue) {
        // remove focus from current pill
        this.setFocusedItemTabIndex(-1); // move to next

        this.focusedIndex = newValue; // set focus

        this.setFocusedItemTabIndex(0);
        this.focus();
      }

      handleKeyDown(event) {
        if (this.pills.length <= 0) {
          return;
        }

        const index = this.focusedIndex;

        switch (event.keyCode) {
          case keyCodes.left:
          case keyCodes.up:
            this.switchFocus(index - 1);
            break;

          case keyCodes.right:
          case keyCodes.down:
            this.switchFocus(index + 1);
            break;

          default:
            this.focus();
        }
      }

      handlePillFocus() {
        if (!this._hasFocus) {
          this._hasFocus = true;
          this.dispatchEvent(new CustomEvent('focus'));
        }
      }

      handlePillBlur(event) {
        // Replace the below with !this.template.contains(event.relatedTarget) once 0.24 is out
        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this._hasFocus = false;
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }

      handleClick() {
        this.focus();
      }

      handlePillClick(clickEvent) {
        const index = parseInt(clickEvent.currentTarget.name, 10);

        if (index >= 0 && this.focusedIndex !== index) {
          this.switchFocus(index);
        } else {
          this.focus();
        }

        clickEvent.stopPropagation();
      }

      handleMoreClick() {
        this.focus();
      }

      get _showMore() {
        return this.isCollapsible && !this.isExpanded;
      }

      get computedPillCountMoreLabel() {
        if (this._isExpanded || isNaN(this._pillsNotFittingCount) || this._pillsNotFittingCount <= 0) {
          return undefined;
        } // TODO: We should have a standard utility for that


        return pillContainerMoreLabel.replace('{0}', this._pillsNotFittingCount);
      }

      _setupResizeObserver() {
        const resizeObserver = new LightningResizeObserver(() => {
          const visibleHeight = this.getBoundingClientRect().height;
          let notFittingCount = 0;

          for (let i = 0; i < this.pillNodes.length; i++) {
            const node = this.pillNodes[i];

            if (node.offsetTop > visibleHeight) {
              notFittingCount += 1;
            }
          }

          this._pillsNotFittingCount = notFittingCount;
        });
        resizeObserver.observe(this.template.querySelector('[role="listbox"]'));
        return resizeObserver;
      }

    }

    lwc.registerDecorators(LightningPillContainer, {
      publicProps: {
        label: {
          config: 0
        },
        variant: {
          config: 3
        },
        singleLine: {
          config: 3
        },
        isCollapsible: {
          config: 3
        },
        isExpanded: {
          config: 3
        },
        items: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        _variant: 1,
        _singleLine: 1,
        _isExpanded: 1,
        _isCollapsible: 1,
        _focusedIndex: 1,
        _focusedTabIndex: 1,
        _pillsNotFittingCount: 1,
        _pillContainerElementId: 1
      }
    });

    var _lightningPillContainer = lwc.registerComponent(LightningPillContainer, {
      tmpl: _tmpl$A
    });

    function tmpl$F($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "data-main-label": true
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 11
      }, [api_element("div", {
        className: $cmp.computedComboboxGroupClass,
        key: 9
      }, [$cmp.computedHasFilter ? api_element("label", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        attrs: {
          "data-filter-label": true
        },
        key: 3
      }, [api_dynamic($cmp.filterLabel)]) : null, $cmp.computedHasFilter ? api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-combobox_object-switcher": true,
          "slds-combobox-addon_start": true
        },
        key: 5
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        attrs: {
          "data-filter": true
        },
        props: {
          "disabled": $cmp.disabled,
          "items": $cmp.filterItems,
          "inputText": $cmp.filterInputText,
          "inputIconName": "utility:down",
          "inputIconSize": "xx-small",
          "dropdownAlignment": "auto"
        },
        key: 4,
        on: {
          "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleFilterReady)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "select": _m3 || ($ctx._m3 = api_bind($cmp.handleSelectFilter))
        }
      }, [])])])]) : null, api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        className: $cmp.computedLookupComboboxClass,
        attrs: {
          "data-lookup": true
        },
        props: {
          "name": $cmp.name,
          "disabled": $cmp.disabled,
          "required": $cmp.required,
          "variant": "lookup",
          "placeholder": $cmp.placeholder,
          "dropdownAlignment": "auto",
          "items": $cmp._items,
          "inputPill": $cmp.inputPill,
          "inputMaxlength": $cmp.inputMaxlength,
          "inputIconName": $cmp.inputIconName,
          "inputIconSize": $cmp.inputIconSize,
          "inputIconAlternativeText": $cmp.inputIconAlternativeText,
          "showInputActivityIndicator": $cmp.showActivityIndicator,
          "showDropdownActivityIndicator": $cmp.showDropdownActivityIndicator
        },
        key: 8,
        on: {
          "ready": _m4 || ($ctx._m4 = api_bind($cmp.handleLookupReady)),
          "textchange": _m5 || ($ctx._m5 = api_bind($cmp.handleTextChange)),
          "textinput": _m6 || ($ctx._m6 = api_bind($cmp.handleTextInput)),
          "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "pillremove": _m9 || ($ctx._m9 = api_bind($cmp.handlePillRemove)),
          "endreached": _m10 || ($ctx._m10 = api_bind($cmp.handleEndReached)),
          "dropdownopenrequest": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownOpenRequest)),
          "select": _m12 || ($ctx._m12 = api_bind($cmp.handleSelect))
        }
      }, [])]), $cmp._hasPills ? api_custom_element("lightning-pill-container", _lightningPillContainer, {
        classMap: {
          "slds-listbox_selection-group": true
        },
        props: {
          "variant": "bare",
          "items": $cmp.pills,
          "isCollapsible": true,
          "isExpanded": $cmp._expandPillContainer
        },
        key: 10,
        on: {
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handlePillsBlur)),
          "focus": _m14 || ($ctx._m14 = api_bind($cmp.handlePillsFocus)),
          "itemremove": _m15 || ($ctx._m15 = api_bind($cmp.handlePillRemove))
        }
      }, []) : null]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "data-help-message": true,
          "id": api_scoped_id("help-message"),
          "aria-live": "assertive"
        },
        key: 12
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$B = lwc.registerTemplate(tmpl$F);
    tmpl$F.stylesheets = [];

    if (_implicitStylesheets$g) {
      tmpl$F.stylesheets.push.apply(tmpl$F.stylesheets, _implicitStylesheets$g);
    }
    tmpl$F.stylesheetTokens = {
      hostAttribute: "lightning-groupedCombobox_groupedCombobox-host",
      shadowAttribute: "lightning-groupedCombobox_groupedCombobox"
    };

    const i18n$l = {
      required: labelRequired
    };

    class LightningGroupedCombobox extends lwc.LightningElement {
      // TODO: Consider renaming this to `inputMaxLength`
      // TODO: Rename to `showInputActivityIndicator`
      // Validity related message
      // TODO: Need to remove as if a readonly combobox is needed,
      // the regular lightning-combobox should be used
      constructor() {
        super();
        this.label = void 0;
        this.inputIconName = 'utility:search';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showActivityIndicator = false;
        this.showDropdownActivityIndicator = false;
        this.placeholder = 'Select an Item';
        this.messageWhenValueMissing = i18n$l.required;
        this.name = void 0;
        this.value = void 0;
        this.required = false;
        this.disabled = false;
        this.readOnly = false;
        this.inputPill = void 0;
        this.filterLabel = void 0;
        this.filterItems = void 0;
        this.filterInputText = void 0;
        this._pills = void 0;
        this._variant = void 0;
        this._items = [];
        this._expandPillContainer = false;
        this._highlightedOptionElementId = '';
        this._helpMessage = void 0;
        this._fieldLevelHelp = void 0;
        this._inputText = '';
        this._filterInputId = void 0;
        this._mainInputId = void 0;
        this._initialized = false;
        this._mainInputId = generateUniqueId();
        this._filterInputId = generateUniqueId();
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element');
        this.interactingState = new InteractingState({
          // keeps interacting state when switching between two comboboxes and the pill container
          debounceInteraction: true
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
        });
      }

      renderedCallback() {
        if (!this._initialized) {
          this._initialized = true;
          this.inputText = this._inputText;
        }

        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get inputText() {
        return this._inputText;
      }

      set inputText(text) {
        this._inputText = text;

        if (this._connected) {
          this.template.querySelector('[data-lookup]').inputText = text;
        }
      }

      get pills() {
        return this._pills;
      }

      set pills(newPills) {
        assert(Array.isArray(newPills), '"pills" must be an array.');

        if (this._connected && (!newPills || newPills.length === 0)) {
          if (this._focusOnPills) {
            // check why requestAnimationFrame is needed, something is stealing focus otherwise
            // eslint-disable-next-line @lwc/lwc/no-async-operation
            requestAnimationFrame(() => {
              this.lookupCombobox.focus();
            });
          }
        }

        this._pills = newPills;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      set items(items = []) {
        this._items = items;

        if (items) {
          assert(Array.isArray(items), '"items" must be an array.');
        }
      }

      get items() {
        return this._items;
      }

      highlightInputText() {
        if (this._connected) {
          this.lookupCombobox.highlightInputText();
        }
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this._connected) {
          this.lookupCombobox.focus();
        }
      }

      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          this.lookupCombobox.focusAndOpenDropdownIfNotEmpty();
        }
      }
      /**
       * Removes focus from the input element.
       */


      blur() {
        if (this._connected) {
          this.lookupCombobox.blur();
        }
      }

      get validity() {
        return this._constraint.validity;
      }

      checkValidity() {
        return this._constraint.checkValidity();
      }

      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }

      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }

      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      get computedUniqueHelpElementId() {
        return this._helpMessage ? this._mainInputId + '-error' : null;
      }

      get lookupCombobox() {
        return this.template.querySelector('[data-lookup]');
      }

      get i18n() {
        return i18n$l;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedComboboxGroupClass() {
        return classSet().add({
          'slds-has-selection': Array.isArray(this._pills) && this._pills.length > 0,
          'slds-combobox-group': this.computedHasFilter
        });
      }

      get computedHasFilter() {
        return Array.isArray(this.filterItems);
      }

      get computedLookupComboboxClass() {
        return this.computedHasFilter ? 'slds-combobox-addon_end' : '';
      }

      get _hasPills() {
        return this.pills && this.pills.length > 0;
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.value)
          });
        }

        return this._constraintApi;
      }

      handleLookupReady(event) {
        this._mainInputId = event.detail.id;
      }

      handleFilterReady(event) {
        this._filterInputId = event.detail.id;
      }

      handleDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }

      handlePillRemove(event) {
        if (!this.disabled) {
          this.dispatchEvent(new CustomEvent('pillremove', {
            detail: event.detail
          }));
        }
      }

      handleTextChange(event) {
        this._inputText = event.detail.text;
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text: event.detail.text
          }
        }));
      }

      handleTextInput(event) {
        this._inputText = event.detail.text;
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text: event.detail.text
          }
        }));
      }

      handleSelect(event) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value: event.detail.value
          }
        }));
      }

      handleSelectFilter(event) {
        const selectedFilterValue = event.detail.value;
        this.dispatchEvent(new CustomEvent('selectfilter', {
          detail: {
            value: selectedFilterValue
          }
        }));
      } // TODO: This should be renamed to `scrollend` or something similar (no -ed at the end)


      handleEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }

      handleFocus() {
        this.interactingState.enter();
        this._expandPillContainer = true;

        if (!this._hasFocus) {
          this._hasFocus = true;
          this.dispatchEvent(new CustomEvent('focus'));
        }
      }

      handlePillsFocus() {
        this.handleFocus();
        this._focusOnPills = true;
      }

      handlePillsBlur() {
        this.handleBlur();
        this._focusOnPills = false;
      }

      handleBlur() {
        this._hasFocus = false; // Once https://github.com/salesforce/lwc/issues/444 is fixed, consider switching to
        // `onfocusout` and `event.relatedTarget` to determine whether the focus stayed in the component,
        // this way the use of async blur can be avoided.
        // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          if (!this._hasFocus) {
            this.interactingState.leave();
            this.dispatchEvent(new CustomEvent('blur'));
            this._expandPillContainer = false;

            if (this.pills && this.pills.length > 0) {
              // Sometimes (involves focusing on lower pills) the pill container scrolls and the top
              // line with the "+ n more" button does not show so we have to manually scroll to the top.
              // We need to figure a better solution for this.
              // eslint-disable-next-line @lwc/lwc/no-async-operation
              requestAnimationFrame(() => {
                if (this._connected) {
                  this.template.querySelector('lightning-pill-container').scrollTop = 0;
                }
              });
            }
          }
        });
      }

      synchronizeA11y() {
        const label = this.template.querySelector('[data-main-label]');
        const filterLabel = this.template.querySelector('[data-filter-label]');
        const helpMessage = this.template.querySelector('[data-help-message]'); // const filter = this.template.querySelector('[data-filter]');

        const lookup = this.template.querySelector('[data-lookup]');

        if (helpMessage) {
          lookup.inputDescribedByElements = helpMessage.id;
        }

        synchronizeAttrs(label, {
          for: this._mainInputId
        });
        synchronizeAttrs(filterLabel, {
          for: this._filterInputId
        });
      }

    }

    lwc.registerDecorators(LightningGroupedCombobox, {
      publicProps: {
        label: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showActivityIndicator: {
          config: 0
        },
        showDropdownActivityIndicator: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        required: {
          config: 0
        },
        disabled: {
          config: 0
        },
        readOnly: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        filterLabel: {
          config: 0
        },
        filterItems: {
          config: 0
        },
        filterInputText: {
          config: 0
        },
        inputText: {
          config: 3
        },
        pills: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _pills: 1,
        _variant: 1,
        _items: 1,
        _expandPillContainer: 1,
        _highlightedOptionElementId: 1,
        _helpMessage: 1,
        _fieldLevelHelp: 1,
        _inputText: 1
      },
      fields: ["_filterInputId", "_mainInputId", "_initialized"]
    });

    var _lightningGroupedCombobox = lwc.registerComponent(LightningGroupedCombobox, {
      tmpl: _tmpl$B
    });

    function tmpl$G($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_custom_element("lightning-grouped-combobox", _lightningGroupedCombobox, {
        props: {
          "disabled": $cmp.disabled,
          "filterInputText": $cmp.filterInputText,
          "filterItems": $cmp.filterItems,
          "filterLabel": $cmp.filterLabel,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "inputIconName": $cmp.inputIconName,
          "inputMaxlength": $cmp.inputMaxlength,
          "inputPill": $cmp.inputPill,
          "inputText": $cmp.inputText,
          "items": $cmp.items,
          "label": $cmp.label,
          "pills": $cmp.internalPills,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "showActivityIndicator": $cmp.showActivityIndicator,
          "value": $cmp._value,
          "variant": $cmp.variant
        },
        key: 0,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "dropdownopenrequest": _m1 || ($ctx._m1 = api_bind($cmp.handleDropdownOpenRequest)),
          "pillremove": _m2 || ($ctx._m2 = api_bind($cmp.handlePillRemove)),
          "select": _m3 || ($ctx._m3 = api_bind($cmp.handleSelect)),
          "selectfilter": _m4 || ($ctx._m4 = api_bind($cmp.handleSelectFilter)),
          "textinput": _m5 || ($ctx._m5 = api_bind($cmp.handleTextInput))
        }
      }, [])];
    }

    var _tmpl$C = lwc.registerTemplate(tmpl$G);
    tmpl$G.stylesheets = [];

    if (_implicitStylesheets$f) {
      tmpl$G.stylesheets.push.apply(tmpl$G.stylesheets, _implicitStylesheets$f);
    }
    tmpl$G.stylesheetTokens = {
      hostAttribute: "lightning-lookupDesktop_lookupDesktop-host",
      shadowAttribute: "lightning-lookupDesktop_lookupDesktop"
    };

    var labelSearchObjectsPlaceholder = 'Search {0}...';

    var labelSearchPlaceholder = 'Search...';

    var labelSelectObject = 'Choose an object';

    /*
     * The name of the type of the item that represents the advanced search option.
     * @type {String}
     */
    const ACTION_ADVANCED_SEARCH = 'actionAdvancedSearch';
    /*
    * The name of the type of the item that represents the create new action.
    * @type {String}
    */

    const ACTION_CREATE_NEW = 'actionCreateNew';
    /**
     * The attribute used to indicate the IDs of the elements that describe the object
     * @type {String}
     */

    const ARIA_DESCRIBEDBY$5 = 'aria-describedby';
    /**
     * The UI API default page value.
     * @type {Number}
     */

    const DEFAULT_PAGE = 1;
    /**
     * The UI API default pageSize value.
     * @type {Number}
     */

    const DEFAULT_PAGE_SIZE$3 = 25;
    /**
     * The add utility icon name.
     * @type {String}
     */

    const ICON_ADD = 'utility:add';
    /**
     * The check utility icon name.
     * @type {String}
     */

    const ICON_CHECK = 'utility:check';
    /**
     * The default entity icon.
     * @type {String}
     */

    const ICON_DEFAULT = 'standard:default';
    /**
     * The search utility icon name.
     * @type {String}
     */

    const ICON_SEARCH = 'utility:search';
    /**
     * The utility icon with small size.
     * @type {String}
     */

    const ICON_SIZE_SMALL = 'small';
    /**
     * The utility icon with extra small size.
     * Typically used with search, and add icons.
     * @type {String}
     */

    const ICON_SIZE_X_SMALL = 'x-small';
    /**
     * The record layout type for Full layout.
     * Used as a param value for getRecordUi wire api.
     * @type {String}
     */

    const LAYOUT_TYPE_FULL = 'Full';
    /**
     * The default list size
     * @type {Number}
     */

    const LIST_SIZE_DEFAULT = 5;
    /**
     * The list size for mobile advanced search
     * @type {Number}
     */

    const LIST_SIZE_MOBILE_ADVANCED_SEARCH = 25;
    /**
     * The mode of the record layout.
     * Used as a param value for getRecordUi wire api.
     * @type {String}
     */

    const MODE_VIEW = 'View';
    /**
     * The ailtn transaction MRU action type for advanced search.
     * @type {String}
     */

    const LOG_ACTION_SEARCH_OPTION = 'SEARCH_OPTION';
    /**
     * The ailtn transaction context query type for MRU.
     * @type {String}
     */

    const LOG_CONTEXT_Q_TYPE_MRU = 'MRU';
    /**
     * The ailtn transaction MRU action type for create new.
     * @type {String}
     */

    const LOG_ACTION_CREATE_NEW_OPTION = 'CREATE_OPTION';
    /**
     * The ailtn transaction context query type for TypeAhead.
     * @type {String}
     */

    const LOG_CONTEXT_Q_TYPE_TYPEAHEAD = 'Typeahead';
    /**
     * The ailtn transaction event source for click interaction.
     * @type {String}
     */

    const LOG_EVENT_CLICK = 'click';
    /**
     * The ailtn transaction event source for pill removal.
     * @type {String}
     */

    const LOG_EVENT_PILL_REMOVE = 'synthetic-pill-remove';
    /**
     * The ailtn transaction name used for performance purpose.
     */

    const LOG_PERF_TRANSACTION_NAME = 'search-lookup';
    /**
     * The ailtn transaction scope for lookup desktop.
     * @type {String}
     */

    const LOG_SCOPE_INPUT_LOOKUP_DESKTOP = 'search-input-lookup-desktop';
    /**
     * The ailtn transaction scope for lookup desktop.
     * @type {String}
     */

    const LOG_SCOPE_INPUT_LOOKUP_MOBILE = 'search-input-lookup-mobile';
    /**
     * The ailtn transaction scope for the entiy selector for the lookup desktop.
     * @type {String}
     */

    const LOG_SCOPE_ENTITY_SELECTOR = 'search-entity-selector';
    /**
     * The ailtn transaction target for lookup input.
     * @type {String}
     */

    const LOG_TARGET_INPUT = 'search-input';
    /**
     * The ailtn transaction target for action items like advanced search.
     * @type {String}
     */

    const LOG_TARGET_LOOKUP_ACTION_OPTION = 'search-lookup-action-option';
    /**
     * The ailtn transaction target for MRU record items.
     * @type {String}
     */

    const LOG_TARGET_LOOKUP_SUGGESTION_OPTION = 'search-lookup-suggestion-option';
    /**
     * The ailtn transaction target for the record pill.
     * @type {String}
     */

    const LOG_TARGET_RECORD_PILL_ITEM = 'search-record-pill-item';
    /**
     * The ailtn transaction target for the entity filter item..
     * @type {String}
     */

    const LOG_TARGET_FILTER_ITEM = 'search-filter-item';
    /**
     * The combo-box action type to show record.
     * @type {String}
     */

    const OPTION_TYPE_CARD = 'option-card';
    /**
     * The combo-box option type to show an action.
     * @type {String}
     */

    const OPTION_TYPE_INLINE = 'option-inline';
    /**
     * The combo-box pill item type to show icons.
     * @type {String}
     */

    const PILL_TYPE_ICON = 'icon';
    /**
     * UI API query parameter for the dependent field bindings.
     * @type {String}
     */

    const QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS = 'dependentFieldBindings';
    /**
     * UI API query parameter for the page.
     * @type {String}
     */

    const QUERY_PARAMS_PAGE = 'page';
    /**
     * UI API query parameter for the page size.
     * @type {String}
     */

    const QUERY_PARAMS_PAGE_SIZE = 'pageSize';
    /**
     * UI API query parameter for the search term.
     * @type {String}
     */

    const QUERY_PARAMS_Q = 'q';
    /**
     * UI API query parameter for the search type like Recent or TypeAhead.
     * @type {String}
     */

    const QUERY_PARAMS_SEARCH_TYPE = 'searchType';
    /**
     * UI API query parameter for the source record ID
     * @type {String}
     */

    const QUERY_PARAMS_SOURCE_RECORD_ID = 'sourceRecordId';
    /**
     * The UI API searchType value for Full Search record
     * @type {String}
     */

    const SEARCH_TYPE_FULL = 'Search';
    /**
     * The UI API searchType value for Recent records.
     * @type {String}
     */

    const SEARCH_TYPE_RECENT = 'Recent';
    /**
     * The UI API searchType value for TypeAhead records.
     * @type {String}
     */

    const SEARCH_TYPE_TYPEAHEAD = 'TypeAhead';
    const COMMON_LOOKUP_CONSTANTS = {
      ACTION_ADVANCED_SEARCH,
      ARIA_DESCRIBEDBY: ARIA_DESCRIBEDBY$5,
      ICON_ADD,
      ICON_CHECK,
      ICON_DEFAULT,
      ICON_SEARCH,
      ICON_SIZE_SMALL,
      ICON_SIZE_X_SMALL,
      LIST_SIZE_DEFAULT,
      LIST_SIZE_MOBILE_ADVANCED_SEARCH,
      OPTION_TYPE_CARD,
      OPTION_TYPE_INLINE,
      PILL_TYPE_ICON
    };
    const GET_LOOKUP_RECORDS_WIRE_CONSTANTS = {
      DEFAULT_PAGE,
      DEFAULT_PAGE_SIZE: DEFAULT_PAGE_SIZE$3,
      LAYOUT_TYPE_FULL,
      MODE_VIEW,
      QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS,
      QUERY_PARAMS_PAGE,
      QUERY_PARAMS_PAGE_SIZE,
      QUERY_PARAMS_Q,
      QUERY_PARAMS_SEARCH_TYPE,
      QUERY_PARAMS_SOURCE_RECORD_ID,
      SEARCH_TYPE_FULL,
      SEARCH_TYPE_RECENT,
      SEARCH_TYPE_TYPEAHEAD
    };
    const LOGGING_CONSTANTS = {
      LOG_ACTION_SEARCH_OPTION,
      LOG_CONTEXT_Q_TYPE_MRU,
      LOG_ACTION_CREATE_NEW_OPTION,
      LOG_CONTEXT_Q_TYPE_TYPEAHEAD,
      LOG_EVENT_CLICK,
      LOG_EVENT_PILL_REMOVE,
      LOG_SCOPE_INPUT_LOOKUP_DESKTOP,
      LOG_SCOPE_INPUT_LOOKUP_MOBILE,
      LOG_SCOPE_ENTITY_SELECTOR,
      LOG_TARGET_INPUT,
      LOG_TARGET_LOOKUP_ACTION_OPTION,
      LOG_TARGET_LOOKUP_SUGGESTION_OPTION,
      LOG_TARGET_RECORD_PILL_ITEM,
      LOG_TARGET_FILTER_ITEM,
      LOG_PERF_TRANSACTION_NAME
    };

    function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$7(target, key, source[key]); }); } return target; }

    function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    /**
     * Requests a log entry for tracking user interactions.
     * @param {String} ailtnEventSource - The synthetic event source for the interaction.
     * @param {String} ailtnScope - The component that handles the action. Effectively it's an ancestor of the target component.
     * @param {String} ailtnTarget - The component that handles the event.
     * @param {Object} ailtnContext - The composite of the context from the target and scope. This needs to be a flat map.
     */

    function log(ailtnEventSource, ailtnScope, ailtnTarget, ailtnContext) {
      if (!ailtnEventSource || !ailtnScope || !ailtnTarget) {
        return;
      }

      const _ailtnContext = ailtnContext || {};

      _ailtnContext.sourceCmp = 'lightning:lookup';
      _ailtnContext.time = Date.now();
      auraInstrumentation.interaction(ailtnTarget, ailtnScope, _ailtnContext, ailtnEventSource);
    }
    class LookupPerformanceLogger {
      constructor() {
        this._attributes = void 0;
        this._eventSource = `synthetic-${LOGGING_CONSTANTS.LOG_PERF_TRANSACTION_NAME}`;
        this._inProgress = false;
        this._transactionName = LOGGING_CONSTANTS.LOG_PERF_TRANSACTION_NAME;
        this._wireTriggered = false;
      }

      startTransaction() {
        this._inProgress = true;
        this._attributes = {};
        auraInstrumentation.perfStart(this._transactionName, this._attributes, this._eventSource);
      }

      endTransaction() {
        if (this._inProgress && this._wireTriggered) {
          this._inProgress = false;
          this._wireTriggered = false;
          auraInstrumentation.perfEnd(this._transactionName, this._attributes, this._eventSource);
        }
      }

      startWireMark(wireName) {
        this._startMark(wireName);
      }

      endWireMark(wireName) {
        this._endMark(wireName);
      }

      startRenderMark() {
        if (this._inProgress) {
          this._wireTriggered = true;

          this._startMark('render');
        }
      }

      endRenderMark() {
        if (this._wireTriggered) {
          this._endMark('render');
        }
      }

      mergeTransactionAttributesWith(attributes = {}) {
        this._attributes = _objectSpread$7({}, this._attributes, attributes);
      }

      _startMark(markName, attributes = null) {
        if (this._inProgress) {
          auraInstrumentation.markStart(this._transactionName, markName, attributes);
        }
      }

      _endMark(markName, attributes = null) {
        if (this._inProgress) {
          auraInstrumentation.markEnd(this._transactionName, markName, attributes);
        }
      }

    }

    lwc.registerDecorators(LookupPerformanceLogger, {
      fields: ["_attributes", "_eventSource", "_inProgress", "_transactionName", "_wireTriggered"]
    });

    var labelAdvancedSearchMobile = 'Show All Results for "{0}"';

    var labelMessageWhenBadInputDefault = 'Select an option or remove the search term.';

    var labelMruHeader = 'Recent {0}';

    var labelFullSearchResultsMobile = 'All Results for "{0}"';

    var labelTypeaheadResultsMobile = 'Initial Results for "{0}"';

    var labelAdd = 'Add';

    var labelCreateNew = 'New {0}';

    var labelSearch = 'Search';

    function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$8(target, key, source[key]); }); } return target; }

    function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const EXTERNAL_ENTITY_REGEXP = /__x$/;
    const i18n$m = {
      add: labelAdd,
      advancedSearchMobile: labelAdvancedSearchMobile,
      createNew: labelCreateNew,
      fullSearchResultsHeader: labelFullSearchResultsMobile,
      mruHeader: labelMruHeader,
      messageWhenBadInputDefault: labelMessageWhenBadInputDefault,
      searchObjectsPlaceholder: labelSearchObjectsPlaceholder,
      searchPlaceholder: labelSearchPlaceholder,
      search: labelSearch,
      typeaheadResultsHeader: labelTypeaheadResultsMobile
    };
    /**
     * Compares given array to check if they have identical (string) elements
     * irrespective of their positions.
     * Note - Does not perform deep comparison.
     * @param {Array} array1 - Source array.
     * @param {Array} array2 - Desination array for comparison.
     * @returns {Boolean} true if array1 and array2 have same elements.
     */

    function arraysIdentical(array1 = [], array2 = []) {
      if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
      }

      if (array1.length !== array2.length) {
        return false;
      }

      const sortedArray1 = Object.assign([], array1).sort();
      const sortedArray2 = Object.assign([], array2).sort();
      return sortedArray1.toString() === sortedArray2.toString();
    }
    /**
     * Get advanced search action item for display.
     * @param {String} term the search term to display in the action option
     */


    function computeAdvancedSearchOption(isDesktop, term) {
      const common = {
        iconSize: COMMON_LOOKUP_CONSTANTS.ICON_SIZE_X_SMALL,
        value: COMMON_LOOKUP_CONSTANTS.ACTION_ADVANCED_SEARCH,
        text: i18n$m.advancedSearchMobile.replace('{0}', term)
      };
      return isDesktop ? _objectSpread$8({}, common, {
        //   highlight: true,
        iconAlternativeText: `${i18n$m.search}`,
        iconName: COMMON_LOOKUP_CONSTANTS.ICON_SEARCH,
        type: COMMON_LOOKUP_CONSTANTS.OPTION_TYPE_CARD
      }) : _objectSpread$8({}, common, {
        action: true,
        endIconName: COMMON_LOOKUP_CONSTANTS.ICON_SEARCH,
        endIconNameAlternativeText: `${i18n$m.search}`,
        type: COMMON_LOOKUP_CONSTANTS.OPTION_TYPE_INLINE
      });
    }
    /**
     * Creates an array of items values not included in valuesToIgnore array.
     * @param {Array} items - The original list of items to be deduped.
     * @param {Array} valuesToIgnore - The list of values to ignore.
     * @returns {Array} - The the deduped and trimmed items list.
     */
    // eslint-disable-next-line @lwc/lwc/no-rest-parameter


    function difference$1(items, ...valuesToIgnore) {
      return (items || []).filter(item => !valuesToIgnore.includes(item.value));
    }
    /**
     * Computes the heading for the display items on desktop.
     * @param {String} entityName - Plural name of target api.
     */


    function computeHeadingDesktop(entityName, searchType) {
      return searchType === GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_RECENT ? `${i18n$m.mruHeader}`.replace('{0}', entityName) : '';
    }
    /**
     * Computes the heading for the display items on mobile.
     * @param {String} term - The term the results are for
     * @param {String} searchType - The type of search
     */


    function computeHeadingMobile(term, searchType) {
      let label = ''; // eslint-disable-next-line default-case

      switch (searchType) {
        case GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_RECENT:
          label = `${i18n$m.mruHeader}`.replace('{0}', 'Items');
          break;

        case GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_TYPEAHEAD:
          label = `${i18n$m.typeaheadResultsHeader}`.replace('{0}', term);
          break;

        case GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_FULL:
          label = `${i18n$m.fullSearchResultsHeader}`.replace('{0}', term);
          break;
      }

      return label;
    }
    /**
     * Returns items with text slices for highlighting.
     *
     * For example -
     * items = [{ text: "salesforce", subText: "(213)111-4444",...}]
     * term = "sal force"
     * returns -
     * [
     *    {
     *      "text": [
     *        {
     *          "text": "sal",
     *          "highlight": true
     *        },
     *        {
     *          "text": "es"
     *        },
     *        {
     *            "text": "force",
     *            "highlight": true
     *        }
     *      ],
     *      "subText": [
     *        {
     *          "text": "(213)111-4444"
     *        }
     *      ],
     *      ...
     *    }
     *  ]
     *
     * Important caveats -
     *
     * Handling term with substrings:
     * --------------------------------
     * Term is broken up into parts for matching by splitting it using whitespaces.
     * Matching for each part starts from the begining till the end of the original text.
     * Parts that are subtrings of each other may get merged while highlighting.
     * For example -
     * text = "salesforce.com account"
     * term = "salesforce.com a"
     * "salesforce.com" would be highlighted but not "a" because it's a substring of "salesforce.com"
     * however for the term "salesforce.com acc" both "salesforce.com" and "acc" would be highlighted.
     *
     * Handling term with wildcards:
     * --------------------------------
     * Wildcards are not dropped while matching.
     * For example -
     * text = "salesforce.com"
     * term = "sales*"
     * would NOT result in highlighting of "sales". However if text was "sales*foo"
     * then the subtring "sales*" would be highlighted.
     *
     * @param {Array} items - Items representing records.
     * @param {String} term - A search term for matching.
     * @return {Array} - An array of items with text split for highlighting.
     */


    function computeHighlightedItems(items, term) {
      const output = []; // No-op if items or term is empty.

      if (!items || items.length === 0 || !term) {
        return output;
      } // Get unique parts of the term.
      // For example -
      // term = "sal sal sales"
      // words = ["sal","sales"]


      const words = term.trim().split(' ').filter((w, i, ar) => {
        return ar.indexOf(w) === i;
      });
      items.forEach(item => {
        const outputItem = Object.assign({}, item); // Creating text list to process text and subText.

        const textList = []; // Process text only if it's not empty

        if (item.text) {
          textList.push({
            type: 'text',
            text: item.text
          });
        } else {
          outputItem.text = null;
        } // Process subText only if it's not empty


        if (item.subText) {
          textList.push({
            type: 'subText',
            text: item.subText
          });
        } else {
          outputItem.subText = null;
        }

        textList.forEach(textItem => {
          // Get matching indexes for the search term.
          const intervals = getMatchingIndexes(textItem.text, words); // If match not found, then return the original text.

          if (intervals.length === 0) {
            outputItem[textItem.type] = [{
              text: textItem.text
            }];
          } else {
            // Get slices of matching text with highlight markers.
            outputItem[textItem.type] = splitTextFromMatchingIndexes(textItem.text, intervals);
          }
        });
        output.push(outputItem);
      });
      return output;
    }

    function computeListSize(searchType, isDesktop) {
      return searchType === GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_FULL && !isDesktop ? COMMON_LOOKUP_CONSTANTS.LIST_SIZE_MOBILE_ADVANCED_SEARCH : COMMON_LOOKUP_CONSTANTS.LIST_SIZE_DEFAULT;
    }
    /**
     * Computes the queryString to use in the getLookupRecords request
     * @param {String} newQueryString - new queryString coming from the child component
     * @param {String} currentQueryString - current queryString stored in the request params
     */


    function computeQueryString(newQueryString, currentQueryString) {
      return newQueryString !== undefined ? newQueryString : currentQueryString;
    }
    /**
     * Computes a list of pills for the record values.
     * @param  {Object} record - A record representation.
     * @param {Object} fieldInfo - The record's field info.
     * @param {Object} referenceInfos - The reference api infos.
     * @param {String} externalObjectValue - the local org Id of the referenced entity.
     * @returns {Array} - An array of pills for the record field values.
     */


    function computeRecordPills(record, fieldInfo, referenceInfos, externalObjectValue) {
      let pills = [];

      if (!record || !fieldInfo || !referenceInfos) {
        return pills;
      }

      const relationshipFieldValue = record.fields[fieldInfo.relationshipName].value; // No-op if relationship field value is empty.

      if (!relationshipFieldValue) {
        return pills;
      }

      const apiName = relationshipFieldValue.apiName; // No-op if field value and relationship field value are inconsistent for non external entities.

      if (relationshipFieldValue.fields.Id.value !== record.fields[fieldInfo.fieldName].value && externalObjectValue !== relationshipFieldValue.fields.Id.value) {
        return pills;
      }

      if (apiName in referenceInfos) {
        const referenceInfo = referenceInfos[apiName];
        const pill = {
          iconAlternativeText: referenceInfo.iconAlternativeText,
          iconName: referenceInfo.iconName,
          iconSize: COMMON_LOOKUP_CONSTANTS.ICON_SIZE_SMALL,
          label: relationshipFieldValue.fields[referenceInfo.nameField].value,
          type: COMMON_LOOKUP_CONSTANTS.PILL_TYPE_ICON,
          value: record.fields[fieldInfo.fieldName].value,
          externalObjectValue: isApiExternal(apiName) ? relationshipFieldValue.fields.Id.value : undefined
        };
        pills = [pill];
      }

      return pills;
    }
    /**
     * Computes a list of values from record for the given field.
     * @param  {Object} record - A record representation.
     * @param {String} fieldApiName - The qualified field name.
     * @returns {Array} - An array of the record field values.
     */


    function computeRecordValues(record, fieldApiName) {
      if (!record || !fieldApiName) {
        return [];
      }

      const fieldName = computeUnqualifiedFieldApiName(fieldApiName);
      const recordField = record.fields[fieldName];
      return recordField && recordField.value ? [recordField.value] : [];
    }
    /**
     * Computes the searchType for the @getLookupRecords wire config
     * @param {Object} requestObject - the request config used to fetch records via getLookupRecords wire
     * @returns {String} - the search type - 'Recent', 'Typeahead', or 'Search'
     */


    function computeSearchType(requestObject) {
      if (isFullSearch(requestObject[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_SEARCH_TYPE])) {
        return GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_FULL;
      }

      return isValidTypeAheadTerm(requestObject[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_Q]) ? GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_TYPEAHEAD : GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_RECENT;
    }
    /**
     * Computes the field API name from a qualified field name.
     * For example - Opportunity.AccountId returns 'AccountId'
     * @param {String} fieldApiName - The qualified field name.
     * @return {String} - The unqualified field name.
     */


    function computeUnqualifiedFieldApiName(fieldApiName = '') {
      if (fieldApiName === null) {
        fieldApiName = '';
      }

      const idx = fieldApiName.indexOf('.'); // The object api name must non-empty.

      if (idx < 1) {
        return '';
      }

      return fieldApiName.substring(idx + 1);
    }
    /**
     * Returns matching indexes for the terms found in the given text.
     *
     * For example -
     * text = "salesforce"
     * words = ["sal","force"]
     * returns - [[0,3],[5,10]]
     *
     * @param {String} text - Original text for matchin search term.
     * @param {String} words - Distinct words or term parts.
     * @return {Array} - An array of intervals.
     */


    function getMatchingIndexes(text, words) {
      let output = []; // No-op if text to match or term is missing.

      if (!text || !words) {
        return output;
      }

      const matchIndexes = {}; // Convert text to lower case for matching.

      const lowerCasedText = text.toLowerCase();

      for (let t = 0; t < words.length; t++) {
        const word = words[t]; // Convert word to lower case for matching.

        const lowerCasedWord = word.toLowerCase();
        let index = 0,
            start = 0,
            numMatches = 0;

        while (start < text.length && index !== -1 && numMatches < 1) {
          index = lowerCasedText.indexOf(lowerCasedWord, start); // Match found.

          if (index > -1) {
            // Get end index for the current term.
            const endIndex = index + lowerCasedWord.length; // If some term part was found previously with the same start
            // index then update the endIndex having longest part.
            // For example -
            // text = "salesforce"
            // words = ["sal", "salesf"]
            //
            // For "sal", matchIndexes would be {0:3}
            // For "salesf", matchIndexes would be updated to {0:6}

            if (matchIndexes[index]) {
              if (matchIndexes[index] < endIndex) {
                matchIndexes[index] = endIndex;
              }
            } else {
              // No matching term part found for the index, make a new entry.
              matchIndexes[index] = endIndex;
            }

            numMatches++; // Increment the start pointer.

            start = endIndex;
          }
        }
      } // Convert indexes map into an array of indexes.


      output = Object.keys(matchIndexes).map(interval => {
        return [parseInt(interval, 10), matchIndexes[interval]];
      });
      return output;
    }

    function getIconOf(objectInfo) {
      if (!objectInfo || !objectInfo.themeInfo || !objectInfo.themeInfo.iconUrl) {
        return COMMON_LOOKUP_CONSTANTS.ICON_DEFAULT;
      }

      const iconUrl = objectInfo.themeInfo.iconUrl;
      const parts = iconUrl.split('/');
      const icon = parts.pop().replace(/(_\d+)(\.\w*)/gi, '');
      const category = parts.pop();
      return `${category}:${icon}`;
    }
    /**
     * Checks if the given term is contains any CJK characters.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term contains any CJK characters.
     */


    function hasCJK(term = '') {
      if (term === null) {
        return false;
      }

      if (typeof term !== 'string') {
        return false;
      }

      const chars = term.trim().split('');

      for (let i = 0; i < chars.length; i++) {
        if (/^[\u1100-\u1200\u3040-\uFB00\uFE30-\uFE50\uFF00-\uFFF0]+$/.test(chars[i])) {
          return true;
        }
      }

      return false;
    }
    /**
     * Checks if at least one action supports "CreateFromLookup".
     * @param {Array} actions - An array of lookup actions received from @wire(getLookupActions)
     * @returns {Boolean} - True if "CreateFromLookup" action was found.
     */


    function hasCreateFromLookup(actions) {
      return (actions || []).some(action => !!action && action.actionListContext === 'Lookup' && action.apiName === 'CreateFromLookup');
    }
    /**
     * Get create new action item for display.
     * @param {String} label - Plural name of target api.
     * @returns {Object} - A create new action item.
     */


    function computeCreateNewOption(label = '') {
      if (label === null) {
        label = '';
      }

      return {
        iconAlternativeText: `${i18n$m.add}`,
        iconName: COMMON_LOOKUP_CONSTANTS.ICON_ADD,
        iconSize: COMMON_LOOKUP_CONSTANTS.ICON_SIZE_X_SMALL,
        text: `${i18n$m.createNew}`.replace('{0}', label),
        type: COMMON_LOOKUP_CONSTANTS.OPTION_TYPE_CARD,
        value: ACTION_CREATE_NEW
      };
    }

    function isApiExternal(apiName) {
      return EXTERNAL_ENTITY_REGEXP.test(apiName);
    }
    /**
     * Checks if the given searchType is of type 'full'
     * @param {String} searchType - the searchType from the config object
     * @returns {Boolean} - True if full search
     */


    function isFullSearch(searchType) {
      return searchType === GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_FULL;
    }
    /**
     * Checks if the given term is a valid search term.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term is a valid search string.
     */


    function isValidSearchTerm(term) {
      if (!term) {
        return false;
      }

      const normalizedTerm = term.replace(/[()"?*]+/g, '').trim();
      return normalizedTerm.length >= 2 || hasCJK(normalizedTerm);
    }
    /**
     * Checks if the given term is a valid typeahead search term.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term is a valid typeahead string.
     */


    function isValidTypeAheadTerm(term) {
      if (!term) {
        return false;
      }

      const normalizedTerm = term.replace(/[()"?*]+/g, '').trim();
      return normalizedTerm.length < 255 && (normalizedTerm.length > 2 || hasCJK(normalizedTerm));
    }
    /**
     * Returns the formated records to be displayed as individual combobox options
     * @param {Array} records - records to create individual options for
     * @param {String} nameField - name field for the entity being mapped
     * @param {Object} iconDetails - the iconDetails for the entity being mapped
     * @param {String} optionType - how to display the items (inline or card)
     * @returns {Array} - The list of options formatted for groupedCombobox to consume
     */


    function mapLookupWireRecords(records, nameField, iconDetails, optionType) {
      return records.map(record => {
        const fields = record.fields;
        return _objectSpread$8({}, iconDetails, {
          iconSize: COMMON_LOOKUP_CONSTANTS.ICON_SIZE_SMALL,
          // eslint-disable-next-line no-prototype-builtins
          subText: fields.hasOwnProperty('DisambiguationField') ? fields.DisambiguationField.value : null,
          text: fields[nameField].value,
          type: optionType,
          value: fields.ExternalId && fields.ExternalId.value || fields.Id.value,
          externalObjectValue: fields.ExternalId && fields.ExternalId.value ? fields.Id.value : undefined
        });
      });
    }
    /**
     * Maps records into their ui representations
     * record have to contain the name field of their referenced api
     * @param {Array} records
     */


    function mapRecordUiWireRecords(recordsWithReferencedApiNameField, objectInfos) {
      const pills = recordsWithReferencedApiNameField.filter(record => record.referencedApiNameField).map(record => ({
        iconAlternativeText: record.apiName,
        iconName: getIconOf(objectInfos[record.apiName]),
        label: record.fields[record.referencedApiNameField].value,
        type: COMMON_LOOKUP_CONSTANTS.PILL_TYPE_ICON,
        value: record.fields.ExternalId && record.fields.ExternalId.value || record.id,
        externalObjectValue: record.fields.ExternalId && record.fields.ExternalId.value ? record.id : undefined
      }));
      const invalidValues = recordsWithReferencedApiNameField.filter(record => !record.referencedApiNameField).map(record => record.id);
      return {
        pills,
        invalidValues
      };
    }
    /**
     * Merges overlapping intervals.
     *
     * For example -
     * intervals = [[0,3],[1,4],[5,7]]
     * returns - [[0,4],[5,7]]
     *
     * @param {Array} intervals - An array of intervals to merge.
     * @return {Array} - An array of merged intervals.
     */


    function mergeIntervals(intervals) {
      if (!intervals || !intervals.length) {
        return [];
      }

      intervals.sort((a, b) => {
        return a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1];
      });
      let prev = intervals[0];
      const output = [prev];
      const intervalsLength = intervals.length;

      for (let i = 0; i < intervalsLength; i++) {
        const curr = intervals[i];

        if (curr[0] <= prev[1]) {
          prev[1] = Math.max(prev[1], curr[1]);
        } else {
          output.push(curr);
          prev = curr;
        }
      }

      return output;
    }
    /**
     * Parses LDS error object.
     * @param {Object} error - LDS error object from wire adapter.
     * @return {Object} - formatted error object.
     *
     */


    function parseLdsError(error) {
      return {
        message: parseError(error).message
      };
    }
    /**
     * Splits text using indexes and adds highlight marker.
     *
     * For example -
     * text = "salesforce"
     * intervals = [[0,3]]
     * returns -
     * [
     *  {
     *    "text": "sal",
     *    "highlight": true
     *  },
     *  {
     *    "text": "esforce"
     *  }
     * ]
     *
     * @param {String} text - Original text for matching indexes.
     * @param {Array} intervals - An array of intervals to highlight.
     * @return {Array} - An array of text items with highlighting.
     */


    function splitTextFromMatchingIndexes(text, intervals) {
      const output = []; // No-op if text or intervals is missing.

      if (!text || !intervals || intervals.length === 0) {
        return output;
      } // Merge intervals to avoid incorrect slicing.


      const _intervals = mergeIntervals(intervals); // Sort array based on first value.


      _intervals.sort((prev, next) => {
        return prev[0] > next[0];
      });

      let prevMatchEndIdx = 0;

      for (let i = 0; i < _intervals.length; i++) {
        const startIdx = _intervals[i][0];
        const endIdx = _intervals[i][1]; // Push part before start index.

        const prevText = text.substring(prevMatchEndIdx, startIdx);

        if (prevText) {
          output.push({
            text: prevText
          });
        } // Push part having match.


        output.push({
          text: text.substring(startIdx, endIdx),
          highlight: true
        }); // Update previous match index with current end index.

        prevMatchEndIdx = endIdx;
      } // Push remaining text.


      const remainingText = text.substring(prevMatchEndIdx);

      if (remainingText) {
        output.push({
          text: remainingText
        });
      }

      return output;
    }

    class LookupEventDispatcher {
      constructor(lookupComponent) {
        this.dispatchEvent = lookupComponent.dispatchEvent.bind(lookupComponent);
      }

      dispatchChangeEvent(value) {
        this.dispatchEvent(createChangeEvent(value));
      }

      dispatchErrorEvent(error) {
        this.dispatchEvent(createErrorEvent$1(error));
      }

      dispatchCreateEvent(value, callback) {
        this.dispatchEvent(createCreateNewEvent(value, callback));
      }

      dispatchEntityFilterSelect(value) {
        this.dispatchEvent(createEntityFilterSelectEvent(value));
      }

      dispatchErrorEventFromLds(error) {
        this.dispatchEvent(createErrorEvent$1(parseLdsError(error)));
      }

      dispatchLookupRecordsRequestEvent(payload) {
        this.dispatchEvent(createLookupRecordsRequestEvent(payload));
      }

      dispatchPillRemoveEvent(removedValue) {
        this.dispatchEvent(createPillRemoveEvent(removedValue));
      }

      dispatchRecordItemSelectEvent(selectedValue) {
        this.dispatchEvent(createRecordItemSelectEvent(selectedValue));
      }

    }

    function createChangeEvent(value) {
      return new CustomEvent('change', {
        bubbles: true,
        composed: true,
        detail: {
          value
        }
      });
    }

    function createErrorEvent$1(error) {
      // eslint-disable-next-line lightning-global/no-custom-event-bubbling
      return new CustomEvent('error', {
        bubbles: true,
        composed: true,
        detail: {
          error
        }
      });
    }
    /**
     * @param {String} value - apiName of the entity for which to create new
     * @param {Function} callback - function to be called after a new record is created
     */


    function createCreateNewEvent(value, callback) {
      // eslint-disable-next-line lightning-global/no-custom-event-bubbling
      return new CustomEvent('createnew', {
        bubbles: true,
        composed: true,
        detail: {
          value,
          callback
        }
      });
    }

    function createEntityFilterSelectEvent(value) {
      return new CustomEvent('entityfilterselect', {
        detail: {
          value
        }
      });
    }
    /**
     * @param {key, value} requestParams - the request parameters to send to parent
     */


    function createLookupRecordsRequestEvent(requestParams) {
      return new CustomEvent('lookuprecordsrequest', {
        detail: {
          requestParams
        }
      });
    }
    /**
     * @param {String} removedValue - the value of the pill removed from the input.
     */


    function createPillRemoveEvent(removedValue) {
      return new CustomEvent('pillremove', {
        detail: {
          removedValue
        }
      });
    }
    /**
     * @param {String} selectedValue - the value selected from the selection panel.
     */


    function createRecordItemSelectEvent(selectedValue) {
      return new CustomEvent('recorditemselect', {
        detail: {
          selectedValue
        }
      });
    }

    var labelCurrentSelection = 'Current Selection';

    function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$9(target, key, source[key]); }); } return target; }

    function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const i18n$n = {
      currentSelection: labelCurrentSelection
    };
    class MetadataManager {
      /**
       * Computes a map of field info like isRequired, dependentFields, etc.
       * @param {Object} objectInfos - Source record's objectInfos.
       * @param {String} apiName - An api name.
       * @param {String} fieldApiName - The qualified field name.
       * @returns {Object} - A map of field infos.
       */
      static computeFieldInfo(objectInfos, apiName, fieldApiName) {
        let computedFieldInfo = {};

        if (!objectInfos || !apiName || !fieldApiName) {
          return computedFieldInfo;
        }

        const fieldName = computeUnqualifiedFieldApiName(fieldApiName);
        const objectInfo = objectInfos[apiName] || {};
        const fieldInfo = objectInfo.fields ? objectInfo.fields[fieldName] : null;

        if (fieldInfo) {
          computedFieldInfo = {
            // See https://sfdc.co/dependent-lookups for more information.
            dependentFields: fieldInfo.filteredLookupInfo ? fieldInfo.filteredLookupInfo.controllingFields : undefined,
            fieldName,
            inlineHelpText: fieldInfo.inlineHelpText,
            isRequired: fieldInfo.required,
            references: fieldInfo.referenceToInfos,
            relationshipName: fieldInfo.relationshipName
          };
        }

        return computedFieldInfo;
      }

      static computeFieldApiName(fieldName = '', sourceApiName = '') {
        if (fieldName === null) {
          fieldName = '';
        }

        if (sourceApiName === null) {
          sourceApiName = '';
        }

        let apiName = '';

        if (typeof fieldName === 'string' && fieldName.length) {
          const idx = fieldName.indexOf('.');

          if (idx >= 1) {
            apiName = fieldName;
          }
        } else if (typeof fieldName === 'object' && typeof fieldName.objectApiName === 'string' && typeof fieldName.fieldApiName === 'string') {
          apiName = fieldName.objectApiName + '.' + fieldName.fieldApiName;
        }

        if (!apiName.length && fieldName.length && sourceApiName.length) {
          apiName = sourceApiName + '.' + fieldName;
        }

        return apiName;
      }

      static computeObjectInfo(objectInfos, apiName) {
        if (!objectInfos || !apiName) {
          return {};
        }

        const objectInfo = objectInfos[apiName] || {};
        const themeInfo = objectInfo.themeInfo || {};
        return {
          apiName,
          color: themeInfo.color || '',
          iconAlternativeText: apiName,
          iconName: getIconOf(objectInfo),
          iconUrl: themeInfo.iconUrl || '',
          keyPrefix: objectInfo.keyPrefix,
          label: objectInfo.label,
          labelPlural: objectInfo.labelPlural
        };
      }
      /**
       * Computes a map of supported references apis with their infos like nameField, label, iconName etc.
       */


      static computeReferenceInfos(objectInfos = {}, referenceToInfos = []) {
        if (objectInfos === null) {
          objectInfos = {};
        }

        if (referenceToInfos === null) {
          referenceToInfos = [];
        }

        const references = {};
        const referenceToInfosLength = referenceToInfos.length;

        for (let i = 0; i < referenceToInfosLength; i++) {
          const reference = referenceToInfos[i];
          const apiName = reference.apiName;
          const nameFields = reference.nameFields;
          let nameField;

          if (Array.isArray(nameFields) && nameFields.length > 0) {
            if (nameFields.length > 1) {
              nameField = 'Name';
            } else {
              nameField = nameFields[0];
            }

            const objectInfo = MetadataManager.computeObjectInfo(objectInfos, apiName);
            objectInfo.nameField = nameField;
            objectInfo.optionalNameField = apiName + '.' + nameField;
            references[apiName] = objectInfo;
          }
        }

        return references;
      }

      get dependentFields() {
        return this.fieldInfo.dependentFields;
      }

      get isFieldRequired() {
        return this.fieldInfo.isRequired;
      }

      get isSingleEntity() {
        return Object.keys(this.referenceInfos).length === 1;
      }

      get optionalNameFields() {
        let references = this.referenceInfos;

        if (references === null) {
          references = {};
        }

        const optionalNameFields = [];

        for (const reference in references) {
          if ( // eslint-disable-next-line no-prototype-builtins
          references.hasOwnProperty(reference) && // eslint-disable-next-line no-prototype-builtins
          references[reference].hasOwnProperty('optionalNameField')) {
            optionalNameFields.push(references[reference].optionalNameField);
          }
        }

        return optionalNameFields;
      }

      get sourceApiName() {
        return this._sourceObjectInfo.apiName;
      }

      get sourceEntityLabel() {
        return this._sourceObjectInfo.label;
      }

      get targetApiName() {
        return this._targetObjectInfo.apiName;
      }

      get targetLabel() {
        return this._targetObjectInfo.label;
      }

      get targetPluralLabel() {
        return this._targetObjectInfo.labelPlural;
      }

      constructor(fieldName, objectInfos, record, selectedEntityApiName) {
        this.fieldApiName = void 0;
        this.fieldInfo = void 0;
        this.fieldLevelHelp = void 0;
        this.referenceInfos = {};
        this._sourceObjectInfo = {};
        this._targetObjectInfo = {};

        if (!fieldName || !Object.keys(record || {}).length || !Object.keys(objectInfos || {}).length) {
          return;
        }

        this._sourceObjectInfo = MetadataManager.computeObjectInfo(objectInfos, record.apiName); // Update field info.

        this.fieldApiName = MetadataManager.computeFieldApiName(fieldName, this._sourceObjectInfo.apiName);
        this.fieldInfo = MetadataManager.computeFieldInfo(objectInfos, this._sourceObjectInfo.apiName, this.fieldApiName);
        this.fieldLevelHelp = this.fieldInfo.inlineHelpText;
        this.referenceInfos = MetadataManager.computeReferenceInfos(objectInfos, this.fieldInfo.references);
        this._targetObjectInfo = MetadataManager.computeObjectInfo(objectInfos, selectedEntityApiName || this.getTargetApiName());
      }

      _getFieldValue(record, field) {
        const {
          fields
        } = record;
        return ['Id', 'RecordTypeId'].includes(field) ? record[this._uncapitalize(field)] : fields && fields[field] && fields[field].value || null;
      }
      /**
       * Checks if object has no keys.
       * @param {String} obj - An object to be validated.
       * @returns {Boolean} - True if object has no keys.
       */


      _isEmptyObject(obj) {
        if (obj === undefined || obj === null) {
          return false;
        } // eslint-disable-next-line guard-for-in


        for (const name in obj) {
          return false;
        }

        return true;
      }

      _uncapitalize(s) {
        return s.charAt(0).toLowerCase() + s.slice(1);
      }
      /**
       * Returns the dependent field bindings map for a given Record representation.
       * @param  {Object} record - A record representation.
       */


      getBindingsMap(record) {
        if (!record || !this.dependentFields || !this.dependentFields.length) {
          return null;
        }

        return this.dependentFields.reduce((acc, field) => _objectSpread$9({}, acc, {
          [field]: this._getFieldValue(record, field)
        }), {});
      }
      /**
       * Returns a CSV string of dependent field bindings given a Record
       * representation and a list of dependent fields.
       * @param  {Object} record - A record representation.
       * @return {Object} - A CSV string of dependent field bindings.
       */


      getBindingsString(record) {
        const bindings = this.getBindingsMap(record);
        return bindings && Object.entries(bindings).map(([key, value]) => `${key}=${value}`).join(',');
      }

      getTargetObjectIconDetails() {
        return {
          iconAlternativeText: this._targetObjectInfo.iconAlternativeText,
          iconName: this._targetObjectInfo.iconName
        };
      }

      getTargetObjectAsScope() {
        let objectInfo = this._targetObjectInfo || {};
        return {
          iconUrl: objectInfo.iconUrl,
          label: objectInfo.label,
          labelPlural: objectInfo.labelPlural,
          name: objectInfo.apiName
        };
      }

      getTargetApiName() {
        // Select first field reference apiName as target api if targetObjectInfo is empty or stale.
        if (this.isTargetEntityEmptyOrStale()) {
          const fieldReferences = this.fieldInfo.references;

          if (Array.isArray(fieldReferences) && fieldReferences.length) {
            return fieldReferences[0].apiName;
          }

          return undefined;
        }

        return this._targetObjectInfo.apiName;
      }

      getEntitiesLabelInfo() {
        return {
          sourceEntityLabel: this.sourceEntityLabel,
          targetEntityLabelPlural: this.targetPluralLabel,
          targetLabel: this.targetLabel
        };
      }

      getReferencedApiNameField(apiName) {
        return Object.prototype.hasOwnProperty.call(this.referenceInfos, apiName) && this.referenceInfos[apiName].nameField;
      }

      getReferencedApiNameFieldFromTargetApi() {
        return this.getReferencedApiNameField(this.targetApiName);
      }

      getFilterItems() {
        const references = this.referenceInfos || {};
        const chosenApi = this.targetApiName;
        const referenceApiNames = Object.keys(references);
        let items = null;

        if (referenceApiNames.length > 1) {
          // Alphabetically sort api names.
          referenceApiNames.sort();
          items = [];
          referenceApiNames.forEach(apiName => {
            const item = {
              text: references[apiName].label,
              type: COMMON_LOOKUP_CONSTANTS.OPTION_TYPE_INLINE,
              value: apiName
            };

            if (chosenApi && apiName === chosenApi) {
              item.highlight = true;
              item.iconAlternativeText = `${i18n$n.currentSelection}`;
              item.iconName = COMMON_LOOKUP_CONSTANTS.ICON_CHECK;
              item.iconSize = COMMON_LOOKUP_CONSTANTS.ICON_SIZE_X_SMALL;
            }

            items.push(item);
          });
        }

        return items;
      }

      isTargetEntityEmptyOrStale() {
        return this._isEmptyObject(this._targetObjectInfo) || !Object.prototype.hasOwnProperty.call(this.referenceInfos, this._targetObjectInfo.apiName);
      }

    }

    lwc.registerDecorators(MetadataManager, {
      fields: ["fieldApiName", "fieldInfo", "fieldLevelHelp", "referenceInfos", "_sourceObjectInfo", "_targetObjectInfo"]
    });

    const MODAL_TYPE = 'modal';
    const POPOVER_TYPE = 'panel';

    function normalizeInt(x) {
      const parsed = parseInt(x, 10);
      return isNaN(parsed) ? 0 : parsed;
    }

    class OverlayOptions {
      constructor() {
        this._options = {
          panelType: MODAL_TYPE,
          visible: true,
          panelConfig: {}
        };
      }

      get options() {
        if (this._options.panelType === POPOVER_TYPE) {
          if (this._options.panelConfig.showCloseButton == null) {
            this._options.panelConfig.showCloseButton = false;
          }

          if (this._options.panelConfig.showPointer == null) {
            this._options.panelConfig.showPointer = true;
          }
        } // Set isCustomPanel to true, make sure AVP always is ui:modal or ui:panel.


        this._options.panelConfig.isCustomPanel = true;
        return this._options;
      }

      id(value) {
        this._options.panelConfig.devNameOrId = value;
      }

      panelType(value) {
        this._options.panelType = value;
      }

      modal() {
        this._options.panelType = MODAL_TYPE;
      }

      popover() {
        this._options.panelType = POPOVER_TYPE;
      }

      bodyClass(value) {
        this._options.panelConfig.bodyClass = value || '';
      }

      body(value) {
        this._options.panelConfig.body = value || null;
      } // modal specific


      modalClass(value) {
        this._options.panelConfig.modalClass = value || '';
        return this;
      }

      headerClass(value) {
        this._options.panelConfig.headerClass = value || '';
      }

      footerClass(value) {
        this._options.panelConfig.footerClass = value || '';
      }

      classNames(value) {
        this._options.panelConfig.classNames = value || '';
      }

      flavor(value) {
        this._options.panelConfig.flavor = value || '';
      }

      title(value) {
        if (value != null && value !== '') {
          this._options.panelConfig.header = null;
          this._options.panelConfig.title = value;
        }
      }

      header(value) {
        if (value != null) {
          if (typeof value === 'string') {
            this._options.panelConfig.header = null;
            this._options.panelConfig.title = value;
          } else {
            this._options.panelConfig.header = value;
            this._options.panelConfig.title = null;
          }
        }
      }

      footer(value) {
        this._options.panelConfig.footer = value;
      }

      showCloseButton(value) {
        this._options.panelConfig.showCloseButton = !!value;
      }

      closeCallback(value) {
        if (typeof value === 'function') {
          this._options.onDestroy = value;
        }
      }

      forceFullPageModal(value) {
        this._options.panelConfig.forceFullPageModal = value;
      } // Popover specific


      referenceSelector(value) {
        this._options.panelConfig.referenceElementSelector = value || '';
      }

      reference(value) {
        this._options.panelConfig.referenceElement = value;
      } // positioning


      showPointer(value) {
        this._options.panelConfig.showPointer = !!value;
      }

      direction(value) {
        this._options.panelConfig.direction = value;
      }

      padding(value) {
        this._options.panelConfig.pad = normalizeInt(value);
      }

      advancedConfig(value) {
        if (typeof value === 'object') {
          this._options.panelConfig.advancedConfig = value;
        }
      }

      boundingElement(value) {
        this._options.panelConfig.boundingElement = value;
      }

      pointerPadding(value) {
        this._options.panelConfig.pointerPad = normalizeInt(value);
      }

      boundingBoxPadding(value) {
        this._options.panelConfig.boundingBoxPad = normalizeInt(value);
      }

      boxDirectionPadding(value) {
        this._options.panelConfig.boxDirectionPad = normalizeInt(value);
      }

      align(value) {
        this._advancedConfig.align = normalizeInt(value);
      }

      targetAlign(value) {
        this._advancedConfig.targetAlign = normalizeInt(value);
      }

      verticalPadding(value) {
        this._advancedConfig.vertPad = normalizeInt(value);
      } // More attributes support W-5455858


      autoFocus(value) {
        this._options.panelConfig.autoFocus = !!value;
      }

      trapFocus(value) {
        this._options.panelConfig.trapFocus = !!value;
      }

      closeOnClickOut(value) {
        this._options.panelConfig.closeOnClickOut = !!value;
      }

      useTransition(value) {
        this._options.panelConfig.useTransition = !!value;
      }

      scopeScrollables(value) {
        this._options.panelConfig.scopeScrollables = !!value;
      }

      closeAction(value) {
        if (typeof value === 'function') {
          this._options.panelConfig.closeAction = value;
        }
      } // Extra attribte pass to custome panel


      customAttributes(value) {
        value = value || {};
        const keys = Object.keys(value);

        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          assert(!this[key], `${key} is a predefined option, can not be overridden by customAttributes`);

          if (!this[key]) {
            this._options.panelConfig[key] = value[key];
          }
        }
      }

      get _advancedConfig() {
        this._options.panelConfig.advancedConfig = this._options.panelConfig.advancedConfig || {};
        return this._options.panelConfig.advancedConfig;
      }

    }

    function parseOptions(options = {}) {
      const config = new OverlayOptions();
      const keys = Object.keys(options);

      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (typeof config[key] === 'function' && options[key] != null) {
          config[key].apply(config, [options[key]]);
        }
      }

      return config.options;
    }

    const PANEL_ANIMATION_TIME = 220; // panel animation is 0.2s, consider ~17ms frame render, refer to panel.css in aura repo.

    class OverlayPanel {
      constructor(instance) {
        this._panelInstance = instance;
        this._visible = true;
      }

      get isVisible() {
        return this._visible;
      }

      get instance() {
        return this._panelInstance;
      }

      _createPromise(isShow, previousPromise) {
        let promise = new Promise(resolve => {
          const panelCall = isShow ? this._panelInstance.show : this._panelInstance.hide;
          let isDone = false;

          const resolveCall = () => {
            if (!isDone) {
              resolve();
              isDone = true;
            }
          };

          panelCall(resolveCall); // force the promise to resolve if animationend event didn't callback.
          // eslint-disable-next-line @lwc/lwc/no-async-operation

          setTimeout(resolveCall, PANEL_ANIMATION_TIME);
        });

        if (previousPromise) {
          promise = this.previousPromise.then(() => promise);
        }

        return promise;
      }

      show() {
        if (!this._visible) {
          this._showPromise = this._createPromise(true, this._hidePromise).then(() => {
            this._showPromise = null;
            this._visible = true;
          });
        }

        return this._showPromise || Promise.resolve();
      }

      hide() {
        if (this._visible) {
          this._hidePromise = this._createPromise(false, this._showPromise).then(() => {
            this._hidePromise = null;
            this._visible = false;
          });
        }

        return this._hidePromise || Promise.resolve();
      }

      close(shouldReturnFocus) {
        return new Promise(resolve => {
          this._panelInstance.close(() => {
            resolve();
          }, shouldReturnFocus);
        });
      }

    }

    function showCustomOverlay(configuration, eventDispatcher) {
      const parameters = parseOptions(configuration);
      return new Promise(resolve => {
        parameters.onCreate = panelInstance => {
          resolve(new OverlayPanel(panelInstance));
        };

        eventDispatcher(parameters);
      });
    }

    function wrapComponent(cmp) {
      return new Promise((resolve, reject) => {
        if (cmp instanceof HTMLElement) {
          aura.createComponent('lightning:overlayInteropWrapper', {
            domElement: cmp
          }, (newComponent, status, errorMessage) => {
            if (status === 'SUCCESS') {
              resolve(newComponent);
            } else {
              const rejectMessage = status === 'INCOMPLETE' ? 'No response from server or client is offline.' : errorMessage;
              reject(rejectMessage);
            }
          });
        } else {
          resolve(cmp);
        }
      });
    }

    function showCustomOverlay$1(configuration) {
      return Promise.all([wrapComponent(configuration.header), wrapComponent(configuration.body), wrapComponent(configuration.footer)]).then(components => {
        const options = Object.assign({}, configuration);
        options.header = components[0];
        options.body = components[1];
        options.footer = components[2];
        return showCustomOverlay(options, eventAttributes => {
          aura.dispatchGlobalEvent('markup://ui:createPanel', eventAttributes, configuration.contextElement);
        });
      });
    }

    /**
     * Shows advanced search panel having scoped search results.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     * Schema -
     * {
     *      additionalFields: {Array},
     *      contextId: {String},
     *      dependentFieldBindings: {Map},
     *      entities: {Array},
     *      field: {String},
     *      groupId: {String},
     *      label: {String},
     *      maxValues: {Integer},
     *      placeholder: {String},
     *      recordId: {String},
     *      saveCallback: {Function},
     *      scopeMap: {Object},
     *      scopeSets: {Object},
     *      source: {String},
     *      term: {String},
     * }
     */

    function showAdvancedSearch(attrs) {
      showCustomOverlay$1({
        isTransient: true,
        isScrollable: false,
        isFullScreen: true,
        flavor: 'large',
        autoFocus: false,
        title: attrs.label
      }).then(panel => {
        updatePanel(panel._panelInstance, attrs);
      });
    }
    /**
     * Updates panel by setting it's body and footer.
     * @param {Object} panel - Instance of panel created, an Aura Component.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     */

    function updatePanel(panel, attrs) {
      if (!panel || !attrs) {
        return;
      }

      setPanelFooter(panel).then(setPanelBody(panel, attrs)).catch(error => {
        throw new Error(error);
      });
    }
    /**
     * Sets an instance of lookupAdvanced to panel's body.
     * @param {Object} panel - Instance of panel, an Aura Component.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     * @returns {Promise} a promise used to resolve the creation of lookupAdvanced.
     */


    function setPanelBody(panel, attrs) {
      attrs.panel = panel;
      const promise = new Promise((resolve, reject) => {
        aura.createComponent('forceSearch:lookupAdvanced', attrs, (cmp, status, error) => {
          if (status === 'SUCCESS') {
            panel.update({
              body: cmp
            });
            resolve();
          } else {
            reject(error);
          }
        });
      });
      return promise;
    }
    /**
     * Sets an instance of lookupAdvancedFooter to panel's footer.
     * @param {Object} panel - Instance of panel, an Aura Component.
     * @return {Promise} a promise used to resolve the creation of
     * lookupAdvancedFooter.
     */


    function setPanelFooter(panel) {
      const promise = new Promise((resolve, reject) => {
        aura.createComponent('forceSearch:lookupAdvancedFooter', {
          'aura:id': 'lookupAdvancedFooter'
        }, (cmp, status, error) => {
          if (status === 'SUCCESS') {
            panel.set('v.footer', cmp);
            resolve();
          } else {
            reject(error);
          }
        });
      });
      return promise;
    }

    /*
    * The name of the type of the item that represents the create new action.
    * @type {String}
    */
    const ACTION_CREATE_NEW$1 = 'actionCreateNew';
    /*
     * GroupId used during advanced search.
     * The groupId indicates the group to which advancedSearch component belongs.
     * Typically only components with identical groupId values will interact.
     * @type {String}
     */

    const ADVANCED_SEARCH_GROUP_ID = 'LOOKUP';
    /*
     * The max number of values a user can select in advanced search.
     * @type {Number}
     */

    const ADVANCED_SEARCH_MAX_VALUES = 1;
    /**
     * The max length for combobox input.
     * @type {Number}
     */

    const INPUT_MAX_LENGTH = 255;
    /**
     * The lightning combobox component name.
     * @type {String}
     */

    const LIGHTNING_COMBOBOX = 'lightning-grouped-combobox';

    const i18n$o = {
      searchPlaceholder: labelSearchPlaceholder,
      searchObjectsPlaceholder: labelSearchObjectsPlaceholder,
      selectEntity: labelSelectObject
    };
    /**
     * Displays an input lookup for the Desktop.
     */

    class LightningLookupDesktop extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */

      /**
       * @return {Boolean} - Indicates whether or not to show the create new option.
       */

      /**
       * Error message to be displayed under the lookup input.
       * @type {String}
       */
      get errorMessage() {
        return this._errorMessage;
      }

      set errorMessage(message) {
        this._errorMessage = message; // set message on grouped combobox.

        const groupedCombobox = this._groupedCombobox;

        if (groupedCombobox) {
          groupedCombobox.setCustomValidity(message);
          groupedCombobox.reportValidity();
        }
      }
      /**
       * @return {String} - The lookup field name.
       */


      get fieldName() {
        return this._fieldName;
      }
      /**
       * Sets the field name for the lookup.
       * @param {String|FieldId} value - The lookup field name.
       */


      set fieldName(value) {
        this._fieldName = value;
        this.updateState();
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (!this._connected) {
          return;
        }

        const combobox = this._groupedCombobox;

        if (combobox) {
          combobox.focus();
        }
      }
      /**
       * The combobox input text value.
       * @type {String}
       */


      /**
       * The list of items used to display in combobox.
       * @type {Array}
       */
      get items() {
        return this._items;
      }

      set items(items) {
        this._lookupPerformanceLogger.startRenderMark();

        this._lookupPerformanceLogger.mergeTransactionAttributesWith({
          qResults: items.length // FIXME if items are grouped, number of results will be wrong

        });

        if (this.enableCreateNew) {
          items = [...items, computeCreateNewOption(this.textInfo.targetLabel)];
        }

        this._items = items;
        this.showActivityIndicator = false;
      }
      /**
       * The text label for the field.
       * @type {String}
       */


      /**
       * @return {Object} - The source record's objectInfos.
       */
      get objectInfos() {
        return this._objectInfos;
      }
      /**
       * Sets the source record's objectInfos.
       * @param {Object} value - The source record's objectInfos.
       */


      set objectInfos(value) {
        this._objectInfos = value;
        this.updateState();
      }
      /**
       * Selected records get from combobox
       * @type {Array}
       */


      get pills() {
        return this._pills;
      }

      set pills(pills) {
        this._pills = pills || [];
        this._value = this._pills.map(p => p.value);

        if (this.maxValues === 1 && this._pills.length) {
          this.inputPill = this._pills[0];
          this.internalPills = [];
        } else {
          this.internalPills = this._pills;
          this.inputPill = null;
        }

        if (this._pills.length) {
          this.dispatchEvent(new CustomEvent('reportvalidity'));
        }

        this.updateFilterItems();
      }
      /**
       * @return {Object} - The source record representation.
       */


      get record() {
        return this._record;
      }
      /**
       * Sets the source record representation.
       * @param {Object} value - The source record.
       */


      set record(value) {
        this._record = value;
        this.updateState();
      }
      /**
       * The field info in the object info is not updated based on the layout metadata.
       * It allows field to be marked as required for the given layout.
       * @return {Boolean} - Indicates whether or not the field is required.
       */


      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */
      get validity() {
        return this._constraint.validity;
      }
      /**
       * Sets the variant type for the lookup.
       * @type {String}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * The field level help text.
       * @type {String}
       */
      get fieldLevelHelp() {
        return this._metadataManager.fieldLevelHelp;
      }
      /**
       * Returns an input text for the entity filter.
       * @returns {String} See desc.
       */


      get filterInputText() {
        return this._metadataManager.targetLabel;
      }
      /**
       * The field api name to trigger @wire(getLookupRecords).
       * Note - Should be only used to trigger the wire.
       * @type {Object}
       */


      get _fieldApiName() {
        return this._metadataManager.fieldApiName;
      }
      /**
       * Returns the grouped combobox element
       * @returns {Object}
       */


      get _groupedCombobox() {
        return this.template.querySelector(LIGHTNING_COMBOBOX);
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.enableCreateNew = void 0;
        this.inputText = '';
        this.label = void 0;
        this.maxValues = void 0;
        this.required = void 0;
        this.textInfo = void 0;
        this.variant = void 0;
        this.filterItems = void 0;
        this.filterLabel = void 0;
        this.inputIconName = void 0;
        this.inputMaxlength = void 0;
        this.inputPill = null;
        this.internalPills = [];
        this.placeholder = '';
        this.showActivityIndicator = void 0;
        this._connected = false;
        this._errorMessage = void 0;
        this._fieldName = void 0;
        this._items = [];
        this._lookupPerformanceLogger = new LookupPerformanceLogger();
        this._metadataManager = void 0;
        this._optionalFields = void 0;
        this._pills = [];
        this._selectedEntityApiName = undefined;
        this._value = void 0;
        this._metadataManager = new MetadataManager();
        this.inputIconName = COMMON_LOOKUP_CONSTANTS.ICON_SEARCH;
        this.inputMaxlength = INPUT_MAX_LENGTH;
        this.filterLabel = i18n$o.selectEntity;
        this._events = new LookupEventDispatcher(this);
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }

      renderedCallback() {
        this._lookupPerformanceLogger.endRenderMark();

        this._lookupPerformanceLogger.endTransaction();
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /**
       * Callback method executed by the parent component to update values after handling "createnew" event.
       * @param {Array} values - An array of newly created record ids.
       */


      createNewCallback(values = []) {
        if (!Array.isArray(values) || !values.length) {
          return;
        }

        this.handleRecordOptionSelect(values[0]);
      }

      getPlaceholder() {
        if (this._metadataManager.isSingleEntity) {
          // Returns "Search <label>", for example - "Search Accounts".
          return i18n$o.searchObjectsPlaceholder.replace('{0}', this._metadataManager.targetPluralLabel);
        } // Returns "Search..."


        return i18n$o.searchPlaceholder;
      }
      /**
       * Handles advanced search by showing scoped results in a panel.
       */


      handleAdvancedSearchAction() {
        // Log click on advanced search option interaction.
        log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOGGING_CONSTANTS.LOG_TARGET_LOOKUP_ACTION_OPTION, {
          scopeName: this._metadataManager.targetApiName,
          type: LOGGING_CONSTANTS.LOG_ACTION_SEARCH_OPTION
        });

        const scopeMap = this._metadataManager.getTargetObjectAsScope();

        const saveCallback = values => {
          // Advanced search returns an array of selected values.
          if (values && values.length > 0) {
            // Select first value as selected value.
            this.handleRecordOptionSelect(values[0]);
            this.dispatchEvent(new CustomEvent('reportvalidity'));
          }
        };

        const fieldName = computeUnqualifiedFieldApiName(this._fieldApiName);
        const lookupAdvancedAttributes = {
          additionalFields: [],
          contextId: '',
          dependentFieldBindings: this._metadataManager.getBindingsMap(this._record),
          entities: [scopeMap],
          field: fieldName,
          groupId: ADVANCED_SEARCH_GROUP_ID,
          label: this.label,
          maxValues: ADVANCED_SEARCH_MAX_VALUES,
          placeholder: this.placeholder,
          recordId: this.record ? this.record.id : '',
          saveCallback,
          scopeMap,
          scopeSets: {
            DEFAULT: [scopeMap]
          },
          source: this._metadataManager.sourceApiName,
          showCreateNew: this.enableCreateNew,
          term: this.inputText
        };

        try {
          // Show advanced search modal.
          showAdvancedSearch(lookupAdvancedAttributes);
        } catch (error) {
          this._events.dispatchErrorEvent(error);
        }
      }
      /**
       * fires reportvalidity event when focus is removed from grouped combobox.
       */


      handleBlur() {
        this.dispatchEvent(new CustomEvent('reportvalidity'));
      }
      /**
       * Handles create new option selection.
       */


      handleCreateNewAction() {
        // Log click on create new option interaction.
        log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOGGING_CONSTANTS.LOG_TARGET_LOOKUP_ACTION_OPTION, {
          scopeName: this._metadataManager.targetApiName,
          sourceName: this._metadataManager.sourceApiName,
          type: LOGGING_CONSTANTS.LOG_ACTION_CREATE_NEW_OPTION
        });

        this._events.dispatchCreateEvent(this._metadataManager.targetApiName, values => this.createNewCallback(values));
      }
      /**
       * Handles the input's focus event.
       */


      handleDropdownOpenRequest() {
        // Log lookup activation.
        log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOGGING_CONSTANTS.LOG_TARGET_INPUT, {
          scopeName: this._metadataManager.targetApiName
        });

        this._lookupPerformanceLogger.startTransaction(); // Show MRU items only if user has not typed any inputText.


        if (!this.inputText.length) {
          this.updateTerm('');
        }
      }
      /**
       * Handles the oninput event from the combobox input, triggering an update to @wire parameters.
       * @param {Object} event - The input's oninput/onchange event.
       */


      handleTextInput(event) {
        // No-op if event detail is empty or inputPill is already populated.
        if (!event.detail || this.inputPill) {
          return;
        }

        this._lookupPerformanceLogger.startTransaction();

        const term = event.detail.text || ''; // Update term.

        this.updateTerm(term);
      }
      /**
       * Handles the pillremove event fired from combo-box when a selected option is removed.
       * @param {Object} event - Contains details of the event being handled.
       */


      handlePillRemove(event) {
        log(LOGGING_CONSTANTS.LOG_EVENT_PILL_REMOVE, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOGGING_CONSTANTS.LOG_TARGET_RECORD_PILL_ITEM, {
          scopeName: this._metadataManager.targetApiName
        });

        if (event && event.detail) {
          const removedValue = (event.detail.item || {}).value;

          if (!removedValue) {
            return;
          }

          this._events.dispatchPillRemoveEvent(removedValue);

          this.updateTerm('');
        }
      }
      /**
       * Handles record option selection
       * @param {String} recordId - The record id of the option.
       */


      handleRecordOptionSelect(recordId) {
        // No-op if record id is empty.
        if (!recordId) {
          return;
        }

        this._events.dispatchRecordItemSelectEvent(recordId);

        this.inputText = '';
      }
      /**
       * Handles the select event fired from combo-box when an option is selected.
       * @param {Object} event - Contains details of the event being handled.
       */


      handleSelect(event) {
        const value = event.detail.value;

        switch (value) {
          case COMMON_LOOKUP_CONSTANTS.ACTION_ADVANCED_SEARCH:
            this.handleAdvancedSearchAction();
            break;

          case ACTION_CREATE_NEW$1:
            this.handleCreateNewAction();
            break;

          default:
            this.handleRecordOptionSelect(value);
            break;
        }
      }
      /**
       * Handles entity filter change.
       * @param {Object} event - The filter's onchange event object.
       */


      handleSelectFilter(event) {
        if (!event.detail) {
          return;
        } // Log click on filter item interaction.


        log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_ENTITY_SELECTOR, LOGGING_CONSTANTS.LOG_TARGET_FILTER_ITEM, {
          scopeName: this._metadataManager.targetApiName
        });
        const selectedEntity = event.detail.value; // No-op if newly selected target api is the same as the previous one.

        if (selectedEntity === this._metadataManager.targetApiName) {
          return;
        }

        this._selectedEntityApiName = selectedEntity;

        this._events.dispatchEntityFilterSelect(selectedEntity);

        this.updateTerm(''); // Update internal state.

        this.updateState();
      }
      /**
       * Updates combobox filter items.
       */


      updateFilterItems() {
        // For single-value lookup, if an inputPill is present then filter items shouldn't be shown.
        this.filterItems = this.maxValues === 1 && this.inputPill ? null : this._metadataManager.getFilterItems();
        this.placeholder = this.getPlaceholder();
      }
      /**
       * Updates lookup's internal state.
       */


      updateState() {
        if (!this._fieldName || !Object.keys(this._record || {}).length || !Object.keys(this._objectInfos || {}).length) {
          return;
        }

        try {
          this._metadataManager = new MetadataManager(this._fieldName, this._objectInfos, this._record, this._selectedEntityApiName); // Update filter items for entity selection.

          this.updateFilterItems();
        } catch (error) {
          this._events.dispatchErrorEvent(error);
        }
      }
      /**
       * Updates term state, triggering the @wire service on term change.
       * @param  {String} term - The search term.
       */


      updateTerm(term) {
        this._lookupPerformanceLogger.mergeTransactionAttributesWith({
          qType: term.length < 3 ? LOGGING_CONSTANTS.LOG_CONTEXT_Q_TYPE_MRU : LOGGING_CONSTANTS.LOG_CONTEXT_Q_TYPE_TYPEAHEAD,
          targetApiName: this._metadataManager.targetApiName,
          qLength: term ? term.length : 0
        }); // Update combobox input text value.


        this.inputText = term;

        this._events.dispatchLookupRecordsRequestEvent({
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_Q]: term.trim()
        });

        this.showActivityIndicator = true;
      }

    }

    lwc.registerDecorators(LightningLookupDesktop, {
      publicProps: {
        disabled: {
          config: 0
        },
        enableCreateNew: {
          config: 0
        },
        errorMessage: {
          config: 3
        },
        fieldName: {
          config: 3
        },
        inputText: {
          config: 0
        },
        items: {
          config: 3
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 0
        },
        objectInfos: {
          config: 3
        },
        pills: {
          config: 3
        },
        record: {
          config: 3
        },
        required: {
          config: 0
        },
        textInfo: {
          config: 0
        },
        validity: {
          config: 1
        },
        variant: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        filterItems: 1,
        filterLabel: 1,
        inputIconName: 1,
        inputMaxlength: 1,
        inputPill: 1,
        internalPills: 1,
        placeholder: 1,
        showActivityIndicator: 1
      },
      fields: ["_connected", "_errorMessage", "_fieldName", "_items", "_lookupPerformanceLogger", "_metadataManager", "_optionalFields", "_pills", "_selectedEntityApiName", "_value"]
    });

    var _lightningLookupDesktop = lwc.registerComponent(LightningLookupDesktop, {
      tmpl: _tmpl$C
    });

    function stylesheet$h(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$h = [stylesheet$h];

    const BUTTON_SELECTOR = 'button.slds-faux-input';
    const VARIANT$2 = {
      STANDARD: 'standard',
      LABEL_HIDDEN: 'label-hidden'
    };

    function tmpl$H($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-faux-input_container": true
        },
        key: 5,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.preventClickOutsideButton))
        }
      }, [api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("slds-faux-input-label")
        },
        key: 1,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.focus))
        }
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.requiredLabel
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        className: $cmp.computedFieldLevelHelpClass,
        props: {
          "id": api_scoped_id("field-help"),
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("button", {
        classMap: {
          "slds-faux-input": true
        },
        attrs: {
          "aria-labelledby": `${api_scoped_id("slds-faux-input-label")}`
        },
        key: 4
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "iconName": "utility:search",
          "size": "x-small"
        },
        key: 3
      }, [])])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 6
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var standard = lwc.registerTemplate(tmpl$H);
    tmpl$H.stylesheets = [];
    tmpl$H.stylesheetTokens = {
      hostAttribute: "lightning-lookupMobileFauxInput_fauxInputStandard-host",
      shadowAttribute: "lightning-lookupMobileFauxInput_fauxInputStandard"
    };

    function tmpl$I($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-faux-input_container": true
        },
        key: 5,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.preventClickOutsideButton))
        }
      }, [api_element("button", {
        classMap: {
          "slds-faux-input": true
        },
        key: 4
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.requiredLabel
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        classMap: {
          "faux-input-field-level-help": true
        },
        props: {
          "id": api_scoped_id("field-help"),
          "content": $cmp.fieldLevelHelp
        },
        key: 1
      }, []) : null]), api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "iconName": "utility:search",
          "size": "x-small"
        },
        key: 3
      }, [])])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 6
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var labelHidden = lwc.registerTemplate(tmpl$I);
    tmpl$I.stylesheets = [];
    tmpl$I.stylesheetTokens = {
      hostAttribute: "lightning-lookupMobileFauxInput_fauxInputLabelHidden-host",
      shadowAttribute: "lightning-lookupMobileFauxInput_fauxInputLabelHidden"
    };

    class LightningLookupMobileFauxInput extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = '';
        this.required = false;
        this.variant = VARIANT$2.STANDARD;
        this._errorMessage = void 0;
        this._fieldLevelHelp = void 0;
      }

      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Error message to be displayed below the input
       * @type {string}
       */
      get errorMessage() {
        return this._errorMessage;
      }

      set errorMessage(value) {
        this._errorMessage = value;
        this.synchronizeA11y();
      }
      /**
       * Help message for the field.
       * @type {string}
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
        this.synchronizeA11y();
      }

      focus() {
        if (this.button) {
          this.button.focus();
        }
      }
      /**
       * Label for the faux input button, shown as assistive text for hidden variant
       * @type {string}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================
      get button() {
        return this.template.querySelector(BUTTON_SELECTOR);
      }

      get isLabelHidden() {
        return this.variant === VARIANT$2.LABEL_HIDDEN;
      }

      get isLabelInline() {
        return this.variant === VARIANT$2.LABEL_INLINE;
      }

      get isLabelStacked() {
        return this.variant === VARIANT$2.LABEL_STACKED;
      }
      /**
       * Computes css classes to handle different label varients.
       * @return {String} String of css classes to be set on pill presenter label element.
       */


      get computedLabelClass() {
        const classnames = classSet('slds-faux-input_label slds-form-element_label');
        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).add({
          'slds-form-element_stacked': this.isLabelStacked
        }).add({
          'slds-form-element_horizontal': this.isLabelInline
        }).toString();
      }
      /**
       * Computes css classes to handle different label varients for fieldLevelHelp.
       * @return {String} String of css classes to be set on lightning-helptext element.
       */


      get computedFieldLevelHelpClass() {
        const classnames = classSet('faux-input-field-level-help');
        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        if (this.errorMessage) {
          ariaValues.push(this.computedUniqueHelpElementId);
        }

        if (this.fieldLevelHelp) {
          ariaValues.push(this.computedUniqueFieldLevelHelpElementId);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedUniqueHelpElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get computedUniqueFieldLevelHelpElementId() {
        return getRealDOMId(this.template.querySelector('.faux-input-field-level-help'));
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      render() {
        return this.variant === VARIANT$2.LABEL_HIDDEN ? labelHidden : standard;
      }

      renderedCallback() {
        this.synchronizeA11y();
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================


      preventClickOutsideButton(event) {
        if (event && event.target !== this.button) {
          event.stopPropagation();
        }
      }

      synchronizeA11y() {
        if (this.button) {
          synchronizeAttrs(this.button, {
            [COMMON_LOOKUP_CONSTANTS.ARIA_DESCRIBEDBY]: this.computedAriaDescribedBy
          });
        }
      }

    }

    lwc.registerDecorators(LightningLookupMobileFauxInput, {
      publicProps: {
        errorMessage: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        label: {
          config: 0
        },
        required: {
          config: 0
        },
        variant: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      fields: ["_errorMessage", "_fieldLevelHelp"]
    });

    var _lightningLookupMobileFauxInput = lwc.registerComponent(LightningLookupMobileFauxInput, {
      tmpl: _tmpl$3
    });

    function tmpl$J($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4
      } = $ctx;
      return [!$cmp.hasPills ? !$cmp.disabled ? api_custom_element("lightning-lookup-mobile-faux-input", _lightningLookupMobileFauxInput, {
        props: {
          "label": $cmp.label,
          "variant": $cmp.variant,
          "errorMessage": $cmp.errorMessage,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "required": $cmp.required
        },
        key: 0,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "click": _m1 || ($ctx._m1 = api_bind($cmp.showPanel))
        }
      }, []) : null : null, !$cmp.hasPills ? $cmp.disabled ? api_element("label", {
        className: $cmp.computedLabelClass,
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.requiredLabel
        },
        key: 1
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null : null, !$cmp.hasPills ? $cmp.disabled ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        className: $cmp.computedFieldLevelHelpClass,
        props: {
          "id": api_scoped_id("input-field-help"),
          "content": $cmp.fieldLevelHelp
        },
        key: 3
      }, []) : null : null : null, !$cmp.hasPills ? $cmp.disabled ? api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-grow": true,
          "slds-input-has-icon": true,
          "slds-input-has-icon_right": true
        },
        key: 6
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("lookup-mobile-disabled")
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 4
      }, []), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:search",
          "variant": "bare",
          "svgClass": "slds-input__icon slds-input__icon_left slds-icon-text-default"
        },
        key: 5
      }, [])]) : null : null, !$cmp.hasPills ? $cmp.disabled ? $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("input-help-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 7
      }, [api_dynamic($cmp.errorMessage)]) : null : null : null, $cmp.hasPills ? api_element("label", {
        className: $cmp.computedLabelClass,
        key: 9,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.focusPillContainer))
        }
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.requiredLabel
        },
        key: 8
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.hasPills ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        className: $cmp.computedFieldLevelHelpClass,
        props: {
          "id": api_scoped_id("pill-container-field-help"),
          "content": $cmp.fieldLevelHelp
        },
        key: 10
      }, []) : null : null, $cmp.hasPills ? api_custom_element("lightning-pill-container", _lightningPillContainer, {
        props: {
          "ariaLabelledBy": `${api_scoped_id("pillcontainerlabel")}`,
          "ariaDescribedBy": api_scoped_id($cmp.computedAriaDescribedBy),
          "items": $cmp.pills
        },
        key: 11,
        on: {
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleBlur)),
          "itemremove": _m4 || ($ctx._m4 = api_bind($cmp.handlePillRemove))
        }
      }, []) : null, $cmp.hasPills ? $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("pill-container-help-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 12
      }, [api_dynamic($cmp.errorMessage)]) : null : null];
    }

    var _tmpl$D = lwc.registerTemplate(tmpl$J);
    tmpl$J.stylesheets = [];

    if (_implicitStylesheets$h) {
      tmpl$J.stylesheets.push.apply(tmpl$J.stylesheets, _implicitStylesheets$h);
    }
    tmpl$J.stylesheetTokens = {
      hostAttribute: "lightning-lookupMobile_lookupMobile-host",
      shadowAttribute: "lightning-lookupMobile_lookupMobile"
    };

    /**
     * The lightning input component name
     * @type {String}
     */
    const LIGHTNING_LOOKUP_MOBILE_FAUX_INPUT = 'lightning-lookup-mobile-faux-input';
    /**
     * The lightning pill container component name
     * @type {String}
     */

    const LIGHTNING_PILL_CONTAINER = 'lightning-pill-container';
    /**
     * label hidden variant constant
     * @type {String}
     */

    const LABEL_HIDDEN = 'label-hidden';
    /**
     * label inline variant constant
     * @type {String}
     */

    const LABEL_INLINE = 'label-inline';
    /**
     * label stacked variant constant
     * @type {String}
     */

    const LABEL_STACKED = 'label-stacked';

    function tmpl$K($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("label", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        attrs: {
          "for": `${api_scoped_id("input")}`,
          "id": api_scoped_id("label")
        },
        key: 0
      }, [api_dynamic($cmp.ariaLabel)]), api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-input-has-icon": true,
          "slds-input-has-icon_right": true
        },
        key: 34
      }, [api_element("div", {
        classMap: {
          "slds-mobile-combobox": true
        },
        attrs: {
          "role": "combobox",
          "aria-expanded": "false"
        },
        key: 33
      }, [api_element("div", {
        classMap: {
          "slds-mobile-combobox__header": true,
          "slds-mobile-combobox__header-has-icon": true
        },
        key: 11
      }, [api_element("div", {
        classMap: {
          "slds-mobile-combobox__addon": true
        },
        key: 2
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.filterIconName,
          "alternativeText": $cmp.filterIconAlternativeText
        },
        key: 1
      }, [])]), api_element("div", {
        classMap: {
          "slds-mobile-combobox__input": true
        },
        attrs: {
          "role": "none"
        },
        key: 10
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("input"),
          "placeholder": $cmp.placeholder,
          "autocomplete": "off",
          "role": "textbox",
          "aria-autocomplete": "list",
          "aria-controls": `${api_scoped_id("listbox")}`
        },
        props: {
          "value": $cmp.inputText
        },
        key: 3,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInputChange))
        }
      }, []), $cmp.textClear ? api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true,
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        attrs: {
          "title": $cmp.i18n.clear
        },
        key: 7,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleClickClearText))
        }
      }, [api_element("svg", {
        classMap: {
          "slds-button__icon": true,
          "slds-icon-text-light": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 5
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#clear")
        },
        key: 4
      }, [])]), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.i18n.clear)])]) : null, !$cmp.textClear ? api_element("svg", {
        classMap: {
          "slds-icon": true,
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 9
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", "/assets/icons/utility-sprite/svg/symbols.svg#search")
        },
        key: 8
      }, [])]) : null])]), api_element("div", {
        classMap: {
          "slds-mobile-lookup__listbox_container": true
        },
        attrs: {
          "id": api_scoped_id("listbox"),
          "role": "listbox",
          "aria-labelledby": `${api_scoped_id("label")}`
        },
        key: 32
      }, api_flatten([api_iterator($cmp.items, function (item) {
        return [item.action ? api_element("button", {
          classMap: {
            "slds-button": true,
            "slds-button_stretch": true,
            "slds-mobile-lookup__listbox_trigger": true
          },
          attrs: {
            "data-value": item.value
          },
          key: api_key(15, item.value),
          on: {
            "click": _m2 || ($ctx._m2 = api_bind($cmp.handleSelected))
          }
        }, [api_dynamic(item.text), api_element("span", {
          classMap: {
            "slds-icon_container": true,
            "slds-icon-utility-search": true
          },
          attrs: {
            "title": $cmp.i18n.search
          },
          key: 14
        }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
          props: {
            "size": "x-small",
            "iconName": item.endIconName
          },
          key: 12
        }, []), api_element("span", {
          classMap: {
            "slds-assistive-text": true
          },
          key: 13
        }, [api_dynamic(item.endIconAlternativeText)])])]) : null, item.items ? api_element("ul", {
          classMap: {
            "slds-mobile-lookup__listbox": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(26, item.label)
        }, api_flatten([item.label ? api_element("li", {
          classMap: {
            "slds-mobile-lookup__listbox-option_heading": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 18
        }, [api_element("div", {
          classMap: {
            "slds-mobile-lookup__listbox-option": true,
            "slds-mobile-lookup__listbox-option_heading": true
          },
          key: 17
        }, [api_element("span", {
          key: 16
        }, [api_dynamic(item.label)])])]) : null, api_iterator(item.items, function (option) {
          return api_element("li", {
            attrs: {
              "role": "presentation",
              "data-value": option.value
            },
            key: api_key(25, option.value),
            on: {
              "click": _m3 || ($ctx._m3 = api_bind($cmp.handleSelected))
            }
          }, [api_element("div", {
            classMap: {
              "slds-mobile-lookup__listbox-option": true
            },
            attrs: {
              "role": "option"
            },
            key: 24
          }, [api_element("span", {
            classMap: {
              "slds-mobile-lookup__listbox_text_container": true
            },
            key: 23
          }, [api_element("span", {
            classMap: {
              "slds-mobile-lookup__listbox_text": true
            },
            key: 20
          }, [api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
            props: {
              "text": option.text
            },
            key: 19
          }, [])]), api_element("span", {
            classMap: {
              "slds-mobile-lookup__listbox_meta": true
            },
            key: 22
          }, [api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
            props: {
              "text": option.subText
            },
            key: 21
          }, [])])])])]);
        })])) : null];
      }), $cmp.showActivityIndicator ? api_element("div", {
        classMap: {
          "slds-mobile-lookup__listbox_loader": true
        },
        attrs: {
          "role": "presentation"
        },
        key: 31
      }, [api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_x-small": true
        },
        attrs: {
          "role": "status"
        },
        key: 30
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 27
      }, [api_dynamic($cmp.i18n.loading)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 28
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 29
      }, [])])]) : null]))])])];
    }

    var _tmpl$E = lwc.registerTemplate(tmpl$K);
    tmpl$K.stylesheets = [];
    tmpl$K.stylesheetTokens = {
      hostAttribute: "lightning-mobileGroupedCombobox_mobileGroupedCombobox-host",
      shadowAttribute: "lightning-mobileGroupedCombobox_mobileGroupedCombobox"
    };

    const i18n$p = {
      clear: labelClear,
      search: labelSearch,
      loading: labelLoading
    };

    class LightningMobileGroupedCombobox extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._items = [];
        this.textClear = false;
        this.ariaLabel = '';
        this.placeholder = '';
        this.filterIconName = void 0;
        this.filterIconAlternativeText = void 0;
        this.inputText = void 0;
        this.showActivityIndicator = false;
        this.items = void 0;
      }

      /**
       * Sets focus on the input element.
       */
      focus() {
        this.template.querySelector('input').focus();
      }
      /**
       * Removes focus from the input element.
       */


      blur() {
        this.template.querySelector('input').blur();
      }
      /**
       * Clear Text Button click handler
       * When the clear text button is clicked:
       *  1. Clear input's value
       *  2. Set focus on the input
       *  3. Fire textinput event
       */


      handleClickClearText() {
        const input = this.template.querySelector('input');
        input.value = '';
        input.focus();
        this.textClear = false;
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            value: ''
          }
        }));
      }
      /**
       * Fire 'textinput' event with value of input everytime the user types into the input.
       * Set indicator of whether or not to show clear text button.
       * @param {object} event
       */


      handleInputChange(event) {
        const value = event.target.value;
        this.textClear = value ? true : false;
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            value
          }
        }));
      }
      /**
       * Fire 'select' event with value of selected item when the user taps on a selectable item
       * @param {object} event
       */


      handleSelected(event) {
        const value = event.currentTarget.getAttribute('data-value');
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value
          }
        }));
      }

      get i18n() {
        return i18n$p;
      }

    }

    lwc.registerDecorators(LightningMobileGroupedCombobox, {
      publicProps: {
        ariaLabel: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        filterIconName: {
          config: 0
        },
        filterIconAlternativeText: {
          config: 0
        },
        inputText: {
          config: 0
        },
        showActivityIndicator: {
          config: 0
        },
        items: {
          config: 0
        }
      },
      publicMethods: ["focus", "blur"],
      fields: ["_items", "textClear"]
    });

    var _lightningMobileGroupedCombobox = lwc.registerComponent(LightningMobileGroupedCombobox, {
      tmpl: _tmpl$E
    });

    function tmpl$L($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-p-around_medium": true
        },
        key: 57
      }, [api_custom_element("lightning-mobile-grouped-combobox", _lightningMobileGroupedCombobox, {
        props: {
          "ariaLabel": $cmp.placeholder,
          "filterIconName": $cmp.filterIconName,
          "items": $cmp.items,
          "inputText": $cmp.inputText,
          "placeholder": $cmp.placeholder,
          "showActivityIndicator": $cmp.showActivityIndicator
        },
        key: 0,
        on: {
          "select": _m0 || ($ctx._m0 = api_bind($cmp.handleSelect)),
          "textinput": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange))
        }
      }, []), $cmp.emptyState.show ? api_element("div", {
        classMap: {
          "slds-illustration": true,
          "slds-illustration_small": true
        },
        key: 56
      }, [api_element("svg", {
        classMap: {
          "slds-illustration__svg": true
        },
        attrs: {
          "viewBox": "0 0 468 194",
          "aria-hidden": "true",
          "xmlns": "http://www.w3.org/2000/svg"
        },
        key: 52
      }, [api_element("g", {
        attrs: {
          "stroke": "none",
          "stroke-width": "1",
          "fill": "none",
          "fill-rule": "evenodd"
        },
        key: 51
      }, [api_element("g", {
        attrs: {
          "transform": "translate(-67.000000, -112.000000)"
        },
        key: 50
      }, [api_element("g", {
        key: 49
      }, [api_element("g", {
        classMap: {
          "slds-illustration__stroke-secondary": true
        },
        attrs: {
          "transform": "translate(245.000000, 200.000000)",
          "stroke-linecap": "round",
          "stroke-width": "3"
        },
        key: 5
      }, [api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"
        },
        key: 1
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"
        },
        key: 2
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M18,27.5 L83.0004985,27.5"
        },
        key: 3
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M0,27.5 L8,27.5"
        },
        key: 4
      }, [])]), api_element("g", {
        classMap: {
          "slds-illustration__stroke-secondary": true
        },
        attrs: {
          "transform": "translate(135.000000, 152.000000)",
          "stroke-linecap": "round",
          "stroke-width": "3"
        },
        key: 10
      }, [api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"
        },
        key: 6
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"
        },
        key: 7
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M18,27.5 L83.0004985,27.5"
        },
        key: 8
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M0,27.5 L8,27.5"
        },
        key: 9
      }, [])]), api_element("g", {
        classMap: {
          "slds-illustration__stroke-secondary": true
        },
        attrs: {
          "transform": "translate(69.000000, 256.000000)",
          "stroke-linecap": "round",
          "stroke-width": "3"
        },
        key: 17
      }, [api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M14,36.5 L464,36.5"
        },
        key: 11
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M0,36.5 L6,36.5"
        },
        key: 12
      }, []), api_element("polyline", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "stroke-linejoin": "round",
          "points": "234.5 36 279.5 0 313.5 26"
        },
        key: 13
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M279.5,1 L279.5,35",
          "stroke-linejoin": "round"
        },
        key: 14
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M313.5,11 C313.5,20.7437888 313.5,25.7437888 313.5,26 C313.5,25.7437888 313.5,20.7437888 313.5,11 Z",
          "stroke-linejoin": "round"
        },
        key: 15
      }, []), api_element("polyline", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "stroke-linejoin": "round",
          "points": "303.5 17 313.5 9 347.5 36"
        },
        key: 16
      }, [])]), api_element("g", {
        attrs: {
          "transform": "translate(113.000000, 178.000000)"
        },
        key: 35
      }, [api_element("g", {
        classMap: {
          "slds-illustration__fill-secondary": true
        },
        attrs: {
          "transform": "translate(30.000000, 8.000000)"
        },
        key: 19
      }, [api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M29.5,60.5 L29.5,12 C29.5,5.372583 34.872583,0 41.5,0 C48.127417,0 53.5,5.372583 53.5,12 L53.5,40.5 L70.5,40.5 L70.5,27 C70.5,23.1340068 73.6340068,20 77.5,20 C81.3659932,20 84.5,23.1340068 84.5,27 L84.5,48.5 C84.5,51.8137085 81.8137085,54.5 78.5,54.5 L53.5,54.5 L53.5,118.5 L29.5,118.5 L29.5,74.5 L6.5,74.5 C3.1862915,74.5 0.5,71.8137085 0.5,68.5 L0.5,39 C0.5,35.1340068 3.63400675,32 7.5,32 C11.3659932,32 14.5,35.1340068 14.5,39 L14.5,60.5 L29.5,60.5 Z"
        },
        key: 18
      }, [])]), api_element("g", {
        attrs: {
          "transform": "translate(59.000000, 7.000000)",
          "fill": "#FFFFFF"
        },
        key: 21
      }, [api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M2,11 C3.65332031,8.49145508 5.65181478,6.77364095 7.9954834,5.84655762 C11.5109863,4.45593262 15.2684326,4.95605469 17.8156738,6.2824707 C20.362915,7.60888672 22.3626709,9.64978027 23.2602539,11.81604 C23.8586426,13.2602132 23.8586426,11.7547201 23.2602539,7.29956055 L19.612793,3.56494141 L13.7923584,0.564331055 L8.765625,1.42663574 L4.67321777,3.19787598 C2.69893392,5.13902708 1.69559733,6.16722532 1.66320801,6.2824707 C1.61462402,6.45533878 0.856079102,9.49145508 0.813964844,9.66003418 C0.785888672,9.77242025 1.18123372,10.2190755 2,11 Z"
        },
        key: 20
      }, [])]), api_element("g", {
        classMap: {
          "slds-illustration__stroke-primary": true
        },
        attrs: {
          "stroke-width": "3"
        },
        key: 34
      }, [api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M0,126.5 L356,126.5",
          "stroke-linecap": "round"
        },
        key: 22
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M362.5,126.5 L372.013149,126.5",
          "stroke-linecap": "round"
        },
        key: 23
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M107.5,20 L107.5,28",
          "stroke-linecap": "round"
        },
        key: 24
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M113,30.6568542 L118.656854,25",
          "stroke-linecap": "round"
        },
        key: 25
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M37.5,32 L37.5,40",
          "stroke-linecap": "round"
        },
        key: 26
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M44,42.6568542 L49.6568542,37",
          "stroke-linecap": "round"
        },
        key: 27
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M25,42.6568542 L30.6568542,37",
          "stroke-linecap": "round",
          "transform": "translate(27.828427, 39.828427) scale(-1, 1) translate(-27.828427, -39.828427) "
        },
        key: 28
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M71.5,0 L71.5,8",
          "stroke-linecap": "round"
        },
        key: 29
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M79,10.6568542 L84.6568542,5",
          "stroke-linecap": "round"
        },
        key: 30
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M58,10.6568542 L63.6568542,5",
          "stroke-linecap": "round",
          "transform": "translate(60.828427, 7.828427) scale(-1, 1) translate(-60.828427, -7.828427) "
        },
        key: 31
      }, []), api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M59.5,68.5 L59.5,20 C59.5,13.372583 64.872583,8 71.5,8 C78.127417,8 83.5,13.372583 83.5,20 L83.5,48.5 L100.5,48.5 L100.5,35 C100.5,31.1340068 103.634007,28 107.5,28 C111.365993,28 114.5,31.1340068 114.5,35 L114.5,56.5 C114.5,59.8137085 111.813708,62.5 108.5,62.5 L83.5,62.5 L83.5,126.5 L59.5,126.5 L59.5,82.5 L36.5,82.5 C33.1862915,82.5 30.5,79.8137085 30.5,76.5 L30.5,47 C30.5,43.1340068 33.6340068,40 37.5,40 C41.3659932,40 44.5,43.1340068 44.5,47 L44.5,68.5 L59.5,68.5 Z"
        },
        key: 32
      }, []), api_element("path", {
        classMap: {
          "slds-illustration__fill-secondary": true
        },
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M77,88.5 L92.5,88.5 L92.5,81 C92.5,77.1340068 95.6340068,74 99.5,74 L99.5,74 C103.365993,74 106.5,77.1340068 106.5,81 L106.5,96.5 C106.5,99.8137085 103.813708,102.5 100.5,102.5 L77,102.5",
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        },
        key: 33
      }, [])])]), api_element("g", {
        classMap: {
          "slds-illustration__stroke-secondary": true
        },
        attrs: {
          "transform": "translate(429.000000, 242.000000)",
          "stroke-linecap": "round",
          "stroke-width": "3"
        },
        key: 41
      }, [api_element("g", {
        key: 40
      }, [api_element("path", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "d": "M12.5,4 L12.5,50"
        },
        key: 36
      }, []), api_element("polyline", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "stroke-linejoin": "round",
          "points": "11 18.5 0.5 18.5 0.5 0"
        },
        key: 37
      }, []), api_element("polyline", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "stroke-linejoin": "round",
          "points": "14 25.5 24.5 25.5 24.5 8"
        },
        key: 38
      }, []), api_element("polyline", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "stroke-linejoin": "round",
          "points": "2.5 31 2.5 38.5 11 38.5"
        },
        key: 39
      }, [])])]), api_element("g", {
        attrs: {
          "transform": "translate(327.000000, 95.000000)"
        },
        key: 48
      }, [api_element("g", {
        key: 45
      }, [api_element("circle", {
        classMap: {
          "slds-illustration__fill-secondary": true
        },
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "cx": "64",
          "cy": "64",
          "r": "23"
        },
        key: 42
      }, []), api_element("circle", {
        classMap: {
          "slds-illustration__stroke-secondary": true
        },
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "stroke-width": "3",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-dasharray": "135,1,1,18",
          "transform": "translate(64.000000, 64.000000) rotate(230.000000) translate(-64.000000, -64.000000) ",
          "cx": "64",
          "cy": "64",
          "r": "45"
        },
        key: 43
      }, []), api_element("circle", {
        classMap: {
          "slds-illustration__stroke-secondary": true
        },
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "stroke-width": "3",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-dasharray": "107,10",
          "transform": "translate(64.000000, 64.000000) rotate(150.000000) translate(-64.000000, -64.000000) ",
          "cx": "64",
          "cy": "64",
          "r": "33"
        },
        key: 44
      }, [])]), api_element("g", {
        classMap: {
          "slds-illustration__stroke-primary": true
        },
        attrs: {
          "transform": "translate(41.000000, 41.000000)",
          "stroke-width": "3"
        },
        key: 47
      }, [api_element("circle", {
        attrs: {
          "vector-effect": "non-scaling-stroke",
          "cx": "23",
          "cy": "23",
          "r": "23"
        },
        key: 46
      }, [])])])])])])]), api_element("div", {
        classMap: {
          "slds-text-longform": true
        },
        key: 55
      }, [api_element("div", {
        classMap: {
          "slds-text-heading_medium": true
        },
        key: 53
      }, [api_dynamic($cmp.emptyState.text)]), api_element("div", {
        classMap: {
          "slds-text-heading_small": true
        },
        key: 54
      }, [api_dynamic($cmp.emptyState.subText)])])]) : null])];
    }

    var _tmpl$F = lwc.registerTemplate(tmpl$L);
    tmpl$L.stylesheets = [];
    tmpl$L.stylesheetTokens = {
      hostAttribute: "lightning-lookupMobileSelectionPanel_lookupMobileSelectionPanel-host",
      shadowAttribute: "lightning-lookupMobileSelectionPanel_lookupMobileSelectionPanel"
    };

    var emptyStateNoResultMRUText = 'No results yet...';

    var emptyStateNoResultMRUWithoutText = 'Try entering a search term.';

    var emptyStateNoResultText = 'No results for "{0}"';

    const EMPTY_TEXT = '';
    const LIGHTNING_MOBILE_COMBOBOX = 'lightning-mobile-grouped-combobox';
    const STENCIL_ARRAY_LENGTH = 5;
    const STENCIL_PLACEHOLDER_ID_PREFIX = 'mobile-lookup-item-placeholder-id';

    function tmpl$M($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        k: api_key,
        i: api_iterator
      } = $api;
      return api_iterator($cmp.stencilArray, function (stencilItem) {
        return api_element("div", {
          classMap: {
            "slds-p-around_x-small": true,
            "slds-grid": true
          },
          key: api_key(4, stencilItem.id)
        }, [api_element("div", {
          classMap: {
            "slds-p-left_x-small": true,
            "slds-col": true
          },
          key: 3
        }, [api_element("div", {
          classMap: {
            "slds-size--2-of-5": true,
            "slds-icon--xx-small": true,
            "slds-m-bottom_xx-small": true,
            "slds-filters__item": true,
            "slds-is-locked": true,
            "slds-progress-bar_circular": true,
            "slds-progress-bar--circular": true
          },
          key: 0
        }, []), api_element("div", {
          classMap: {
            "slds-size--4-of-5": true,
            "slds-icon--xx-small": true,
            "slds-m-bottom_xx-small": true,
            "slds-filters__item": true,
            "slds-is-locked": true,
            "slds-progress-bar_circular": true,
            "slds-progress-bar--circular": true
          },
          key: 1
        }, []), api_element("div", {
          classMap: {
            "slds-border_bottom": true
          },
          key: 2
        }, [])])]);
      });
    }

    var stencil = lwc.registerTemplate(tmpl$M);
    tmpl$M.stylesheets = [];
    tmpl$M.stylesheetTokens = {
      hostAttribute: "lightning-lookupMobileSelectionPanel_loadingStencil-host",
      shadowAttribute: "lightning-lookupMobileSelectionPanel_loadingStencil"
    };

    class LightningLookupMobileSelectionPanel extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.placeholder = void 0;
        this.showActivityIndicator = false;
        this.emptyState = {
          show: false,
          text: '',
          subText: ''
        };
        this.filterIconName = void 0;
        this.filterIconAlternativeText = void 0;
        this.inputText = '';
        this.stencilArray = [];
        this._filterItems = [];
        this._initialDataRequestComplete = false;
        this._items = [];
        this._lookupPerformanceLogger = new LookupPerformanceLogger();
      }

      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * The list of entities to filter on.
       * @type {Array}
       */
      get filterItems() {
        return this._filterItems;
      }

      set filterItems(filterOptions) {
        this._filterItems = filterOptions;

        if (filterOptions.length) {
          this.filterIconName = filterOptions[0].iconName;
          this.filterIconAlternativeText = filterOptions[0].iconAlternativeText;
        }
      }
      /**
       * The list of items to display in combobox.
       * @type {Array}
       */


      get items() {
        return this._items;
      }

      set items(groupedItems) {
        this._items = groupedItems;
        this._initialDataRequestComplete = true;

        this._focusCombobox();

        const {
          searchType,
          items
        } = this._getSearchTypeAndItems(groupedItems);

        if (searchType && items) {
          this._manageNoResultsEmptyState();

          this._lookupPerformanceLogger.startRenderMark();

          this._lookupPerformanceLogger.mergeTransactionAttributesWith({
            qResults: items.length,
            qType: searchType
          });
        }
      }
      /**
       * The placeholder text to show in the input
       */


      // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================
      connectedCallback() {
        this._lookupPerformanceLogger.mergeTransactionAttributesWith({
          isMobile: true
        });

        this._lookupPerformanceLogger.startTransaction();

        this._generatePlaceholderArray(); // request recent items when connected


        this._dispatchInputChangeEvent(EMPTY_TEXT);
      }

      render() {
        return this._initialDataRequestComplete ? _tmpl$F : stencil;
      }

      renderedCallback() {
        this._lookupPerformanceLogger.endRenderMark();

        this._lookupPerformanceLogger.endTransaction();
      } // ================================================================================
      // HANDLER METHODS
      // ================================================================================


      handleInputChange(event) {
        if (!event.detail) {
          return;
        }

        this._lookupPerformanceLogger.startTransaction();

        const text = event.detail.value || '';
        this.inputText = text;

        this._lookupPerformanceLogger.mergeTransactionAttributesWith({
          qLength: text ? text.length : 0
        }); // re-dispatch event to be listened to by the panel instance in lookupMobile


        this._dispatchInputChangeEvent(text);
      }

      handleSelect(event) {
        if (!event.detail) {
          return;
        }

        const value = event.detail && event.detail.value;

        this._logItemSelected(value); // re-dispatch event to be listened to by the panel instance in lookupMobile


        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value
          }
        }));
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================


      _dispatchInputChangeEvent(text) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            value: text
          }
        }));
      }

      _focusCombobox() {
        const combobox = this.template.querySelector(LIGHTNING_MOBILE_COMBOBOX);

        if (combobox) {
          combobox.focus();
        }
      }

      _computeEmptyState(items, searchType, advancedSearchActionPresent) {
        let emptyState = {
          show: false,
          subText: '',
          text: emptyStateNoResultText.replace('{0}', this.inputText)
        };

        if (items.length === 0) {
          emptyState.show = true;

          if (this._isTypeAhead(searchType) && advancedSearchActionPresent) {
            emptyState.show = false;
          } else if (this._isMRU(searchType)) {
            emptyState.subText = emptyStateNoResultMRUWithoutText;
            emptyState.text = emptyStateNoResultMRUText;
          }
        }

        return emptyState;
      }

      _manageNoResultsEmptyState() {
        const advancedSearchText = labelAdvancedSearchMobile.replace('{0}', this.inputText);
        const advancedSearchActionPresent = !!this.items.find(item => item.action && item.text === advancedSearchText);

        const {
          searchType,
          items
        } = this._getSearchTypeAndItems(this.items);

        if (searchType && items) {
          this.emptyState = this._computeEmptyState(items, searchType, advancedSearchActionPresent);
        }
      }

      _getSearchTypeAndItems(items) {
        const groupedRecords = items.find(item => !item.action);

        if (groupedRecords) {
          return {
            searchType: groupedRecords.searchType,
            items: groupedRecords.items
          };
        }

        return {};
      }

      _isMRU(searchType) {
        return searchType === GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_RECENT;
      }

      _isAdvancedSearch(searchType) {
        return searchType === GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_FULL;
      }

      _isTypeAhead(searchType) {
        return searchType === GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_TYPEAHEAD;
      }

      _logItemSelected(value) {
        if (value === COMMON_LOOKUP_CONSTANTS.ACTION_ADVANCED_SEARCH) {
          log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_MOBILE, LOGGING_CONSTANTS.LOG_TARGET_LOOKUP_ACTION_OPTION, {
            type: LOGGING_CONSTANTS.LOG_ACTION_SEARCH_OPTION
          });

          this._lookupPerformanceLogger.startTransaction();
        } else {
          const {
            searchType,
            items
          } = this._getSearchTypeAndItems(this.items);

          const itemCount = items.length;
          const position = items.findIndex(item => {
            return item.value === value;
          });
          log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_MOBILE, LOGGING_CONSTANTS.LOG_TARGET_LOOKUP_SUGGESTION_OPTION, {
            recordId: value,
            position,
            qLength: this.inputText.length,
            qType: searchType,
            qResults: itemCount
          });
        }
      }

      _generatePlaceholderArray() {
        this.stencilArray = [...Array(STENCIL_ARRAY_LENGTH)].map((_, index) => {
          return {
            id: `${STENCIL_PLACEHOLDER_ID_PREFIX}${index}`
          };
        });
      }

    }

    lwc.registerDecorators(LightningLookupMobileSelectionPanel, {
      publicProps: {
        filterItems: {
          config: 3
        },
        items: {
          config: 3
        },
        placeholder: {
          config: 0
        },
        showActivityIndicator: {
          config: 0
        }
      },
      fields: ["emptyState", "filterIconName", "filterIconAlternativeText", "inputText", "stencilArray", "_filterItems", "_initialDataRequestComplete", "_items", "_lookupPerformanceLogger"]
    });

    var LightningLookupMobileSelectionPanel$1 = lwc.registerComponent(LightningLookupMobileSelectionPanel, {
      tmpl: _tmpl$F
    });

    var labelSearchObjectsPlaceholder$1 = 'Search {0}';

    var labelPanelHeader = 'Relate {0} To';

    const i18n$q = {
      searchObjectsPlaceholder: labelSearchObjectsPlaceholder$1,
      panelHeader: labelPanelHeader
    };
    /**
     * Computes the header for the selection panel
     * @param {String} label Label for the source object
     * @returns {String} - Header for the selection panel
     */

    function computePanelHeader(label = '') {
      // Returns "Relate <label> to" for example - "Relate Account to"
      return `${i18n$q.panelHeader}`.replace('{0}', label);
    }
    /**
     * Prefixes 'Search' to placeholder text for lookup input.
     * @param {String} label Plural name of target api.
     * @returns {String} Placeholder text for lookup input.
     */


    function computePlaceholder(label = '') {
      return `${i18n$q.searchObjectsPlaceholder}`.replace('{0}', label);
    }

    const i18n$r = {
      required: labelRequired
    };

    class LightningLookupMobile extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */

      /**
       * Error message to be displayed under the lookup input.
       * @type {String}
       */
      get errorMessage() {
        return this._errorMessage;
      }

      set errorMessage(value) {
        this._errorMessage = value;
        this.synchronizeA11y();
      }
      /**
       * The list of entity options to scope by.
       */


      /**
       * The field level help text.
       * @type {String}
       */
      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
        this.synchronizeA11y();
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (!this._connected) {
          return;
        }

        this.renderedElement.focus();
      }
      /**
       * The text label for the layout field.
       * @type {String}
       */


      /**
       * The list of items to be displayed
       * @type {Array}
       */
      get items() {
        return this._items;
      }

      set items(value) {
        this._items = value;

        if (this._lookupSelectionPanel) {
          this._lookupSelectionPanel.items = value;
          this._lookupSelectionPanel.showActivityIndicator = false;
        }
      }
      /**
       * The array of selected values pill representation.
       * @type {Array}
       */


      /**
       * Text and label details needed to compute labels, placeholder etc.
       */
      get textInfo() {
        return this._textInfo;
      }

      set textInfo(textInfo) {
        this._textInfo = textInfo;

        if (this._lookupSelectionPanel) {
          this._lookupSelectionPanel.placeholder = computePlaceholder(textInfo.targetEntityLabelPlural);
        }
      }
      /**
       * Sets the variant type for the lookup.
       * @type {String}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Computes css classes to handle different label varients.
       * @return {String} String of css classes to be set on the label element.
       */
      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');
        classnames.add('slds-no-flex');
        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).add({
          'slds-form-element_stacked': this.isLabelStacked
        }).add({
          'slds-form-element_horizontal': this.isLabelInline
        }).toString();
      }
      /**
       * Computes css classes to handle different label varients for fieldLevelHelp.
       * @return {String} String of css classes to be set on lightning-helptext element.
       */


      get computedFieldLevelHelpClass() {
        const classnames = classSet('lookup-mobile-field-level-help');
        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        if (this.errorMessage) {
          ariaValues.push(this.computedUniqueHelpElementId);
        }

        if (this.fieldLevelHelp) {
          ariaValues.push(this.computedUniqueFieldLevelHelpElementId);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedUniqueHelpElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get computedUniqueFieldLevelHelpElementId() {
        return getRealDOMId(this.template.querySelector('.lookup-mobile-field-level-help'));
      }
      /**
       * @return {boolean} Indicates if the lookup has a pill selected.
       */


      get hasPills() {
        return this.pills && this.pills.length > 0;
      }

      get isLabelHidden() {
        return this.variant === LABEL_HIDDEN;
      }

      get isLabelInline() {
        return this.variant === LABEL_INLINE;
      }

      get isLabelStacked() {
        return this.variant === LABEL_STACKED;
      }

      get renderedElement() {
        if (!this._connected) {
          return null;
        }

        let element;

        if (this.hasPills) {
          element = this.template.querySelector(LIGHTNING_PILL_CONTAINER);
        } else {
          element = this.template.querySelector(LIGHTNING_LOOKUP_MOBILE_FAUX_INPUT);
        }

        return element;
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.filterItems = void 0;
        this.label = void 0;
        this.pills = [];
        this.required = void 0;
        this.variant = void 0;
        this.inputValue = void 0;
        this.requiredLabel = i18n$r.required;
        this._connected = false;
        this._errorMessage = void 0;
        this._fieldLevelHelp = void 0;
        this._items = void 0;
        this._lookupSelectionPanel = void 0;
        this._queueFocus = false;
        this._textInfo = void 0;
        this._value = void 0;
        this._events = new LookupEventDispatcher(this);
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }

      renderedCallback() {
        this.synchronizeA11y();

        if (this._queueFocus) {
          this.focus();
          this._queueFocus = false;
        }
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================


      dispatchLookupRecordsRequest(key, value) {
        this._lookupSelectionPanel.showActivityIndicator = true;

        this._events.dispatchLookupRecordsRequestEvent({
          [key]: value
        });
      }
      /**
       * fires reportvalidity event when focus is removed from grouped combobox.
       */


      handleBlur() {
        this.dispatchEvent(new CustomEvent('reportvalidity'));
      }

      handlePillRemove(event) {
        // [Temporary] - W-7351876 - Prevent pill remove when disabled.
        // TODO: Use a proper disabled state for pill container when available.
        if (this.disabled) {
          return;
        }

        if (event && event.detail) {
          const removedValue = (event.detail.item || {}).value;
          log(LOGGING_CONSTANTS.LOG_EVENT_PILL_REMOVE, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_MOBILE, LOGGING_CONSTANTS.LOG_TARGET_RECORD_PILL_ITEM);

          if (!removedValue) {
            return;
          }

          this._events.dispatchPillRemoveEvent(removedValue);

          this._queueFocus = true;
        }
      }

      handleItemSelect(recordId) {
        if (!recordId) {
          return;
        }

        this._events.dispatchRecordItemSelectEvent(recordId); // Close the panel


        if (this._lookupSelectionPanel) {
          aura.dispatchGlobalEvent('markup://force:hidePanel');
        }
      }

      showPanel() {
        log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_MOBILE, LOGGING_CONSTANTS.LOG_TARGET_INPUT); // eslint-disable-next-line no-unused-vars
        this.createPanel();
        showCustomOverlay$1({
          body: this._lookupSelectionPanel,
          isScrollable: false,
          panelType: 'mobileOverlay',
          showCloseButton: true,
          title: computePanelHeader(this._textInfo.sourceEntityLabel)
        }).then(overlay => {
        });
      }

      createPanel() {
        this._lookupSelectionPanel = lwc.createElement('lightning-lookup-mobile-selection-panel', {
          is: LightningLookupMobileSelectionPanel$1
        });
        Object.assign(this._lookupSelectionPanel, {
          filterItems: this.filterItems,
          placeholder: computePlaceholder(this._textInfo.targetEntityLabelPlural)
        });
        const lookupMobile = this; // listen to the inputchange event fired by lookupMobileSelectionPanel

        this._lookupSelectionPanel.addEventListener('textinput', event => {
          const value = event.detail && event.detail.value;
          lookupMobile.dispatchLookupRecordsRequest(GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_Q, value);
        }); // listen to the select event fired by lookupMobileSelectionPanel


        this._lookupSelectionPanel.addEventListener('select', event => {
          const value = event.detail && event.detail.value;

          if (value === COMMON_LOOKUP_CONSTANTS.ACTION_ADVANCED_SEARCH) {
            lookupMobile.dispatchLookupRecordsRequest(GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_SEARCH_TYPE, GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_FULL);
          } else {
            lookupMobile.handleItemSelect(value);
          }
        });
      }

      synchronizeA11y() {
        let element;

        if (this.disabled && this.hasPills) {
          element = this.template.querySelector('input');
        } else {
          element = this.template.querySelector(LIGHTNING_PILL_CONTAINER);
        }

        if (element) {
          element.setAttribute([COMMON_LOOKUP_CONSTANTS.ARIA_DESCRIBEDBY], this.computedAriaDescribedBy);
        }
      }

    }

    lwc.registerDecorators(LightningLookupMobile, {
      publicProps: {
        disabled: {
          config: 0
        },
        errorMessage: {
          config: 3
        },
        filterItems: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        label: {
          config: 0
        },
        items: {
          config: 3
        },
        pills: {
          config: 0
        },
        required: {
          config: 0
        },
        textInfo: {
          config: 3
        },
        variant: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        inputValue: 1,
        requiredLabel: 1
      },
      fields: ["_connected", "_errorMessage", "_fieldLevelHelp", "_items", "_lookupSelectionPanel", "_queueFocus", "_textInfo", "_value"]
    });

    var _lightningLookupMobile = lwc.registerComponent(LightningLookupMobile, {
      tmpl: _tmpl$D
    });

    function tmpl$N($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8
      } = $ctx;
      return [$cmp.isDesktop ? api_custom_element("lightning-lookup-desktop", _lightningLookupDesktop, {
        props: {
          "disabled": $cmp.disabled,
          "enableCreateNew": $cmp._isCreateNewEnabled,
          "fieldName": $cmp.fieldName,
          "items": $cmp.items,
          "label": $cmp.label,
          "maxValues": $cmp.maxValues,
          "objectInfos": $cmp._objectInfos,
          "pills": $cmp.internalPills,
          "textInfo": $cmp.textInfo,
          "record": $cmp._record,
          "required": $cmp.required,
          "variant": $cmp.variant
        },
        key: 0,
        on: {
          "entityfilterselect": _m0 || ($ctx._m0 = api_bind($cmp.handleEntityFilterSelect)),
          "lookuprecordsrequest": _m1 || ($ctx._m1 = api_bind($cmp.handleLookupRecordsRequest)),
          "pillremove": _m2 || ($ctx._m2 = api_bind($cmp.handlePillRemove)),
          "recorditemselect": _m3 || ($ctx._m3 = api_bind($cmp.handleRecordItemSelect)),
          "reportvalidity": _m4 || ($ctx._m4 = api_bind($cmp.handleReportValidity))
        }
      }, []) : null, !$cmp.isDesktop ? api_custom_element("lightning-lookup-mobile", _lightningLookupMobile, {
        props: {
          "disabled": $cmp.disabled,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "filterItems": $cmp.filterItems,
          "items": $cmp.items,
          "label": $cmp.label,
          "pills": $cmp.internalPills,
          "textInfo": $cmp.textInfo,
          "required": $cmp.required,
          "variant": $cmp.variant
        },
        key: 1,
        on: {
          "lookuprecordsrequest": _m5 || ($ctx._m5 = api_bind($cmp.handleLookupRecordsRequest)),
          "pillremove": _m6 || ($ctx._m6 = api_bind($cmp.handlePillRemove)),
          "recorditemselect": _m7 || ($ctx._m7 = api_bind($cmp.handleRecordItemSelect)),
          "reportvalidity": _m8 || ($ctx._m8 = api_bind($cmp.handleReportValidity))
        }
      }, []) : null];
    }

    var _tmpl$G = lwc.registerTemplate(tmpl$N);
    tmpl$N.stylesheets = [];

    if (_implicitStylesheets$e) {
      tmpl$N.stylesheets.push.apply(tmpl$N.stylesheets, _implicitStylesheets$e);
    }
    tmpl$N.stylesheetTokens = {
      hostAttribute: "lightning-lookup_lookup-host",
      shadowAttribute: "lightning-lookup_lookup"
    };

    var labelNone$1 = 'None';

    /**
     * Default for maximum number of lookup values
     */
    const DEFAULT_MAX_VALUES = 1;
    /**
     * The desktop form factor.
     * @type {String}
     */

    const FORM_FACTOR_DESKTOP = 'Large';
    /**
     * The query selector used for the desktop implementation of lookups.
     * @type {String}
     */

    const LIGHTNING_LOOKUP_DESKTOP = 'lightning-lookup-desktop';
    /**
     * The query selector used for the mobile implementation of lookups.
     * @type {String}
     */

    const LIGHTNING_LOOKUP_MOBILE = 'lightning-lookup-mobile';

    function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$a(target, key, source[key]); }); } return target; }

    function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const i18n$s = {
      messageWhenBadInputDefault: labelMessageWhenBadInputDefault,
      none: labelNone$1
    };

    class LightningLookup extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Checks the lookup validity, and fires an 'invalid' event if it's in invalid state.
       * @return {Boolean} - The validity status of the lookup.
       */
      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * @return {Boolean} - Indicates whether the field is disabled.
       */


      get disabled() {
        return this._disabled;
      }
      /**
       * Sets whether the field is disabled.
       * @param {Boolean} value - A flag to mark the field as disabled.
       */


      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * @return {String} in case of external lookup relationship,
       * returns the local org Id of the referenced entity.
       * Undefined otherwise
       */


      get externalObjectValue() {
        return this._externalObjectValue;
      }
      /**
       * Use in case of External Lookup Rela tionship only
       * @param {String} value - the local org Id of the referenced entity
       */


      set externalObjectValue(value) {
        this._externalObjectValue = value;
        this.updatePills([], false);
      }
      /**
       * @return {String} - The field name.
       */


      get fieldName() {
        return this._fieldName;
      }
      /**
       * Sets the field name.
       * @param {String|FieldId} value - The qualified field name.
       */


      set fieldName(value) {
        this._fieldName = value;
        this.updateMetadata();
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (!this._connected) {
          return;
        }

        if (this._lookupElement) {
          this._lookupElement.focus();
        }
      }
      /**
       * The text label for the field.
       */


      /**
       * @return {String} - The error message to be displayed when the user enters the text in
       * the input but does not select a valid option.
       */
      get messageWhenBadInput() {
        return this._messageWhenBadInput || i18n$s.messageWhenBadInputDefault;
      }
      /**
       * Sets the error message to be displayed when the user enters the text in the input
       * but does not select a valid option.
       * @param {String} value - The error message.
       */


      set messageWhenBadInput(value) {
        this._messageWhenBadInput = value;
      }
      /**
       * The error message to be displayed when the lookup value
       * is required but is currently missing.
       * @type {String}
       */


      /**
       * @return {Object} - The source record's objectInfos.
       */
      get objectInfos() {
        return this._objectInfos;
      }
      /**
       * Sets the source record's objectInfos.
       * @param {Object} value - The source record's objectInfos.
       */


      set objectInfos(value) {
        this._objectInfos = value;
        this.updateMetadata();
      }
      /**
       * @return {Object} - The source record representation.
       */


      get record() {
        return this._record;
      }
      /**
       * Sets the source record representation.
       * @param {Object} value - The source record.
       */


      set record(value) {
        this._record = value;
        this.updateMetadata();
      }
      /**
       * The field info in the object info is not updated based on the layout metadata.
       * It allows field to be marked as required for the given layout.
       * @return {Boolean} - Indicates whether or not the field is required.
       */


      get required() {
        return this._required;
      }
      /**
       * Sets the flag to mark the field as required.
       * @param {Boolean} value - A flag to mark the field as required.
       */


      set required(value) {
        this._required = normalizeBoolean(value);
        this.updateMetadata();
      }
      /**
       * Shows validation message based on the validity status.
       * @return {Boolean} - The validity status of the lookup.
       */


      reportValidity() {
        const element = this._lookupElement;

        if (element) {
          return this._constraint.reportValidity(message => {
            element.errorMessage = message;
          });
        }

        return false;
      }
      /**
       * Sets a custom validity message.
       * @param {String} message - The validation message to be shown in an error state.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);

        if (this._lookupElement) {
          this._lookupElement.errorMessage = message;
        }
      }
      /**
       * @return {Boolean} - Indicates whether the advanced search option is enabled.
       * this setter is needed to avoid disabling lwc/valid-api eslint error
       */


      get showAdvancedSearch() {
        return this._showAdvancedSearch;
      }

      set showAdvancedSearch(value) {
        this._showAdvancedSearch = value;
        this.updateMetadata();
      }
      /**
       * @return {Boolean} - Indicates whether or not to show the create new option.
       */


      /**
       * Displays a validation message if the lookup is in invalid state.
       */
      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * @return {Array} - An array of selected lookup values.
       */


      get value() {
        return this.internalValue;
      }
      /**
       * Sets the values for the lookup.
       * @param {Array} value - An array of record ids.
       */


      set value(value) {
        if (!arraysIdentical(this.internalValue, value)) {
          this.updateValue(value, false);
          this.updatePills([], false);
        }
      }
      /**
       * @return {String} - The value of variant.
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }
      /**
       * Sets the variant type for the lookup.
       * @param {String} value - The value of variant.
       */


      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      } // ================================================================================
      // REACTIVE PROPERTIES
      // ================================================================================

      /**
       * The field level help text.
       * @type {String}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Gets the validity constaint.
       */
      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => this._required && (!Array.isArray(this.internalValue) || !this.internalValue.length),
            badInput: () => {
              return this._lookupElement.inputText ? this._lookupElement.inputText.trim().length : false;
            }
          });
        }

        return this._constraintApi;
      }
      /**
       * Indicates whether or not the component is loaded on the desktop form factor.
       * @return {Boolean} - See desc.
       */


      get isDesktop() {
        return this._isDesktop;
      }
      /**
       * Indicates if the lookup is single value.
       * @return {Boolean} - true if maxValues is 1.
       */


      get _isSingleValue() {
        return this.maxValues === 1;
      }

      get _isMRU() {
        return this._searchType === GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_RECENT;
      }
      /**
       * Returns the lookup DOM element.
       * @returns {Object} - See desc.
       */


      get lookupElement() {
        if (!this._connected) {
          return null;
        }

        if (this._lookupElement) {
          return this._lookupElement;
        }

        return null;
      }

      get _searchTerm() {
        return this._requestParams[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_Q];
      }

      get _searchType() {
        return this._requestParams[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_SEARCH_TYPE];
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.label = i18n$s.none;
        this.maxValues = DEFAULT_MAX_VALUES;
        this.messageWhenValueMissing = void 0;
        this.showCreateNew = false;
        this.fieldLevelHelp = void 0;
        this.filterItems = void 0;
        this.internalPills = [];
        this.internalValue = void 0;
        this.items = [];
        this.textInfo = void 0;
        this._actionObjectApiNames = void 0;
        this._apiNamesWithCreateNewEnabled = [];
        this._connected = false;
        this._disabled = false;
        this._externalObjectValue = void 0;
        this._fieldApiName = void 0;
        this._fieldName = void 0;
        this._getLookupActionsInProgress = void 0;
        this._isCreateNewEnabled = false;
        this._isDesktop = void 0;
        this._initProps = false;
        this._label = i18n$s.none;
        this._lookupElement = void 0;
        this._metadataManager = void 0;
        this._messageWhenBadInput = void 0;
        this._objectInfos = void 0;
        this._optionalFields = void 0;
        this._record = void 0;
        this._recordIds = void 0;
        this._required = false;
        this._selectedEntityApiName = void 0;
        this._showAdvancedSearch = true;
        this._variant = VARIANT.STANDARD;
        this._targetApiName = void 0;
        this._requestParams = {
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_Q]: '',
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_SEARCH_TYPE]: GET_LOOKUP_RECORDS_WIRE_CONSTANTS.SEARCH_TYPE_RECENT,
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_PAGE]: GET_LOOKUP_RECORDS_WIRE_CONSTANTS.DEFAULT_PAGE,
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_PAGE_SIZE]: GET_LOOKUP_RECORDS_WIRE_CONSTANTS.DEFAULT_PAGE_SIZE,
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS]: null
        };
        this._wireItems = [];
        this._isDesktop = formFactor === FORM_FACTOR_DESKTOP;
        this._events = new LookupEventDispatcher(this);
        this._metadataManager = new MetadataManager();
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      disconnectedCallback() {
        this._connected = false;
        this._initProps = false;
        this._lookupElement = undefined;
      }

      renderedCallback() {
        if (!this._lookupElement) {
          const lookupSelector = this._isDesktop ? LIGHTNING_LOOKUP_DESKTOP : LIGHTNING_LOOKUP_MOBILE;
          this._lookupElement = this.template.querySelector(lookupSelector);
        }

        if (!this._initProps) {
          this.updateMetadata();
          this._initProps = true;
        }
      } // ================================================================================
      // WIRE METHODS
      // ================================================================================


      wiredLookupActions({
        error,
        data
      }) {
        this._getLookupActionsInProgress = false;

        if (error) {
          this._events.dispatchErrorEventFromLds(error);

          return;
        } else if (!data) {
          return;
        }

        try {
          this._apiNamesWithCreateNewEnabled = Object.keys(data.actions || {}).filter(apiName => hasCreateFromLookup(data.actions[apiName].actions));
          this._isCreateNewEnabled = this.isCreateNewEnabled();
        } catch (e) {
          this._events.dispatchErrorEvent(e);
        }
      }

      wiredLookupRecords({
        error,
        data
      }) {
        if (error) {
          this._events.dispatchErrorEventFromLds(error);

          this.items = [];
          return;
        } else if (!data) {
          return;
        }

        try {
          const records = data.records || [];
          this._wireItems = mapLookupWireRecords(records, this._metadataManager.getReferencedApiNameFieldFromTargetApi(), this._metadataManager.getTargetObjectIconDetails(), COMMON_LOOKUP_CONSTANTS.OPTION_TYPE_CARD); // FIXME : Remove this hack

          if (this._getLookupActionsInProgress) {
            let counter = 0;

            const delayedUpdateItems = () => {
              if (this._getLookupActionsInProgress && counter < 100) {
                counter++;
                setTimeout(delayedUpdateItems, 100); // eslint-disable-line @lwc/lwc/no-async-operation
              } else {
                this.items = this.getDisplayItems(this._wireItems);
              }
            };

            setTimeout(delayedUpdateItems, 100); // eslint-disable-line @lwc/lwc/no-async-operation
          } else {
            // Update display items.
            this.items = this.getDisplayItems(this._wireItems);
          }
        } catch (e) {
          this._events.dispatchErrorEvent(e);
        }
      }

      wiredRecordUi({
        error,
        data
      }) {
        if (error) {
          this._events.dispatchErrorEventFromLds(error);

          return;
        } else if (!(data && data.records)) {
          return;
        }

        try {
          const records = Object.values(data.records).map(record => _objectSpread$a({}, record, {
            referencedApiNameField: this._metadataManager.getReferencedApiNameField(record.apiName)
          }));
          const {
            pills,
            invalidValues
          } = mapRecordUiWireRecords(records, this._objectInfos);

          if (invalidValues.length > 0 && this.internalValue) {
            // Remove invalid values from this.internalValues
            const values = this.internalValue.filter(value => !invalidValues.includes(value));
            this.updateValue(values, false);
          }

          this.updatePills(pills);
        } catch (e) {
          this._events.dispatchErrorEvent(e);
        }
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /*
       * Returns the items to be displayed in the combobox
       * @param {Array} wireRecords - the records returned from the wire service
       * @returns {Array<groupedDisplayItems>} displayItems - A grouped set of items to display
       * @returns {String} groupedDisplayItems.label - the label for the grouped set
       * @returns {Array} groupedDisplayItems.items - the list of options for the grouped set
       */


      getDisplayItems(wireRecords) {
        // filter
        let items = difference$1(wireRecords, ...(this.internalValue || [])).slice(0, computeListSize(this._searchType, this.isDesktop));

        if (this._searchTerm.length > 0) {
          items = computeHighlightedItems(items, this._searchTerm);
        }

        items = [{
          label: this._computeLabel(items),
          items,
          searchType: this._searchType
        }];
        this.setAdvancedSearchOption(items);
        return items;
      }
      /**
       * Handler for entityfilterselect event
       * @param {Event} event - custom event containing the targetApiName
       */


      handleEntityFilterSelect(event) {
        const newTargetApiName = event && event.detail && event.detail.value;
        this._selectedEntityApiName = newTargetApiName;
        this.updateMetadata();
      }
      /**
       * Shows validation message based on the validity status on blur of the input.
       */


      handleReportValidity() {
        this.reportValidity();
      }
      /**
       * Handler for lookuprecordsrequest event fired from child component.
       * @param {Event} event - custom event object with request parameters
       */


      handleLookupRecordsRequest(event) {
        const requestParams = event.detail.requestParams;
        const queryString = computeQueryString(requestParams[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_Q], this._searchTerm);
        const searchType = requestParams[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_SEARCH_TYPE] || computeSearchType(requestParams); // update the request params

        this._requestParams = _objectSpread$a({}, this._requestParams, {
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_Q]: queryString,
          [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_SEARCH_TYPE]: searchType
        }); // Trigger wire.

        this._triggerGetLookupRecordsWire();

        if (this.showCreateNew) {
          this._getLookupActionsInProgress = true;
          this._actionObjectApiNames = Object.keys(this._metadataManager.referenceInfos);
        }
      }
      /**
       * Handler for pillremove event fired from child component.
       * @param {Object} event - custom event object with removed pill value.
       */


      handlePillRemove(event) {
        if (!event || !event.detail) {
          return;
        }

        const removedValue = event.detail.removedValue;

        if (this._isSingleValue) {
          // Set empty value and pills array.
          this.updateValue([]);
          this.updatePills([]);
        } else {
          if (removedValue && this.internalValue && this.internalPills) {
            // Remove deleted value.
            const values = this.internalValue.filter(v => v !== removedValue); // Remove pill for the removed value.

            const pills = this.internalPills.filter(p => p.value !== removedValue); // Update values, and pills.

            this.updateValue(values);
            this.updatePills(pills);
          }
        }
      }
      /**
       * Handler for recorditemselect event fired from child component.
       * @param {Object} event - custom event object with selected recordId value.
       */


      handleRecordItemSelect(event) {
        if (!event || !event.detail) {
          return;
        } // No-op if maxValues count is reached.


        if (Array.isArray(this.internalValue) && this.internalValue.length === this.maxValues) {
          return;
        }

        const newPill = this._createPillForSelectedValue(event.detail.selectedValue);

        this._logItemSelected(newPill.value);

        let pills;

        if (this._isPillAbsentFromCurrentSelection(newPill)) {
          if (this._isSingleValue) {
            this.updateValue([newPill.value]);
            pills = [];
            this._externalObjectValue = newPill.externalObjectValue;
          } else {
            // Append new value to the existing list.
            const values = [...(this.internalValue || []), newPill.value];
            this.updateValue(values);
            pills = [...this.internalPills];
          }

          if (this._isPillResolved(newPill)) {
            pills.push(newPill);
          }

          this.updatePills(pills);
        } // Compute validity


        this.reportValidity();
      }

      isCreateNewEnabled() {
        return this.showCreateNew && this._apiNamesWithCreateNewEnabled.includes(this._metadataManager.targetApiName);
      }

      setAdvancedSearchOption(items) {
        if (this.showAdvancedSearch && isValidSearchTerm(this._searchTerm) && !isFullSearch(this._searchType)) {
          items.unshift(computeAdvancedSearchOption(this.isDesktop, this._searchTerm));
        }
      }
      /**
       * Updates classList based on the variant.
       */


      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this._variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this._variant === VARIANT.LABEL_INLINE
        });
      }

      updateMetadata() {
        if (!this._fieldName || !Object.keys(this._record || {}).length || !Object.keys(this._objectInfos || {}).length) {
          return;
        }

        this._metadataManager = new MetadataManager(this._fieldName, this._objectInfos, this._record, this._selectedEntityApiName);
        this.filterItems = [this._metadataManager.getTargetObjectIconDetails()];
        this.textInfo = this._metadataManager.getEntitiesLabelInfo(); // Update values.

        if (this.internalValue === undefined) {
          const values = computeRecordValues(this._record, this._metadataManager.fieldApiName); // Don't fire change event since default values is assigned from the record.

          this.updateValue(values, false);
          this.updatePills([]);
        } // Update fieldLevelHelp and required


        this.fieldLevelHelp = this._metadataManager.fieldLevelHelp;
        this._required = this._metadataManager.isFieldRequired || this._required;
        this._requestParams[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS] = this._metadataManager.getBindingsString(this._record);
        this._requestParams[GET_LOOKUP_RECORDS_WIRE_CONSTANTS.QUERY_PARAMS_SOURCE_RECORD_ID] = this._record && this._record.id;
      }
      /**
       * Updates the pill using info it obtained via argument, local data or wire.
       * @param {Array} pills - An array of pills infos representing values.
       */


      updatePills(pills = []) {
        // Check if any pills are missing, if so then trigger @wire(getRecordUi) to resolve them.
        const pillValues = pills.map(pill => {
          return pill.value;
        });
        let pillsResolved = arraysIdentical(pillValues, this.internalValue);

        if (!pillsResolved) {
          try {
            // Try to resolve pill from the source record itself to avoid hitting wire.
            const values = computeRecordValues(this._record, this._metadataManager.fieldApiName);

            if (arraysIdentical(values, this.internalValue)) {
              pills = computeRecordPills(this._record, this._metadataManager.fieldInfo, this._metadataManager.referenceInfos, this._externalObjectValue);

              if (pills.length) {
                pillsResolved = true;
              }
            }
          } catch (error) {
            this._events.dispatchErrorEvent(error);
          }
        }

        if (pillsResolved) {
          if (pills && pills.length) {
            this.internalPills = this._isSingleValue ? pills.splice(0, 1) : pills;
          } else {
            this.internalPills = [];
          }

          return;
        }

        if (!pillsResolved && this.internalValue.length) {
          // Trigger wire to get record representations of live values, and update pills.
          if (isApiExternal(this._metadataManager.targetApiName)) {
            if (this._externalObjectValue) {
              this._optionalFields = [...this._metadataManager.optionalNameFields, this._metadataManager.targetApiName + '.ExternalId'];
              this._recordIds = [this._externalObjectValue];
            }
          } else {
            this._optionalFields = this._metadataManager.optionalNameFields;
            this._recordIds = this.internalValue.slice();
          }
        }
      }
      /**
       * Updates the lookup value.
       * @param {Array} value - An array of record ids.
       */


      updateValue(value = [], triggerEvent = true) {
        if (value === null) {
          value = [];
        }

        if (!Array.isArray(value)) {
          return;
        }

        value = (value || []).filter(val => val) // Drop empty.
        .map(val => normalizeRecordId(val.trim())) // Convert to 18-char record ids.
        .filter((elem, index, self) => {
          return index === self.indexOf(elem); // De-deupe.
        }); // No-op if values remain unchanged.

        if (arraysIdentical(value, this.internalValue)) {
          return;
        } // Trim values as per the max count.


        if (value.length > this.maxValues) {
          value = value.slice(0, this.maxValues);
        } // Update internal copy of values.


        this.internalValue = value;

        if (triggerEvent) {
          // Fire an event to notify that values have been changed.
          this._events.dispatchChangeEvent(this.internalValue);
        }

        if (!this.internalValue.length) {
          this._externalObjectValue = undefined;
        }
      }

      _computeLabel(items) {
        if (items.length === 0) {
          return '';
        }

        return this.isDesktop ? computeHeadingDesktop(this._metadataManager.targetPluralLabel, this._searchType) : computeHeadingMobile(this._searchTerm, this._searchType);
      }

      _createPillForSelectedValue(selectedValue) {
        if (typeof selectedValue === 'string') {
          // Selected recordId is always expected to be present in the wireItems for TA or MRU.
          // Use it to populate pill info so as to avoid triggering wire.
          return this._createPillFromWireItems(selectedValue);
        } else if (typeof selectedValue === 'object') {
          //otherwise, for advanced search, we need to get info from metadata and record
          return this._createPillFromSelectedValue(selectedValue);
        }

        return undefined;
      }

      _createPillFromSelectedValue(selectedValue) {
        return _objectSpread$a({}, this._metadataManager.getTargetObjectIconDetails(), {
          iconSize: COMMON_LOOKUP_CONSTANTS.ICON_SIZE_SMALL,
          label: selectedValue.Name || selectedValue.label,
          type: COMMON_LOOKUP_CONSTANTS.PILL_TYPE_ICON,
          value: selectedValue.allFields && selectedValue.allFields.ExternalId || selectedValue.id,
          externalObjectValue: selectedValue.allFields && selectedValue.allFields.ExternalId ? selectedValue.id : undefined
        });
      }

      _createPillFromWireItems(selectedValue) {
        const wireItem = this._wireItems.find(record => record.value === selectedValue);

        if (wireItem) {
          return {
            iconAlternativeText: wireItem.iconAlternativeText,
            iconName: wireItem.iconName,
            iconSize: wireItem.iconSize,
            label: wireItem.text,
            type: COMMON_LOOKUP_CONSTANTS.PILL_TYPE_ICON,
            value: wireItem.value,
            externalObjectValue: wireItem.externalObjectValue
          };
        }

        return {
          value: selectedValue
        };
      }

      _isPillAbsentFromCurrentSelection(newPill) {
        return !Array.isArray(this.internalValue) || !this.internalValue.includes(newPill.value);
      }

      _isPillResolved(pill) {
        return pill && pill.label && pill.iconName;
      }

      _logItemSelected(recordId) {
        // FIXME: Item position is wrong for MRU because of grouping
        const itemCount = this.items.length;
        const position = this.items.findIndex(item => {
          return item.value === recordId;
        });
        log(LOGGING_CONSTANTS.LOG_EVENT_CLICK, LOGGING_CONSTANTS.LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOGGING_CONSTANTS.LOG_TARGET_LOOKUP_SUGGESTION_OPTION, {
          recordId,
          position,
          qType: this._isMRU ? GET_LOOKUP_RECORDS_WIRE_CONSTANTS.LOG_CONTEXT_Q_TYPE_MRU : GET_LOOKUP_RECORDS_WIRE_CONSTANTS.LOG_CONTEXT_Q_TYPE_TYPEAHEAD,
          mruVisibleCount: this._isMRU ? itemCount : 0,
          typeAheadVisibleCount: this._isMRU ? 0 : itemCount,
          scopeName: this._metadataManager.targetApiName
        });
      }

      _triggerGetLookupRecordsWire() {
        this._fieldApiName = this._metadataManager.fieldApiName;
        this._targetApiName = this._metadataManager.targetApiName;
      }

    }

    lwc.registerDecorators(LightningLookup, {
      publicProps: {
        disabled: {
          config: 3
        },
        externalObjectValue: {
          config: 3
        },
        fieldName: {
          config: 3
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenValueMissing: {
          config: 0
        },
        objectInfos: {
          config: 3
        },
        record: {
          config: 3
        },
        required: {
          config: 3
        },
        showAdvancedSearch: {
          config: 3
        },
        showCreateNew: {
          config: 0
        },
        validity: {
          config: 1
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "focus", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      wire: {
        wiredLookupActions: {
          adapter: getLookupActions$2,
          params: {
            objectApiNames: "_actionObjectApiNames"
          },
          static: {},
          method: 1
        },
        wiredLookupRecords: {
          adapter: getLookupRecords$1,
          params: {
            fieldApiName: "_fieldApiName",
            requestParams: "_requestParams",
            targetApiName: "_targetApiName"
          },
          static: {},
          method: 1
        },
        wiredRecordUi: {
          adapter: getRecordUi$2,
          params: {
            optionalFields: "_optionalFields",
            recordIds: "_recordIds"
          },
          static: {
            layoutTypes: [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.LAYOUT_TYPE_FULL],
            modes: [GET_LOOKUP_RECORDS_WIRE_CONSTANTS.MODE_VIEW]
          },
          method: 1
        }
      },
      track: {
        fieldLevelHelp: 1,
        filterItems: 1,
        internalPills: 1,
        internalValue: 1,
        items: 1,
        textInfo: 1
      },
      fields: ["_actionObjectApiNames", "_apiNamesWithCreateNewEnabled", "_connected", "_disabled", "_externalObjectValue", "_fieldApiName", "_fieldName", "_getLookupActionsInProgress", "_isCreateNewEnabled", "_isDesktop", "_initProps", "_label", "_lookupElement", "_metadataManager", "_messageWhenBadInput", "_objectInfos", "_optionalFields", "_record", "_recordIds", "_required", "_selectedEntityApiName", "_showAdvancedSearch", "_variant", "_targetApiName", "_requestParams", "_wireItems"]
    });

    var _lightningLookup = lwc.registerComponent(LightningLookup, {
      tmpl: _tmpl$G
    });

    function stylesheet$i(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$i = [stylesheet$i];

    function tmpl$O($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 9
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 0
      }, [api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 1
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__row": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-size_1-of-2": true
        },
        key: 3
      }, [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-latitude": true
        },
        props: {
          "label": $cmp.i18n.latitude,
          "name": "latitude",
          "value": $cmp.latitude,
          "required": $cmp.required,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "messageWhenBadInput": $cmp.i18n.invalidLatitude,
          "messageWhenValueMissing": $cmp.i18n.coordinateIsRequired
        },
        key: 2,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleLatitudeChange)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleLatitudeBlur))
        }
      }, [])]), api_element("div", {
        classMap: {
          "slds-size_1-of-2": true
        },
        key: 5
      }, [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-longitude": true
        },
        props: {
          "label": $cmp.i18n.longitude,
          "name": "longitude",
          "value": $cmp.longitude,
          "required": $cmp.required,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "messageWhenBadInput": $cmp.i18n.invalidLongitude,
          "messageWhenValueMissing": $cmp.i18n.coordinateIsRequired
        },
        key: 4,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleLongitudeChange)),
          "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleLongitudeBlur))
        }
      }, [])])])])])])];
    }

    var _tmpl$H = lwc.registerTemplate(tmpl$O);
    tmpl$O.stylesheets = [];

    if (_implicitStylesheets$i) {
      tmpl$O.stylesheets.push.apply(tmpl$O.stylesheets, _implicitStylesheets$i);
    }
    tmpl$O.stylesheetTokens = {
      hostAttribute: "lightning-inputLocation_inputLocation-host",
      shadowAttribute: "lightning-inputLocation_inputLocation"
    };

    var labelCoordinateIsRequired = 'Coordinate is required';

    var labelInvalidLatitude = 'Latitude should be a decimal number in a range [-90, 90]';

    var labelInvalidLongitude = 'Longitude should be a decimal number in a range [-180, 180]';

    var labelLatitude = 'Latitude';

    var labelLongitude = 'Longitude';

    const VALID_RANGES = {
      LATITUDE: [-90, 90],
      LONGITUDE: [-180, 180]
    };

    function isNumber(value) {
      return value !== '' && value !== null && isFinite(value);
    }

    function isValidRange(start, end, dec) {
      const val = parseFloat(dec);
      return !isNaN(val) && val <= end && val >= start ? true : false;
    }

    function validateFormatAndRange(coordinate, range) {
      const truncatedCoordinate = coordinate.trim();
      return isNumber(truncatedCoordinate) && isValidRange(range[0], range[1], truncatedCoordinate);
    }

    function validateCoordinate(name, value) {
      return validateFormatAndRange(value, VALID_RANGES[name.toUpperCase()]);
    }

    const i18n$t = {
      coordinateIsRequired: labelCoordinateIsRequired,
      invalidLatitude: labelInvalidLatitude,
      invalidLongitude: labelInvalidLongitude,
      latitude: labelLatitude,
      longitude: labelLongitude
    };
    /**
     * Represents a geolocation compound field that accepts a latitude and longitude value.
     */

    class LightningInputLocation extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.fieldLevelHelp = void 0;
        this._latitude = '';
        this._longitude = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._variant = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.interactingState = new InteractingState({
          // keeps interacting state when switch between latitude and longitude
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
          this.dispatchEvent(new CustomEvent('blur'));
        });
        this.classList.add('slds-form-element', 'slds-form-compound');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The latitude value. Latitude values must be within -90 and 90.
       * @type {string}
       *
       */


      get latitude() {
        return this._latitude;
      }

      set latitude(value) {
        //  Converting the value to string when value is of type decimal to be consistent
        if (value != null) {
          value = value.toString();
        }

        this._latitude = normalizeString(value);
      }
      /**
       * The longitude value. Longitude values must be within -180 and 180.
       * @type {string}
       *
       */


      get longitude() {
        return this._longitude;
      }

      set longitude(value) {
        //  Converting the value to string when value is of type decimal to be consistent
        if (value != null) {
          value = value.toString();
        }

        this._longitude = normalizeString(value);
      }
      /**
       * If present, the geolocation fields are disabled and users cannot interact with them.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the geolocations fields are read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the geolocation fields must be filled out before the form is submitted.
       * An error message is displayed if a user interacts with the field
       * and does not provide a value.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of a geolocation compound field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and geolocation fields.
       * Use label-stacked to place the label above the geolocation fields.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }
      /**
       * Sets focus on the latitude field.
       */


      focus() {
        if (this._connected) {
          this.getCoordinateElement('latitude').focus();
        }
      }
      /**
       * Removes keyboard focus from the latitude and longitude fields.
       */


      blur() {
        if (this._connected) {
          this.getCoordinateElement('latitude').blur();
          this.getCoordinateElement('longitude').blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the latitude and longitude field meet all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the latitude or longitude field if the coordinates are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the latitude or longitude field when
       * the value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - Name of the field, which must be latitude or longitude.
       */


      setCustomValidityForField(message, fieldName) {
        assert(['latitude', 'longitude'].indexOf(fieldName) >= 0, '"fieldName" must be "latitude" or "longitude"');

        this._coordinateConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        Object.keys(this._coordinateConstraints).forEach(coordinate => {
          this._reportValidityForCoordinate(coordinate);
        });
        return valid;
      }

      get i18n() {
        return i18n$t;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleLatitudeBlur() {
        this.interactingState.leave();

        this._reportValidityForCoordinate('latitude');
      }

      handleLongitudeBlur() {
        this.interactingState.leave();

        this._reportValidityForCoordinate('longitude');
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleLatitudeChange(event) {
        this.handleChange('latitude', event);
      }

      handleLongitudeChange(event) {
        this.handleChange('longitude', event);
      }

      handleChange(coordinate, event) {
        event.stopPropagation();
        const value = event.detail.value;

        if (this[coordinate] === value) {
          // Value didn't change. No need to dispatch.
          return;
        } // Update component state accordingly


        if (coordinate === 'longitude') {
          this._longitude = value;
        } else if (coordinate === 'latitude') {
          this._latitude = value;
        }

        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            latitude: this.latitude,
            longitude: this.longitude
          }
        }));
      }

      get _coordinateConstraints() {
        if (!this._coordinateConstraintApis) {
          this._coordinateConstraintApis = ['latitude', 'longitude'].reduce((constraints, coordinate) => {
            const constraintProviders = {
              badInput: () => !this.disabled && !isEmptyString(this[coordinate]) && !validateCoordinate(coordinate, this[coordinate]),
              valueMissing: () => !this.disabled && this.required && isEmptyString(this[coordinate])
            };
            constraints[coordinate] = new FieldConstraintApi(this.getCoordinateElement.bind(this, coordinate), constraintProviders);
            return constraints;
          }, {});
        }

        return this._coordinateConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          const {
            _coordinateConstraints
          } = this;

          const checkCoordinates = property => Object.values(_coordinateConstraints).some(coordinateConstraint => coordinateConstraint.validity[property]);

          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => checkCoordinates('customError'),
            badInput: () => checkCoordinates('badInput'),
            valueMissing: () => checkCoordinates('valueMissing')
          });
        }

        return this._combinedConstraintApi;
      }

      getCoordinateElement(fieldName) {
        const propertyName = `_${fieldName}Element`;

        if (!this[propertyName]) {
          this[propertyName] = this.template.querySelector(`lightning-input[data-${fieldName}]`);
        }

        return this[propertyName];
      }

      _reportValidityForCoordinate(coordinate) {
        this._coordinateConstraints[coordinate].reportValidity(helpMessage => {
          const coordinateElement = this.getCoordinateElement(coordinate);
          coordinateElement.setCustomValidity(helpMessage);
          coordinateElement.reportValidity();
        });
      }

    }

    LightningInputLocation.delegatesFocus = true;

    lwc.registerDecorators(LightningInputLocation, {
      publicProps: {
        label: {
          config: 0
        },
        fieldLevelHelp: {
          config: 0
        },
        latitude: {
          config: 3
        },
        longitude: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity"],
      track: {
        _latitude: 1,
        _longitude: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _variant: 1
      }
    });

    var _lightningInputLocation = lwc.registerComponent(LightningInputLocation, {
      tmpl: _tmpl$H
    });

    function tmpl$P($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15
      } = $ctx;
      return [$cmp.failed ? api_element("span", {
        classMap: {
          "slds-hide": true
        },
        key: 0
      }, [api_text("No input rendered: "), api_dynamic($cmp.errorMessage)]) : null, $cmp.ready ? $cmp.isTypeName ? api_custom_element("lightning-input-name", _lightningInputName, {
        props: {
          "label": $cmp.label,
          "firstName": $cmp.internalValue.FirstName,
          "firstNameLabel": $cmp.firstNameLabel,
          "middleName": $cmp.internalValue.MiddleName,
          "middleNameLabel": $cmp.middleNameLabel,
          "lastName": $cmp.internalValue.LastName,
          "lastNameLabel": $cmp.lastNameLabel,
          "salutation": $cmp.internalValue.Salutation,
          "salutationLabel": $cmp.salutationLabel,
          "options": $cmp.picklistOptions,
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText,
          "fieldsToDisplay": $cmp.nameFieldsToDisplay
        },
        key: 1,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeAddress ? api_custom_element("lightning-input-address", _lightningInputAddress, {
        props: {
          "streetLabel": $cmp.streetLabel,
          "cityLabel": $cmp.cityLabel,
          "provinceLabel": $cmp.state.label,
          "countryLabel": $cmp.countryLabel,
          "postalCodeLabel": $cmp.postCodeLabel,
          "street": $cmp._street,
          "city": $cmp._city,
          "province": $cmp._state,
          "postalCode": $cmp._postalCode,
          "country": $cmp._country,
          "provinceOptions": $cmp.state.options,
          "countryOptions": $cmp.country.options,
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 2,
        on: {
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeNumber ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "name": $cmp._fieldName,
          "type": "number",
          "variant": $cmp.inputVariant,
          "required": $cmp.required,
          "label": $cmp.label,
          "formatter": $cmp.numberFormatter,
          "value": $cmp.internalValue,
          "step": $cmp.numberStep,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 3,
        on: {
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeText ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "label": $cmp.label,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "name": $cmp._fieldName,
          "required": $cmp.required,
          "maxLength": $cmp.fieldLength,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 4,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeCheckbox ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "checked": $cmp.internalValue,
          "type": "checkbox",
          "variant": $cmp.inputVariant,
          "required": $cmp.externalRequired,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 5,
        on: {
          "change": _m4 || ($ctx._m4 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeEmail ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.internalValue,
          "required": $cmp.required,
          "type": "email",
          "variant": $cmp.inputVariant,
          "maxLength": $cmp.uiField.length,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 6,
        on: {
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeTextArea ? api_custom_element("lightning-textarea", _lightningTextarea, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "variant": $cmp.inputVariant,
          "maxLength": $cmp.uiField.length,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 7,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeRichText ? api_custom_element("lightning-quill", _lightningQuill, {
        props: {
          "label": $cmp.label,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 8,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeDate ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "type": "date",
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 9,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeDateTime ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "type": "datetime",
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "required": $cmp.required,
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 10,
        on: {
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypePicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "options": $cmp.picklistOptions,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 11,
        on: {
          "programmaticchange": _m10 || ($ctx._m10 = api_bind($cmp.handlePicklistProgrammaticChange)),
          "change": _m11 || ($ctx._m11 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeMultiPicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
        props: {
          "multiple": true,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "options": $cmp.picklistOptions,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 12,
        on: {
          "change": _m12 || ($ctx._m12 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeReference ? api_custom_element("lightning-lookup", _lightningLookup, {
        props: {
          "disabled": $cmp._disabled,
          "fieldName": $cmp._fieldName,
          "objectInfos": $cmp.objectInfos,
          "record": $cmp.record.record,
          "value": $cmp.lookupValue,
          "variant": $cmp.inputVariant,
          "label": $cmp.label,
          "required": $cmp.required
        },
        key: 13,
        on: {
          "change": _m13 || ($ctx._m13 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeLocation ? api_custom_element("lightning-input-location", _lightningInputLocation, {
        props: {
          "longitude": $cmp.value.longitude,
          "latitude": $cmp.value.latitude,
          "label": $cmp.label,
          "disabled": $cmp._disabled,
          "readOnly": $cmp.readOnly,
          "required": $cmp.required
        },
        key: 14,
        on: {
          "change": _m14 || ($ctx._m14 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeUnsupportedReference ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": true,
          "readOnly": $cmp.readOnly,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.displayValue,
          "required": $cmp.required,
          "type": "text",
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 15,
        on: {
          "change": _m15 || ($ctx._m15 = api_bind($cmp.handleChange))
        }
      }, []) : null : null];
    }

    var _tmpl$I = lwc.registerTemplate(tmpl$P);
    tmpl$P.stylesheets = [];
    tmpl$P.stylesheetTokens = {
      hostAttribute: "lightning-inputField_inputField-host",
      shadowAttribute: "lightning-inputField_inputField"
    };

    function isInDependencyChain(uiField, fields, picklistValues) {
      return hasDependents(uiField, fields, picklistValues) || hasController(uiField, fields, picklistValues);
    }
    function hasDependents(uiField, fields, picklistValues) {
      for (const fieldName in fields) {
        if (Object.prototype.hasOwnProperty.call(fields, fieldName)) {
          const field = fields[fieldName];

          if (field.controllerName === uiField.apiName) {
            // make sure the dependent field exists in the form
            if (picklistFieldInForm(fieldName, picklistValues)) {
              return true;
            }
          }
        }
      }

      return false;
    }

    function hasController(uiField, fields, picklistValues) {
      const controllerName = uiField.controllerName;
      const hasControllingField = fields[controllerName] !== undefined;
      return hasControllingField && (picklistFieldInForm(controllerName, picklistValues) || checkboxFieldInForm(controllerName, fields));
    }

    function isControllerMissing(uiField, fields, picklistValues) {
      const controllerName = uiField.controllerName;
      const hasControllingField = fields[controllerName] !== undefined;
      return hasControllingField && !picklistFieldInForm(controllerName, picklistValues) && !checkboxFieldInForm(controllerName, fields);
    }

    function picklistFieldInForm(fieldName, picklistValues) {
      return picklistValues[fieldName] !== undefined;
    }

    function checkboxFieldInForm(fieldName, fields) {
      return fields[fieldName] !== undefined && Fields.BOOLEAN === fields[fieldName].dataType;
    }

    /**
     * Given a scale returns the corresponding decimal places 'step' (ie. lowest unit of decrease/increase for a number
     * in the given scale).
     * for example given the scale 1 result in 0.1, for 2 -> 0.01, etc.
     * @param {number} scale an integer number.
     * @returns {number} 'step' for the given scale.
     */
    function scaleToDecimalPlaces(scale) {
      // Using toFixed to correct for bad js arithmetic precision, resulting
      // in 0.000009999999999999999 for Math.pow(10, -5) instead of the expected
      // 0.00001
      const resultAsString = Math.pow(10, -parseInt(scale, 10)).toFixed(scale);
      return parseFloat(resultAsString);
    }

    const NUMBER_TYPES = [Fields.DECIMAL, Fields.INT, Fields.PERCENT, Fields.CURRENCY, Fields.DOUBLE];
    const STATE_CODE = 'StateCode';
    const COUNTRY_CODE = 'CountryCode';

    function uncapitalize(str) {
      return `${str[0].toLowerCase()}${str.slice(1)}`;
    }

    function isUnsupportedReferenceField(name) {
      return UNSUPPORTED_REFERENCE_FIELDS.indexOf(name) !== -1;
    } // Returns a normalized string name by removing the prefix (e.g. removes 'Billing' from 'BillingStreet' for Address fields)


    function removePrefix(str, prefix) {
      return prefix ? str.replace(prefix, '') : str;
    } // Adds a prefix to the string (e.g. adds 'Billing' to 'Street' for Address fields)


    function addPrefix(str, prefix) {
      return prefix ? prefix + str : str;
    }

    function isEmptyObject(obj) {
      // fastest way to do this!
      // eslint-disable-next-line guard-for-in
      for (const name in obj) {
        return false;
      }

      return true;
    }
    /**
     * Returns a map of updated values from a compound field,
     * normalizing the names and capitalization rules
     * @param {Object} originalValue A map of the original values
     * @param {Object} changedValues Values that have changed
     * @param {Object} fieldPrefix The field prefix in the map of original values (e.g. 'Billing' in 'BillingStreet')
     *
     * @returns {Object} Map of updated values
     */


    function normalizeCompoundFieldValues(originalValue, changedValues, fieldPrefix) {
      return Object.keys(originalValue).reduce((ret, rawKey) => {
        const key = removePrefix(rawKey, fieldPrefix); // map state and country values to code if code is present,
        // rather than raw value

        let normalizedKey;

        if (key === STATE_CODE || uncapitalize(key) === 'state') {
          normalizedKey = 'province';
        } else if (key === COUNTRY_CODE) {
          normalizedKey = 'country';
        } else {
          normalizedKey = uncapitalize(key);
        }

        const normalizedValue = changedValues[normalizedKey] ? changedValues[normalizedKey] : null;
        ret[addPrefix(key, fieldPrefix)] = normalizedValue;
        return ret;
      }, {});
    }

    const VARIANT_MAPPING = {
      stacked: VARIANT.LABEL_STACKED,
      horizontal: VARIANT.LABEL_INLINE
    };
    /**
     * Represents an editable input for a field on a Salesforce object.
     */

    class LightningInputField extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.firstNameLabel = '';
        this.middleNameLabel = '';
        this.lastNameLabel = '';
        this.salutationLabel = '';
        this.nameFieldsToDisplay = ['salutation', 'firstName', 'lastName'];
        this.streetLabel = '';
        this.cityLabel = '';
        this.provinceLabel = '';
        this.countryLabel = '';
        this.postCodeLabel = '';
        this.uiField = {};
        this.failed = false;
        this.errorMessage = '';
        this.ready = false;
        this.picklistOptions = void 0;
        this.isCompoundField = false;
        this.nameField = {};
        this.addressField = {};
        this.label = '';
        this._uiFieldRequired = false;
        this._externalRequired = false;
        this.inlineHelpText = '';
        this._disabled = void 0;
        this._readOnly = void 0;
        this.internalValue = void 0;
        this.objectInfos = void 0;
        this.record = void 0;
        this._fieldName = void 0;
        this._street = void 0;
        this._country = void 0;
        this._postalCode = void 0;
        this._state = void 0;
        this._city = void 0;
        this._labelAlignment = '';
        this._variant = void 0;
        this._rawFieldName = void 0;
        this.originalValue = void 0;
        this.isDirty = false;
        this.serverError = void 0;
        this.serverErrorValue = void 0;
        this._inChangeCycle = false;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.isStackedLabel() && !this.isTypeAddress && !this.isTypeName,
          'slds-form-element_horizontal': this.isHorizontalLabel() && !this.isTypeAddress && !this.isTypeName
        });
      }

      isStackedLabel() {
        // only add the form class if density or variant is stacked
        return this._labelAlignment === 'stacked' && !this.variant || this.variant === VARIANT.LABEL_STACKED;
      }

      isHorizontalLabel() {
        // only add the form class if density or variant is horizontal
        return this._labelAlignment === 'horizontal' && !this.variant || this.variant === VARIANT.LABEL_INLINE;
      }
      /**
       * The variant changes the label position of an input field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * The variant, if specified, determines the label position.
       * Otherwise, the density setting of the parent form determines the label position.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = value;
        this.updateClassList();
      }
      /**
       * Reserved for internal use.
       * @param {*} record Reserved for internal use.
       */


      wireRecordUi(record) {
        let uiField; // TODO break up wireRecordUi method, too much stuff happening here

        try {
          uiField = getUiField(this.fieldName, record.record, record.objectInfo);
        } catch (e) {
          this.failed = true;
          this.errorMessage = `Field "${this.fieldName}" not found in response.`;
          return;
        }

        this.record = record;
        this.uiField = uiField;
        this.label = uiField.label;
        this._uiFieldRequired = uiField.required;
        this.objectInfos = record.objectInfos;
        this.inlineHelpText = uiField.inlineHelpText;
        this._labelAlignment = record.labelAlignment ? record.labelAlignment : '';
        this.updateClassList();

        if (!this.isDirty) {
          this.internalValue = uiField.value;
        }

        if (this._rawFieldName && this._rawFieldName.objectApiName && this._rawFieldName.objectApiName !== record.objectInfo.apiName) {
          throw new Error(`objectApiName (${this._rawFieldName.objectApiName}) for field ${this.fieldName} does not match the objectApiName provided for the form (${record.objectInfo.apiName}).`);
        }

        this.originalValue = uiField.value; // reset the disabled and readonly values in case they had been overridden based on the previous wired response

        this._disabled = this._externalDisabled;
        this._readonly = this._externalReadonly;
        this.isCompoundField = false;

        if (isCompoundField(this.fieldName, record.objectInfo, isPersonAccount(record.record))) {
          this.isCompoundField = true;
          this.fieldPrefix = this.getFieldPrefix();
          this.initializeCompoundField(uiField, record);
        } else if (!record.createMode && uiField.updateable === false || record.createMode && uiField.createable === false) {
          this._disabled = true;
          this._readOnly = true;
        }

        if (!this.isAnyPicklistType && !this.isCompoundField) {
          // compound fields without picklists will be marked ready in initializeCompoundField
          // picklists and compound fields that have picklist constituents will be marked ready after the options are wired
          this.ready = true;
        }
      }

      get inputVariant() {
        // precendence to variant over density
        if (this.variant) {
          return this.variant;
        }

        if (VARIANT_MAPPING[this._labelAlignment]) {
          return VARIANT_MAPPING[this._labelAlignment];
        }

        return this.variant;
      }

      get fieldLength() {
        // Latitude and Longitude are subfield of GeoLocation. inputField use input type=text for now.
        // Since inputLocation use input type=text and no max-length limitation,
        // if it's Location sub field, don't set the max-length either.
        return !this.isLocationSubField ? this.uiField.length : undefined;
      }
      /**
       * Reserved for internal use.
       * @param {*} picklistValues Reserved for internal use
       */


      wirePicklistValues(picklistValues) {
        // picklist fields rely on the record for dependency management.
        // The initialization logic will fail if record-ui isn't already wired.
        if (!this.record) {
          return;
        }

        this._picklistValues = picklistValues;

        if (this.isAnyPicklistType) {
          this.initializePicklist(this.fieldName);
        } else if (this.isCompoundField) {
          this.initializePicklistsForCompoundField(this.uiField, this.record);
        } else if (this.isTypeCheckbox) {
          // Also need to register checkbox fields that are part of a dependency chain
          this.registerCheckboxDependency();
        }

        this.ready = true;
      }

      updateAddressField(changedValues = {}) {
        // W-6297329 gack this.addressField.*. undefined
        let address = {
          country: this.getNormalizedStateCountryField('Country').value,
          postalCode: this.addressField.PostalCode && this.addressField.PostalCode.value,
          city: this.addressField.City && this.addressField.City.value,
          province: this.getNormalizedStateCountryField('State').value,
          street: this.addressField.Street && this.addressField.Street.value
        };
        address = Object.assign(address, changedValues);
        this._country = address.country;
        this._postalCode = address.postalCode;
        this._state = address.province;
        this._street = address.street;
        this._city = address.city;
        this.streetLabel = this.addressField.Street && this.addressField.Street.label;
        this.cityLabel = this.addressField.City && this.addressField.City.label;
        this.postCodeLabel = this.addressField.PostalCode && this.addressField.PostalCode.label;

        if (this.addressField.Country) {
          this.countryLabel = this.addressField.Country.label;
        } else if (this.addressField.CountryCode) {
          this.countryLabel = this.addressField.CountryCode.label;
        }
      }

      initializeCompoundField(uiField, record) {
        let isNameField = false;
        const compoundFields = getCompoundFields(this.fieldName, record.record, record.objectInfo);
        let compoundField = this.addressField;

        if (uiField.extraTypeInfo === Fields.PERSON_NAME) {
          compoundField = this.nameField;
          isNameField = true;
        }

        if (!record.createMode && !compoundFieldIsUpdateable(compoundFields, record.record, record.objectInfo) || record.createMode && !compoundFieldIsCreateable(compoundFields, record.record, record.objectInfo)) {
          this._disabled = true;
        }

        let hasPicklists = false;
        compoundFields.forEach(field => {
          const fieldName = removePrefix(field, this.fieldPrefix);
          compoundField[fieldName] = getUiField(field, record.record, record.objectInfo);

          if (compoundField[fieldName].type === Fields.PICKLIST) {
            hasPicklists = true;
          }
        });

        if (isNameField && this.isTypeName) {
          this.firstNameLabel = compoundField.FirstName.label; // Middle names only show up if a perm is enabled

          if (compoundField.MiddleName) {
            this.middleNameLabel = compoundField.MiddleName.label;
            this.nameFieldsToDisplay.push('middleName');
          }

          this.lastNameLabel = compoundField.LastName.label;
          this.salutationLabel = compoundField.Salutation.label;
        } // if the compound field doesn't have a picklist constituent, mark it ready


        if (!hasPicklists) {
          this.ready = true;
        }

        if (this.isTypeAddress) {
          this.updateAddressField();
        }
      }
      /**
       * Resets the form fields to their initial values.
       */


      reset() {
        this.isDirty = false;
        this.wireRecordUi(this.record); // clear any errors

        this.setErrors('');

        if (this.canBeControllingField) {
          this.dispatchControllerFieldChangeEvent(this.fieldName, this.internalValue);
        }
      } // TODO this should be removed after records experience updates their code to not rely on this method

      /**
       * Reserved for internal use.
       * @param {*} fieldName Reserved for internal use.
       * @param {*} options Reserved for internal use.
       */


      updateDependentField(fieldName, options) {
        this.updateFieldOptions(fieldName, options); // make sure the component is marked ready

        this.ready = true;
      }
      /**
       * Reserved for internal use.
       * @param {*} errors Reserved for internal use.
       */


      setErrors(errors) {
        if (errors && errors.body && errors.body.output && errors.body.output.fieldErrors && errors.body.output.fieldErrors[this.fieldName]) {
          this.setCustomValidity(errors.body.output.fieldErrors[this.fieldName][0].message);
          this.serverError = errors.body.output.fieldErrors[this.fieldName];
          this.serverErrorValue = this.value;
        } else {
          this.serverError = undefined;
          this.setCustomValidity('');
        }
      }
      /**
       * The field value, which overrides the existing value.
       * @type {string}
       *
       */


      get value() {
        return this.internalValue;
      }

      set fieldName(name) {
        this._previousRawFieldName = this._rawFieldName;
        this._rawFieldName = name;

        if (name && name.fieldApiName) {
          this._fieldName = name.fieldApiName;
        } else {
          this._fieldName = name;
        } // If fieldname changes, we need to notify recordEditForm of the new field
        // If the field is a picklist, recordEditForm would also have to update the dependency manager
        // and wire up-to-date picklist values to inputField


        if (this.connected && name && this._previousRawFieldName !== name) {
          this.registerInputField();
        }
      }
      /**
       * The API name of the field to be displayed.
       * @type {string}
       */


      get fieldName() {
        return this._fieldName;
      }

      set value(val) {
        if (this._inChangeCycle && this.isTypeReference) {
          // reject values being set from outside
          return;
        } // uninitialized values passed through
        // templates are undefined but should not
        // mark the field as dirty


        if (val !== undefined) {
          this.internalValue = val;
          this.isDirty = true;
        } // We need to notify the dependency manager of the change in case the field has dependents


        if (this.ready && this.canBeControllingField) {
          this.dispatchControllerFieldChangeEvent(this.fieldName, val);
        }
      }
      /**
       * If present, the field is grayed out and users can't interact with it.
       * Disabled fields don't receive focus and are skipped in tabbing navigation.
       * @type {boolean}
       *
       */


      get disabled() {
        return !!this._disabled;
      }
      /**
       * Specifies whether an input field is read-only. This value defaults to false.
       * Not supported for the following field types: rich text, picklist, multi-select picklist, and lookup.
       * A read-only field is not disabled by default.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return !!this._readOnly;
      }

      set readOnly(val) {
        this._readOnly = val; // Need to keep track of the value passed into the component since we override this in certain cases

        this._externalReadonly = val;
      }
      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._uiFieldRequired || this._externalRequired;
      }

      set required(value) {
        this._externalRequired = normalizeBoolean(value);
      } // Only used by checkbox, there is no way to make a checkbox field required in the layout in core.


      get externalRequired() {
        return this._externalRequired;
      }
      /**
       * Reserved for internal use.
       * @returns {boolean} Returns true if the input field is valid.
       */


      reportValidity() {
        const input = this.getInputComponent();

        if (input) {
          return input.reportValidity();
        }

        return true;
      }

      set disabled(val) {
        this._disabled = val; // Need to keep track of the value passed into the component since we override this in certain cases

        this._externalDisabled = this._disabled;
      }
      /**
       * Reserved for internal use. If present, the field has been modified by the user but not saved or submitted.
       * @type {boolean}
       * @default false
       */


      get dirty() {
        return this.isDirty;
      }

      get isTypeName() {
        return this.isCompoundField && (Fields.PERSON_NAME === this.uiField.extraTypeInfo || Fields.SWITCHABLE_PERSON_NAME === this.uiField.extraTypeInfo);
      }

      get isTypeAddress() {
        return this.uiField.compound && Fields.ADDRESS === this.uiField.type;
      }

      get country() {
        return this.getNormalizedStateCountryField('Country');
      }

      get state() {
        return this.getNormalizedStateCountryField('State');
      }

      getNormalizedStateCountryField(fieldName) {
        if (this.addressField && this.addressField[`${fieldName}Code`]) {
          return this.addressField[`${fieldName}Code`];
        } else if (this.addressField && this.addressField[fieldName]) {
          return this.addressField[fieldName];
        }

        return {};
      } // The longitude and latitude fields are passed down as type=DOUBLE
      // however, these fields should not be mapped to input type='number
      // otherwise the value will be localized based on the user's locale


      get isTypeNumber() {
        return NUMBER_TYPES.includes(this.uiField.type) && !this.isLocationSubField;
      }

      get isLocationSubField() {
        const compoundComponentName = this.uiField.compoundComponentName;
        return compoundComponentName === 'Latitude' || compoundComponentName === 'Longitude';
      }

      get numberFormatter() {
        let formatter = 'decimal';

        switch (this.uiField.type) {
          case 'Currency':
            formatter = 'currency';
            break;

          case 'Percent':
            formatter = 'percent-fixed';
            break;
        }

        return formatter;
      }

      get numberStep() {
        switch (this.uiField.type) {
          case 'Currency':
            return 0.01;

          case 'Percent':
          case 'Double':
          case 'Decimal':
            return scaleToDecimalPlaces(this.uiField.scale);

          default:
            return 1;
        }
      } // text type is the default


      get isTypeText() {
        return !this.isTypeNumber && !this.isTypeRichText && !this.isTypeTextArea && !this.isTypeCheckbox && !this.isTypeDate && !this.isTypeDateTime && !this.isTypeEmail && !this.isTypePicklist && !this.isTypeMultiPicklist && !this.isTypeName && !this.isTypeReference && !this.isTypeLocation && !this.isTypeUnsupportedReference && !this.isTypeAddress;
      }

      get isTypeRichText() {
        return Fields.TEXTAREA === this.uiField.type && Fields.RICH_TEXTAREA === this.uiField.extraTypeInfo && this.uiField.htmlFormatted;
      }

      get isTypeTextArea() {
        return Fields.TEXTAREA === this.uiField.type && Fields.PLAIN_TEXTAREA === this.uiField.extraTypeInfo && !this.uiField.htmlFormatted;
      }

      get isTypeCheckbox() {
        return Fields.BOOLEAN === this.uiField.type;
      }

      get isTypeEmail() {
        return Fields.EMAIL === this.uiField.type;
      }

      get isTypeDate() {
        return Fields.DATE === this.uiField.type;
      }

      get isTypeDateTime() {
        return Fields.DATETIME === this.uiField.type;
      }

      get isTypePicklist() {
        return Fields.PICKLIST === this.uiField.type;
      }

      get isTypeMultiPicklist() {
        return Fields.MULTI_PICKLIST === this.uiField.type;
      }

      get canBeControllingField() {
        return this.isTypePicklist || this.isTypeCheckbox;
      }

      get isAnyPicklistType() {
        return this.isTypePicklist || this.isTypeMultiPicklist;
      }

      get isTypeReference() {
        if (this.isTypeUnsupportedReference) {
          return false;
        }

        return Fields.REFERENCE === this.uiField.type;
      }

      get isTypeLocation() {
        return Fields.LOCATION === this.uiField.type;
      }

      get isTypeUnsupportedReference() {
        return isUnsupportedReferenceField(this.fieldName);
      }

      get displayValue() {
        return this.uiField.displayValue;
      }
      /**
       * Lookup needs an array,
       * so this casts the value to an array
       */


      get lookupValue() {
        if (this.value === undefined) {
          return [];
        } else if (Array.isArray(this.value)) {
          return this.value;
        }

        return [this.value];
      }

      renderedCallback() {
        if (!this.ready) {
          this.registerInputField();
        }
      }

      registerInputField() {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('registerinputfield', {
          bubbles: true,
          composed: true,
          cancelable: true
        }));
      }

      setCustomValidity(message) {
        const input = this.getInputComponent();

        if (input && input.setCustomValidity) {
          input.setCustomValidity(message ? message : '');
          input.showHelpMessageIfInvalid();
        }
      } // TODO refactor this function into smaller pieces


      handleChange(e) {
        // ignore change events until ready
        if (!this.ready) {
          return;
        } // change events without detail should be ignored


        if (!e.detail) {
          return;
        }

        if (this.isTypeName || this.isTypeAddress || this.isTypeLocation) {
          this.handleCompoundFieldChange(e);
          return;
        }

        if (e.detail.checked !== undefined) {
          this.internalValue = e.detail.checked;
        } else if (this.isTypeReference) {
          // multiselect doesn't actually work yet,
          // normalize falsey values
          this.internalValue = e.detail.value[0] ? e.detail.value[0] : ''; // ignore reset of value from bubble to interop

          this._inChangeCycle = true; // eslint-disable-next-line @lwc/lwc/no-async-operation

          setTimeout(() => {
            this._inChangeCycle = false;
          }, 0);
        } else {
          this.internalValue = e.detail.value;
        }

        if (this.internalValue !== this.originalValue) {
          this.isDirty = true;

          if (this.serverError) {
            this.setCustomValidity();
            this.serverError = false;
          }
        } else {
          this.isDirty = false;
        }

        if (this.canBeControllingField) {
          this.dispatchControllerFieldChangeEvent(this.fieldName, this.internalValue);
        }
      } // The reason why this is separate from the handleChange method is that
      // we don't want to mark the field dirty when the field value was automatically selected by the picklist based on the available options
      // This specifically manifests itself when we initially have no value and as a result the picklist selects the 'None' option


      handlePicklistProgrammaticChange(event) {
        if (!this.ready) {
          return;
        }

        this.internalValue = event.target.value;
        this.dispatchControllerFieldChangeEvent(this.fieldName, this.internalValue);
      }

      handleCompoundFieldChange(e) {
        const newValue = normalizeCompoundFieldValues(this.originalValue, e.detail, this.fieldPrefix);
        const countryCodeField = addPrefix(COUNTRY_CODE, this.fieldPrefix); // currently input-address return 'province' as both stateCode and state. Having both of these
        // set to the same value returns an API error.
        // eslint-disable-next-line no-prototype-builtins

        if (this.originalValue.hasOwnProperty(countryCodeField)) {
          delete newValue[this.fieldPrefix + 'Country'];
          delete newValue[this.fieldPrefix + 'State'];
        } // if the newValue is not an empty object
        // this is a dirty record


        if (!isEmptyObject(newValue)) {
          this.isDirty = true; // CountryCode is a controlling picklist, so we need to update the options for StateCode

          if (newValue[countryCodeField] !== this.internalValue[countryCodeField]) {
            this.dispatchControllerFieldChangeEvent(countryCodeField, newValue[countryCodeField]);
          }

          const modifiedObject = Object.assign({}, this.internalValue, newValue);
          this.internalValue = modifiedObject;

          if (this.isTypeAddress) {
            this.updateAddressField(e.detail);
          }
        }
      }

      registerCheckboxDependency() {
        // no need to bother with dependency management if there are no picklists in the form.
        if (!this._picklistValues) {
          return;
        }

        const hasDependents$1 = hasDependents(this.uiField, this.record.objectInfo.fields, this._picklistValues); // register checkboxes that are part of a dependency chain

        if (hasDependents$1) {
          this.dispatchRegisterDependencyEvent(this.fieldName);
        }
      }

      initializePicklistsForCompoundField() {
        const compoundFields = getCompoundFields(this.fieldName, this.record.record, this.record.objectInfo);
        let compoundField = this.addressField;

        if (this.uiField.extraTypeInfo === Fields.PERSON_NAME) {
          compoundField = this.nameField;
        }

        compoundFields.forEach(field => {
          const fieldName = removePrefix(field, this.fieldPrefix);

          if (compoundField[fieldName].type === Fields.PICKLIST) {
            this.initializePicklist(field);
          }
        });
      }

      initializePicklist(fieldName) {
        if (!this._picklistValues || !this._picklistValues[fieldName]) {
          // We could be in a state where the picklist renders and registers itself *while* recordEditForm is still processing an existing wire
          // In this case, the picklist values will be available after the new wire results are passed into inputField
          console.warn(`Could not find picklist values for field [${fieldName}]`);
          return;
        } // should disable the picklist if the controlling field is missing


        const controllerMissing = isControllerMissing(this.uiField, this.record.objectInfo.fields, this._picklistValues);

        if (controllerMissing) {
          this.internalValue = '';
          this.picklistOptions = [];
          throw new Error(`Field [${this.uiField.controllerName}] controls the field [${fieldName}] but was not found in the form`);
        } // state and country picklists are in a dependency chain, no need to check.


        let isInDependencyChain$1 = false;

        if (this.isTypeAddress) {
          isInDependencyChain$1 = true;
        } else {
          isInDependencyChain$1 = this.isAnyPicklistType && isInDependencyChain(this.uiField, this.record.objectInfo.fields, this._picklistValues);
        }

        if (isInDependencyChain$1) {
          // initializing picklists in empty state, dependency manager will later update the options.
          this.picklistOptions = [];
          this.dispatchRegisterDependencyEvent(fieldName);
        } else {
          // regular picklist field not within a dependency chain
          this.picklistOptions = this._picklistValues[fieldName].values;
        }
      }

      updateFieldOptions(fieldName, options) {
        if (this.isTypeAddress) {
          const field = removePrefix(fieldName, this.fieldPrefix);
          this.addressField[field].options = options;
        } else if (this.isAnyPicklistType) {
          this.picklistOptions = options;
        }
      }

      getFieldPrefix() {
        if (this.isTypeAddress) {
          // Address fields usually have a prefix, e.g. `BillingStreet` or `ShippingStreet`
          return this.fieldName.split(/Address$/)[0];
        }

        return null;
      }

      dispatchRegisterDependencyEvent(fieldName) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('registerfielddependency', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            fieldName,
            // field-dependency-manager only needs the update method and the live value of the input-field
            fieldElement: {
              updateFieldOptions: this.updateFieldOptions.bind(this),
              getFieldValue: () => {
                return this.value;
              }
            }
          }
        }));
      }

      dispatchControllerFieldChangeEvent(fieldName, value) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatedependentfields', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            fieldName,
            value
          }
        }));
      }

      getInputComponent() {
        return this.template.querySelector('lightning-input,lightning-textarea,lightning-picklist,lightning-lookup');
      }

    }

    lwc.registerDecorators(LightningInputField, {
      publicProps: {
        variant: {
          config: 3
        },
        value: {
          config: 3
        },
        fieldName: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        dirty: {
          config: 1
        }
      },
      publicMethods: ["wireRecordUi", "wirePicklistValues", "reset", "updateDependentField", "setErrors", "reportValidity"],
      track: {
        firstNameLabel: 1,
        middleNameLabel: 1,
        lastNameLabel: 1,
        salutationLabel: 1,
        nameFieldsToDisplay: 1,
        streetLabel: 1,
        cityLabel: 1,
        provinceLabel: 1,
        countryLabel: 1,
        postCodeLabel: 1,
        uiField: 1,
        failed: 1,
        errorMessage: 1,
        ready: 1,
        picklistOptions: 1,
        isCompoundField: 1,
        nameField: 1,
        addressField: 1,
        label: 1,
        _uiFieldRequired: 1,
        _externalRequired: 1,
        inlineHelpText: 1,
        _disabled: 1,
        _readOnly: 1,
        internalValue: 1,
        objectInfos: 1,
        record: 1,
        _fieldName: 1,
        _street: 1,
        _country: 1,
        _postalCode: 1,
        _state: 1,
        _city: 1,
        _labelAlignment: 1,
        _variant: 1
      },
      fields: ["_rawFieldName", "originalValue", "isDirty", "serverError", "serverErrorValue", "_inChangeCycle"]
    });

    var _lightningInputField = lwc.registerComponent(LightningInputField, {
      tmpl: _tmpl$I
    });

    function tmpl$Q($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_custom_element("lightning-record-edit-form", _lightningRecordEditForm, {
        props: {
          "objectApiName": $cmp.itemObject
        },
        key: 10,
        on: {
          "success": _m0 || ($ctx._m0 = api_bind($cmp.handleCreated)),
          "error": _m1 || ($ctx._m1 = api_bind($cmp.handleError))
        }
      }, [api_custom_element("lightning-messages", _lightningMessages, {
        key: 0
      }, []), api_element("div", {
        classMap: {
          "slds-grid": true
        },
        key: 9
      }, [api_element("div", {
        classMap: {
          "slds-col": true,
          "slds-size_1-of-2": true
        },
        key: 5
      }, [api_custom_element("lightning-input-field", _lightningInputField, {
        classMap: {
          "focusField": true
        },
        props: {
          "fieldName": $cmp.typeField
        },
        key: 1
      }, []), api_custom_element("lightning-input-field", _lightningInputField, {
        props: {
          "fieldName": $cmp.categoryField
        },
        key: 2
      }, []), api_custom_element("lightning-input-field", _lightningInputField, {
        props: {
          "fieldName": $cmp.countField
        },
        key: 3
      }, []), api_custom_element("lightning-input-field", _lightningInputField, {
        props: {
          "fieldName": $cmp.threshHoldCountField
        },
        key: 4
      }, [])]), api_element("div", {
        classMap: {
          "slds-col": true,
          "slds-size_1-of-2": true
        },
        key: 8
      }, [api_custom_element("lightning-input-field", _lightningInputField, {
        props: {
          "fieldName": $cmp.subtypeField
        },
        key: 6
      }, []), api_custom_element("lightning-input-field", _lightningInputField, {
        props: {
          "fieldName": $cmp.locationField,
          "value": $cmp.location
        },
        key: 7
      }, [])])])])];
    }

    var _tmpl$J = lwc.registerTemplate(tmpl$Q);
    tmpl$Q.stylesheets = [];
    tmpl$Q.stylesheetTokens = {
      hostAttribute: "lwc-itemCreate_itemCreate-host",
      shadowAttribute: "lwc-itemCreate_itemCreate"
    };

    const DEFAULT_TOAST_MODE = 'dismissible';
    const DEFAULT_VARIANT$2 = 'info';
    const DEFAULT_DURATION = 3000;
    const WARN_MESSAGES = {
      IGNORING_MESSAGE_DATA: 'Ignoring messageData attribute in toast definition, messageData should be an array of action links.',
      MISSING_TITLE_AND_MESSAGE: "Toast definition is invalid. Missing both attributes 'title' and 'message'. At east one of them should be present",
      TOAST_DEFINITION_SHOULD_BE_OBJECT: "The toast definition should be an object, for example: { title: 'Title text', message: 'Message text' }"
    };

    function setPropertyIfTruthyValue(obj, prop, propValue) {
      if (propValue) {
        obj[prop] = propValue;
      }
    }

    function getStringProp(obj, prop) {
      let value = obj[prop] ? obj[prop] : undefined;

      if (value && !(typeof value === 'string')) {
        console.warn(`Attribute '${prop}' should have a string value.`); // eslint-disable-line no-console

        value = undefined;
      }

      return value;
    }

    function getMessageData(definition) {
      const msgData = definition.messageData;
      const msgDataIsArray = Array.isArray(msgData);

      if (msgData && !msgDataIsArray) {
        console.warn(WARN_MESSAGES.IGNORING_MESSAGE_DATA); // eslint-disable-line no-console
      }

      return msgData && msgDataIsArray ? msgData : undefined;
    }

    function getValidToastDefinition(toastDefinition) {
      const toastDefinitionIsObject = toastDefinition !== null && typeof toastDefinition === 'object' && !Array.isArray(toastDefinition);

      if (!toastDefinitionIsObject) {
        console.warn(WARN_MESSAGES.TOAST_DEFINITION_SHOULD_BE_OBJECT); // eslint-disable-line no-console

        return null;
      }

      const title = getStringProp(toastDefinition, 'title');
      const message = getStringProp(toastDefinition, 'message');

      if (!title && !message) {
        console.warn(WARN_MESSAGES.MISSING_TITLE_AND_MESSAGE); // eslint-disable-line no-console

        return null;
      }

      return toastDefinition;
    }

    function getNormalizedToastDefinition(validDefinition) {
      const normalizedToastDefinition = {};
      const title = getStringProp(validDefinition, 'title');
      const message = getStringProp(validDefinition, 'message');
      const messageData = getMessageData(validDefinition);
      normalizedToastDefinition.type = normalizeString(validDefinition.variant, {
        fallbackValue: DEFAULT_VARIANT$2,
        validValues: ['info', 'success', 'warning', 'error']
      });
      normalizedToastDefinition.mode = normalizeString(validDefinition.mode, {
        fallbackValue: DEFAULT_TOAST_MODE,
        validValues: ['dismissible', 'pester', 'sticky']
      });
      normalizedToastDefinition.duration = DEFAULT_DURATION;
      setPropertyIfTruthyValue(normalizedToastDefinition, 'title', title);
      setPropertyIfTruthyValue(normalizedToastDefinition, 'message', message);
      setPropertyIfTruthyValue(normalizedToastDefinition, 'messageData', messageData);
      return normalizedToastDefinition;
    }

    function getToastEventArgument(normalizedToastDefinition) {
      const eventArguments = {
        mode: normalizedToastDefinition.mode,
        duration: normalizedToastDefinition.duration,
        type: normalizedToastDefinition.type
      };

      if (normalizedToastDefinition.title && normalizedToastDefinition.message) {
        eventArguments.title = normalizedToastDefinition.title;
      }

      eventArguments.message = normalizedToastDefinition.message ? normalizedToastDefinition.message : normalizedToastDefinition.title;

      if (normalizedToastDefinition.messageData) {
        eventArguments.messageTemplate = eventArguments.message;
        eventArguments.messageTemplateData = normalizedToastDefinition.messageData;
      }

      return eventArguments;
    }

    function showToast(toastDefinition, eventDispatcher) {
      const validToastDefinition = getValidToastDefinition(toastDefinition);
      const shouldShowToast = validToastDefinition !== null;

      if (validToastDefinition !== null) {
        const normalizedToast = getNormalizedToastDefinition(validToastDefinition);
        eventDispatcher(getToastEventArgument(normalizedToast));
      }

      return shouldShowToast;
    }

    function tmpl$R($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "label": $cmp.buttonText
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonClick))
        }
      }, [])];
    }

    var _tmpl$K = lwc.registerTemplate(tmpl$R);
    tmpl$R.stylesheets = [];
    tmpl$R.stylesheetTokens = {
      hostAttribute: "lightning-noticeFooter_noticeFooter-host",
      shadowAttribute: "lightning-noticeFooter_noticeFooter"
    };

    var labelOkButton = 'OK';

    const i18n$u = {
      okButton: labelOkButton
    };

    class NoticeFooter extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.handleClickCallback = void 0;
      }

      get buttonText() {
        return `${i18n$u.okButton}`;
      }

      handleButtonClick() {
        if (typeof this.handleClickCallback === 'function') {
          this.handleClickCallback.call();
        }
      }

    }

    lwc.registerDecorators(NoticeFooter, {
      publicProps: {
        handleClickCallback: {
          config: 0
        }
      }
    });

    lwc.registerComponent(NoticeFooter, {
      tmpl: _tmpl$K
    });

    function tmpl$S($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator
      } = $api;
      return api_iterator($cmp.formattedParts, function (part) {
        return [part.isLink ? api_element("a", {
          attrs: {
            "target": "_blank",
            "href": part.href,
            "rel": "noopener"
          },
          key: api_key(0, part.key)
        }, [api_dynamic(part.value)]) : null, part.isText ? api_dynamic(part.value) : null, part.isNewline ? api_element("br", {
          key: api_key(1, part.key)
        }, []) : null];
      });
    }

    var _tmpl$L = lwc.registerTemplate(tmpl$S);
    tmpl$S.stylesheets = [];
    tmpl$S.stylesheetTokens = {
      hostAttribute: "lightning-formattedText_formattedText-host",
      shadowAttribute: "lightning-formattedText_formattedText"
    };

    /**
     * Displays text, replaces newlines with line breaks, and linkifies if requested.
     */

    class FormattedText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = '';
        this._linkify = false;
      }

      /**
       * If present, URLs and email addresses are displayed in anchor tags.
       * They are displayed in plain text by default.
       * @type {boolean}
       * @default false
       */
      get linkify() {
        return this._linkify;
      }

      set linkify(value) {
        this._linkify = normalizeBoolean(value);
      }

      get formattedParts() {
        if (!this.value || typeof this.value !== 'string') {
          return [];
        }

        return this.linkify ? parseToFormattedLinkifiedParts(this.value) : parseToFormattedParts(this.value);
      }

    }

    lwc.registerDecorators(FormattedText, {
      publicProps: {
        value: {
          config: 0
        },
        linkify: {
          config: 3
        }
      },
      track: {
        _linkify: 1
      }
    });

    var _lightningFormattedText = lwc.registerComponent(FormattedText, {
      tmpl: _tmpl$L
    });

    function tmpl$T($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element
      } = $api;
      return [$cmp.messageTitle ? api_element("p", {
        key: 1
      }, [api_element("strong", {
        key: 0
      }, [api_dynamic($cmp.messageTitle)])]) : null, api_element("p", {
        key: 3
      }, [api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        props: {
          "value": $cmp.messageBody,
          "linkify": "true"
        },
        key: 2
      }, [])])];
    }

    var _tmpl$M = lwc.registerTemplate(tmpl$T);
    tmpl$T.stylesheets = [];
    tmpl$T.stylesheetTokens = {
      hostAttribute: "lightning-noticeContent_noticeContent-host",
      shadowAttribute: "lightning-noticeContent_noticeContent"
    };

    class NoticeContent extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.messageTitle = void 0;
        this.messageBody = void 0;
      }

    }

    lwc.registerDecorators(NoticeContent, {
      publicProps: {
        messageTitle: {
          config: 0
        },
        messageBody: {
          config: 0
        }
      }
    });

    lwc.registerComponent(NoticeContent, {
      tmpl: _tmpl$M
    });

    const ShowToastEventName = 'lightning__showtoast';
    class ShowToastEvent extends CustomEvent {
      constructor(toast) {
        super(ShowToastEventName, {
          composed: true,
          cancelable: true,
          bubbles: true
        });
        showToast(toast, forceShowToastAttributes => {
          Object.defineProperties(this, {
            toastAttributes: {
              value: forceShowToastAttributes,
              writable: false
            }
          });
        });
      }

    }

    var Item_OBJECT = {"objectApiName":"Item__c"};

    var Type_FIELD = {"fieldApiName":"Type__c","objectApiName":"Item__c"};

    var Location_FIELD = {"fieldApiName":"Location__c","objectApiName":"Item__c"};

    var Subtype_FIELD = {"fieldApiName":"SubType__c","objectApiName":"Item__c"};

    var Category_FIELD = {"fieldApiName":"Category__c","objectApiName":"Item__c"};

    var Count_FIELD = {"fieldApiName":"Count__c","objectApiName":"Item__c"};

    var Threshold_Count_FIELD = {"fieldApiName":"Threshhold_Limit__c","objectApiName":"Item__c"};

    /* eslint-disable no-console */

    /**
     * Creates Account records.
     */

    class ItemCreate extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.location = void 0;
        this.itemObject = Item_OBJECT;
        this.typeField = Type_FIELD;
        this.locationField = Location_FIELD;
        this.subtypeField = Subtype_FIELD;
        this.categoryField = Category_FIELD;
        this.countField = Count_FIELD;
        this.threshHoldCountField = Threshold_Count_FIELD;
      }

      submitForm() {
        this.template.querySelector('lightning-record-edit-form').submit();
      }

      handleCreated(event) {
        this.dispatchEvent(new ShowToastEvent({
          title: 'Success',
          message: 'New item was successfully created',
          variant: 'success'
        }));
        this.dispatchEvent(new CustomEvent('itemcreated', {
          detail: event.detail.id
        }));
      }

      handleError(event) {
        this.dispatchEvent(new ShowToastEvent({
          title: 'Some error occured',
          message: event.detail.detail,
          variant: 'error'
        }));
      }

    }

    lwc.registerDecorators(ItemCreate, {
      publicProps: {
        location: {
          config: 0
        }
      },
      publicMethods: ["submitForm"],
      fields: ["itemObject", "typeField", "locationField", "subtypeField", "categoryField", "countField", "threshHoldCountField"]
    });

    var itemCreate = lwc.registerComponent(ItemCreate, {
      tmpl: _tmpl$J
    });

    return itemCreate;

});
